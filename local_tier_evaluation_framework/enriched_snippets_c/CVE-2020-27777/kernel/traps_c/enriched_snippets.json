[
  {
    "function_name": "ppc_warn_emulated_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2295-2311",
    "snippet": "static int __init ppc_warn_emulated_init(void)\n{\n\tstruct dentry *dir;\n\tunsigned int i;\n\tstruct ppc_emulated_entry *entries = (void *)&ppc_emulated;\n\n\tdir = debugfs_create_dir(\"emulated_instructions\",\n\t\t\t\t powerpc_debugfs_root);\n\n\tdebugfs_create_u32(\"do_warn\", 0644, dir, &ppc_warn_emulated);\n\n\tfor (i = 0; i < sizeof(ppc_emulated)/sizeof(*entries); i++)\n\t\tdebugfs_create_u32(entries[i].name, 0644, dir,\n\t\t\t\t   (u32 *)&entries[i].val.counter);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "entries[i].name",
            "0644",
            "dir",
            "(u32 *)&entries[i].val.counter"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"do_warn\"",
            "0644",
            "dir",
            "&ppc_warn_emulated"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"emulated_instructions\"",
            "powerpc_debugfs_root"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init ppc_warn_emulated_init(void)\n{\n\tstruct dentry *dir;\n\tunsigned int i;\n\tstruct ppc_emulated_entry *entries = (void *)&ppc_emulated;\n\n\tdir = debugfs_create_dir(\"emulated_instructions\",\n\t\t\t\t powerpc_debugfs_root);\n\n\tdebugfs_create_u32(\"do_warn\", 0644, dir, &ppc_warn_emulated);\n\n\tfor (i = 0; i < sizeof(ppc_emulated)/sizeof(*entries); i++)\n\t\tdebugfs_create_u32(entries[i].name, 0644, dir,\n\t\t\t\t   (u32 *)&entries[i].val.counter);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_warn_emulated_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2289-2293",
    "snippet": "void ppc_warn_emulated_print(const char *type)\n{\n\tpr_warn_ratelimited(\"%s used emulated %s instruction\\n\", current->comm,\n\t\t\t    type);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"%s used emulated %s instruction\\n\"",
            "current->comm",
            "type"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid ppc_warn_emulated_print(const char *type)\n{\n\tpr_warn_ratelimited(\"%s used emulated %s instruction\\n\", current->comm,\n\t\t\t    type);\n}"
  },
  {
    "function_name": "trap_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2245-2247",
    "snippet": "void __init trap_init(void)\n{\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __init trap_init(void)\n{\n}"
  },
  {
    "function_name": "kernel_bad_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2237-2242",
    "snippet": "void kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Bad kernel stack pointer\"",
            "regs",
            "SIGABRT"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\"",
            "regs->gpr[1]",
            "regs->nip"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid kernel_bad_stack(struct pt_regs *regs)\n{\n\tprintk(KERN_EMERG \"Bad kernel stack pointer %lx at %lx\\n\",\n\t       regs->gpr[1], regs->nip);\n\tdie(\"Bad kernel stack pointer\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "WatchdogException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2226-2230",
    "snippet": "void WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WatchdogHandler",
          "args": [
            "regs"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "WatchdogHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "2219-2224",
          "snippet": "void __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\""
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid WatchdogException(struct pt_regs *regs)\n{\n\tprintk (KERN_EMERG \"PowerPC Book-E Watchdog Exception\\n\");\n\tWatchdogHandler(regs);\n}"
  },
  {
    "function_name": "WatchdogHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2219-2224",
    "snippet": "void __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_TCR",
            "mfspr(SPRN_TCR)&(~TCR_WIE)"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_TCR"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid __attribute__ ((weak)) WatchdogHandler(struct pt_regs *regs)\n{\n\t/* Generic WatchdogHandler, implement your own */\n\tmtspr(SPRN_TCR, mfspr(SPRN_TCR)&(~TCR_WIE));\n\treturn;\n}"
  },
  {
    "function_name": "unrecoverable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2206-2211",
    "snippet": "void unrecoverable_exception(struct pt_regs *regs)\n{\n\tpr_emerg(\"Unrecoverable exception %lx at %lx (msr=%lx)\\n\",\n\t\t regs->trap, regs->nip, regs->msr);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Unrecoverable exception %lx at %lx (msr=%lx)\\n\"",
            "regs->trap",
            "regs->nip",
            "regs->msr"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid unrecoverable_exception(struct pt_regs *regs)\n{\n\tpr_emerg(\"Unrecoverable exception %lx at %lx (msr=%lx)\\n\",\n\t\t regs->trap, regs->nip, regs->msr);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "SPEFloatingPointRoundException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2164-2197",
    "snippet": "void SPEFloatingPointRoundException(struct pt_regs *regs)\n{\n\textern int speround_handler(struct pt_regs *regs);\n\tint err;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tpreempt_disable();\n\tif (regs->msr & MSR_SPE)\n\t\tgiveup_spe(current);\n\tpreempt_enable();\n\n\tregs->nip -= 4;\n\terr = speround_handler(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, FPE_FLTUNK, regs->nip);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "FPE_FLTUNK",
            "regs->nip"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "speround_handler",
          "args": [
            "regs"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "current"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_spe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "370-377",
          "snippet": "void giveup_spe(struct task_struct *tsk)\n{\n\tcheck_if_tm_restore_required(tsk);\n\n\tmsr_check_and_set(MSR_SPE);\n\t__giveup_spe(tsk);\n\tmsr_check_and_clear(MSR_SPE);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_spe(struct task_struct *tsk)\n{\n\tcheck_if_tm_restore_required(tsk);\n\n\tmsr_check_and_set(MSR_SPE);\n\t__giveup_spe(tsk);\n\tmsr_check_and_clear(MSR_SPE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SPEFloatingPointRoundException(struct pt_regs *regs)\n{\n\textern int speround_handler(struct pt_regs *regs);\n\tint err;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tpreempt_disable();\n\tif (regs->msr & MSR_SPE)\n\t\tgiveup_spe(current);\n\tpreempt_enable();\n\n\tregs->nip -= 4;\n\terr = speround_handler(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, FPE_FLTUNK, regs->nip);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "SPEFloatingPointException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2112-2162",
    "snippet": "void SPEFloatingPointException(struct pt_regs *regs)\n{\n\textern int do_spe_mathemu(struct pt_regs *regs);\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = FPE_FLTUNK;\n\tint err;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tflush_spe_to_thread(current);\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\terr = do_spe_mathemu(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "code",
            "regs->nip"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_spe_mathemu",
          "args": [
            "regs"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "393-404",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SPEFloatingPointException(struct pt_regs *regs)\n{\n\textern int do_spe_mathemu(struct pt_regs *regs);\n\tunsigned long spefscr;\n\tint fpexc_mode;\n\tint code = FPE_FLTUNK;\n\tint err;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tflush_spe_to_thread(current);\n\n\tspefscr = current->thread.spefscr;\n\tfpexc_mode = current->thread.fpexc_mode;\n\n\tif ((spefscr & SPEFSCR_FOVF) && (fpexc_mode & PR_FP_EXC_OVF)) {\n\t\tcode = FPE_FLTOVF;\n\t}\n\telse if ((spefscr & SPEFSCR_FUNF) && (fpexc_mode & PR_FP_EXC_UND)) {\n\t\tcode = FPE_FLTUND;\n\t}\n\telse if ((spefscr & SPEFSCR_FDBZ) && (fpexc_mode & PR_FP_EXC_DIV))\n\t\tcode = FPE_FLTDIV;\n\telse if ((spefscr & SPEFSCR_FINV) && (fpexc_mode & PR_FP_EXC_INV)) {\n\t\tcode = FPE_FLTINV;\n\t}\n\telse if ((spefscr & (SPEFSCR_FG | SPEFSCR_FX)) && (fpexc_mode & PR_FP_EXC_RES))\n\t\tcode = FPE_FLTRES;\n\n\terr = do_spe_mathemu(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else if (err == -EINVAL) {\n\t\t/* didn't recognize the instruction */\n\t\tprintk(KERN_ERR \"unrecognized spe instruction \"\n\t\t       \"in %s at %lx\\n\", current->comm, regs->nip);\n\t} else {\n\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "CacheLockingException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2098-2108",
    "snippet": "void CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_PRVOPC",
            "regs->nip"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid CacheLockingException(struct pt_regs *regs, unsigned long address,\n\t\t\t   unsigned long error_code)\n{\n\t/* We treat cache locking instructions from the user\n\t * as priv ops, in the future we could try to do\n\t * something smarter\n\t */\n\tif (error_code & (ESR_DLK|ESR_ILK))\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\treturn;\n}"
  },
  {
    "function_name": "altivec_assist_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "2064-2094",
    "snippet": "void altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\tPPC_WARN_EMULATED(altivec, regs);\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tprintk_ratelimited(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vr_state.vscr.u[3] |= 0x10000;\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\"",
            "current->comm",
            "regs->nip"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGSEGV",
            "regs",
            "SEGV_ACCERR",
            "regs->nip"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_altivec",
          "args": [
            "regs"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_altivec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "262-351",
          "snippet": "int emulate_altivec(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tunsigned int i, word;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user_instr(instr, (void __user *)regs->nip))\n\t\treturn -EFAULT;\n\n\tword = ppc_inst_val(instr);\n\tif (ppc_inst_primary_opcode(instr) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (word >> 21) & 0x1f;\n\tva = (word >> 16) & 0x1f;\n\tvb = (word >> 11) & 0x1f;\n\tvc = (word >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (word & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint emulate_altivec(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tunsigned int i, word;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user_instr(instr, (void __user *)regs->nip))\n\t\treturn -EFAULT;\n\n\tword = ppc_inst_val(instr);\n\tif (ppc_inst_primary_opcode(instr) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (word >> 21) & 0x1f;\n\tva = (word >> 16) & 0x1f;\n\tvb = (word >> 11) & 0x1f;\n\tvc = (word >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (word & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "altivec",
            "regs"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Kernel VMX/Altivec assist exception\"",
            "regs",
            "SIGILL"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\"",
            "regs->nip"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_assist_exception(struct pt_regs *regs)\n{\n\tint err;\n\n\tif (!user_mode(regs)) {\n\t\tprintk(KERN_EMERG \"VMX/Altivec assist exception in kernel mode\"\n\t\t       \" at %lx\\n\", regs->nip);\n\t\tdie(\"Kernel VMX/Altivec assist exception\", regs, SIGILL);\n\t}\n\n\tflush_altivec_to_thread(current);\n\n\tPPC_WARN_EMULATED(altivec, regs);\n\terr = emulate_altivec(regs);\n\tif (err == 0) {\n\t\tregs->nip += 4;\t\t/* skip emulated instruction */\n\t\temulate_single_step(regs);\n\t\treturn;\n\t}\n\n\tif (err == -EFAULT) {\n\t\t/* got an error reading the instruction */\n\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->nip);\n\t} else {\n\t\t/* didn't recognize the instruction */\n\t\t/* XXX quick hack for now: set the non-Java bit in the VSCR */\n\t\tprintk_ratelimited(KERN_ERR \"Unrecognized altivec instruction \"\n\t\t\t\t   \"in %s at %lx\\n\", current->comm, regs->nip);\n\t\tcurrent->thread.vr_state.vscr.u[3] |= 0x10000;\n\t}\n}"
  },
  {
    "function_name": "DebugException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1993-2059",
    "snippet": "void DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tcurrent->thread.debug.dbsr = debug_status;\n\n\t/* Hack alert: On BookE, Branch Taken stops on the branch itself, while\n\t * on server, it stops on the target of the branch. In order to simulate\n\t * the server behaviour, we thus restart right away with a single step\n\t * instead of stopping here when hitting a BT\n\t */\n\tif (debug_status & DBSR_BT) {\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable BT */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_BT);\n\t\t/* Clear the BT event */\n\t\tmtspr(SPRN_DBSR, DBSR_BT);\n\n\t\t/* Do the single step trick only when coming from userspace */\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\t\tcurrent->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\t\tregs->msr |= MSR_DE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (kprobe_post_handler(regs))\n\t\t\treturn;\n\n\t\tif (notify_die(DIE_SSTEP, \"block_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\t} else if (debug_status & DBSR_IC) { \t/* Instruction complete */\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable instruction completion */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t/* Clear the instruction completion event */\n\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\n\t\tif (kprobe_post_handler(regs))\n\t\t\treturn;\n\n\t\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\t\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t\t\t       current->thread.debug.dbcr1))\n\t\t\t\tregs->msr |= MSR_DE;\n\t\t\telse\n\t\t\t\t/* Make sure the IDM bit is off */\n\t\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\t} else\n\t\thandle_debug(regs, debug_status);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_debug",
          "args": [
            "regs",
            "debug_status"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "handle_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1934-1991",
          "snippet": "static void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_TRACE",
            "regs->nip"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "current->thread.debug.dbcr0",
            "current->thread.debug.dbcr1"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"single_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_post_handler",
          "args": [
            "regs"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_post_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "480-521",
          "snippet": "int kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBSR",
            "DBSR_IC"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "mfspr(SPRN_DBCR0) & ~DBCR0_IC"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DBCR0"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"block_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBSR",
            "DBSR_BT"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "mfspr(SPRN_DBCR0) & ~DBCR0_BT"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DBCR0"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tcurrent->thread.debug.dbsr = debug_status;\n\n\t/* Hack alert: On BookE, Branch Taken stops on the branch itself, while\n\t * on server, it stops on the target of the branch. In order to simulate\n\t * the server behaviour, we thus restart right away with a single step\n\t * instead of stopping here when hitting a BT\n\t */\n\tif (debug_status & DBSR_BT) {\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable BT */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_BT);\n\t\t/* Clear the BT event */\n\t\tmtspr(SPRN_DBSR, DBSR_BT);\n\n\t\t/* Do the single step trick only when coming from userspace */\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\t\tcurrent->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\t\tregs->msr |= MSR_DE;\n\t\t\treturn;\n\t\t}\n\n\t\tif (kprobe_post_handler(regs))\n\t\t\treturn;\n\n\t\tif (notify_die(DIE_SSTEP, \"block_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\t} else if (debug_status & DBSR_IC) { \t/* Instruction complete */\n\t\tregs->msr &= ~MSR_DE;\n\n\t\t/* Disable instruction completion */\n\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t/* Clear the instruction completion event */\n\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\n\t\tif (kprobe_post_handler(regs))\n\t\t\treturn;\n\n\t\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t       5, SIGTRAP) == NOTIFY_STOP) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (debugger_sstep(regs))\n\t\t\treturn;\n\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\t\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t\t\t       current->thread.debug.dbcr1))\n\t\t\t\tregs->msr |= MSR_DE;\n\t\t\telse\n\t\t\t\t/* Make sure the IDM bit is off */\n\t\t\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\t} else\n\t\thandle_debug(regs, debug_status);\n}"
  },
  {
    "function_name": "handle_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1934-1991",
    "snippet": "static void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "current->thread.debug.dbcr0"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "current->thread.debug.dbcr0",
            "current->thread.debug.dbcr1"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send_trap",
          "args": [
            "regs",
            "mfspr(SPRN_IAC4)",
            "debug_status",
            "4"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "612-623",
          "snippet": "void do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int breakpt)\n{\n\tcurrent->thread.trap_nr = TRAP_HWBKPT;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tforce_sig_ptrace_errno_trap(breakpt, /* breakpoint or watchpoint id */\n\t\t\t\t    (void __user *)address);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int breakpt)\n{\n\tcurrent->thread.trap_nr = TRAP_HWBKPT;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tforce_sig_ptrace_errno_trap(breakpt, /* breakpoint or watchpoint id */\n\t\t\t\t    (void __user *)address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC4"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC3"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "current"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC2"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_IAC1"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "current"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DAC2"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "current"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DAC1"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "current"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void handle_debug(struct pt_regs *regs, unsigned long debug_status)\n{\n\tint changed = 0;\n\t/*\n\t * Determine the cause of the debug event, clear the\n\t * event flags and send a trap to the handler. Torez\n\t */\n\tif (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tcurrent->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n#endif\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC1), debug_status,\n\t\t\t     5);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & (DBSR_DAC2R | DBSR_DAC2W)) {\n\t\tdbcr_dac(current) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t\tdo_send_trap(regs, mfspr(SPRN_DAC2), debug_status,\n\t\t\t     6);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC1) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC12MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC1), debug_status,\n\t\t\t     1);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC2) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC2), debug_status,\n\t\t\t     2);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC3) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tdbcr_iac_range(current) &= ~DBCR_IAC34MODE;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC3), debug_status,\n\t\t\t     3);\n\t\tchanged |= 0x01;\n\t}  else if (debug_status & DBSR_IAC4) {\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tdo_send_trap(regs, mfspr(SPRN_IAC4), debug_status,\n\t\t\t     4);\n\t\tchanged |= 0x01;\n\t}\n\t/*\n\t * At the point this routine was called, the MSR(DE) was turned off.\n\t * Check all other debug flags and see if that bit needs to be turned\n\t * back on or not.\n\t */\n\tif (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,\n\t\t\t       current->thread.debug.dbcr1))\n\t\tregs->msr |= MSR_DE;\n\telse\n\t\t/* Make sure the IDM flag is off */\n\t\tcurrent->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\n\tif (changed & 0x01)\n\t\tmtspr(SPRN_DBCR0, current->thread.debug.dbcr0);\n}"
  },
  {
    "function_name": "performance_monitor_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1926-1931",
    "snippet": "void performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_irq",
          "args": [
            "regs"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.pmu_irqs"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}"
  },
  {
    "function_name": "vsx_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1901-1923",
    "snippet": "void vsx_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This works similarly,\n\t * though we're loading both FP and VEC registers in here.\n\t *\n\t * If FP isn't in use, load FP regs.  If VEC isn't in use, load VEC\n\t * regs.  Either way, set MSR_VSX.\n\t */\n\n\tTM_DEBUG(\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n\tcurrent->thread.used_vsr = 1;\n\n\t/* This reclaims FP and/or VR regs if they're already enabled */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\tcurrent->thread.load_vec = 1;\n\tcurrent->thread.load_fp = 1;\n\n\ttm_recheckpoint(&current->thread);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1033-1069",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "959-963",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid vsx_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This works similarly,\n\t * though we're loading both FP and VEC registers in here.\n\t *\n\t * If FP isn't in use, load FP regs.  If VEC isn't in use, load VEC\n\t * regs.  Either way, set MSR_VSX.\n\t */\n\n\tTM_DEBUG(\"VSX Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n\tcurrent->thread.used_vsr = 1;\n\n\t/* This reclaims FP and/or VR regs if they're already enabled */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\tcurrent->thread.load_vec = 1;\n\tcurrent->thread.load_fp = 1;\n\n\ttm_recheckpoint(&current->thread);\n}"
  },
  {
    "function_name": "altivec_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1886-1899",
    "snippet": "void altivec_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This function operates\n\t * the same way.\n\t */\n\n\tTM_DEBUG(\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\tcurrent->thread.load_vec = 1;\n\ttm_recheckpoint(&current->thread);\n\tcurrent->thread.used_vr = 1;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1033-1069",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "959-963",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_unavailable_tm(struct pt_regs *regs)\n{\n\t/* See the comments in fp_unavailable_tm().  This function operates\n\t * the same way.\n\t */\n\n\tTM_DEBUG(\"Vector Unavailable trap whilst transactional at 0x%lx,\"\n\t\t \"MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\tcurrent->thread.load_vec = 1;\n\ttm_recheckpoint(&current->thread);\n\tcurrent->thread.used_vr = 1;\n}"
  },
  {
    "function_name": "fp_unavailable_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1853-1884",
    "snippet": "void fp_unavailable_tm(struct pt_regs *regs)\n{\n\t/* Note:  This does not handle any kind of FP laziness. */\n\n\tTM_DEBUG(\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n        /* We can only have got here if the task started using FP after\n         * beginning the transaction.  So, the transactional regs are just a\n         * copy of the checkpointed ones.  But, we still need to recheckpoint\n         * as we're enabling FP for the process; it will return, abort the\n         * transaction, and probably retry but now with FP enabled.  So the\n         * checkpointed FP registers need to be loaded.\n\t */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\t/*\n\t * Reclaim initially saved out bogus (lazy) FPRs to ckfp_state, and\n\t * then it was overwrite by the thr->fp_state by tm_reclaim_thread().\n\t *\n\t * At this point, ck{fp,vr}_state contains the exact values we want to\n\t * recheckpoint.\n\t */\n\n\t/* Enable FP for the task: */\n\tcurrent->thread.load_fp = 1;\n\n\t/*\n\t * Recheckpoint all the checkpointed ckpt, ck{fp, vr}_state registers.\n\t */\n\ttm_recheckpoint(&current->thread);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1033-1069",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_FAC_UNAV"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "959-963",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\"",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid fp_unavailable_tm(struct pt_regs *regs)\n{\n\t/* Note:  This does not handle any kind of FP laziness. */\n\n\tTM_DEBUG(\"FP Unavailable trap whilst transactional at 0x%lx, MSR=%lx\\n\",\n\t\t regs->nip, regs->msr);\n\n        /* We can only have got here if the task started using FP after\n         * beginning the transaction.  So, the transactional regs are just a\n         * copy of the checkpointed ones.  But, we still need to recheckpoint\n         * as we're enabling FP for the process; it will return, abort the\n         * transaction, and probably retry but now with FP enabled.  So the\n         * checkpointed FP registers need to be loaded.\n\t */\n\ttm_reclaim_current(TM_CAUSE_FAC_UNAV);\n\n\t/*\n\t * Reclaim initially saved out bogus (lazy) FPRs to ckfp_state, and\n\t * then it was overwrite by the thr->fp_state by tm_reclaim_thread().\n\t *\n\t * At this point, ck{fp,vr}_state contains the exact values we want to\n\t * recheckpoint.\n\t */\n\n\t/* Enable FP for the task: */\n\tcurrent->thread.load_fp = 1;\n\n\t/*\n\t * Recheckpoint all the checkpointed ckpt, ck{fp, vr}_state registers.\n\t */\n\ttm_recheckpoint(&current->thread);\n}"
  },
  {
    "function_name": "facility_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1733-1848",
    "snippet": "void facility_unavailable_exception(struct pt_regs *regs)\n{\n\tstatic char *facility_strings[] = {\n\t\t[FSCR_FP_LG] = \"FPU\",\n\t\t[FSCR_VECVSX_LG] = \"VMX/VSX\",\n\t\t[FSCR_DSCR_LG] = \"DSCR\",\n\t\t[FSCR_PM_LG] = \"PMU SPRs\",\n\t\t[FSCR_BHRB_LG] = \"BHRB\",\n\t\t[FSCR_TM_LG] = \"TM\",\n\t\t[FSCR_EBB_LG] = \"EBB\",\n\t\t[FSCR_TAR_LG] = \"TAR\",\n\t\t[FSCR_MSGP_LG] = \"MSGP\",\n\t\t[FSCR_SCV_LG] = \"SCV\",\n\t\t[FSCR_PREFIX_LG] = \"PREFIX\",\n\t};\n\tchar *facility = \"unknown\";\n\tu64 value;\n\tu32 instword, rd;\n\tu8 status;\n\tbool hv;\n\n\thv = (TRAP(regs) == 0xf80);\n\tif (hv)\n\t\tvalue = mfspr(SPRN_HFSCR);\n\telse\n\t\tvalue = mfspr(SPRN_FSCR);\n\n\tstatus = value >> 56;\n\tif ((hv || status >= 2) &&\n\t    (status < ARRAY_SIZE(facility_strings)) &&\n\t    facility_strings[status])\n\t\tfacility = facility_strings[status];\n\n\t/* We should not have taken this interrupt in kernel */\n\tif (!user_mode(regs)) {\n\t\tpr_emerg(\"Facility '%s' unavailable (%d) exception in kernel mode at %lx\\n\",\n\t\t\t facility, status, regs->nip);\n\t\tdie(\"Unexpected facility unavailable exception\", regs, SIGABRT);\n\t}\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tif (status == FSCR_DSCR_LG) {\n\t\t/*\n\t\t * User is accessing the DSCR register using the problem\n\t\t * state only SPR number (0x03) either through a mfspr or\n\t\t * a mtspr instruction. If it is a write attempt through\n\t\t * a mtspr, then we set the inherit bit. This also allows\n\t\t * the user to write or read the register directly in the\n\t\t * future by setting via the FSCR DSCR bit. But in case it\n\t\t * is a read DSCR attempt through a mfspr instruction, we\n\t\t * just emulate the instruction instead. This code path will\n\t\t * always emulate all the mfspr instructions till the user\n\t\t * has attempted at least one mtspr instruction. This way it\n\t\t * preserves the same behaviour when the user is accessing\n\t\t * the DSCR through privilege level only SPR number (0x11)\n\t\t * which is emulated through illegal instruction exception.\n\t\t * We always leave HFSCR DSCR set.\n\t\t */\n\t\tif (get_user(instword, (u32 __user *)(regs->nip))) {\n\t\t\tpr_err(\"Failed to fetch the user instruction\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write into DSCR (mtspr 0x03, RS) */\n\t\tif ((instword & PPC_INST_MTSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MTSPR_DSCR_USER) {\n\t\t\trd = (instword >> 21) & 0x1f;\n\t\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\t\tcurrent->thread.dscr_inherit = 1;\n\t\t\tcurrent->thread.fscr |= FSCR_DSCR;\n\t\t\tmtspr(SPRN_FSCR, current->thread.fscr);\n\t\t}\n\n\t\t/* Read from DSCR (mfspr RT, 0x03) */\n\t\tif ((instword & PPC_INST_MFSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MFSPR_DSCR_USER) {\n\t\t\tif (emulate_instruction(regs)) {\n\t\t\t\tpr_err(\"DSCR based mfspr emulation failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (status == FSCR_TM_LG) {\n\t\t/*\n\t\t * If we're here then the hardware is TM aware because it\n\t\t * generated an exception with FSRM_TM set.\n\t\t *\n\t\t * If cpu_has_feature(CPU_FTR_TM) is false, then either firmware\n\t\t * told us not to do TM, or the kernel is not built with TM\n\t\t * support.\n\t\t *\n\t\t * If both of those things are true, then userspace can spam the\n\t\t * console by triggering the printk() below just by continually\n\t\t * doing tbegin (or any TM instruction). So in that case just\n\t\t * send the process a SIGILL immediately.\n\t\t */\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto out;\n\n\t\ttm_unavailable(regs);\n\t\treturn;\n\t}\n\n\tpr_err_ratelimited(\"%sFacility '%s' unavailable (%d), exception at 0x%lx, MSR=%lx\\n\",\n\t\thv ? \"Hypervisor \" : \"\", facility, status, regs->nip, regs->msr);\n\nout:\n\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"%sFacility '%s' unavailable (%d), exception at 0x%lx, MSR=%lx\\n\"",
            "hv ? \"Hypervisor \" : \"\"",
            "facility",
            "status",
            "regs->nip",
            "regs->msr"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_unavailable",
          "args": [
            "regs"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "tm_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1717-1731",
          "snippet": "static void tm_unavailable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.load_tm++;\n\t\tregs->msr |= MSR_TM;\n\t\ttm_enable();\n\t\ttm_restore_sprs(&current->thread);\n\t\treturn;\n\t}\n#endif\n\tpr_emerg(\"Unrecoverable TM Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable TM Unavailable Exception\", regs, SIGABRT);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_unavailable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.load_tm++;\n\t\tregs->msr |= MSR_TM;\n\t\ttm_enable();\n\t\ttm_restore_sprs(&current->thread);\n\t\treturn;\n\t}\n#endif\n\tpr_emerg(\"Unrecoverable TM Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable TM Unavailable Exception\", regs, SIGABRT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DSCR based mfspr emulation failed\\n\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "regs"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1341-1434",
          "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_FSCR",
            "current->thread.fscr"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to fetch the user instruction\\n\""
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "instword",
            "(u32 __user *)(regs->nip)"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "135-138",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unexpected facility unavailable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Facility '%s' unavailable (%d) exception in kernel mode at %lx\\n\"",
            "facility",
            "status",
            "regs->nip"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "facility_strings"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_FSCR"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HFSCR"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid facility_unavailable_exception(struct pt_regs *regs)\n{\n\tstatic char *facility_strings[] = {\n\t\t[FSCR_FP_LG] = \"FPU\",\n\t\t[FSCR_VECVSX_LG] = \"VMX/VSX\",\n\t\t[FSCR_DSCR_LG] = \"DSCR\",\n\t\t[FSCR_PM_LG] = \"PMU SPRs\",\n\t\t[FSCR_BHRB_LG] = \"BHRB\",\n\t\t[FSCR_TM_LG] = \"TM\",\n\t\t[FSCR_EBB_LG] = \"EBB\",\n\t\t[FSCR_TAR_LG] = \"TAR\",\n\t\t[FSCR_MSGP_LG] = \"MSGP\",\n\t\t[FSCR_SCV_LG] = \"SCV\",\n\t\t[FSCR_PREFIX_LG] = \"PREFIX\",\n\t};\n\tchar *facility = \"unknown\";\n\tu64 value;\n\tu32 instword, rd;\n\tu8 status;\n\tbool hv;\n\n\thv = (TRAP(regs) == 0xf80);\n\tif (hv)\n\t\tvalue = mfspr(SPRN_HFSCR);\n\telse\n\t\tvalue = mfspr(SPRN_FSCR);\n\n\tstatus = value >> 56;\n\tif ((hv || status >= 2) &&\n\t    (status < ARRAY_SIZE(facility_strings)) &&\n\t    facility_strings[status])\n\t\tfacility = facility_strings[status];\n\n\t/* We should not have taken this interrupt in kernel */\n\tif (!user_mode(regs)) {\n\t\tpr_emerg(\"Facility '%s' unavailable (%d) exception in kernel mode at %lx\\n\",\n\t\t\t facility, status, regs->nip);\n\t\tdie(\"Unexpected facility unavailable exception\", regs, SIGABRT);\n\t}\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tif (status == FSCR_DSCR_LG) {\n\t\t/*\n\t\t * User is accessing the DSCR register using the problem\n\t\t * state only SPR number (0x03) either through a mfspr or\n\t\t * a mtspr instruction. If it is a write attempt through\n\t\t * a mtspr, then we set the inherit bit. This also allows\n\t\t * the user to write or read the register directly in the\n\t\t * future by setting via the FSCR DSCR bit. But in case it\n\t\t * is a read DSCR attempt through a mfspr instruction, we\n\t\t * just emulate the instruction instead. This code path will\n\t\t * always emulate all the mfspr instructions till the user\n\t\t * has attempted at least one mtspr instruction. This way it\n\t\t * preserves the same behaviour when the user is accessing\n\t\t * the DSCR through privilege level only SPR number (0x11)\n\t\t * which is emulated through illegal instruction exception.\n\t\t * We always leave HFSCR DSCR set.\n\t\t */\n\t\tif (get_user(instword, (u32 __user *)(regs->nip))) {\n\t\t\tpr_err(\"Failed to fetch the user instruction\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Write into DSCR (mtspr 0x03, RS) */\n\t\tif ((instword & PPC_INST_MTSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MTSPR_DSCR_USER) {\n\t\t\trd = (instword >> 21) & 0x1f;\n\t\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\t\tcurrent->thread.dscr_inherit = 1;\n\t\t\tcurrent->thread.fscr |= FSCR_DSCR;\n\t\t\tmtspr(SPRN_FSCR, current->thread.fscr);\n\t\t}\n\n\t\t/* Read from DSCR (mfspr RT, 0x03) */\n\t\tif ((instword & PPC_INST_MFSPR_DSCR_USER_MASK)\n\t\t\t\t== PPC_INST_MFSPR_DSCR_USER) {\n\t\t\tif (emulate_instruction(regs)) {\n\t\t\t\tpr_err(\"DSCR based mfspr emulation failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (status == FSCR_TM_LG) {\n\t\t/*\n\t\t * If we're here then the hardware is TM aware because it\n\t\t * generated an exception with FSRM_TM set.\n\t\t *\n\t\t * If cpu_has_feature(CPU_FTR_TM) is false, then either firmware\n\t\t * told us not to do TM, or the kernel is not built with TM\n\t\t * support.\n\t\t *\n\t\t * If both of those things are true, then userspace can spam the\n\t\t * console by triggering the printk() below just by continually\n\t\t * doing tbegin (or any TM instruction). So in that case just\n\t\t * send the process a SIGILL immediately.\n\t\t */\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto out;\n\n\t\ttm_unavailable(regs);\n\t\treturn;\n\t}\n\n\tpr_err_ratelimited(\"%sFacility '%s' unavailable (%d), exception at 0x%lx, MSR=%lx\\n\",\n\t\thv ? \"Hypervisor \" : \"\", facility, status, regs->nip, regs->msr);\n\nout:\n\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n}"
  },
  {
    "function_name": "tm_unavailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1717-1731",
    "snippet": "static void tm_unavailable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.load_tm++;\n\t\tregs->msr |= MSR_TM;\n\t\ttm_enable();\n\t\ttm_restore_sprs(&current->thread);\n\t\treturn;\n\t}\n#endif\n\tpr_emerg(\"Unrecoverable TM Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable TM Unavailable Exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable TM Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"Unrecoverable TM Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_restore_sprs",
          "args": [
            "&current->thread"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_unavailable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.load_tm++;\n\t\tregs->msr |= MSR_TM;\n\t\ttm_enable();\n\t\ttm_restore_sprs(&current->thread);\n\t\treturn;\n\t}\n#endif\n\tpr_emerg(\"Unrecoverable TM Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable TM Unavailable Exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "vsx_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1702-1714",
    "snippet": "void vsx_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an vsx instruction,\n\t\t   but this kernel doesn't support vsx. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VSX Unavailable Exception\", regs, SIGABRT);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable VSX Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid vsx_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an vsx instruction,\n\t\t   but this kernel doesn't support vsx. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VSX Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VSX Unavailable Exception\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "altivec_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1683-1700",
    "snippet": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\tgoto bail;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable VMX/Altivec Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\tgoto bail;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "kernel_fp_unavailable_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1672-1681",
    "snippet": "void kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable FP Unavailable Exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\"",
            "regs->trap",
            "regs->nip"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid kernel_fp_unavailable_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(KERN_EMERG \"Unrecoverable FP Unavailable Exception \"\n\t\t\t  \"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable FP Unavailable Exception\", regs, SIGABRT);\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "stack_overflow_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1663-1670",
    "snippet": "void stack_overflow_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tdie(\"Kernel stack overflow\", regs, SIGSEGV);\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Kernel stack overflow\"",
            "regs",
            "SIGSEGV"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid stack_overflow_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tdie(\"Kernel stack overflow\", regs, SIGSEGV);\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "StackOverflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1654-1661",
    "snippet": "void StackOverflow(struct pt_regs *regs)\n{\n\tpr_crit(\"Kernel stack overflow in process %s[%d], r1=%lx\\n\",\n\t\tcurrent->comm, task_pid_nr(current), regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"kernel stack overflow\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1469-1519",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "135-139",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/slab.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/slab.h>\n#include <asm/code-patching.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"Kernel stack overflow in process %s[%d], r1=%lx\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "regs->gpr[1]"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid StackOverflow(struct pt_regs *regs)\n{\n\tpr_crit(\"Kernel stack overflow in process %s[%d], r1=%lx\\n\",\n\t\tcurrent->comm, task_pid_nr(current), regs->gpr[1]);\n\tdebugger(regs);\n\tshow_regs(regs);\n\tpanic(\"kernel stack overflow\");\n}"
  },
  {
    "function_name": "alignment_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1604-1652",
    "snippet": "void alignment_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint sig, code, fixed = 0;\n\tunsigned long  reason;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\treason = get_reason(regs);\n\n\tif (reason & REASON_BOUNDARY) {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t\tgoto bad;\n\t}\n\n\tif (tm_abort_check(regs, TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT))\n\t\tgoto bail;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\t/* skip over emulated instruction */\n\t\tregs->nip += inst_length(reason);\n\t\temulate_single_step(regs);\n\t\tgoto bail;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tsig = SIGSEGV;\n\t\tcode = SEGV_ACCERR;\n\t} else {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t}\nbad:\n\tif (user_mode(regs))\n\t\t_exception(sig, regs, code, regs->dar);\n\telse\n\t\tbad_page_fault(regs, regs->dar, sig);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REASON_BOUNDARY\t\tSRR1_BOUNDARY",
      "#define REASON_BOUNDARY\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_page_fault",
          "args": [
            "regs",
            "regs->dar",
            "sig"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "sig",
            "regs",
            "code",
            "regs->dar"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inst_length",
          "args": [
            "reason"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_alignment",
          "args": [
            "regs"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "fix_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/align.c",
          "lines": "296-359",
          "snippet": "int fix_alignment(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tstruct instruction_op op;\n\tint r, type;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tif (unlikely(__get_user_instr(instr, (void __user *)regs->nip)))\n\t\treturn -EFAULT;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\t/* We don't handle PPC little-endian any more... */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\treturn -EIO;\n\t\tinstr = ppc_inst_swab(instr);\n\t}\n\n#ifdef CONFIG_SPE\n\tif (ppc_inst_primary_opcode(instr) == 0x4) {\n\t\tint reg = (ppc_inst_val(instr) >> 21) & 0x1f;\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\n\t/*\n\t * ISA 3.0 (such as P9) copy, copy_first, paste and paste_last alignment\n\t * check.\n\t *\n\t * Send a SIGBUS to the process that caused the fault.\n\t *\n\t * We do not emulate these because paste may contain additional metadata\n\t * when pasting to a co-processor. Furthermore, paste_last is the\n\t * synchronisation point for preceding copy/paste sequences.\n\t */\n\tif ((ppc_inst_val(instr) & 0xfc0006fe) == (PPC_INST_COPY & 0xfc0006fe))\n\t\treturn -EIO;\n\n\tr = analyse_instr(&op, regs, instr);\n\tif (r < 0)\n\t\treturn -EINVAL;\n\n\ttype = GETTYPE(op.type);\n\tif (!OP_IS_LOAD_STORE(type)) {\n\t\tif (op.type != CACHEOP + DCBZ)\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\tr = emulate_dcbz(op.ea, regs);\n\t} else {\n\t\tif (type == LARX || type == STCX)\n\t\t\treturn -EIO;\n\t\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\t\tr = emulate_loadstore(regs, &op);\n\t}\n\n\tif (!r)\n\t\treturn 1;\n\treturn r;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sstep.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint fix_alignment(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tstruct instruction_op op;\n\tint r, type;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tif (unlikely(__get_user_instr(instr, (void __user *)regs->nip)))\n\t\treturn -EFAULT;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\t/* We don't handle PPC little-endian any more... */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\treturn -EIO;\n\t\tinstr = ppc_inst_swab(instr);\n\t}\n\n#ifdef CONFIG_SPE\n\tif (ppc_inst_primary_opcode(instr) == 0x4) {\n\t\tint reg = (ppc_inst_val(instr) >> 21) & 0x1f;\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\n\t/*\n\t * ISA 3.0 (such as P9) copy, copy_first, paste and paste_last alignment\n\t * check.\n\t *\n\t * Send a SIGBUS to the process that caused the fault.\n\t *\n\t * We do not emulate these because paste may contain additional metadata\n\t * when pasting to a co-processor. Furthermore, paste_last is the\n\t * synchronisation point for preceding copy/paste sequences.\n\t */\n\tif ((ppc_inst_val(instr) & 0xfc0006fe) == (PPC_INST_COPY & 0xfc0006fe))\n\t\treturn -EIO;\n\n\tr = analyse_instr(&op, regs, instr);\n\tif (r < 0)\n\t\treturn -EINVAL;\n\n\ttype = GETTYPE(op.type);\n\tif (!OP_IS_LOAD_STORE(type)) {\n\t\tif (op.type != CACHEOP + DCBZ)\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\tr = emulate_dcbz(op.ea, regs);\n\t} else {\n\t\tif (type == LARX || type == STCX)\n\t\t\treturn -EIO;\n\t\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\t\tr = emulate_loadstore(regs, &op);\n\t}\n\n\tif (!r)\n\t\treturn 1;\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_abort_check",
          "args": [
            "regs",
            "TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "tm_abort_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1335-1338",
          "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reason",
          "args": [
            "regs"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_BOUNDARY\t\tSRR1_BOUNDARY\n#define REASON_BOUNDARY\t\t0\n\nvoid alignment_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tint sig, code, fixed = 0;\n\tunsigned long  reason;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\treason = get_reason(regs);\n\n\tif (reason & REASON_BOUNDARY) {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t\tgoto bad;\n\t}\n\n\tif (tm_abort_check(regs, TM_CAUSE_ALIGNMENT | TM_CAUSE_PERSISTENT))\n\t\tgoto bail;\n\n\t/* we don't implement logging of alignment exceptions */\n\tif (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))\n\t\tfixed = fix_alignment(regs);\n\n\tif (fixed == 1) {\n\t\t/* skip over emulated instruction */\n\t\tregs->nip += inst_length(reason);\n\t\temulate_single_step(regs);\n\t\tgoto bail;\n\t}\n\n\t/* Operand address was bad */\n\tif (fixed == -EFAULT) {\n\t\tsig = SIGSEGV;\n\t\tcode = SEGV_ACCERR;\n\t} else {\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRALN;\n\t}\nbad:\n\tif (user_mode(regs))\n\t\t_exception(sig, regs, code, regs->dar);\n\telse\n\t\tbad_page_fault(regs, regs->dar, sig);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "emulation_assist_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1597-1601",
    "snippet": "void emulation_assist_interrupt(struct pt_regs *regs)\n{\n\tregs->msr |= REASON_ILLEGAL;\n\tprogram_check_exception(regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REASON_ILLEGAL\t\tSRR1_PROGILL",
      "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "program_check_exception",
          "args": [
            "regs"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "program_check_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1472-1590",
          "snippet": "void program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\tunsigned long bugaddr;\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\tif (kprobe_handler(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tbugaddr = regs->nip;\n\t\t/*\n\t\t * Fixup bugaddr for BUG_ON() in real mode\n\t\t */\n\t\tif (!is_kernel_addr(bugaddr) && !(regs->msr & MSR_IR))\n\t\t\tbugaddr += PAGE_OFFSET;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(bugaddr, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t *\n\t\t * If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%lx) tm_scratch=%llx\\n\",\n\t\t\t       regs->nip, regs->msr, get_paca()->tm_scratch);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define REASON_TRAP\t\tSRR1_PROGTRAP",
            "#define REASON_PRIVILEGED\tSRR1_PROGPRIV",
            "#define REASON_ILLEGAL\t\tSRR1_PROGILL",
            "#define REASON_FP\t\tSRR1_PROGFPE",
            "#define REASON_TM\t\tSRR1_PROGTM",
            "#define REASON_TRAP\t\tESR_PTR",
            "#define REASON_PRIVILEGED\tESR_PPR",
            "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)",
            "#define REASON_FP\t\tESR_FP"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_TRAP\t\tSRR1_PROGTRAP\n#define REASON_PRIVILEGED\tSRR1_PROGPRIV\n#define REASON_ILLEGAL\t\tSRR1_PROGILL\n#define REASON_FP\t\tSRR1_PROGFPE\n#define REASON_TM\t\tSRR1_PROGTM\n#define REASON_TRAP\t\tESR_PTR\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_FP\t\tESR_FP\n\nvoid program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\tunsigned long bugaddr;\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\tif (kprobe_handler(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tbugaddr = regs->nip;\n\t\t/*\n\t\t * Fixup bugaddr for BUG_ON() in real mode\n\t\t */\n\t\tif (!is_kernel_addr(bugaddr) && !(regs->msr & MSR_IR))\n\t\t\tbugaddr += PAGE_OFFSET;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(bugaddr, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t *\n\t\t * If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%lx) tm_scratch=%llx\\n\",\n\t\t\t       regs->nip, regs->msr, get_paca()->tm_scratch);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_ILLEGAL\t\tSRR1_PROGILL\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n\nvoid emulation_assist_interrupt(struct pt_regs *regs)\n{\n\tregs->msr |= REASON_ILLEGAL;\n\tprogram_check_exception(regs);\n}"
  },
  {
    "function_name": "program_check_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1472-1590",
    "snippet": "void program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\tunsigned long bugaddr;\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\tif (kprobe_handler(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tbugaddr = regs->nip;\n\t\t/*\n\t\t * Fixup bugaddr for BUG_ON() in real mode\n\t\t */\n\t\tif (!is_kernel_addr(bugaddr) && !(regs->msr & MSR_IR))\n\t\t\tbugaddr += PAGE_OFFSET;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(bugaddr, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t *\n\t\t * If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%lx) tm_scratch=%llx\\n\",\n\t\t\t       regs->nip, regs->msr, get_paca()->tm_scratch);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REASON_TRAP\t\tSRR1_PROGTRAP",
      "#define REASON_PRIVILEGED\tSRR1_PROGPRIV",
      "#define REASON_ILLEGAL\t\tSRR1_PROGILL",
      "#define REASON_FP\t\tSRR1_PROGFPE",
      "#define REASON_TM\t\tSRR1_PROGTM",
      "#define REASON_TRAP\t\tESR_PTR",
      "#define REASON_PRIVILEGED\tESR_PPR",
      "#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)",
      "#define REASON_FP\t\tESR_FP"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_instruction",
          "args": [
            "regs"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1341-1434",
          "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_math",
          "args": [
            "regs"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_math",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1469-1469",
          "snippet": "static inline int emulate_math(struct pt_regs *regs) { return -1; }",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int emulate_math(struct pt_regs *regs) { return -1; }"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable exception\"",
            "regs",
            "SIGABRT"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%lx) tm_scratch=%llx\\n\"",
            "regs->nip",
            "regs->msr",
            "get_paca()->tm_scratch"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_bug",
          "args": [
            "bugaddr",
            "regs"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "bugaddr"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_BPT",
            "\"breakpoint\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_handler",
          "args": [
            "regs"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "268-378",
          "snippet": "int kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (!(regs->msr & MSR_IR) || !(regs->msr & MSR_DR))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tunsigned int instr;\n\n\t\tif (get_kernel_nofault(instr, addr))\n\t\t\tgoto no_kprobe;\n\n\t\tif (instr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tif (is_trap(instr))\n\t\t\t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\tif (kcb->kprobe_status == KPROBE_HIT_SS && is_trap(insn)) {\n\t\t\t/* Turn off 'trace' bits */\n\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\tgoto no_kprobe;\n\t\t}\n\n\t\t/*\n\t\t * We have reentered the kprobe_handler(), since another probe\n\t\t * was hit while within the handler. We here save the original\n\t\t * kprobes variables and just single step on the instruction of\n\t\t * the new probe without calling any user handlers.\n\t\t */\n\t\tsave_previous_kprobe(kcb);\n\t\tset_current_kprobe(p, regs, kcb);\n\t\tkprobes_inc_nmissed_count(p);\n\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\tif (p->ainsn.boostable >= 0) {\n\t\t\tret = try_to_emulate(p, regs);\n\n\t\t\tif (ret > 0) {\n\t\t\t\trestore_previous_kprobe(kcb);\n\t\t\t\tpreempt_enable_no_resched();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tprepare_singlestep(p, regs);\n\t\treturn 1;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs)) {\n\t\t/* handler changed execution path, so skip ss setup */\n\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\treturn 1;\n\t}\n\n\tif (p->ainsn.boostable >= 0) {\n\t\tret = try_to_emulate(p, regs);\n\n\t\tif (ret > 0) {\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (!(regs->msr & MSR_IR) || !(regs->msr & MSR_DR))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tunsigned int instr;\n\n\t\tif (get_kernel_nofault(instr, addr))\n\t\t\tgoto no_kprobe;\n\n\t\tif (instr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tif (is_trap(instr))\n\t\t\t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\tif (kcb->kprobe_status == KPROBE_HIT_SS && is_trap(insn)) {\n\t\t\t/* Turn off 'trace' bits */\n\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\tgoto no_kprobe;\n\t\t}\n\n\t\t/*\n\t\t * We have reentered the kprobe_handler(), since another probe\n\t\t * was hit while within the handler. We here save the original\n\t\t * kprobes variables and just single step on the instruction of\n\t\t * the new probe without calling any user handlers.\n\t\t */\n\t\tsave_previous_kprobe(kcb);\n\t\tset_current_kprobe(p, regs, kcb);\n\t\tkprobes_inc_nmissed_count(p);\n\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\tif (p->ainsn.boostable >= 0) {\n\t\t\tret = try_to_emulate(p, regs);\n\n\t\t\tif (ret > 0) {\n\t\t\t\trestore_previous_kprobe(kcb);\n\t\t\t\tpreempt_enable_no_resched();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tprepare_singlestep(p, regs);\n\t\treturn 1;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs)) {\n\t\t/* handler changed execution path, so skip ss setup */\n\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\treturn 1;\n\t}\n\n\tif (p->ainsn.boostable >= 0) {\n\t\tret = try_to_emulate(p, regs);\n\n\t\tif (ret > 0) {\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_bpt",
          "args": [
            "regs"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_fpe",
          "args": [
            "regs"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "parse_fpe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1191-1200",
          "snippet": "static void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_reason",
          "args": [
            "regs"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REASON_TRAP\t\tSRR1_PROGTRAP\n#define REASON_PRIVILEGED\tSRR1_PROGPRIV\n#define REASON_ILLEGAL\t\tSRR1_PROGILL\n#define REASON_FP\t\tSRR1_PROGFPE\n#define REASON_TM\t\tSRR1_PROGTM\n#define REASON_TRAP\t\tESR_PTR\n#define REASON_PRIVILEGED\tESR_PPR\n#define REASON_ILLEGAL\t\t(ESR_PIL | ESR_PUO)\n#define REASON_FP\t\tESR_FP\n\nvoid program_check_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\tunsigned int reason = get_reason(regs);\n\n\t/* We can now get here via a FP Unavailable exception if the core\n\t * has no FPU, in that case the reason flags will be 0 */\n\n\tif (reason & REASON_FP) {\n\t\t/* IEEE FP exception */\n\t\tparse_fpe(regs);\n\t\tgoto bail;\n\t}\n\tif (reason & REASON_TRAP) {\n\t\tunsigned long bugaddr;\n\t\t/* Debugger is first in line to stop recursive faults in\n\t\t * rcu_lock, notify_die, or atomic_notifier_call_chain */\n\t\tif (debugger_bpt(regs))\n\t\t\tgoto bail;\n\n\t\tif (kprobe_handler(regs))\n\t\t\tgoto bail;\n\n\t\t/* trap exception */\n\t\tif (notify_die(DIE_BPT, \"breakpoint\", regs, 5, 5, SIGTRAP)\n\t\t\t\t== NOTIFY_STOP)\n\t\t\tgoto bail;\n\n\t\tbugaddr = regs->nip;\n\t\t/*\n\t\t * Fixup bugaddr for BUG_ON() in real mode\n\t\t */\n\t\tif (!is_kernel_addr(bugaddr) && !(regs->msr & MSR_IR))\n\t\t\tbugaddr += PAGE_OFFSET;\n\n\t\tif (!(regs->msr & MSR_PR) &&  /* not user-mode */\n\t\t    report_bug(bugaddr, regs) == BUG_TRAP_TYPE_WARN) {\n\t\t\tregs->nip += 4;\n\t\t\tgoto bail;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (reason & REASON_TM) {\n\t\t/* This is a TM \"Bad Thing Exception\" program check.\n\t\t * This occurs when:\n\t\t * -  An rfid/hrfid/mtmsrd attempts to cause an illegal\n\t\t *    transition in TM states.\n\t\t * -  A trechkpt is attempted when transactional.\n\t\t * -  A treclaim is attempted when non transactional.\n\t\t * -  A tend is illegally attempted.\n\t\t * -  writing a TM SPR when transactional.\n\t\t *\n\t\t * If usermode caused this, it's done something illegal and\n\t\t * gets a SIGILL slap on the wrist.  We call it an illegal\n\t\t * operand to distinguish from the instruction just being bad\n\t\t * (e.g. executing a 'tend' on a CPU without TM!); it's an\n\t\t * illegal /placement/ of a valid instruction.\n\t\t */\n\t\tif (user_mode(regs)) {\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPN, regs->nip);\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\tprintk(KERN_EMERG \"Unexpected TM Bad Thing exception \"\n\t\t\t       \"at %lx (msr 0x%lx) tm_scratch=%llx\\n\",\n\t\t\t       regs->nip, regs->msr, get_paca()->tm_scratch);\n\t\t\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * If we took the program check in the kernel skip down to sending a\n\t * SIGILL. The subsequent cases all relate to emulating instructions\n\t * which we should only do for userspace. We also do not want to enable\n\t * interrupts for kernel faults because that might lead to further\n\t * faults, and loose the context of the original exception.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto sigill;\n\n\t/* We restore the interrupt state now */\n\tif (!arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\t/* (reason & REASON_ILLEGAL) would be the obvious thing here,\n\t * but there seems to be a hardware bug on the 405GP (RevD)\n\t * that means ESR is sometimes set incorrectly - either to\n\t * ESR_DST (!?) or 0.  In the process of chasing this with the\n\t * hardware people - not sure if it can happen on any illegal\n\t * instruction or only on FP instructions, whether there is a\n\t * pattern to occurrences etc. -dgibson 31/Mar/2003\n\t */\n\tif (!emulate_math(regs))\n\t\tgoto bail;\n\n\t/* Try to emulate it if we should. */\n\tif (reason & (REASON_ILLEGAL | REASON_PRIVILEGED)) {\n\t\tswitch (emulate_instruction(regs)) {\n\t\tcase 0:\n\t\t\tregs->nip += 4;\n\t\t\temulate_single_step(regs);\n\t\t\tgoto bail;\n\t\tcase -EFAULT:\n\t\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nsigill:\n\tif (reason & REASON_PRIVILEGED)\n\t\t_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);\n\telse\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "emulate_math",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1469-1469",
    "snippet": "static inline int emulate_math(struct pt_regs *regs) { return -1; }",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int emulate_math(struct pt_regs *regs) { return -1; }"
  },
  {
    "function_name": "emulate_math",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1442-1467",
    "snippet": "static int emulate_math(struct pt_regs *regs)\n{\n\tint ret;\n\textern int do_mathemu(struct pt_regs *regs);\n\n\tret = do_mathemu(regs);\n\tif (ret >= 0)\n\t\tPPC_WARN_EMULATED(math, regs);\n\n\tswitch (ret) {\n\tcase 0:\n\t\temulate_single_step(regs);\n\t\treturn 0;\n\tcase 1: {\n\t\t\tint code = 0;\n\t\t\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\t\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t\t\treturn 0;\n\t\t}\n\tcase -EFAULT:\n\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGSEGV",
            "regs",
            "SEGV_MAPERR",
            "regs->nip"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_fpscr",
          "args": [
            "current->thread.fp_state.fpscr"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_single_step",
          "args": [
            "regs"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1158-1162",
          "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "math",
            "regs"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mathemu",
          "args": [
            "regs"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_math(struct pt_regs *regs)\n{\n\tint ret;\n\textern int do_mathemu(struct pt_regs *regs);\n\n\tret = do_mathemu(regs);\n\tif (ret >= 0)\n\t\tPPC_WARN_EMULATED(math, regs);\n\n\tswitch (ret) {\n\tcase 0:\n\t\temulate_single_step(regs);\n\t\treturn 0;\n\tcase 1: {\n\t\t\tint code = 0;\n\t\t\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\t\t\t_exception(SIGFPE, regs, code, regs->nip);\n\t\t\treturn 0;\n\t\t}\n\tcase -EFAULT:\n\t\t_exception(SIGSEGV, regs, SEGV_MAPERR, regs->nip);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "is_valid_bugaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1436-1439",
    "snippet": "int is_valid_bugaddr(unsigned long addr)\n{\n\treturn is_kernel_addr(addr);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "addr"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint is_valid_bugaddr(unsigned long addr)\n{\n\treturn is_kernel_addr(addr);\n}"
  },
  {
    "function_name": "emulate_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1341-1434",
    "snippet": "static int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DSCR",
            "current->thread.dscr"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mtdscr",
            "regs"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DSCR"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_DSCR"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mfdscr",
            "regs"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DSCR"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "sync",
            "regs"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_isel",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_isel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1302-1317",
          "snippet": "static int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "isel",
            "regs"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_popcntb_inst",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_popcntb_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1285-1300",
          "snippet": "static int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "popcntb",
            "regs"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_string_inst",
          "args": [
            "regs",
            "instword"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_string_inst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1213-1283",
          "snippet": "static int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "string",
            "regs"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_abort_check",
          "args": [
            "regs",
            "TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "tm_abort_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1335-1338",
          "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mcrxr",
            "regs"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "dcba",
            "regs"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "mfpvr",
            "regs"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "instword",
            "(u32 __user *)(regs->nip)"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "135-138",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_instruction(struct pt_regs *regs)\n{\n\tu32 instword;\n\tu32 rd;\n\n\tif (!user_mode(regs))\n\t\treturn -EINVAL;\n\tCHECK_FULL_REGS(regs);\n\n\tif (get_user(instword, (u32 __user *)(regs->nip)))\n\t\treturn -EFAULT;\n\n\t/* Emulate the mfspr rD, PVR. */\n\tif ((instword & PPC_INST_MFSPR_PVR_MASK) == PPC_INST_MFSPR_PVR) {\n\t\tPPC_WARN_EMULATED(mfpvr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_PVR);\n\t\treturn 0;\n\t}\n\n\t/* Emulating the dcba insn is just a no-op.  */\n\tif ((instword & PPC_INST_DCBA_MASK) == PPC_INST_DCBA) {\n\t\tPPC_WARN_EMULATED(dcba, regs);\n\t\treturn 0;\n\t}\n\n\t/* Emulate the mcrxr insn.  */\n\tif ((instword & PPC_INST_MCRXR_MASK) == PPC_INST_MCRXR) {\n\t\tint shift = (instword >> 21) & 0x1c;\n\t\tunsigned long msk = 0xf0000000UL >> shift;\n\n\t\tPPC_WARN_EMULATED(mcrxr, regs);\n\t\tregs->ccr = (regs->ccr & ~msk) | ((regs->xer >> shift) & msk);\n\t\tregs->xer &= ~0xf0000000UL;\n\t\treturn 0;\n\t}\n\n\t/* Emulate load/store string insn. */\n\tif ((instword & PPC_INST_STRING_GEN_MASK) == PPC_INST_STRING) {\n\t\tif (tm_abort_check(regs,\n\t\t\t\t   TM_CAUSE_EMULATE | TM_CAUSE_PERSISTENT))\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_EMULATED(string, regs);\n\t\treturn emulate_string_inst(regs, instword);\n\t}\n\n\t/* Emulate the popcntb (Population Count Bytes) instruction. */\n\tif ((instword & PPC_INST_POPCNTB_MASK) == PPC_INST_POPCNTB) {\n\t\tPPC_WARN_EMULATED(popcntb, regs);\n\t\treturn emulate_popcntb_inst(regs, instword);\n\t}\n\n\t/* Emulate isel (Integer Select) instruction */\n\tif ((instword & PPC_INST_ISEL_MASK) == PPC_INST_ISEL) {\n\t\tPPC_WARN_EMULATED(isel, regs);\n\t\treturn emulate_isel(regs, instword);\n\t}\n\n\t/* Emulate sync instruction variants */\n\tif ((instword & PPC_INST_SYNC_MASK) == PPC_INST_SYNC) {\n\t\tPPC_WARN_EMULATED(sync, regs);\n\t\tasm volatile(\"sync\");\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Emulate the mfspr rD, DSCR. */\n\tif ((((instword & PPC_INST_MFSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MFSPR_DSCR_MASK) ==\n\t\tPPC_INST_MFSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mfdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tregs->gpr[rd] = mfspr(SPRN_DSCR);\n\t\treturn 0;\n\t}\n\t/* Emulate the mtspr DSCR, rD. */\n\tif ((((instword & PPC_INST_MTSPR_DSCR_USER_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR_USER) ||\n\t     ((instword & PPC_INST_MTSPR_DSCR_MASK) ==\n\t\tPPC_INST_MTSPR_DSCR)) &&\n\t\t\tcpu_has_feature(CPU_FTR_DSCR)) {\n\t\tPPC_WARN_EMULATED(mtdscr, regs);\n\t\trd = (instword >> 21) & 0x1f;\n\t\tcurrent->thread.dscr = regs->gpr[rd];\n\t\tcurrent->thread.dscr_inherit = 1;\n\t\tmtspr(SPRN_DSCR, current->thread.dscr);\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "tm_abort_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1335-1338",
    "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int reason)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "tm_abort_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1320-1333",
    "snippet": "static inline bool tm_abort_check(struct pt_regs *regs, int cause)\n{\n        /* If we're emulating a load/store in an active transaction, we cannot\n         * emulate it as the kernel operates in transaction suspended context.\n         * We need to abort the transaction.  This creates a persistent TM\n         * abort so tell the user what caused it with a new code.\n\t */\n\tif (MSR_TM_TRANSACTIONAL(regs->msr)) {\n\t\ttm_enable();\n\t\ttm_abort(cause);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_abort",
          "args": [
            "cause"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_TRANSACTIONAL",
          "args": [
            "regs->msr"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool tm_abort_check(struct pt_regs *regs, int cause)\n{\n        /* If we're emulating a load/store in an active transaction, we cannot\n         * emulate it as the kernel operates in transaction suspended context.\n         * We need to abort the transaction.  This creates a persistent TM\n         * abort so tell the user what caused it with a new code.\n\t */\n\tif (MSR_TM_TRANSACTIONAL(regs->msr)) {\n\t\ttm_enable();\n\t\ttm_abort(cause);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "emulate_isel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1302-1317",
    "snippet": "static int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_isel(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 rB = (instword >> 11) & 0x1f;\n\tu8 BC = (instword >> 6) & 0x1f;\n\tu8 bit;\n\tunsigned long tmp;\n\n\ttmp = (rA == 0) ? 0 : regs->gpr[rA];\n\tbit = (regs->ccr >> (31 - BC)) & 0x1;\n\n\tregs->gpr[rT] = bit ? tmp : regs->gpr[rB];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulate_popcntb_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1285-1300",
    "snippet": "static int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_popcntb_inst(struct pt_regs *regs, u32 instword)\n{\n\tu32 ra,rs;\n\tunsigned long tmp;\n\n\tra = (instword >> 16) & 0x1f;\n\trs = (instword >> 21) & 0x1f;\n\n\ttmp = regs->gpr[rs];\n\ttmp = tmp - ((tmp >> 1) & 0x5555555555555555ULL);\n\ttmp = (tmp & 0x3333333333333333ULL) + ((tmp >> 2) & 0x3333333333333333ULL);\n\ttmp = (tmp + (tmp >> 4)) & 0x0f0f0f0f0f0f0f0fULL;\n\tregs->gpr[ra] = tmp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "emulate_string_inst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1213-1283",
    "snippet": "static int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "(u8 __user *)EA"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "val",
            "(u8 __user *)EA"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "135-138",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int emulate_string_inst(struct pt_regs *regs, u32 instword)\n{\n\tu8 rT = (instword >> 21) & 0x1f;\n\tu8 rA = (instword >> 16) & 0x1f;\n\tu8 NB_RB = (instword >> 11) & 0x1f;\n\tu32 num_bytes;\n\tunsigned long EA;\n\tint pos = 0;\n\n\t/* Early out if we are an invalid form of lswx */\n\tif ((instword & PPC_INST_STRING_MASK) == PPC_INST_LSWX)\n\t\tif ((rT == rA) || (rT == NB_RB))\n\t\t\treturn -EINVAL;\n\n\tEA = (rA == 0) ? 0 : regs->gpr[rA];\n\n\tswitch (instword & PPC_INST_STRING_MASK) {\n\t\tcase PPC_INST_LSWX:\n\t\tcase PPC_INST_STSWX:\n\t\t\tEA += NB_RB;\n\t\t\tnum_bytes = regs->xer & 0x7f;\n\t\t\tbreak;\n\t\tcase PPC_INST_LSWI:\n\t\tcase PPC_INST_STSWI:\n\t\t\tnum_bytes = (NB_RB == 0) ? 32 : NB_RB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (num_bytes != 0)\n\t{\n\t\tu8 val;\n\t\tu32 shift = 8 * (3 - (pos & 0x3));\n\n\t\t/* if process is 32-bit, clear upper 32 bits of EA */\n\t\tif ((regs->msr & MSR_64BIT) == 0)\n\t\t\tEA &= 0xFFFFFFFF;\n\n\t\tswitch ((instword & PPC_INST_STRING_MASK)) {\n\t\t\tcase PPC_INST_LSWX:\n\t\t\tcase PPC_INST_LSWI:\n\t\t\t\tif (get_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t/* first time updating this reg,\n\t\t\t\t * zero it out */\n\t\t\t\tif (pos == 0)\n\t\t\t\t\tregs->gpr[rT] = 0;\n\t\t\t\tregs->gpr[rT] |= val << shift;\n\t\t\t\tbreak;\n\t\t\tcase PPC_INST_STSWI:\n\t\t\tcase PPC_INST_STSWX:\n\t\t\t\tval = regs->gpr[rT] >> shift;\n\t\t\t\tif (put_user(val, (u8 __user *)EA))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\t/* move EA to next address */\n\t\tEA += 1;\n\t\tnum_bytes--;\n\n\t\t/* manage our position within the register */\n\t\tif (++pos == 4) {\n\t\t\tpos = 0;\n\t\t\tif (++rT == 32)\n\t\t\t\trT = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_fpe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1191-1200",
    "snippet": "static void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGFPE",
            "regs",
            "code",
            "regs->nip"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_fpscr",
          "args": [
            "current->thread.fp_state.fpscr"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void parse_fpe(struct pt_regs *regs)\n{\n\tint code = 0;\n\n\tflush_fp_to_thread(current);\n\n\tcode = __parse_fpscr(current->thread.fp_state.fpscr);\n\n\t_exception(SIGFPE, regs, code, regs->nip);\n}"
  },
  {
    "function_name": "__parse_fpscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1164-1189",
    "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "emulate_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1158-1162",
    "snippet": "static void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_step_exception",
          "args": [
            "regs"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "single_step_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1129-1149",
          "snippet": "void single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\tclear_br_trace(regs);\n\n\tif (kprobe_post_handler(regs))\n\t\treturn;\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\tclear_br_trace(regs);\n\n\tif (kprobe_post_handler(regs))\n\t\treturn;\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "single_stepping",
          "args": [
            "regs"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void emulate_single_step(struct pt_regs *regs)\n{\n\tif (single_stepping(regs))\n\t\tsingle_step_exception(regs);\n}"
  },
  {
    "function_name": "single_step_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1129-1149",
    "snippet": "void single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\tclear_br_trace(regs);\n\n\tif (kprobe_post_handler(regs))\n\t\treturn;\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_TRACE",
            "regs->nip"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_sstep",
          "args": [
            "regs"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_SSTEP",
            "\"single_step\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_post_handler",
          "args": [
            "regs"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_post_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "480-521",
          "snippet": "int kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_br_trace",
          "args": [
            "regs"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_single_step",
          "args": [
            "regs"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid single_step_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tclear_single_step(regs);\n\tclear_br_trace(regs);\n\n\tif (kprobe_post_handler(regs))\n\t\treturn;\n\n\tif (notify_die(DIE_SSTEP, \"single_step\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_sstep(regs))\n\t\tgoto bail;\n\n\t_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "RunModeException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1124-1127",
    "snippet": "void RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, TRAP_UNK, 0);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_UNK",
            "0"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid RunModeException(struct pt_regs *regs)\n{\n\t_exception(SIGTRAP, regs, TRAP_UNK, 0);\n}"
  },
  {
    "function_name": "instruction_breakpoint_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1109-1122",
    "snippet": "void instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_iabr_match(regs))\n\t\tgoto bail;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_BRKPT",
            "regs->nip"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_iabr_match",
          "args": [
            "regs"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_IABR_MATCH",
            "\"iabr_match\"",
            "regs",
            "5",
            "5",
            "SIGTRAP"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid instruction_breakpoint_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tif (notify_die(DIE_IABR_MATCH, \"iabr_match\", regs, 5,\n\t\t\t\t\t5, SIGTRAP) == NOTIFY_STOP)\n\t\tgoto bail;\n\tif (debugger_iabr_match(regs))\n\t\tgoto bail;\n\t_exception(SIGTRAP, regs, TRAP_BRKPT, regs->nip);\n\nbail:\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "unknown_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1097-1107",
    "snippet": "void unknown_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, TRAP_UNK, 0);\n\n\texception_exit(prev_state);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_exit",
          "args": [
            "prev_state"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGTRAP",
            "regs",
            "TRAP_UNK",
            "0"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\"",
            "regs->nip",
            "regs->msr",
            "regs->trap"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_enter",
          "args": [],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid unknown_exception(struct pt_regs *regs)\n{\n\tenum ctx_state prev_state = exception_enter();\n\n\tprintk(\"Bad trap at PC: %lx, SR: %lx, vector=%lx\\n\",\n\t       regs->nip, regs->msr, regs->trap);\n\n\t_exception(SIGTRAP, regs, TRAP_UNK, 0);\n\n\texception_exit(prev_state);\n}"
  },
  {
    "function_name": "handle_hmi_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "1068-1095",
    "snippet": "void handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n#ifdef CONFIG_VSX\n\t/* Real mode flagged P9 special emu is needed */\n\tif (local_paca->hmi_p9_special_emu) {\n\t\tlocal_paca->hmi_p9_special_emu = 0;\n\n\t\t/*\n\t\t * We don't want to take page faults while doing the\n\t\t * emulation, we just replay the instruction if necessary.\n\t\t */\n\t\tpagefault_disable();\n\t\tp9_hmi_special_emu(regs);\n\t\tpagefault_enable();\n\t}\n#endif /* CONFIG_VSX */\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.handle_hmi_exception",
          "args": [
            "regs"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "handle_hmi_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1068-1095",
          "snippet": "void handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n#ifdef CONFIG_VSX\n\t/* Real mode flagged P9 special emu is needed */\n\tif (local_paca->hmi_p9_special_emu) {\n\t\tlocal_paca->hmi_p9_special_emu = 0;\n\n\t\t/*\n\t\t * We don't want to take page faults while doing the\n\t\t * emulation, we just replay the instruction if necessary.\n\t\t */\n\t\tpagefault_disable();\n\t\tp9_hmi_special_emu(regs);\n\t\tpagefault_enable();\n\t}\n#endif /* CONFIG_VSX */\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pagefault_enable",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_hmi_special_emu",
          "args": [
            "regs"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "p9_hmi_special_emu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "888-1065",
          "snippet": "static void p9_hmi_special_emu(struct pt_regs *regs)\n{\n\tunsigned int ra, rb, t, i, sel, instr, rc;\n\tconst void __user *addr;\n\tu8 vbuf[16], *vdst;\n\tunsigned long ea, msr, msr_mask;\n\tbool swap;\n\n\tif (__get_user_inatomic(instr, (unsigned int __user *)regs->nip))\n\t\treturn;\n\n\t/*\n\t * lxvb16x\topcode: 0x7c0006d8\n\t * lxvd2x\topcode: 0x7c000698\n\t * lxvh8x\topcode: 0x7c000658\n\t * lxvw4x\topcode: 0x7c000618\n\t */\n\tif ((instr & 0xfc00073e) != 0x7c000618) {\n\t\tpr_devel(\"HMI vec emu: not vector CI %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr);\n\t\treturn;\n\t}\n\n\t/* Grab vector registers into the task struct */\n\tmsr = regs->msr; /* Grab msr before we flush the bits */\n\tflush_vsx_to_thread(current);\n\tenable_kernel_altivec();\n\n\t/*\n\t * Is userspace running with a different endian (this is rare but\n\t * not impossible)\n\t */\n\tswap = (msr & MSR_LE) != (MSR_KERNEL & MSR_LE);\n\n\t/* Decode the instruction */\n\tra = (instr >> 16) & 0x1f;\n\trb = (instr >> 11) & 0x1f;\n\tt = (instr >> 21) & 0x1f;\n\tif (instr & 1)\n\t\tvdst = (u8 *)&current->thread.vr_state.vr[t];\n\telse\n\t\tvdst = (u8 *)&current->thread.fp_state.fpr[t][0];\n\n\t/* Grab the vector address */\n\tea = regs->gpr[rb] + (ra ? regs->gpr[ra] : 0);\n\tif (is_32bit_task())\n\t\tea &= 0xfffffffful;\n\taddr = (__force const void __user *)ea;\n\n\t/* Check it */\n\tif (!access_ok(addr, 16)) {\n\t\tpr_devel(\"HMI vec emu: bad access %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\t/* Read the vector */\n\trc = 0;\n\tif ((unsigned long)addr & 0xfUL)\n\t\t/* unaligned case */\n\t\trc = __copy_from_user_inatomic(vbuf, addr, 16);\n\telse\n\t\t__get_user_atomic_128_aligned(vbuf, addr, rc);\n\tif (rc) {\n\t\tpr_devel(\"HMI vec emu: page fault %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\tpr_devel(\"HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx\"\n\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t smp_processor_id(), current->comm, current->pid, regs->nip,\n\t\t instr, (unsigned long) addr);\n\n\t/* Grab instruction \"selector\" */\n\tsel = (instr >> 6) & 3;\n\n\t/*\n\t * Check to make sure the facility is actually enabled. This\n\t * could happen if we get a false positive hit.\n\t *\n\t * lxvd2x/lxvw4x always check MSR VSX sel = 0,2\n\t * lxvh8x/lxvb16x check MSR VSX or VEC depending on VSR used sel = 1,3\n\t */\n\tmsr_mask = MSR_VSX;\n\tif ((sel & 1) && (instr & 1)) /* lxvh8x & lxvb16x + VSR >= 32 */\n\t\tmsr_mask = MSR_VEC;\n\tif (!(msr & msr_mask)) {\n\t\tpr_devel(\"HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x msr:%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, msr);\n\t\treturn;\n\t}\n\n\t/* Do logging here before we modify sel based on endian */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tPPC_WARN_EMULATED(lxvw4x, regs);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tPPC_WARN_EMULATED(lxvh8x, regs);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tPPC_WARN_EMULATED(lxvd2x, regs);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tPPC_WARN_EMULATED(lxvb16x, regs);\n\t\tbreak;\n\t}\n\n#ifdef __LITTLE_ENDIAN__\n\t/*\n\t * An LE kernel stores the vector in the task struct as an LE\n\t * byte array (effectively swapping both the components and\n\t * the content of the components). Those instructions expect\n\t * the components to remain in ascending address order, so we\n\t * swap them back.\n\t *\n\t * If we are running a BE user space, the expectation is that\n\t * of a simple memcpy, so forcing the emulation to look like\n\t * a lxvb16x should do the trick.\n\t */\n\tif (swap)\n\t\tsel = 3;\n\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = ((u32 *)vbuf)[3-i];\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = ((u16 *)vbuf)[7-i];\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = ((u64 *)vbuf)[1-i];\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tvdst[i] = vbuf[15-i];\n\t\tbreak;\n\t}\n#else /* __LITTLE_ENDIAN__ */\n\t/* On a big endian kernel, a BE userspace only needs a memcpy */\n\tif (!swap)\n\t\tsel = 3;\n\n\t/* Otherwise, we need to swap the content of the components */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = cpu_to_le32(((u32 *)vbuf)[i]);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = cpu_to_le16(((u16 *)vbuf)[i]);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = cpu_to_le64(((u64 *)vbuf)[i]);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tmemcpy(vdst, vbuf, 16);\n\t\tbreak;\n\t}\n#endif /* !__LITTLE_ENDIAN__ */\n\n\t/* Go to next instruction */\n\tregs->nip += 4;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void p9_hmi_special_emu(struct pt_regs *regs)\n{\n\tunsigned int ra, rb, t, i, sel, instr, rc;\n\tconst void __user *addr;\n\tu8 vbuf[16], *vdst;\n\tunsigned long ea, msr, msr_mask;\n\tbool swap;\n\n\tif (__get_user_inatomic(instr, (unsigned int __user *)regs->nip))\n\t\treturn;\n\n\t/*\n\t * lxvb16x\topcode: 0x7c0006d8\n\t * lxvd2x\topcode: 0x7c000698\n\t * lxvh8x\topcode: 0x7c000658\n\t * lxvw4x\topcode: 0x7c000618\n\t */\n\tif ((instr & 0xfc00073e) != 0x7c000618) {\n\t\tpr_devel(\"HMI vec emu: not vector CI %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr);\n\t\treturn;\n\t}\n\n\t/* Grab vector registers into the task struct */\n\tmsr = regs->msr; /* Grab msr before we flush the bits */\n\tflush_vsx_to_thread(current);\n\tenable_kernel_altivec();\n\n\t/*\n\t * Is userspace running with a different endian (this is rare but\n\t * not impossible)\n\t */\n\tswap = (msr & MSR_LE) != (MSR_KERNEL & MSR_LE);\n\n\t/* Decode the instruction */\n\tra = (instr >> 16) & 0x1f;\n\trb = (instr >> 11) & 0x1f;\n\tt = (instr >> 21) & 0x1f;\n\tif (instr & 1)\n\t\tvdst = (u8 *)&current->thread.vr_state.vr[t];\n\telse\n\t\tvdst = (u8 *)&current->thread.fp_state.fpr[t][0];\n\n\t/* Grab the vector address */\n\tea = regs->gpr[rb] + (ra ? regs->gpr[ra] : 0);\n\tif (is_32bit_task())\n\t\tea &= 0xfffffffful;\n\taddr = (__force const void __user *)ea;\n\n\t/* Check it */\n\tif (!access_ok(addr, 16)) {\n\t\tpr_devel(\"HMI vec emu: bad access %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\t/* Read the vector */\n\trc = 0;\n\tif ((unsigned long)addr & 0xfUL)\n\t\t/* unaligned case */\n\t\trc = __copy_from_user_inatomic(vbuf, addr, 16);\n\telse\n\t\t__get_user_atomic_128_aligned(vbuf, addr, rc);\n\tif (rc) {\n\t\tpr_devel(\"HMI vec emu: page fault %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\tpr_devel(\"HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx\"\n\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t smp_processor_id(), current->comm, current->pid, regs->nip,\n\t\t instr, (unsigned long) addr);\n\n\t/* Grab instruction \"selector\" */\n\tsel = (instr >> 6) & 3;\n\n\t/*\n\t * Check to make sure the facility is actually enabled. This\n\t * could happen if we get a false positive hit.\n\t *\n\t * lxvd2x/lxvw4x always check MSR VSX sel = 0,2\n\t * lxvh8x/lxvb16x check MSR VSX or VEC depending on VSR used sel = 1,3\n\t */\n\tmsr_mask = MSR_VSX;\n\tif ((sel & 1) && (instr & 1)) /* lxvh8x & lxvb16x + VSR >= 32 */\n\t\tmsr_mask = MSR_VEC;\n\tif (!(msr & msr_mask)) {\n\t\tpr_devel(\"HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x msr:%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, msr);\n\t\treturn;\n\t}\n\n\t/* Do logging here before we modify sel based on endian */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tPPC_WARN_EMULATED(lxvw4x, regs);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tPPC_WARN_EMULATED(lxvh8x, regs);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tPPC_WARN_EMULATED(lxvd2x, regs);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tPPC_WARN_EMULATED(lxvb16x, regs);\n\t\tbreak;\n\t}\n\n#ifdef __LITTLE_ENDIAN__\n\t/*\n\t * An LE kernel stores the vector in the task struct as an LE\n\t * byte array (effectively swapping both the components and\n\t * the content of the components). Those instructions expect\n\t * the components to remain in ascending address order, so we\n\t * swap them back.\n\t *\n\t * If we are running a BE user space, the expectation is that\n\t * of a simple memcpy, so forcing the emulation to look like\n\t * a lxvb16x should do the trick.\n\t */\n\tif (swap)\n\t\tsel = 3;\n\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = ((u32 *)vbuf)[3-i];\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = ((u16 *)vbuf)[7-i];\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = ((u64 *)vbuf)[1-i];\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tvdst[i] = vbuf[15-i];\n\t\tbreak;\n\t}\n#else /* __LITTLE_ENDIAN__ */\n\t/* On a big endian kernel, a BE userspace only needs a memcpy */\n\tif (!swap)\n\t\tsel = 3;\n\n\t/* Otherwise, we need to swap the content of the components */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = cpu_to_le32(((u32 *)vbuf)[i]);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = cpu_to_le16(((u16 *)vbuf)[i]);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = cpu_to_le64(((u64 *)vbuf)[i]);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tmemcpy(vdst, vbuf, 16);\n\t\tbreak;\n\t}\n#endif /* !__LITTLE_ENDIAN__ */\n\n\t/* Go to next instruction */\n\tregs->nip += 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagefault_disable",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "regs"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n#ifdef CONFIG_VSX\n\t/* Real mode flagged P9 special emu is needed */\n\tif (local_paca->hmi_p9_special_emu) {\n\t\tlocal_paca->hmi_p9_special_emu = 0;\n\n\t\t/*\n\t\t * We don't want to take page faults while doing the\n\t\t * emulation, we just replay the instruction if necessary.\n\t\t */\n\t\tpagefault_disable();\n\t\tp9_hmi_special_emu(regs);\n\t\tpagefault_enable();\n\t}\n#endif /* CONFIG_VSX */\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}"
  },
  {
    "function_name": "p9_hmi_special_emu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "888-1065",
    "snippet": "static void p9_hmi_special_emu(struct pt_regs *regs)\n{\n\tunsigned int ra, rb, t, i, sel, instr, rc;\n\tconst void __user *addr;\n\tu8 vbuf[16], *vdst;\n\tunsigned long ea, msr, msr_mask;\n\tbool swap;\n\n\tif (__get_user_inatomic(instr, (unsigned int __user *)regs->nip))\n\t\treturn;\n\n\t/*\n\t * lxvb16x\topcode: 0x7c0006d8\n\t * lxvd2x\topcode: 0x7c000698\n\t * lxvh8x\topcode: 0x7c000658\n\t * lxvw4x\topcode: 0x7c000618\n\t */\n\tif ((instr & 0xfc00073e) != 0x7c000618) {\n\t\tpr_devel(\"HMI vec emu: not vector CI %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr);\n\t\treturn;\n\t}\n\n\t/* Grab vector registers into the task struct */\n\tmsr = regs->msr; /* Grab msr before we flush the bits */\n\tflush_vsx_to_thread(current);\n\tenable_kernel_altivec();\n\n\t/*\n\t * Is userspace running with a different endian (this is rare but\n\t * not impossible)\n\t */\n\tswap = (msr & MSR_LE) != (MSR_KERNEL & MSR_LE);\n\n\t/* Decode the instruction */\n\tra = (instr >> 16) & 0x1f;\n\trb = (instr >> 11) & 0x1f;\n\tt = (instr >> 21) & 0x1f;\n\tif (instr & 1)\n\t\tvdst = (u8 *)&current->thread.vr_state.vr[t];\n\telse\n\t\tvdst = (u8 *)&current->thread.fp_state.fpr[t][0];\n\n\t/* Grab the vector address */\n\tea = regs->gpr[rb] + (ra ? regs->gpr[ra] : 0);\n\tif (is_32bit_task())\n\t\tea &= 0xfffffffful;\n\taddr = (__force const void __user *)ea;\n\n\t/* Check it */\n\tif (!access_ok(addr, 16)) {\n\t\tpr_devel(\"HMI vec emu: bad access %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\t/* Read the vector */\n\trc = 0;\n\tif ((unsigned long)addr & 0xfUL)\n\t\t/* unaligned case */\n\t\trc = __copy_from_user_inatomic(vbuf, addr, 16);\n\telse\n\t\t__get_user_atomic_128_aligned(vbuf, addr, rc);\n\tif (rc) {\n\t\tpr_devel(\"HMI vec emu: page fault %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\tpr_devel(\"HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx\"\n\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t smp_processor_id(), current->comm, current->pid, regs->nip,\n\t\t instr, (unsigned long) addr);\n\n\t/* Grab instruction \"selector\" */\n\tsel = (instr >> 6) & 3;\n\n\t/*\n\t * Check to make sure the facility is actually enabled. This\n\t * could happen if we get a false positive hit.\n\t *\n\t * lxvd2x/lxvw4x always check MSR VSX sel = 0,2\n\t * lxvh8x/lxvb16x check MSR VSX or VEC depending on VSR used sel = 1,3\n\t */\n\tmsr_mask = MSR_VSX;\n\tif ((sel & 1) && (instr & 1)) /* lxvh8x & lxvb16x + VSR >= 32 */\n\t\tmsr_mask = MSR_VEC;\n\tif (!(msr & msr_mask)) {\n\t\tpr_devel(\"HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x msr:%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, msr);\n\t\treturn;\n\t}\n\n\t/* Do logging here before we modify sel based on endian */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tPPC_WARN_EMULATED(lxvw4x, regs);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tPPC_WARN_EMULATED(lxvh8x, regs);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tPPC_WARN_EMULATED(lxvd2x, regs);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tPPC_WARN_EMULATED(lxvb16x, regs);\n\t\tbreak;\n\t}\n\n#ifdef __LITTLE_ENDIAN__\n\t/*\n\t * An LE kernel stores the vector in the task struct as an LE\n\t * byte array (effectively swapping both the components and\n\t * the content of the components). Those instructions expect\n\t * the components to remain in ascending address order, so we\n\t * swap them back.\n\t *\n\t * If we are running a BE user space, the expectation is that\n\t * of a simple memcpy, so forcing the emulation to look like\n\t * a lxvb16x should do the trick.\n\t */\n\tif (swap)\n\t\tsel = 3;\n\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = ((u32 *)vbuf)[3-i];\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = ((u16 *)vbuf)[7-i];\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = ((u64 *)vbuf)[1-i];\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tvdst[i] = vbuf[15-i];\n\t\tbreak;\n\t}\n#else /* __LITTLE_ENDIAN__ */\n\t/* On a big endian kernel, a BE userspace only needs a memcpy */\n\tif (!swap)\n\t\tsel = 3;\n\n\t/* Otherwise, we need to swap the content of the components */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = cpu_to_le32(((u32 *)vbuf)[i]);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = cpu_to_le16(((u16 *)vbuf)[i]);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = cpu_to_le64(((u64 *)vbuf)[i]);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tmemcpy(vdst, vbuf, 16);\n\t\tbreak;\n\t}\n#endif /* !__LITTLE_ENDIAN__ */\n\n\t/* Go to next instruction */\n\tregs->nip += 4;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vdst",
            "vbuf",
            "16"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "((u64 *)vbuf)[i]"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "((u16 *)vbuf)[i]"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "((u32 *)vbuf)[i]"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "lxvb16x",
            "regs"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "lxvd2x",
            "regs"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "lxvh8x",
            "regs"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_EMULATED",
          "args": [
            "lxvw4x",
            "regs"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x msr:%016lx\\n\"",
            "smp_processor_id()",
            "current->comm",
            "current->pid",
            "regs->nip",
            "instr",
            "msr"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx\"\n\t\t \" instr=%08x addr=%016lx\\n\"",
            "smp_processor_id()",
            "current->comm",
            "current->pid",
            "regs->nip",
            "instr",
            "(unsigned long) addr"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"HMI vec emu: page fault %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\"",
            "smp_processor_id()",
            "current->comm",
            "current->pid",
            "regs->nip",
            "instr",
            "(unsigned long)addr"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_atomic_128_aligned",
          "args": [
            "vbuf",
            "addr",
            "rc"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "vbuf",
            "addr",
            "16"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"HMI vec emu: bad access %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\"",
            "smp_processor_id()",
            "current->comm",
            "current->pid",
            "regs->nip",
            "instr",
            "(unsigned long)addr"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "addr",
            "16"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_kernel_altivec",
          "args": [],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "enable_kernel_altivec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "259-281",
          "snippet": "void enable_kernel_altivec(void)\n{\n\tunsigned long cpumsr;\n\n\tWARN_ON(preemptible());\n\n\tcpumsr = msr_check_and_set(MSR_VEC);\n\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VEC)) {\n\t\tcheck_if_tm_restore_required(current);\n\t\t/*\n\t\t * If a thread has already been reclaimed then the\n\t\t * checkpointed registers are on the CPU but have definitely\n\t\t * been saved by the reclaim code. Don't need to and *cannot*\n\t\t * giveup as this would save  to the 'live' structure not the\n\t\t * checkpointed structure.\n\t\t */\n\t\tif (!MSR_TM_ACTIVE(cpumsr) &&\n\t\t     MSR_TM_ACTIVE(current->thread.regs->msr))\n\t\t\treturn;\n\t\t__giveup_altivec(current);\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_altivec(void)\n{\n\tunsigned long cpumsr;\n\n\tWARN_ON(preemptible());\n\n\tcpumsr = msr_check_and_set(MSR_VEC);\n\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VEC)) {\n\t\tcheck_if_tm_restore_required(current);\n\t\t/*\n\t\t * If a thread has already been reclaimed then the\n\t\t * checkpointed registers are on the CPU but have definitely\n\t\t * been saved by the reclaim code. Don't need to and *cannot*\n\t\t * giveup as this would save  to the 'live' structure not the\n\t\t * checkpointed structure.\n\t\t */\n\t\tif (!MSR_TM_ACTIVE(cpumsr) &&\n\t\t     MSR_TM_ACTIVE(current->thread.regs->msr))\n\t\t\treturn;\n\t\t__giveup_altivec(current);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "current"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"HMI vec emu: not vector CI %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x\\n\"",
            "smp_processor_id()",
            "current->comm",
            "current->pid",
            "regs->nip",
            "instr"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "instr",
            "(unsigned int __user *)regs->nip"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void p9_hmi_special_emu(struct pt_regs *regs)\n{\n\tunsigned int ra, rb, t, i, sel, instr, rc;\n\tconst void __user *addr;\n\tu8 vbuf[16], *vdst;\n\tunsigned long ea, msr, msr_mask;\n\tbool swap;\n\n\tif (__get_user_inatomic(instr, (unsigned int __user *)regs->nip))\n\t\treturn;\n\n\t/*\n\t * lxvb16x\topcode: 0x7c0006d8\n\t * lxvd2x\topcode: 0x7c000698\n\t * lxvh8x\topcode: 0x7c000658\n\t * lxvw4x\topcode: 0x7c000618\n\t */\n\tif ((instr & 0xfc00073e) != 0x7c000618) {\n\t\tpr_devel(\"HMI vec emu: not vector CI %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr);\n\t\treturn;\n\t}\n\n\t/* Grab vector registers into the task struct */\n\tmsr = regs->msr; /* Grab msr before we flush the bits */\n\tflush_vsx_to_thread(current);\n\tenable_kernel_altivec();\n\n\t/*\n\t * Is userspace running with a different endian (this is rare but\n\t * not impossible)\n\t */\n\tswap = (msr & MSR_LE) != (MSR_KERNEL & MSR_LE);\n\n\t/* Decode the instruction */\n\tra = (instr >> 16) & 0x1f;\n\trb = (instr >> 11) & 0x1f;\n\tt = (instr >> 21) & 0x1f;\n\tif (instr & 1)\n\t\tvdst = (u8 *)&current->thread.vr_state.vr[t];\n\telse\n\t\tvdst = (u8 *)&current->thread.fp_state.fpr[t][0];\n\n\t/* Grab the vector address */\n\tea = regs->gpr[rb] + (ra ? regs->gpr[ra] : 0);\n\tif (is_32bit_task())\n\t\tea &= 0xfffffffful;\n\taddr = (__force const void __user *)ea;\n\n\t/* Check it */\n\tif (!access_ok(addr, 16)) {\n\t\tpr_devel(\"HMI vec emu: bad access %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\t/* Read the vector */\n\trc = 0;\n\tif ((unsigned long)addr & 0xfUL)\n\t\t/* unaligned case */\n\t\trc = __copy_from_user_inatomic(vbuf, addr, 16);\n\telse\n\t\t__get_user_atomic_128_aligned(vbuf, addr, rc);\n\tif (rc) {\n\t\tpr_devel(\"HMI vec emu: page fault %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, (unsigned long)addr);\n\t\treturn;\n\t}\n\n\tpr_devel(\"HMI vec emu: emulated vector CI %i:%s[%d] nip=%016lx\"\n\t\t \" instr=%08x addr=%016lx\\n\",\n\t\t smp_processor_id(), current->comm, current->pid, regs->nip,\n\t\t instr, (unsigned long) addr);\n\n\t/* Grab instruction \"selector\" */\n\tsel = (instr >> 6) & 3;\n\n\t/*\n\t * Check to make sure the facility is actually enabled. This\n\t * could happen if we get a false positive hit.\n\t *\n\t * lxvd2x/lxvw4x always check MSR VSX sel = 0,2\n\t * lxvh8x/lxvb16x check MSR VSX or VEC depending on VSR used sel = 1,3\n\t */\n\tmsr_mask = MSR_VSX;\n\tif ((sel & 1) && (instr & 1)) /* lxvh8x & lxvb16x + VSR >= 32 */\n\t\tmsr_mask = MSR_VEC;\n\tif (!(msr & msr_mask)) {\n\t\tpr_devel(\"HMI vec emu: MSR fac clear %i:%s[%d] nip=%016lx\"\n\t\t\t \" instr=%08x msr:%016lx\\n\",\n\t\t\t smp_processor_id(), current->comm, current->pid,\n\t\t\t regs->nip, instr, msr);\n\t\treturn;\n\t}\n\n\t/* Do logging here before we modify sel based on endian */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tPPC_WARN_EMULATED(lxvw4x, regs);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tPPC_WARN_EMULATED(lxvh8x, regs);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tPPC_WARN_EMULATED(lxvd2x, regs);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tPPC_WARN_EMULATED(lxvb16x, regs);\n\t\tbreak;\n\t}\n\n#ifdef __LITTLE_ENDIAN__\n\t/*\n\t * An LE kernel stores the vector in the task struct as an LE\n\t * byte array (effectively swapping both the components and\n\t * the content of the components). Those instructions expect\n\t * the components to remain in ascending address order, so we\n\t * swap them back.\n\t *\n\t * If we are running a BE user space, the expectation is that\n\t * of a simple memcpy, so forcing the emulation to look like\n\t * a lxvb16x should do the trick.\n\t */\n\tif (swap)\n\t\tsel = 3;\n\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = ((u32 *)vbuf)[3-i];\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = ((u16 *)vbuf)[7-i];\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = ((u64 *)vbuf)[1-i];\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tvdst[i] = vbuf[15-i];\n\t\tbreak;\n\t}\n#else /* __LITTLE_ENDIAN__ */\n\t/* On a big endian kernel, a BE userspace only needs a memcpy */\n\tif (!swap)\n\t\tsel = 3;\n\n\t/* Otherwise, we need to swap the content of the components */\n\tswitch (sel) {\n\tcase 0:\t/* lxvw4x */\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t((u32 *)vdst)[i] = cpu_to_le32(((u32 *)vbuf)[i]);\n\t\tbreak;\n\tcase 1: /* lxvh8x */\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t((u16 *)vdst)[i] = cpu_to_le16(((u16 *)vbuf)[i]);\n\t\tbreak;\n\tcase 2: /* lxvd2x */\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u64 *)vdst)[i] = cpu_to_le64(((u64 *)vbuf)[i]);\n\t\tbreak;\n\tcase 3: /* lxvb16x */\n\t\tmemcpy(vdst, vbuf, 16);\n\t\tbreak;\n\t}\n#endif /* !__LITTLE_ENDIAN__ */\n\n\t/* Go to next instruction */\n\tregs->nip += 4;\n}"
  },
  {
    "function_name": "SMIException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "882-885",
    "snippet": "void SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"System Management Interrupt\"",
            "regs",
            "SIGABRT"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid SMIException(struct pt_regs *regs)\n{\n\tdie(\"System Management Interrupt\", regs, SIGABRT);\n}"
  },
  {
    "function_name": "machine_check_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "826-880",
    "snippet": "void machine_check_exception(struct pt_regs *regs)\n{\n\tint recover = 0;\n\n\t/*\n\t * BOOK3S_64 does not call this handler as a non-maskable interrupt\n\t * (it uses its own early real-mode handler to handle the MCE proper\n\t * and then raises irq_work to call this handler when interrupts are\n\t * enabled).\n\t *\n\t * This is silly. The BOOK3S_64 should just call a different function\n\t * rather than expecting semantics to magically change. Something\n\t * like 'non_nmi_machine_check_exception()', perhaps?\n\t */\n\tconst bool nmi = !IS_ENABLED(CONFIG_PPC_BOOK3S_64);\n\n\tif (nmi) nmi_enter();\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tif (nmi) nmi_exit();\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable Machine check\", regs, SIGBUS);\n\n\treturn;\n\nbail:\n\tif (nmi) nmi_exit();\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nmi_exit",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable Machine check\"",
            "regs",
            "SIGBUS"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nmi_exit",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_io_access",
          "args": [
            "regs"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "check_io_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "537-573",
          "snippet": "static inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == PPC_INST_NOP)\n\t\t\tnip -= 2;\n\t\telse if (*nip == PPC_INST_ISYNC)\n\t\t\t--nip;\n\t\tif (*nip == PPC_INST_SYNC || (*nip >> 26) == OP_TRAP) {\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == PPC_INST_NOP)\n\t\t\tnip -= 2;\n\t\telse if (*nip == PPC_INST_ISYNC)\n\t\t\t--nip;\n\t\tif (*nip == PPC_INST_SYNC || (*nip >> 26) == OP_TRAP) {\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger_fault_handler",
          "args": [
            "regs"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_cpu_spec->machine_check",
          "args": [
            "regs"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.machine_check_exception",
          "args": [
            "regs"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "826-880",
          "snippet": "void machine_check_exception(struct pt_regs *regs)\n{\n\tint recover = 0;\n\n\t/*\n\t * BOOK3S_64 does not call this handler as a non-maskable interrupt\n\t * (it uses its own early real-mode handler to handle the MCE proper\n\t * and then raises irq_work to call this handler when interrupts are\n\t * enabled).\n\t *\n\t * This is silly. The BOOK3S_64 should just call a different function\n\t * rather than expecting semantics to magically change. Something\n\t * like 'non_nmi_machine_check_exception()', perhaps?\n\t */\n\tconst bool nmi = !IS_ENABLED(CONFIG_PPC_BOOK3S_64);\n\n\tif (nmi) nmi_enter();\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tif (nmi) nmi_exit();\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable Machine check\", regs, SIGBUS);\n\n\treturn;\n\nbail:\n\tif (nmi) nmi_exit();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_MACHINE_CHECK",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.mce_exceptions"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_enter",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S_64"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid machine_check_exception(struct pt_regs *regs)\n{\n\tint recover = 0;\n\n\t/*\n\t * BOOK3S_64 does not call this handler as a non-maskable interrupt\n\t * (it uses its own early real-mode handler to handle the MCE proper\n\t * and then raises irq_work to call this handler when interrupts are\n\t * enabled).\n\t *\n\t * This is silly. The BOOK3S_64 should just call a different function\n\t * rather than expecting semantics to magically change. Something\n\t * like 'non_nmi_machine_check_exception()', perhaps?\n\t */\n\tconst bool nmi = !IS_ENABLED(CONFIG_PPC_BOOK3S_64);\n\n\tif (nmi) nmi_enter();\n\n\t__this_cpu_inc(irq_stat.mce_exceptions);\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\t/* See if any machine dependent calls. In theory, we would want\n\t * to call the CPU first, and call the ppc_md. one if the CPU\n\t * one returns a positive number. However there is existing code\n\t * that assumes the board gets a first chance, so let's keep it\n\t * that way for now and fix things later. --BenH.\n\t */\n\tif (ppc_md.machine_check_exception)\n\t\trecover = ppc_md.machine_check_exception(regs);\n\telse if (cur_cpu_spec->machine_check)\n\t\trecover = cur_cpu_spec->machine_check(regs);\n\n\tif (recover > 0)\n\t\tgoto bail;\n\n\tif (debugger_fault_handler(regs))\n\t\tgoto bail;\n\n\tif (check_io_access(regs))\n\t\tgoto bail;\n\n\tif (nmi) nmi_exit();\n\n\tdie(\"Machine check\", regs, SIGBUS);\n\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable Machine check\", regs, SIGBUS);\n\n\treturn;\n\nbail:\n\tif (nmi) nmi_exit();\n}"
  },
  {
    "function_name": "machine_check_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "789-823",
    "snippet": "int machine_check_generic(struct pt_regs *regs)\n{\n\tunsigned long reason = regs->msr;\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tpr_cont(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tpr_cont(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tpr_cont(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tpr_cont(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tpr_cont(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tpr_cont(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tpr_cont(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_cont(\"Unknown values in msr\\n\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Unknown values in msr\\n\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"L2 data cache parity error\\n\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"L1 Instruction Cache error\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"L1 Data Cache error\\n\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Address parity error signal\\n\""
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Data parity error signal\\n\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Transfer error ack signal\\n\""
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Machine check signal\\n\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from SRR1=%lx): \"",
            "reason"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_generic(struct pt_regs *regs)\n{\n\tunsigned long reason = regs->msr;\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from SRR1=%lx): \", reason);\n\tswitch (reason & 0x601F0000) {\n\tcase 0x80000:\n\t\tpr_cont(\"Machine check signal\\n\");\n\t\tbreak;\n\tcase 0:\t\t/* for 601 */\n\tcase 0x40000:\n\tcase 0x140000:\t/* 7450 MSS error and TEA */\n\t\tpr_cont(\"Transfer error ack signal\\n\");\n\t\tbreak;\n\tcase 0x20000:\n\t\tpr_cont(\"Data parity error signal\\n\");\n\t\tbreak;\n\tcase 0x10000:\n\t\tpr_cont(\"Address parity error signal\\n\");\n\t\tbreak;\n\tcase 0x20000000:\n\t\tpr_cont(\"L1 Data Cache error\\n\");\n\t\tbreak;\n\tcase 0x40000000:\n\t\tpr_cont(\"L1 Instruction Cache error\\n\");\n\t\tbreak;\n\tcase 0x00100000:\n\t\tpr_cont(\"L2 data cache parity error\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_cont(\"Unknown values in msr\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e200",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "764-787",
    "snippet": "int machine_check_e200(struct pt_regs *regs)\n{\n\tunsigned long reason = mfspr(SPRN_MCSR);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tpr_cont(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tpr_cont(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tpr_cont(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tpr_cont(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tpr_cont(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tpr_cont(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Write Bus Error on buffered store or cache line push\\n\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Read Bus Error on data load\\n\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Read Bus Error on instruction fetch\\n\""
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Cache Parity Error\\n\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Cache Push Parity Error\\n\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e200(struct pt_regs *regs)\n{\n\tunsigned long reason = mfspr(SPRN_MCSR);\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_CP_PERR)\n\t\tpr_cont(\"Cache Push Parity Error\\n\");\n\tif (reason & MCSR_CPERR)\n\t\tpr_cont(\"Cache Parity Error\\n\");\n\tif (reason & MCSR_EXCP_ERR)\n\t\tpr_cont(\"ISI, ITLB, or Bus Error on first instruction fetch for an exception handler\\n\");\n\tif (reason & MCSR_BUS_IRERR)\n\t\tpr_cont(\"Bus - Read Bus Error on instruction fetch\\n\");\n\tif (reason & MCSR_BUS_DRERR)\n\t\tpr_cont(\"Bus - Read Bus Error on data load\\n\");\n\tif (reason & MCSR_BUS_WRERR)\n\t\tpr_cont(\"Bus - Write Bus Error on buffered store or cache line push\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "759-762",
    "snippet": "int machine_check_generic(struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_generic(struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e500",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "717-757",
    "snippet": "int machine_check_e500(struct pt_regs *regs)\n{\n\tunsigned long reason = mfspr(SPRN_MCSR);\n\n\tif (reason & MCSR_BUS_RBERR) {\n\t\tif (fsl_rio_mcheck_exception(regs))\n\t\t\treturn 1;\n\t\tif (fsl_pci_mcheck_exception(regs))\n\t\t\treturn 1;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tpr_cont(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tpr_cont(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tpr_cont(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tpr_cont(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tpr_cont(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tpr_cont(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tpr_cont(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tpr_cont(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tpr_cont(\"Bus - Write Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tpr_cont(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tpr_cont(\"Bus - Read Parity Error\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Read Parity Error\\n\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Instruction Parity Error\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Write Data Bus Error\\n\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Read Data Bus Error\\n\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Instruction Data Error\\n\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Write Address Error\\n\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Read Address Error\\n\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Bus - Instruction Address Error\\n\""
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Data Cache Parity Error\\n\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Data Cache Push Parity Error\\n\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Instruction Cache Parity Error\\n\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_pci_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_rio_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e500(struct pt_regs *regs)\n{\n\tunsigned long reason = mfspr(SPRN_MCSR);\n\n\tif (reason & MCSR_BUS_RBERR) {\n\t\tif (fsl_rio_mcheck_exception(regs))\n\t\t\treturn 1;\n\t\tif (fsl_pci_mcheck_exception(regs))\n\t\t\treturn 1;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\tif (reason & MCSR_ICPERR)\n\t\tpr_cont(\"Instruction Cache Parity Error\\n\");\n\tif (reason & MCSR_DCP_PERR)\n\t\tpr_cont(\"Data Cache Push Parity Error\\n\");\n\tif (reason & MCSR_DCPERR)\n\t\tpr_cont(\"Data Cache Parity Error\\n\");\n\tif (reason & MCSR_BUS_IAERR)\n\t\tpr_cont(\"Bus - Instruction Address Error\\n\");\n\tif (reason & MCSR_BUS_RAERR)\n\t\tpr_cont(\"Bus - Read Address Error\\n\");\n\tif (reason & MCSR_BUS_WAERR)\n\t\tpr_cont(\"Bus - Write Address Error\\n\");\n\tif (reason & MCSR_BUS_IBERR)\n\t\tpr_cont(\"Bus - Instruction Data Error\\n\");\n\tif (reason & MCSR_BUS_RBERR)\n\t\tpr_cont(\"Bus - Read Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_WBERR)\n\t\tpr_cont(\"Bus - Write Data Bus Error\\n\");\n\tif (reason & MCSR_BUS_IPERR)\n\t\tpr_cont(\"Bus - Instruction Parity Error\\n\");\n\tif (reason & MCSR_BUS_RPERR)\n\t\tpr_cont(\"Bus - Read Parity Error\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_e500mc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "610-715",
    "snippet": "int machine_check_e500mc(struct pt_regs *regs)\n{\n\tunsigned long mcsr = mfspr(SPRN_MCSR);\n\tunsigned long pvr = mfspr(SPRN_PVR);\n\tunsigned long reason = mcsr;\n\tint recoverable = 1;\n\n\tif (reason & MCSR_LD) {\n\t\trecoverable = fsl_rio_mcheck_exception(regs);\n\t\tif (recoverable == 1)\n\t\t\tgoto silent_out;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\n\tif (reason & MCSR_ICPERR) {\n\t\tpr_cont(\"Instruction Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * This is recoverable by invalidating the i-cache.\n\t\t */\n\t\tmtspr(SPRN_L1CSR1, mfspr(SPRN_L1CSR1) | L1CSR1_ICFI);\n\t\twhile (mfspr(SPRN_L1CSR1) & L1CSR1_ICFI)\n\t\t\t;\n\n\t\t/*\n\t\t * This will generally be accompanied by an instruction\n\t\t * fetch error report -- only treat MCSR_IF as fatal\n\t\t * if it wasn't due to an L1 parity error.\n\t\t */\n\t\treason &= ~MCSR_IF;\n\t}\n\n\tif (reason & MCSR_DCPERR_MC) {\n\t\tpr_cont(\"Data Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * In write shadow mode we auto-recover from the error, but it\n\t\t * may still get logged and cause a machine check.  We should\n\t\t * only treat the non-write shadow case as non-recoverable.\n\t\t */\n\t\t/* On e6500 core, L1 DCWS (Data cache write shadow mode) bit\n\t\t * is not implemented but L1 data cache always runs in write\n\t\t * shadow mode. Hence on data cache parity errors HW will\n\t\t * automatically invalidate the L1 Data Cache.\n\t\t */\n\t\tif (PVR_VER(pvr) != PVR_VER_E6500) {\n\t\t\tif (!(mfspr(SPRN_L1CSR2) & L1CSR2_DCWS))\n\t\t\t\trecoverable = 0;\n\t\t}\n\t}\n\n\tif (reason & MCSR_L2MMU_MHIT) {\n\t\tpr_cont(\"Hit on multiple TLB entries\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_NMI)\n\t\tpr_cont(\"Non-maskable interrupt\\n\");\n\n\tif (reason & MCSR_IF) {\n\t\tpr_cont(\"Instruction Fetch Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LD) {\n\t\tpr_cont(\"Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_ST) {\n\t\tpr_cont(\"Store Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LDG) {\n\t\tpr_cont(\"Guarded Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_TLBSYNC)\n\t\tpr_cont(\"Simultaneous tlbsync operations\\n\");\n\n\tif (reason & MCSR_BSL2_ERR) {\n\t\tpr_cont(\"Level 2 Cache Error\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_MAV) {\n\t\tu64 addr;\n\n\t\taddr = mfspr(SPRN_MCAR);\n\t\taddr |= (u64)mfspr(SPRN_MCARU) << 32;\n\n\t\tpr_cont(\"Machine Check %s Address: %#llx\\n\",\n\t\t       reason & MCSR_MEA ? \"Effective\" : \"Physical\", addr);\n\t}\n\nsilent_out:\n\tmtspr(SPRN_MCSR, mcsr);\n\treturn mfspr(SPRN_MCSR) == 0 && recoverable;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MCSR",
            "mcsr"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Machine Check %s Address: %#llx\\n\"",
            "reason & MCSR_MEA ? \"Effective\" : \"Physical\"",
            "addr"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCARU"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCAR"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Level 2 Cache Error\\n\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Simultaneous tlbsync operations\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Guarded Load Error Report\\n\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Store Error Report\\n\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Load Error Report\\n\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Instruction Fetch Error Report\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Non-maskable interrupt\\n\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Hit on multiple TLB entries\\n\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR2"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PVR_VER",
          "args": [
            "pvr"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Data Cache Parity Error\\n\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR1"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_L1CSR1",
            "mfspr(SPRN_L1CSR1) | L1CSR1_ICFI"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_L1CSR1"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Instruction Cache Parity Error\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"Machine Check Signal\\n\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Caused by (from MCSR=%lx): \"",
            "reason"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Machine check in kernel mode.\\n\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsl_rio_mcheck_exception",
          "args": [
            "regs"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MCSR"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint machine_check_e500mc(struct pt_regs *regs)\n{\n\tunsigned long mcsr = mfspr(SPRN_MCSR);\n\tunsigned long pvr = mfspr(SPRN_PVR);\n\tunsigned long reason = mcsr;\n\tint recoverable = 1;\n\n\tif (reason & MCSR_LD) {\n\t\trecoverable = fsl_rio_mcheck_exception(regs);\n\t\tif (recoverable == 1)\n\t\t\tgoto silent_out;\n\t}\n\n\tprintk(\"Machine check in kernel mode.\\n\");\n\tprintk(\"Caused by (from MCSR=%lx): \", reason);\n\n\tif (reason & MCSR_MCP)\n\t\tpr_cont(\"Machine Check Signal\\n\");\n\n\tif (reason & MCSR_ICPERR) {\n\t\tpr_cont(\"Instruction Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * This is recoverable by invalidating the i-cache.\n\t\t */\n\t\tmtspr(SPRN_L1CSR1, mfspr(SPRN_L1CSR1) | L1CSR1_ICFI);\n\t\twhile (mfspr(SPRN_L1CSR1) & L1CSR1_ICFI)\n\t\t\t;\n\n\t\t/*\n\t\t * This will generally be accompanied by an instruction\n\t\t * fetch error report -- only treat MCSR_IF as fatal\n\t\t * if it wasn't due to an L1 parity error.\n\t\t */\n\t\treason &= ~MCSR_IF;\n\t}\n\n\tif (reason & MCSR_DCPERR_MC) {\n\t\tpr_cont(\"Data Cache Parity Error\\n\");\n\n\t\t/*\n\t\t * In write shadow mode we auto-recover from the error, but it\n\t\t * may still get logged and cause a machine check.  We should\n\t\t * only treat the non-write shadow case as non-recoverable.\n\t\t */\n\t\t/* On e6500 core, L1 DCWS (Data cache write shadow mode) bit\n\t\t * is not implemented but L1 data cache always runs in write\n\t\t * shadow mode. Hence on data cache parity errors HW will\n\t\t * automatically invalidate the L1 Data Cache.\n\t\t */\n\t\tif (PVR_VER(pvr) != PVR_VER_E6500) {\n\t\t\tif (!(mfspr(SPRN_L1CSR2) & L1CSR2_DCWS))\n\t\t\t\trecoverable = 0;\n\t\t}\n\t}\n\n\tif (reason & MCSR_L2MMU_MHIT) {\n\t\tpr_cont(\"Hit on multiple TLB entries\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_NMI)\n\t\tpr_cont(\"Non-maskable interrupt\\n\");\n\n\tif (reason & MCSR_IF) {\n\t\tpr_cont(\"Instruction Fetch Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LD) {\n\t\tpr_cont(\"Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_ST) {\n\t\tpr_cont(\"Store Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_LDG) {\n\t\tpr_cont(\"Guarded Load Error Report\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_TLBSYNC)\n\t\tpr_cont(\"Simultaneous tlbsync operations\\n\");\n\n\tif (reason & MCSR_BSL2_ERR) {\n\t\tpr_cont(\"Level 2 Cache Error\\n\");\n\t\trecoverable = 0;\n\t}\n\n\tif (reason & MCSR_MAV) {\n\t\tu64 addr;\n\n\t\taddr = mfspr(SPRN_MCAR);\n\t\taddr |= (u64)mfspr(SPRN_MCARU) << 32;\n\n\t\tpr_cont(\"Machine Check %s Address: %#llx\\n\",\n\t\t       reason & MCSR_MEA ? \"Effective\" : \"Physical\", addr);\n\t}\n\nsilent_out:\n\tmtspr(SPRN_MCSR, mcsr);\n\treturn mfspr(SPRN_MCSR) == 0 && recoverable;\n}"
  },
  {
    "function_name": "check_io_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "537-573",
    "snippet": "static inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == PPC_INST_NOP)\n\t\t\tnip -= 2;\n\t\telse if (*nip == PPC_INST_ISYNC)\n\t\t\t--nip;\n\t\tif (*nip == PPC_INST_SYNC || (*nip >> 26) == OP_TRAP) {\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extable_fixup",
          "args": [
            "entry"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s bad port %lx at %p\\n\"",
            "(*nip & 0x100)? \"OUT to\": \"IN from\"",
            "regs->gpr[rb] - _IO_BASE",
            "nip"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_exception_tables",
          "args": [
            "regs->nip"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int check_io_access(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC32\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == PPC_INST_NOP)\n\t\t\tnip -= 2;\n\t\telse if (*nip == PPC_INST_ISYNC)\n\t\t\t--nip;\n\t\tif (*nip == PPC_INST_SYNC || (*nip >> 26) == OP_TRAP) {\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC32 */\n\treturn 0;\n}"
  },
  {
    "function_name": "system_reset_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "440-525",
    "snippet": "void system_reset_exception(struct pt_regs *regs)\n{\n\tunsigned long hsrr0, hsrr1;\n\tbool saved_hsrrs = false;\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tnmi_enter();\n\n\t/*\n\t * System reset can interrupt code where HSRRs are live and MSR[RI]=1.\n\t * The system reset interrupt itself may clobber HSRRs (e.g., to call\n\t * OPAL), so save them here and restore them before returning.\n\t *\n\t * Machine checks don't need to save HSRRs, as the real mode handler\n\t * is careful to avoid them, and the regular handler is not delivered\n\t * as an NMI.\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\thsrr0 = mfspr(SPRN_HSRR0);\n\t\thsrr1 = mfspr(SPRN_HSRR1);\n\t\tsaved_hsrrs = true;\n\t}\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t__this_cpu_inc(irq_stat.sreset_irqs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\tgoto out;\n\t}\n\n\tif (debugger(regs))\n\t\tgoto out;\n\n\tkmsg_dump(KMSG_DUMP_OOPS);\n\t/*\n\t * A system reset is a request to dump, so we always send\n\t * it through the crashdump code (if fadump or kdump are\n\t * registered).\n\t */\n\tcrash_fadump(regs, \"System Reset\");\n\n\tcrash_kexec(regs);\n\n\t/*\n\t * We aren't the primary crash CPU. We need to send it\n\t * to a holding pattern to avoid it ending up in the panic\n\t * code.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/*\n\t * No debugger or crash dump registered, print logs then\n\t * panic.\n\t */\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\tmdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tnmi_panic(regs, \"System Reset\");\n\nout:\n#ifdef CONFIG_PPC_BOOK3S_64\n\tBUG_ON(get_paca()->in_nmi == 0);\n\tif (get_paca()->in_nmi > 1)\n\t\tdie(\"Unrecoverable nested System Reset\", regs, SIGABRT);\n#endif\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable System Reset\", regs, SIGABRT);\n\n\tif (saved_hsrrs) {\n\t\tmtspr(SPRN_HSRR0, hsrr0);\n\t\tmtspr(SPRN_HSRR1, hsrr1);\n\t}\n\n\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_set_ftrace_enabled",
          "args": [
            "ftrace_enabled"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_exit",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_HSRR1",
            "hsrr1"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_HSRR0",
            "hsrr0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Unrecoverable System Reset\"",
            "regs",
            "SIGABRT"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "get_paca()->in_nmi == 0"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_panic",
          "args": [
            "regs",
            "\"System Reset\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_DIE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "2*MSEC_PER_SEC"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_kexec_secondary",
          "args": [
            "regs"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_kexec",
          "args": [
            "regs"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_fadump",
          "args": [
            "regs",
            "\"System Reset\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "crash_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "680-738",
          "snippet": "void crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [
            "#define CRASH_TIMEOUT\t\t500"
          ],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#define CRASH_TIMEOUT\t\t500\n\nstatic struct fw_dump fw_dump;\n\nvoid crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_OOPS"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "135-139",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/slab.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/slab.h>\n#include <asm/code-patching.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.system_reset_exception",
          "args": [
            "regs"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "system_reset_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "440-525",
          "snippet": "void system_reset_exception(struct pt_regs *regs)\n{\n\tunsigned long hsrr0, hsrr1;\n\tbool saved_hsrrs = false;\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tnmi_enter();\n\n\t/*\n\t * System reset can interrupt code where HSRRs are live and MSR[RI]=1.\n\t * The system reset interrupt itself may clobber HSRRs (e.g., to call\n\t * OPAL), so save them here and restore them before returning.\n\t *\n\t * Machine checks don't need to save HSRRs, as the real mode handler\n\t * is careful to avoid them, and the regular handler is not delivered\n\t * as an NMI.\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\thsrr0 = mfspr(SPRN_HSRR0);\n\t\thsrr1 = mfspr(SPRN_HSRR1);\n\t\tsaved_hsrrs = true;\n\t}\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t__this_cpu_inc(irq_stat.sreset_irqs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\tgoto out;\n\t}\n\n\tif (debugger(regs))\n\t\tgoto out;\n\n\tkmsg_dump(KMSG_DUMP_OOPS);\n\t/*\n\t * A system reset is a request to dump, so we always send\n\t * it through the crashdump code (if fadump or kdump are\n\t * registered).\n\t */\n\tcrash_fadump(regs, \"System Reset\");\n\n\tcrash_kexec(regs);\n\n\t/*\n\t * We aren't the primary crash CPU. We need to send it\n\t * to a holding pattern to avoid it ending up in the panic\n\t * code.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/*\n\t * No debugger or crash dump registered, print logs then\n\t * panic.\n\t */\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\tmdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tnmi_panic(regs, \"System Reset\");\n\nout:\n#ifdef CONFIG_PPC_BOOK3S_64\n\tBUG_ON(get_paca()->in_nmi == 0);\n\tif (get_paca()->in_nmi > 1)\n\t\tdie(\"Unrecoverable nested System Reset\", regs, SIGABRT);\n#endif\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable System Reset\", regs, SIGABRT);\n\n\tif (saved_hsrrs) {\n\t\tmtspr(SPRN_HSRR0, hsrr0);\n\t\tmtspr(SPRN_HSRR1, hsrr1);\n\t}\n\n\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.sreset_irqs"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hv_nmi_check_nonrecoverable",
          "args": [
            "regs"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "hv_nmi_check_nonrecoverable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "396-438",
          "snippet": "void hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HSRR1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HSRR0"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_enter",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_set_ftrace_enabled",
          "args": [
            "0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_get_ftrace_enabled",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid system_reset_exception(struct pt_regs *regs)\n{\n\tunsigned long hsrr0, hsrr1;\n\tbool saved_hsrrs = false;\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tnmi_enter();\n\n\t/*\n\t * System reset can interrupt code where HSRRs are live and MSR[RI]=1.\n\t * The system reset interrupt itself may clobber HSRRs (e.g., to call\n\t * OPAL), so save them here and restore them before returning.\n\t *\n\t * Machine checks don't need to save HSRRs, as the real mode handler\n\t * is careful to avoid them, and the regular handler is not delivered\n\t * as an NMI.\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\thsrr0 = mfspr(SPRN_HSRR0);\n\t\thsrr1 = mfspr(SPRN_HSRR1);\n\t\tsaved_hsrrs = true;\n\t}\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t__this_cpu_inc(irq_stat.sreset_irqs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\tgoto out;\n\t}\n\n\tif (debugger(regs))\n\t\tgoto out;\n\n\tkmsg_dump(KMSG_DUMP_OOPS);\n\t/*\n\t * A system reset is a request to dump, so we always send\n\t * it through the crashdump code (if fadump or kdump are\n\t * registered).\n\t */\n\tcrash_fadump(regs, \"System Reset\");\n\n\tcrash_kexec(regs);\n\n\t/*\n\t * We aren't the primary crash CPU. We need to send it\n\t * to a holding pattern to avoid it ending up in the panic\n\t * code.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/*\n\t * No debugger or crash dump registered, print logs then\n\t * panic.\n\t */\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\tmdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tnmi_panic(regs, \"System Reset\");\n\nout:\n#ifdef CONFIG_PPC_BOOK3S_64\n\tBUG_ON(get_paca()->in_nmi == 0);\n\tif (get_paca()->in_nmi > 1)\n\t\tdie(\"Unrecoverable nested System Reset\", regs, SIGABRT);\n#endif\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable System Reset\", regs, SIGABRT);\n\n\tif (saved_hsrrs) {\n\t\tmtspr(SPRN_HSRR0, hsrr0);\n\t\tmtspr(SPRN_HSRR1, hsrr1);\n\t}\n\n\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}"
  },
  {
    "function_name": "hv_nmi_check_nonrecoverable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "396-438",
    "snippet": "void hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}"
  },
  {
    "function_name": "_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "367-373",
    "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_fault",
          "args": [
            "signr",
            "code",
            "(void __user *)addr"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception_common",
          "args": [
            "signr",
            "regs",
            "code",
            "addr"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "exception_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "335-357",
          "snippet": "static bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
  },
  {
    "function_name": "_exception_pkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "359-365",
    "snippet": "void _exception_pkey(struct pt_regs *regs, unsigned long addr, int key)\n{\n\tif (!exception_common(SIGSEGV, regs, SEGV_PKUERR, addr))\n\t\treturn;\n\n\tforce_sig_pkuerr((void __user *) addr, key);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exception_common",
          "args": [
            "SIGSEGV",
            "regs",
            "SEGV_PKUERR",
            "addr"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "exception_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "335-357",
          "snippet": "static bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception_pkey(struct pt_regs *regs, unsigned long addr, int key)\n{\n\tif (!exception_common(SIGSEGV, regs, SEGV_PKUERR, addr))\n\t\treturn;\n\n\tforce_sig_pkuerr((void __user *) addr, key);\n}"
  },
  {
    "function_name": "exception_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "335-357",
    "snippet": "static bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_pkey_regs_save",
          "args": [
            "&current->thread"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irq_disabled_regs",
          "args": [
            "regs"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irqs_disabled",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_signal_msg",
          "args": [
            "signr",
            "regs",
            "code",
            "addr"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "show_signal_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "309-333",
          "snippet": "static void show_signal_msg(int signr, struct pt_regs *regs, int code,\n\t\t\t    unsigned long addr)\n{\n\tstatic DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (!show_unhandled_signals)\n\t\treturn;\n\n\tif (!unhandled_signal(current, signr))\n\t\treturn;\n\n\tif (!__ratelimit(&rs))\n\t\treturn;\n\n\tpr_info(\"%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x\",\n\t\tcurrent->comm, current->pid, signame(signr), signr,\n\t\taddr, regs->nip, regs->link, code);\n\n\tprint_vma_addr(KERN_CONT \" in \", regs->nip);\n\n\tpr_cont(\"\\n\");\n\n\tshow_user_instructions(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void show_signal_msg(int signr, struct pt_regs *regs, int code,\n\t\t\t    unsigned long addr)\n{\n\tstatic DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (!show_unhandled_signals)\n\t\treturn;\n\n\tif (!unhandled_signal(current, signr))\n\t\treturn;\n\n\tif (!__ratelimit(&rs))\n\t\treturn;\n\n\tpr_info(\"%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x\",\n\t\tcurrent->comm, current->pid, signame(signr), signr,\n\t\taddr, regs->nip, regs->link, code);\n\n\tprint_vma_addr(KERN_CONT \" in \", regs->nip);\n\n\tpr_cont(\"\\n\");\n\n\tshow_user_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "die",
          "args": [
            "\"Exception in kernel mode\"",
            "regs",
            "signr"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "285-301",
          "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic bool exception_common(int signr, struct pt_regs *regs, int code,\n\t\t\t      unsigned long addr)\n{\n\tif (!user_mode(regs)) {\n\t\tdie(\"Exception in kernel mode\", regs, signr);\n\t\treturn false;\n\t}\n\n\tshow_signal_msg(signr, regs, code, addr);\n\n\tif (arch_irqs_disabled() && !arch_irq_disabled_regs(regs))\n\t\tlocal_irq_enable();\n\n\tcurrent->thread.trap_nr = code;\n\n\t/*\n\t * Save all the pkey registers AMR/IAMR/UAMOR. Eg: Core dumps need\n\t * to capture the content, if the task gets killed.\n\t */\n\tthread_pkey_regs_save(&current->thread);\n\n\treturn true;\n}"
  },
  {
    "function_name": "show_signal_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "309-333",
    "snippet": "static void show_signal_msg(int signr, struct pt_regs *regs, int code,\n\t\t\t    unsigned long addr)\n{\n\tstatic DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (!show_unhandled_signals)\n\t\treturn;\n\n\tif (!unhandled_signal(current, signr))\n\t\treturn;\n\n\tif (!__ratelimit(&rs))\n\t\treturn;\n\n\tpr_info(\"%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x\",\n\t\tcurrent->comm, current->pid, signame(signr), signr,\n\t\taddr, regs->nip, regs->link, code);\n\n\tprint_vma_addr(KERN_CONT \" in \", regs->nip);\n\n\tpr_cont(\"\\n\");\n\n\tshow_user_instructions(regs);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_user_instructions",
          "args": [
            "regs"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "show_user_instructions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1345-1376",
          "snippet": "void show_user_instructions(struct pt_regs *regs)\n{\n\tunsigned long pc;\n\tint n = NR_INSN_TO_PRINT;\n\tstruct seq_buf s;\n\tchar buf[96]; /* enough for 8 times 9 + 2 chars */\n\n\tpc = regs->nip - (NR_INSN_TO_PRINT * 3 / 4 * sizeof(int));\n\n\tseq_buf_init(&s, buf, sizeof(buf));\n\n\twhile (n) {\n\t\tint i;\n\n\t\tseq_buf_clear(&s);\n\n\t\tfor (i = 0; i < 8 && n; i++, n--, pc += sizeof(int)) {\n\t\t\tint instr;\n\n\t\t\tif (copy_from_user_nofault(&instr, (void __user *)pc,\n\t\t\t\t\tsizeof(instr))) {\n\t\t\t\tseq_buf_printf(&s, \"XXXXXXXX \");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseq_buf_printf(&s, regs->nip == pc ? \"<%08x> \" : \"%08x \", instr);\n\t\t}\n\n\t\tif (!seq_buf_has_overflowed(&s))\n\t\t\tpr_info(\"%s[%d]: code: %s\\n\", current->comm,\n\t\t\t\tcurrent->pid, s.buffer);\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NR_INSN_TO_PRINT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NR_INSN_TO_PRINT\t16\n\nvoid show_user_instructions(struct pt_regs *regs)\n{\n\tunsigned long pc;\n\tint n = NR_INSN_TO_PRINT;\n\tstruct seq_buf s;\n\tchar buf[96]; /* enough for 8 times 9 + 2 chars */\n\n\tpc = regs->nip - (NR_INSN_TO_PRINT * 3 / 4 * sizeof(int));\n\n\tseq_buf_init(&s, buf, sizeof(buf));\n\n\twhile (n) {\n\t\tint i;\n\n\t\tseq_buf_clear(&s);\n\n\t\tfor (i = 0; i < 8 && n; i++, n--, pc += sizeof(int)) {\n\t\t\tint instr;\n\n\t\t\tif (copy_from_user_nofault(&instr, (void __user *)pc,\n\t\t\t\t\tsizeof(instr))) {\n\t\t\t\tseq_buf_printf(&s, \"XXXXXXXX \");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tseq_buf_printf(&s, regs->nip == pc ? \"<%08x> \" : \"%08x \", instr);\n\t\t}\n\n\t\tif (!seq_buf_has_overflowed(&s))\n\t\t\tpr_info(\"%s[%d]: code: %s\\n\", current->comm,\n\t\t\t\tcurrent->pid, s.buffer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_vma_addr",
          "args": [
            "KERN_CONT \" in \"",
            "regs->nip"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x\"",
            "current->comm",
            "current->pid",
            "signame(signr)",
            "signr",
            "addr",
            "regs->nip",
            "regs->link",
            "code"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signame",
          "args": [
            "signr"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "signame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "96-107",
          "snippet": "static const char *signame(int signr)\n{\n\tswitch (signr) {\n\tcase SIGBUS:\treturn \"bus error\";\n\tcase SIGFPE:\treturn \"floating point exception\";\n\tcase SIGILL:\treturn \"illegal instruction\";\n\tcase SIGSEGV:\treturn \"segfault\";\n\tcase SIGTRAP:\treturn \"unhandled trap\";\n\t}\n\n\treturn \"unknown signal\";\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic const char *signame(int signr)\n{\n\tswitch (signr) {\n\tcase SIGBUS:\treturn \"bus error\";\n\tcase SIGFPE:\treturn \"floating point exception\";\n\tcase SIGILL:\treturn \"illegal instruction\";\n\tcase SIGSEGV:\treturn \"segfault\";\n\tcase SIGTRAP:\treturn \"unhandled trap\";\n\t}\n\n\treturn \"unknown signal\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&rs"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhandled_signal",
          "args": [
            "current",
            "signr"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void show_signal_msg(int signr, struct pt_regs *regs, int code,\n\t\t\t    unsigned long addr)\n{\n\tstatic DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (!show_unhandled_signals)\n\t\treturn;\n\n\tif (!unhandled_signal(current, signr))\n\t\treturn;\n\n\tif (!__ratelimit(&rs))\n\t\treturn;\n\n\tpr_info(\"%s[%d]: %s (%d) at %lx nip %lx lr %lx code %x\",\n\t\tcurrent->comm, current->pid, signame(signr), signr,\n\t\taddr, regs->nip, regs->link, code);\n\n\tprint_vma_addr(KERN_CONT \" in \", regs->nip);\n\n\tpr_cont(\"\\n\");\n\n\tshow_user_instructions(regs);\n}"
  },
  {
    "function_name": "user_single_step_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "304-307",
    "snippet": "void user_single_step_report(struct pt_regs *regs)\n{\n\tforce_sig_fault(SIGTRAP, TRAP_TRACE, (void __user *)regs->nip);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_fault",
          "args": [
            "SIGTRAP",
            "TRAP_TRACE",
            "(void __user *)regs->nip"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid user_single_step_report(struct pt_regs *regs)\n{\n\tforce_sig_fault(SIGTRAP, TRAP_TRACE, (void __user *)regs->nip);\n}"
  },
  {
    "function_name": "die",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "285-301",
    "snippet": "void die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oops_end",
          "args": [
            "flags",
            "regs",
            "err"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "oops_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "206-249",
          "snippet": "static void oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count) {\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tdie_owner = -1;\n\t\tarch_spin_unlock(&die_lock);\n\t}\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\treturn;\n\n\tcrash_fadump(regs, \"die oops\");\n\n\tif (kexec_should_crash(current))\n\t\tcrash_kexec(regs);\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
            "static int die_owner = -1;",
            "static unsigned int die_nest_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic void oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count) {\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tdie_owner = -1;\n\t\tarch_spin_unlock(&die_lock);\n\t}\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\treturn;\n\n\tcrash_fadump(regs, \"die oops\");\n\n\tif (kexec_should_crash(current))\n\t\tcrash_kexec(regs);\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__die",
          "args": [
            "str",
            "regs",
            "err"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__die",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "261-282",
          "snippet": "static int __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n\n\tprintk(\"%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\\n\",\n\t       IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? \"LE\" : \"BE\",\n\t       PAGE_SIZE / 1024, get_mmu_str(),\n\t       IS_ENABLED(CONFIG_PREEMPT) ? \" PREEMPT\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? \" SMP\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? (\" NR_CPUS=\" __stringify(NR_CPUS)) : \"\",\n\t       debug_pagealloc_enabled() ? \" DEBUG_PAGEALLOC\" : \"\",\n\t       IS_ENABLED(CONFIG_NUMA) ? \" NUMA\" : \"\",\n\t       ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int die_counter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int die_counter;\n\nstatic int __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n\n\tprintk(\"%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\\n\",\n\t       IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? \"LE\" : \"BE\",\n\t       PAGE_SIZE / 1024, get_mmu_str(),\n\t       IS_ENABLED(CONFIG_PREEMPT) ? \" PREEMPT\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? \" SMP\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? (\" NR_CPUS=\" __stringify(NR_CPUS)) : \"\",\n\t       debug_pagealloc_enabled() ? \" DEBUG_PAGEALLOC\" : \"\",\n\t       IS_ENABLED(CONFIG_NUMA) ? \" NUMA\" : \"\",\n\t       ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oops_begin",
          "args": [
            "regs"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "oops_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "180-203",
          "snippet": "static unsigned long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
            "static int die_owner = -1;",
            "static unsigned int die_nest_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic unsigned long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugger",
          "args": [
            "regs"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_debugger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "135-139",
          "snippet": "static int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/slab.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/slab.h>\n#include <asm/code-patching.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_debugger(struct pt_regs *regs)\n{\n\treturn !kgdb_handle_exception(1, computeSignal(TRAP(regs)),\n\t\t\t\t      DIE_OOPS, regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid die(const char *str, struct pt_regs *regs, long err)\n{\n\tunsigned long flags;\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) != 0x100) {\n\t\tif (debugger(regs))\n\t\t\treturn;\n\t}\n\n\tflags = oops_begin(regs);\n\tif (__die(str, regs, err))\n\t\terr = 0;\n\toops_end(flags, regs, err);\n}"
  },
  {
    "function_name": "__die",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "261-282",
    "snippet": "static int __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n\n\tprintk(\"%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\\n\",\n\t       IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? \"LE\" : \"BE\",\n\t       PAGE_SIZE / 1024, get_mmu_str(),\n\t       IS_ENABLED(CONFIG_PREEMPT) ? \" PREEMPT\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? \" SMP\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? (\" NR_CPUS=\" __stringify(NR_CPUS)) : \"\",\n\t       debug_pagealloc_enabled() ? \" DEBUG_PAGEALLOC\" : \"\",\n\t       IS_ENABLED(CONFIG_NUMA) ? \" NUMA\" : \"\",\n\t       ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int die_counter;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1469-1519",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_OOPS",
            "str",
            "regs",
            "err",
            "255",
            "SIGSEGV"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\\n\"",
            "IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? \"LE\" : \"BE\"",
            "PAGE_SIZE / 1024",
            "get_mmu_str()",
            "IS_ENABLED(CONFIG_PREEMPT) ? \" PREEMPT\" : \"\"",
            "IS_ENABLED(CONFIG_SMP) ? \" SMP\" : \"\"",
            "IS_ENABLED(CONFIG_SMP) ? (\" NR_CPUS=\" __stringify(NR_CPUS)) : \"\"",
            "debug_pagealloc_enabled() ? \" DEBUG_PAGEALLOC\" : \"\"",
            "IS_ENABLED(CONFIG_NUMA) ? \" NUMA\" : \"\"",
            "ppc_md.name ? ppc_md.name : \"\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\" NR_CPUS=\" __stringify",
          "args": [
            "NR_CPUS"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mmu_str",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmu_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "252-259",
          "snippet": "static char *get_mmu_str(void)\n{\n\tif (early_radix_enabled())\n\t\treturn \" MMU=Radix\";\n\tif (early_mmu_has_feature(MMU_FTR_HPTE_TABLE))\n\t\treturn \" MMU=Hash\";\n\treturn \"\";\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char *get_mmu_str(void)\n{\n\tif (early_radix_enabled())\n\t\treturn \" MMU=Radix\";\n\tif (early_mmu_has_feature(MMU_FTR_HPTE_TABLE))\n\t\treturn \" MMU=Hash\";\n\treturn \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CPU_LITTLE_ENDIAN"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Oops: %s, sig: %ld [#%d]\\n\"",
            "str",
            "err",
            "++die_counter"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int die_counter;\n\nstatic int __die(const char *str, struct pt_regs *regs, long err)\n{\n\tprintk(\"Oops: %s, sig: %ld [#%d]\\n\", str, err, ++die_counter);\n\n\tprintk(\"%s PAGE_SIZE=%luK%s%s%s%s%s%s %s\\n\",\n\t       IS_ENABLED(CONFIG_CPU_LITTLE_ENDIAN) ? \"LE\" : \"BE\",\n\t       PAGE_SIZE / 1024, get_mmu_str(),\n\t       IS_ENABLED(CONFIG_PREEMPT) ? \" PREEMPT\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? \" SMP\" : \"\",\n\t       IS_ENABLED(CONFIG_SMP) ? (\" NR_CPUS=\" __stringify(NR_CPUS)) : \"\",\n\t       debug_pagealloc_enabled() ? \" DEBUG_PAGEALLOC\" : \"\",\n\t       IS_ENABLED(CONFIG_NUMA) ? \" NUMA\" : \"\",\n\t       ppc_md.name ? ppc_md.name : \"\");\n\n\tif (notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV) == NOTIFY_STOP)\n\t\treturn 1;\n\n\tprint_modules();\n\tshow_regs(regs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_mmu_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "252-259",
    "snippet": "static char *get_mmu_str(void)\n{\n\tif (early_radix_enabled())\n\t\treturn \" MMU=Radix\";\n\tif (early_mmu_has_feature(MMU_FTR_HPTE_TABLE))\n\t\treturn \" MMU=Hash\";\n\treturn \"\";\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_mmu_has_feature",
          "args": [
            "MMU_FTR_HPTE_TABLE"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_radix_enabled",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char *get_mmu_str(void)\n{\n\tif (early_radix_enabled())\n\t\treturn \" MMU=Radix\";\n\tif (early_mmu_has_feature(MMU_FTR_HPTE_TABLE))\n\t\treturn \" MMU=Hash\";\n\treturn \"\";\n}"
  },
  {
    "function_name": "oops_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "206-249",
    "snippet": "static void oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count) {\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tdie_owner = -1;\n\t\tarch_spin_unlock(&die_lock);\n\t}\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\treturn;\n\n\tcrash_fadump(regs, \"die oops\");\n\n\tif (kexec_should_crash(current))\n\t\tcrash_kexec(regs);\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
      "static int die_owner = -1;",
      "static unsigned int die_nest_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "signr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Fatal exception\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "MSEC_PER_SEC"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "current"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_kexec",
          "args": [
            "regs"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_should_crash",
          "args": [
            "current"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_fadump",
          "args": [
            "regs",
            "\"die oops\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "crash_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "680-738",
          "snippet": "void crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [
            "#define CRASH_TIMEOUT\t\t500"
          ],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#define CRASH_TIMEOUT\t\t500\n\nstatic struct fw_dump fw_dump;\n\nvoid crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&die_lock"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oops_exit",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_DIE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "0"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic void oops_end(unsigned long flags, struct pt_regs *regs,\n\t\t\t       int signr)\n{\n\tbust_spinlocks(0);\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tdie_nest_count--;\n\toops_exit();\n\tprintk(\"\\n\");\n\tif (!die_nest_count) {\n\t\t/* Nest count reaches zero, release the lock. */\n\t\tdie_owner = -1;\n\t\tarch_spin_unlock(&die_lock);\n\t}\n\traw_local_irq_restore(flags);\n\n\t/*\n\t * system_reset_excption handles debugger, crash dump, panic, for 0x100\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\treturn;\n\n\tcrash_fadump(regs, \"die oops\");\n\n\tif (kexec_should_crash(current))\n\t\tcrash_kexec(regs);\n\n\tif (!signr)\n\t\treturn;\n\n\t/*\n\t * While our oops output is serialised by a spinlock, output\n\t * from panic() called below can race and corrupt it. If we\n\t * know we are going to panic, delay for 1 second so we have a\n\t * chance to get clean backtraces from all CPUs that are oopsing.\n\t */\n\tif (in_interrupt() || panic_on_oops || !current->pid ||\n\t    is_global_init(current)) {\n\t\tmdelay(MSEC_PER_SEC);\n\t}\n\n\tif (panic_on_oops)\n\t\tpanic(\"Fatal exception\");\n\tdo_exit(signr);\n}"
  },
  {
    "function_name": "oops_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "180-203",
    "snippet": "static unsigned long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;",
      "static int die_owner = -1;",
      "static unsigned int die_nest_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmac_backlight_unblank",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "pmac_backlight_unblank",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "128-128",
          "snippet": "static inline void pmac_backlight_unblank(void) { }",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void pmac_backlight_unblank(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powermac"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "1"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_verbose",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&die_lock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_trylock",
          "args": [
            "&die_lock"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "flags"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oops_enter",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic arch_spinlock_t die_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstatic int die_owner = -1;\nstatic unsigned int die_nest_count;\n\nstatic unsigned long oops_begin(struct pt_regs *regs)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\toops_enter();\n\n\t/* racy, but better than risking deadlock. */\n\traw_local_irq_save(flags);\n\tcpu = smp_processor_id();\n\tif (!arch_spin_trylock(&die_lock)) {\n\t\tif (cpu == die_owner)\n\t\t\t/* nested oops. should stop eventually */;\n\t\telse\n\t\t\tarch_spin_lock(&die_lock);\n\t}\n\tdie_nest_count++;\n\tdie_owner = cpu;\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tif (machine_is(powermac))\n\t\tpmac_backlight_unblank();\n\treturn flags;\n}"
  },
  {
    "function_name": "panic_flush_kmsg_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "171-178",
    "snippet": "extern void panic_flush_kmsg_end(void)\n{\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\tbust_spinlocks(0);\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "console_flush_on_panic",
          "args": [
            "CONSOLE_FLUSH_PENDING"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_PANIC"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_flush_on_panic",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nextern void panic_flush_kmsg_end(void)\n{\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\tbust_spinlocks(0);\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n}"
  },
  {
    "function_name": "panic_flush_kmsg_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "158-169",
    "snippet": "extern void panic_flush_kmsg_start(void)\n{\n\t/*\n\t * These are mostly taken from kernel/panic.c, but tries to do\n\t * relatively minimal work. Don't use delay functions (TB may\n\t * be broken), don't crash dump (need to set a firmware log),\n\t * don't run notifiers. We do want to get some information to\n\t * Linux console.\n\t */\n\tconsole_verbose();\n\tbust_spinlocks(1);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bust_spinlocks",
          "args": [
            "1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "console_verbose",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nextern void panic_flush_kmsg_start(void)\n{\n\t/*\n\t * These are mostly taken from kernel/panic.c, but tries to do\n\t * relatively minimal work. Don't use delay functions (TB may\n\t * be broken), don't crash dump (need to set a firmware log),\n\t * don't run notifiers. We do want to get some information to\n\t * Linux console.\n\t */\n\tconsole_verbose();\n\tbust_spinlocks(1);\n}"
  },
  {
    "function_name": "die_will_crash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "140-151",
    "snippet": "bool die_will_crash(void)\n{\n\tif (should_fadump_crash())\n\t\treturn true;\n\tif (kexec_should_crash(current))\n\t\treturn true;\n\tif (in_interrupt() || panic_on_oops ||\n\t\t\t!current->pid || is_global_init(current))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "current"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_should_crash",
          "args": [
            "current"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fadump_crash",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "should_fadump_crash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "176-181",
          "snippet": "int should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nbool die_will_crash(void)\n{\n\tif (should_fadump_crash())\n\t\treturn true;\n\tif (kexec_should_crash(current))\n\t\treturn true;\n\tif (in_interrupt() || panic_on_oops ||\n\t\t\t!current->pid || is_global_init(current))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "pmac_backlight_unblank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "128-128",
    "snippet": "static inline void pmac_backlight_unblank(void) { }",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void pmac_backlight_unblank(void) { }"
  },
  {
    "function_name": "pmac_backlight_unblank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "114-126",
    "snippet": "static void pmac_backlight_unblank(void)\n{\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tprops = &pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(pmac_backlight);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pmac_backlight_mutex"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backlight_update_status",
          "args": [
            "pmac_backlight"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pmac_backlight_mutex"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void pmac_backlight_unblank(void)\n{\n\tmutex_lock(&pmac_backlight_mutex);\n\tif (pmac_backlight) {\n\t\tstruct backlight_properties *props;\n\n\t\tprops = &pmac_backlight->props;\n\t\tprops->brightness = props->max_brightness;\n\t\tprops->power = FB_BLANK_UNBLANK;\n\t\tbacklight_update_status(pmac_backlight);\n\t}\n\tmutex_unlock(&pmac_backlight_mutex);\n}"
  },
  {
    "function_name": "signame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
    "lines": "96-107",
    "snippet": "static const char *signame(int signr)\n{\n\tswitch (signr) {\n\tcase SIGBUS:\treturn \"bus error\";\n\tcase SIGFPE:\treturn \"floating point exception\";\n\tcase SIGILL:\treturn \"illegal instruction\";\n\tcase SIGSEGV:\treturn \"segfault\";\n\tcase SIGTRAP:\treturn \"unhandled trap\";\n\t}\n\n\treturn \"unknown signal\";\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/stacktrace.h>",
      "#include <asm/kprobes.h>",
      "#include <sysdev/fsl_pci.h>",
      "#include <asm/hmi.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/fadump.h>",
      "#include <asm/rio.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/kexec.h>",
      "#include <asm/tm.h>",
      "#include <asm/processor.h>",
      "#include <asm/firmware.h>",
      "#include <asm/backlight.h>",
      "#include <asm/reg.h>",
      "#include <asm/pmc.h>",
      "#include <asm/rtas.h>",
      "#include <asm/machdep.h>",
      "#include <asm/io.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/emulated_ops.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/console.h>",
      "#include <linux/smp.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/bug.h>",
      "#include <linux/backlight.h>",
      "#include <linux/kexec.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/delay.h>",
      "#include <linux/prctl.h>",
      "#include <linux/module.h>\t/* print_modules */",
      "#include <linux/extable.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic const char *signame(int signr)\n{\n\tswitch (signr) {\n\tcase SIGBUS:\treturn \"bus error\";\n\tcase SIGFPE:\treturn \"floating point exception\";\n\tcase SIGILL:\treturn \"illegal instruction\";\n\tcase SIGSEGV:\treturn \"segfault\";\n\tcase SIGTRAP:\treturn \"unhandled trap\";\n\t}\n\n\treturn \"unknown signal\";\n}"
  }
]