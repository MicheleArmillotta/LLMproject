[
  {
    "function_name": "rtas_take_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1191-1199",
    "snippet": "void rtas_take_timebase(void)\n{\n\twhile (!timebase)\n\t\tbarrier();\n\tarch_spin_lock(&timebase_lock);\n\tset_tb(timebase >> 32, timebase & 0xffffffff);\n\ttimebase = 0;\n\tarch_spin_unlock(&timebase_lock);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t timebase_lock;",
      "static u64 timebase = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tb",
          "args": [
            "timebase >> 32",
            "timebase & 0xffffffff"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "422-427",
          "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic arch_spinlock_t timebase_lock;\nstatic u64 timebase = 0;\n\nvoid rtas_take_timebase(void)\n{\n\twhile (!timebase)\n\t\tbarrier();\n\tarch_spin_lock(&timebase_lock);\n\tset_tb(timebase >> 32, timebase & 0xffffffff);\n\ttimebase = 0;\n\tarch_spin_unlock(&timebase_lock);\n}"
  },
  {
    "function_name": "rtas_give_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1174-1189",
    "snippet": "void rtas_give_timebase(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\tarch_spin_lock(&timebase_lock);\n\trtas_call(rtas_token(\"freeze-time-base\"), 0, 1, NULL);\n\ttimebase = get_tb();\n\tarch_spin_unlock(&timebase_lock);\n\n\twhile (timebase)\n\t\tbarrier();\n\trtas_call(rtas_token(\"thaw-time-base\"), 0, 1, NULL);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t timebase_lock;",
      "static u64 timebase = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"thaw-time-base\")",
            "0",
            "1",
            "NULL"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"thaw-time-base\""
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "422-427",
          "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic arch_spinlock_t timebase_lock;\nstatic u64 timebase = 0;\n\nvoid rtas_give_timebase(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\tarch_spin_lock(&timebase_lock);\n\trtas_call(rtas_token(\"freeze-time-base\"), 0, 1, NULL);\n\ttimebase = get_tb();\n\tarch_spin_unlock(&timebase_lock);\n\n\twhile (timebase)\n\t\tbarrier();\n\trtas_call(rtas_token(\"thaw-time-base\"), 0, 1, NULL);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "early_init_dt_scan_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1134-1169",
    "snippet": "int __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udbg_init_rtas_console",
          "args": [],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_init_rtas_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "189-194",
          "snippet": "void __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"get-term-char\"",
            "NULL"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"put-term-char\"",
            "NULL"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"rtas-size\"",
            "NULL"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,rtas-entry\"",
            "NULL"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,rtas-base\"",
            "NULL"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"rtas\""
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}"
  },
  {
    "function_name": "rtas_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1088-1132",
    "snippet": "void __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\tu32 base, size, entry;\n\tint no_base, no_size, no_entry;\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (!rtas.dev)\n\t\treturn;\n\n\tno_base = of_property_read_u32(rtas.dev, \"linux,rtas-base\", &base);\n\tno_size = of_property_read_u32(rtas.dev, \"rtas-size\", &size);\n\tif (no_base || no_size) {\n\t\tof_node_put(rtas.dev);\n\t\trtas.dev = NULL;\n\t\treturn;\n\t}\n\n\trtas.base = base;\n\trtas.size = size;\n\tno_entry = of_property_read_u32(rtas.dev, \"linux,rtas-entry\", &entry);\n\trtas.entry = no_entry ? rtas.base : entry;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_phys_alloc_range(RTAS_RMOBUF_MAX, PAGE_SIZE,\n\t\t\t\t\t\t 0, rtas_region);\n\tif (!rtas_rmo_buf)\n\t\tpanic(\"ERROR: RTAS: Failed to allocate %lx bytes below %pa\\n\",\n\t\t      PAGE_SIZE, &rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};",
      "unsigned long rtas_rmo_buf;",
      "static int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-last-error\""
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ERROR: RTAS: Failed to allocate %lx bytes below %pa\\n\"",
            "PAGE_SIZE",
            "&rtas_region"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_panic_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "691-708",
          "snippet": "static int ppc_panic_event(struct notifier_block *this,\n                             unsigned long event, void *ptr)\n{\n\t/*\n\t * panic does a local_irq_disable, but we really\n\t * want interrupts to be hard disabled.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If firmware-assisted dump has been registered then trigger\n\t * firmware-assisted dump and let firmware handle everything else.\n\t */\n\tcrash_fadump(NULL, ptr);\n\tif (ppc_md.panic)\n\t\tppc_md.panic(ptr);  /* May not return */\n\treturn NOTIFY_DONE;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include \"setup.h\"",
            "#include <asm/kasan.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/hugetlb.h>",
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct machdep_calls ppc_md;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include \"setup.h\"\n#include <asm/kasan.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/mmu_context.h>\n#include <asm/livepatch.h>\n#include <asm/hugetlb.h>\n#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/pgtable.h>\n#include <linux/hugetlb.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nstruct machdep_calls ppc_md;\n\nstatic int ppc_panic_event(struct notifier_block *this,\n                             unsigned long event, void *ptr)\n{\n\t/*\n\t * panic does a local_irq_disable, but we really\n\t * want interrupts to be hard disabled.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If firmware-assisted dump has been registered then trigger\n\t * firmware-assisted dump and let firmware handle everything else.\n\t */\n\tcrash_fadump(NULL, ptr);\n\tif (ppc_md.panic)\n\t\tppc_md.panic(ptr);  /* May not return */\n\treturn NOTIFY_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_phys_alloc_range",
          "args": [
            "RTAS_RMOBUF_MAX",
            "PAGE_SIZE",
            "0",
            "rtas_region"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ppc64_rma_size",
            "RTAS_INSTANTIATE_MAX"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_LPAR"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "rtas.dev",
            "\"linux,rtas-entry\"",
            "&entry"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "rtas.dev"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "rtas.dev",
            "\"rtas-size\"",
            "&size"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "rtas.dev",
            "\"linux,rtas-base\"",
            "&base"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "\"rtas\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nunsigned long rtas_rmo_buf;\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nvoid __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\tu32 base, size, entry;\n\tint no_base, no_size, no_entry;\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (!rtas.dev)\n\t\treturn;\n\n\tno_base = of_property_read_u32(rtas.dev, \"linux,rtas-base\", &base);\n\tno_size = of_property_read_u32(rtas.dev, \"rtas-size\", &size);\n\tif (no_base || no_size) {\n\t\tof_node_put(rtas.dev);\n\t\trtas.dev = NULL;\n\t\treturn;\n\t}\n\n\trtas.base = base;\n\trtas.size = size;\n\tno_entry = of_property_read_u32(rtas.dev, \"linux,rtas-entry\", &entry);\n\trtas.entry = no_entry ? rtas.base : entry;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_phys_alloc_range(RTAS_RMOBUF_MAX, PAGE_SIZE,\n\t\t\t\t\t\t 0, rtas_region);\n\tif (!rtas_rmo_buf)\n\t\tpanic(\"ERROR: RTAS: Failed to allocate %lx bytes below %pa\\n\",\n\t\t      PAGE_SIZE, &rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n}"
  },
  {
    "function_name": "get_pseries_errorlog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "965-993",
    "snippet": "struct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,\n\t\t\t\t\t      uint16_t section_id)\n{\n\tstruct rtas_ext_event_log_v6 *ext_log =\n\t\t(struct rtas_ext_event_log_v6 *)log->buffer;\n\tstruct pseries_errorlog *sect;\n\tunsigned char *p, *log_end;\n\tuint32_t ext_log_length = rtas_error_extended_log_length(log);\n\tuint8_t log_format = rtas_ext_event_log_format(ext_log);\n\tuint32_t company_id = rtas_ext_event_company_id(ext_log);\n\n\t/* Check that we understand the format */\n\tif (ext_log_length < sizeof(struct rtas_ext_event_log_v6) ||\n\t    log_format != RTAS_V6EXT_LOG_FORMAT_EVENT_LOG ||\n\t    company_id != RTAS_V6EXT_COMPANY_ID_IBM)\n\t\treturn NULL;\n\n\tlog_end = log->buffer + ext_log_length;\n\tp = ext_log->vendor_log;\n\n\twhile (p < log_end) {\n\t\tsect = (struct pseries_errorlog *)p;\n\t\tif (pseries_errorlog_id(sect) == section_id)\n\t\t\treturn sect;\n\t\tp += pseries_errorlog_length(sect);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pseries_errorlog_length",
          "args": [
            "sect"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pseries_errorlog_id",
          "args": [
            "sect"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_ext_event_company_id",
          "args": [
            "ext_log"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_ext_event_log_format",
          "args": [
            "ext_log"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_extended_log_length",
          "args": [
            "log"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,\n\t\t\t\t\t      uint16_t section_id)\n{\n\tstruct rtas_ext_event_log_v6 *ext_log =\n\t\t(struct rtas_ext_event_log_v6 *)log->buffer;\n\tstruct pseries_errorlog *sect;\n\tunsigned char *p, *log_end;\n\tuint32_t ext_log_length = rtas_error_extended_log_length(log);\n\tuint8_t log_format = rtas_ext_event_log_format(ext_log);\n\tuint32_t company_id = rtas_ext_event_company_id(ext_log);\n\n\t/* Check that we understand the format */\n\tif (ext_log_length < sizeof(struct rtas_ext_event_log_v6) ||\n\t    log_format != RTAS_V6EXT_LOG_FORMAT_EVENT_LOG ||\n\t    company_id != RTAS_V6EXT_COMPANY_ID_IBM)\n\t\treturn NULL;\n\n\tlog_end = log->buffer + ext_log_length;\n\tp = ext_log->vendor_log;\n\n\twhile (p < log_end) {\n\t\tsect = (struct pseries_errorlog *)p;\n\t\tif (pseries_errorlog_id(sect) == section_id)\n\t\t\treturn sect;\n\t\tp += pseries_errorlog_length(sect);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "rtas_ibm_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "952-955",
    "snippet": "int rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "rtas_call_reentrant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "918-949",
    "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args->rets[0]"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args->rets[i + 1]"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_rtas_call_unlocked",
          "args": [
            "args",
            "token",
            "nargs",
            "nret",
            "list"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "va_rtas_call_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "416-434",
          "snippet": "static void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void enter_rtas(unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\n\nstatic void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "outputs"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_ibm_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "846-899",
    "snippet": "int rtas_ibm_suspend_me(u64 handle)\n{\n\tlong state;\n\tlong rc;\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tstruct rtas_suspend_me_data data;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (!rtas_service_present(\"ibm,suspend-me\"))\n\t\treturn -ENOSYS;\n\n\t/* Make sure the state is valid */\n\trc = plpar_hcall(H_VASI_STATE, retbuf, handle);\n\n\tstate = retbuf[0];\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned %ld\\n\",rc);\n\t\treturn rc;\n\t} else if (state == H_VASI_ENABLED) {\n\t\treturn -EAGAIN;\n\t} else if (state != H_VASI_SUSPENDING) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\",\n\t\t       state);\n\t\treturn -EIO;\n\t}\n\n\tatomic_set(&data.working, 0);\n\tatomic_set(&data.done, 0);\n\tatomic_set(&data.error, 0);\n\tdata.token = rtas_token(\"ibm,suspend-me\");\n\tdata.complete = &done;\n\n\tlock_device_hotplug();\n\n\tcpu_hotplug_disable();\n\n\t/* Call function on all CPUs.  One of us will make the\n\t * rtas call\n\t */\n\ton_each_cpu(rtas_percpu_suspend_me, &data, 0);\n\n\twait_for_completion(&done);\n\n\tif (atomic_read(&data.error) != 0)\n\t\tprintk(KERN_ERR \"Error doing global join\\n\");\n\n\n\tcpu_hotplug_enable();\n\n\tunlock_device_hotplug();\n\n\treturn atomic_read(&data.error);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data.error"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_device_hotplug",
          "args": [],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_enable",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error doing global join\\n\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data.error"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "rtas_percpu_suspend_me",
            "&data",
            "0"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_disable",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_device_hotplug",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,suspend-me\""
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.error",
            "0"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.done",
            "0"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.working",
            "0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\"",
            "state"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plpar_hcall",
          "args": [
            "H_VASI_STATE",
            "retbuf",
            "handle"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_service_present",
          "args": [
            "\"ibm,suspend-me\""
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_service_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "327-330",
          "snippet": "int rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_ibm_suspend_me(u64 handle)\n{\n\tlong state;\n\tlong rc;\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tstruct rtas_suspend_me_data data;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (!rtas_service_present(\"ibm,suspend-me\"))\n\t\treturn -ENOSYS;\n\n\t/* Make sure the state is valid */\n\trc = plpar_hcall(H_VASI_STATE, retbuf, handle);\n\n\tstate = retbuf[0];\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned %ld\\n\",rc);\n\t\treturn rc;\n\t} else if (state == H_VASI_ENABLED) {\n\t\treturn -EAGAIN;\n\t} else if (state != H_VASI_SUSPENDING) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\",\n\t\t       state);\n\t\treturn -EIO;\n\t}\n\n\tatomic_set(&data.working, 0);\n\tatomic_set(&data.done, 0);\n\tatomic_set(&data.error, 0);\n\tdata.token = rtas_token(\"ibm,suspend-me\");\n\tdata.complete = &done;\n\n\tlock_device_hotplug();\n\n\tcpu_hotplug_disable();\n\n\t/* Call function on all CPUs.  One of us will make the\n\t * rtas call\n\t */\n\ton_each_cpu(rtas_percpu_suspend_me, &data, 0);\n\n\twait_for_completion(&done);\n\n\tif (atomic_read(&data.error) != 0)\n\t\tprintk(KERN_ERR \"Error doing global join\\n\");\n\n\n\tcpu_hotplug_enable();\n\n\tunlock_device_hotplug();\n\n\treturn atomic_read(&data.error);\n}"
  },
  {
    "function_name": "rtas_percpu_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "841-844",
    "snippet": "static void rtas_percpu_suspend_me(void *info)\n{\n\t__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_cpu",
          "args": [
            "(struct rtas_suspend_me_data *)info",
            "1"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "789-834",
          "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void rtas_percpu_suspend_me(void *info)\n{\n\t__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);\n}"
  },
  {
    "function_name": "rtas_suspend_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "836-839",
    "snippet": "int rtas_suspend_cpu(struct rtas_suspend_me_data *data)\n{\n\treturn __rtas_suspend_cpu(data, 0);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_cpu",
          "args": [
            "data",
            "0"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "789-834",
          "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_suspend_cpu(struct rtas_suspend_me_data *data)\n{\n\treturn __rtas_suspend_cpu(data, 0);\n}"
  },
  {
    "function_name": "__rtas_suspend_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "789-834",
    "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "data->complete"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&data->working"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->done",
            "1"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->error",
            "rc"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\"",
            "smp_processor_id()",
            "rc"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rtas_suspend_last_cpu",
          "args": [
            "data",
            "wake_when_done"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_last_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "746-781",
          "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "msr_save"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plpar_hcall_norets",
          "args": [
            "H_JOIN"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->done"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "msr_save & ~(MSR_EE)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->working"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_suspend_last_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "783-787",
    "snippet": "int rtas_suspend_last_cpu(struct rtas_suspend_me_data *data)\n{\n\tatomic_inc(&data->working);\n\treturn __rtas_suspend_last_cpu(data, 0);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_last_cpu",
          "args": [
            "data",
            "0"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_last_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "746-781",
          "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->working"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_suspend_last_cpu(struct rtas_suspend_me_data *data)\n{\n\tatomic_inc(&data->working);\n\treturn __rtas_suspend_last_cpu(data, 0);\n}"
  },
  {
    "function_name": "__rtas_suspend_last_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "746-781",
    "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "data->complete"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&data->working"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->done",
            "1"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pSeries_coalesce_init",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->error",
            "rc"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slb_set_size",
          "args": [
            "slb_size"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ibm,suspend-me returned %d\\n\"",
            "rc"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "data->token",
            "0",
            "1",
            "NULL"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->done"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slb_set_size",
          "args": [
            "SLB_MIN_SIZE"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_os_term",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "719-742",
    "snippet": "void rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char rtas_os_term_buf[2048];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"ibm,os-term call failed %d\\n\"",
            "status"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "status"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"ibm,os-term\")",
            "1",
            "1",
            "NULL",
            "__pa(rtas_os_term_buf)"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "rtas_os_term_buf"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,os-term\""
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rtas_os_term_buf",
            "2048",
            "\"OS panic: %s\"",
            "str"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic char rtas_os_term_buf[2048];\n\nvoid rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}"
  },
  {
    "function_name": "rtas_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "706-714",
    "snippet": "void __noreturn rtas_halt(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_HALT);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS power-off returned %d\\n\"",
            "rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1)"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"power-off\")",
            "2",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"power-off\""
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_HALT"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid __noreturn rtas_halt(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_HALT);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_power_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "696-704",
    "snippet": "void rtas_power_off(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_POWER_OFF);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS power-off returned %d\\n\"",
            "rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1)"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"power-off\")",
            "2",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"power-off\""
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_POWER_OFF"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid rtas_power_off(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_POWER_OFF);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "687-694",
    "snippet": "void __noreturn rtas_restart(char *cmd)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_RESTART);\n\tprintk(\"RTAS system-reboot returned %d\\n\",\n\t       rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS system-reboot returned %d\\n\"",
            "rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL)"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"system-reboot\")",
            "0",
            "1",
            "NULL"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"system-reboot\""
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_RESTART"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid __noreturn rtas_restart(char *cmd)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_RESTART);\n\tprintk(\"RTAS system-reboot returned %d\\n\",\n\t       rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_set_indicator_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "668-685",
    "snippet": "int rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "3",
            "1",
            "NULL",
            "indicator",
            "index",
            "new_value"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_set_indicator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "647-662",
    "snippet": "int rtas_set_indicator(int indicator, int index, int new_value)\n{\n\tint token = rtas_token(\"set-indicator\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "3",
            "1",
            "NULL",
            "indicator",
            "index",
            "new_value"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator(int indicator, int index, int new_value)\n{\n\tint token = rtas_token(\"set-indicator\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_indicator_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "621-644",
    "snippet": "bool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "indicators[i].maxindex"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "indicators[i].token"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"rtas-indicators\"",
            "&proplen"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nbool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "rtas_get_sensor_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "604-619",
    "snippet": "int rtas_get_sensor_fast(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 2, 2, state, sensor, index);\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "state",
            "sensor",
            "index"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_sensor_fast(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 2, 2, state, sensor, index);\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_get_sensor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "586-601",
    "snippet": "int rtas_get_sensor(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, state, sensor, index);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "state",
            "sensor",
            "index"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_sensor(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, state, sensor, index);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_set_power_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "568-583",
    "snippet": "int rtas_set_power_level(int powerdomain, int level, int *setlevel)\n{\n\tint token = rtas_token(\"set-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, setlevel, powerdomain, level);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "setlevel",
            "powerdomain",
            "level"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-power-level\""
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_power_level(int powerdomain, int level, int *setlevel)\n{\n\tint token = rtas_token(\"set-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, setlevel, powerdomain, level);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_get_power_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "551-565",
    "snippet": "int rtas_get_power_level(int powerdomain, int *level)\n{\n\tint token = rtas_token(\"get-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\twhile ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)\n\t\tudelay(1);\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "522-549",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "478-481",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "1",
            "2",
            "level",
            "powerdomain"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-power-level\""
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_power_level(int powerdomain, int *level)\n{\n\tint token = rtas_token(\"get-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\twhile ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)\n\t\tudelay(1);\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_error_rc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "522-549",
    "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: unexpected RTAS error %d\\n\"",
            "__func__",
            "rtas_rc"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_busy_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "509-519",
    "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "ms"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay_time",
          "args": [
            "status"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "490-505",
          "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
  },
  {
    "function_name": "rtas_busy_delay_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "490-505",
    "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
  },
  {
    "function_name": "rtas_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "445-484",
    "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\n\t/* We use the global rtas args buffer */\n\trtas_args = &rtas.args;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(rtas_args, token, nargs, nret, list);\n\tva_end(list);\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff_copy"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "buff_copy",
            "ERR_TYPE_RTAS_LOG",
            "0"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "198-274",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rtas",
          "args": [
            "s"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "84-89",
          "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[0]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[i+1]"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fetch_rtas_last_error",
          "args": [
            "NULL"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__fetch_rtas_last_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "366-406",
          "snippet": "static char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void enter_rtas(unsigned long);",
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[0]"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_rtas_call_unlocked",
          "args": [
            "rtas_args",
            "token",
            "nargs",
            "nret",
            "list"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "va_rtas_call_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "416-434",
          "snippet": "static void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void enter_rtas(unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\n\nstatic void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "outputs"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_rtas",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "lock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "74-82",
          "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\n\t/* We use the global rtas args buffer */\n\trtas_args = &rtas.args;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(rtas_args, token, nargs, nret, list);\n\tva_end(list);\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_call_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "436-443",
    "snippet": "void rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret, ...)\n{\n\tva_list list;\n\n\tva_start(list, nret);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_rtas_call_unlocked",
          "args": [
            "args",
            "token",
            "nargs",
            "nret",
            "list"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "va_rtas_call_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "416-434",
          "snippet": "static void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void enter_rtas(unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\n\nstatic void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "nret"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret, ...)\n{\n\tva_list list;\n\n\tva_start(list, nret);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n}"
  },
  {
    "function_name": "va_rtas_call_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "416-434",
    "snippet": "static void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void enter_rtas(unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(args)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "args"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "va_arg(list, __u32)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "__u32"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nret"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nargs"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "token"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\n\nstatic void\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\n\t\t      va_list list)\n{\n\tint i;\n\n\targs->token = cpu_to_be32(token);\n\targs->nargs = cpu_to_be32(nargs);\n\targs->nret  = cpu_to_be32(nret);\n\targs->rets  = &(args->args[nargs]);\n\n\tfor (i = 0; i < nargs; ++i)\n\t\targs->args[i] = cpu_to_be32(va_arg(list, __u32));\n\n\tfor (i = 0; i < nret; ++i)\n\t\targs->rets[i] = 0;\n\n\tenter_rtas(__pa(args));\n}"
  },
  {
    "function_name": "__fetch_rtas_last_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "366-406",
    "snippet": "static char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void enter_rtas(unsigned long);",
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "rtas_err_buf",
            "RTAS_ERROR_LOG_MAX"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "RTAS_ERROR_LOG_MAX",
            "GFP_ATOMIC"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err_args.args[2] == 0"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(&rtas.args)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "&rtas.args"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bufsz"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "__pa(rtas_err_buf)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rtas_last_error_token"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "339-353",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "rtas_get_error_log_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "339-353",
    "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"RTAS: bad log buffer size %d\\n\"",
            "rtas_error_log_max"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-error-log-max\""
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
  },
  {
    "function_name": "rtas_service_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "327-330",
    "snippet": "int rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "service"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}"
  },
  {
    "function_name": "rtas_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "317-324",
    "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*tokp"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "service",
            "NULL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
  },
  {
    "function_name": "rtas_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "197-314",
    "snippet": "void rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&progress_lock"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "display_character",
            "1",
            "1",
            "NULL",
            "*os"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&progress_lock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&progress_lock"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "root"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-truncation-length\"",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-number-of-lines\"",
            "NULL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,form-feed\"",
            "NULL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-line-length\"",
            "NULL"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/rtas\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nvoid rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}"
  },
  {
    "function_name": "udbg_init_rtas_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "189-194",
    "snippet": "void __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}"
  },
  {
    "function_name": "udbg_rtascon_getc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "178-186",
    "snippet": "static int udbg_rtascon_getc(void)\n{\n\tint c;\n\n\twhile ((c = udbg_rtascon_getc_poll()) == -1)\n\t\t;\n\n\treturn c;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udbg_rtascon_getc_poll",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_rtascon_getc_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "165-176",
          "snippet": "static int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int udbg_rtascon_getc(void)\n{\n\tint c;\n\n\twhile ((c = udbg_rtascon_getc_poll()) == -1)\n\t\t;\n\n\treturn c;\n}"
  },
  {
    "function_name": "udbg_rtascon_getc_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "165-176",
    "snippet": "static int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_getchar_token",
            "0",
            "2",
            "&c"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}"
  },
  {
    "function_name": "udbg_rtascon_putc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "146-163",
    "snippet": "static void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "478-481",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_putchar_token",
            "1",
            "1",
            "NULL",
            "c"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udbg_rtascon_putc",
          "args": [
            "'\\r'"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_rtascon_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "146-163",
          "snippet": "static void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}"
  },
  {
    "function_name": "udbg_init_rtas_panel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "132-135",
    "snippet": "void __init udbg_init_rtas_panel(void)\n{\n\tudbg_putc = call_rtas_display_status_delay;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_panel(void)\n{\n\tudbg_putc = call_rtas_display_status_delay;\n}"
  },
  {
    "function_name": "call_rtas_display_status_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "108-130",
    "snippet": "static void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "10000"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "478-481",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rtas_display_status",
          "args": [
            "c"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "call_rtas_display_status_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "108-130",
          "snippet": "static void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "500"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_rtas_display_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "96-106",
    "snippet": "static void call_rtas_display_status(unsigned char c)\n{\n\tunsigned long s;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\ts = lock_rtas();\n\trtas_call_unlocked(&rtas.args, 10, 1, 1, NULL, c);\n\tunlock_rtas(s);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rtas",
          "args": [
            "s"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "84-89",
          "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call_unlocked",
          "args": [
            "&rtas.args",
            "10",
            "1",
            "1",
            "NULL",
            "c"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "436-443",
          "snippet": "void rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret, ...)\n{\n\tva_list list;\n\n\tva_start(list, nret);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret, ...)\n{\n\tva_list list;\n\n\tva_start(list, nret);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_rtas",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "lock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "74-82",
          "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void call_rtas_display_status(unsigned char c)\n{\n\tunsigned long s;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\ts = lock_rtas();\n\trtas_call_unlocked(&rtas.args, 10, 1, 1, NULL, c);\n\tunlock_rtas(s);\n}"
  },
  {
    "function_name": "unlock_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "84-89",
    "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&rtas.lock"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "lock_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "74-82",
    "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&rtas.lock"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock(&rtas.lock);\n\treturn flags;\n}"
  },
  {
    "function_name": "rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
    "lines": "996-1081",
    "snippet": "SYSCALL_DEFINE1(rtas, struct rtas_args __user *, uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs >= ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void enter_rtas(unsigned long);",
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};",
      "static int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nSYSCALL_DEFINE1(rtas, struct rtas_args __user *, uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs >= ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  }
]