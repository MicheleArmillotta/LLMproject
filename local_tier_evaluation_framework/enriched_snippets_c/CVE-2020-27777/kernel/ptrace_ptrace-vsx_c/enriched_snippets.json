[
  {
    "function_name": "vsr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-vsx.c",
    "lines": "126-148",
    "snippet": "int vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t    unsigned int pos, unsigned int count,\n\t    const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "32 * sizeof(double)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t    unsigned int pos, unsigned int count,\n\t    const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vsr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-vsx.c",
    "lines": "97-112",
    "snippet": "int vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t    struct membuf to)\n{\n\tu64 buf[32];\n\tint i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\treturn membuf_write(&to, buf, 32 * sizeof(double));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "buf",
            "32 * sizeof(double)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t    struct membuf to)\n{\n\tu64 buf[32];\n\tint i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\treturn membuf_write(&to, buf, 32 * sizeof(double));\n}"
  },
  {
    "function_name": "vsr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-vsx.c",
    "lines": "79-83",
    "snippet": "int vsr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint vsr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}"
  },
  {
    "function_name": "fpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-vsx.c",
    "lines": "49-71",
    "snippet": "int fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t    unsigned int pos, unsigned int count,\n\t    const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "-1"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t    unsigned int pos, unsigned int count,\n\t    const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n}"
  },
  {
    "function_name": "fpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-vsx.c",
    "lines": "21-34",
    "snippet": "int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t    struct membuf to)\n{\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn membuf_write(&to, buf, 33 * sizeof(u64));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "buf",
            "33 * sizeof(u64)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t    struct membuf to)\n{\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn membuf_write(&to, buf, 33 * sizeof(u64));\n}"
  }
]