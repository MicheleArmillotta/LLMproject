[
  {
    "function_name": "eeh_init_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1875-1902",
    "snippet": "static int __init eeh_init_proc(void)\n{\n\tif (machine_is(pseries) || machine_is(powernv)) {\n\t\tproc_create_single(\"powerpc/eeh\", 0, NULL, proc_eeh_show);\n#ifdef CONFIG_DEBUG_FS\n\t\tdebugfs_create_file_unsafe(\"eeh_enable\", 0600,\n\t\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t\t   &eeh_enable_dbgfs_ops);\n\t\tdebugfs_create_u32(\"eeh_max_freezes\", 0600,\n\t\t\t\tpowerpc_debugfs_root, &eeh_max_freezes);\n\t\tdebugfs_create_bool(\"eeh_disable_recovery\", 0600,\n\t\t\t\tpowerpc_debugfs_root,\n\t\t\t\t&eeh_debugfs_no_recover);\n\t\tdebugfs_create_file_unsafe(\"eeh_dev_check\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_dev_check_fops);\n\t\tdebugfs_create_file_unsafe(\"eeh_dev_break\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_dev_break_fops);\n\t\tdebugfs_create_file_unsafe(\"eeh_force_recover\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_force_recover_fops);\n\t\teeh_cache_debugfs_init();\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32 eeh_max_freezes = 5;",
      "bool eeh_debugfs_no_recover;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_cache_debugfs_init",
          "args": [],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_cache_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "282-287",
          "snippet": "void eeh_cache_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"eeh_address_cache\", 0400,\n\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t&eeh_addr_cache_fops);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nvoid eeh_cache_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"eeh_address_cache\", 0400,\n\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t&eeh_addr_cache_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"eeh_force_recover\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_force_recover_fops"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"eeh_dev_break\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_dev_break_fops"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"eeh_dev_check\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_dev_check_fops"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"eeh_disable_recovery\"",
            "0600",
            "powerpc_debugfs_root",
            "&eeh_debugfs_no_recover"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"eeh_max_freezes\"",
            "0600",
            "powerpc_debugfs_root",
            "&eeh_max_freezes"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"eeh_enable\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_enable_dbgfs_ops"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"powerpc/eeh\"",
            "0",
            "NULL",
            "proc_eeh_show"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powernv"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nu32 eeh_max_freezes = 5;\nbool eeh_debugfs_no_recover;\n\nstatic int __init eeh_init_proc(void)\n{\n\tif (machine_is(pseries) || machine_is(powernv)) {\n\t\tproc_create_single(\"powerpc/eeh\", 0, NULL, proc_eeh_show);\n#ifdef CONFIG_DEBUG_FS\n\t\tdebugfs_create_file_unsafe(\"eeh_enable\", 0600,\n\t\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t\t   &eeh_enable_dbgfs_ops);\n\t\tdebugfs_create_u32(\"eeh_max_freezes\", 0600,\n\t\t\t\tpowerpc_debugfs_root, &eeh_max_freezes);\n\t\tdebugfs_create_bool(\"eeh_disable_recovery\", 0600,\n\t\t\t\tpowerpc_debugfs_root,\n\t\t\t\t&eeh_debugfs_no_recover);\n\t\tdebugfs_create_file_unsafe(\"eeh_dev_check\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_dev_check_fops);\n\t\tdebugfs_create_file_unsafe(\"eeh_dev_break\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_dev_break_fops);\n\t\tdebugfs_create_file_unsafe(\"eeh_force_recover\", 0600,\n\t\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t\t&eeh_force_recover_fops);\n\t\teeh_cache_debugfs_init();\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_dev_break_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1833-1864",
    "snippet": "static ssize_t eeh_dev_break_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tuint32_t domain, bus, dev, fn;\n\tstruct pci_dev *pdev;\n\tchar buf[20];\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\tret = sscanf(buf, \"%x:%x:%x.%x\", &domain, &bus, &dev, &fn);\n\tif (ret != 4) {\n\t\tpr_err(\"%s: expected 4 args, got %d\\n\", __func__, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tret = eeh_debugfs_break_device(pdev);\n\tpci_dev_put(pdev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_debugfs_break_device",
          "args": [
            "pdev"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_debugfs_break_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1740-1831",
          "snippet": "static int eeh_debugfs_break_device(struct pci_dev *pdev)\n{\n\tstruct resource *bar = NULL;\n\tvoid __iomem *mapped;\n\tu16 old, bit;\n\tint i, pos;\n\n\t/* Do we have an MMIO BAR to disable? */\n\tfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (!r->flags || !r->start)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_IO)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_UNSET)\n\t\t\tcontinue;\n\n\t\tbar = r;\n\t\tbreak;\n\t}\n\n\tif (!bar) {\n\t\tpci_err(pdev, \"Unable to find Memory BAR to cause EEH with\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpci_err(pdev, \"Going to break: %pR\\n\", bar);\n\n\tif (pdev->is_virtfn) {\n#ifndef CONFIG_PCI_IOV\n\t\treturn -ENXIO;\n#else\n\t\t/*\n\t\t * VFs don't have a per-function COMMAND register, so the best\n\t\t * we can do is clear the Memory Space Enable bit in the PF's\n\t\t * SRIOV control reg.\n\t\t *\n\t\t * Unfortunately, this requires that we have a PF (i.e doesn't\n\t\t * work for a passed-through VF) and it has the potential side\n\t\t * effect of also causing an EEH on every other VF under the\n\t\t * PF. Oh well.\n\t\t */\n\t\tpdev = pdev->physfn;\n\t\tif (!pdev)\n\t\t\treturn -ENXIO; /* passed through VFs have no PF */\n\n\t\tpos  = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\t\tpos += PCI_SRIOV_CTRL;\n\t\tbit  = PCI_SRIOV_CTRL_MSE;\n#endif /* !CONFIG_PCI_IOV */\n\t} else {\n\t\tbit = PCI_COMMAND_MEMORY;\n\t\tpos = PCI_COMMAND;\n\t}\n\n\t/*\n\t * Process here is:\n\t *\n\t * 1. Disable Memory space.\n\t *\n\t * 2. Perform an MMIO to the device. This should result in an error\n\t *    (CA  / UR) being raised by the device which results in an EEH\n\t *    PE freeze. Using the in_8() accessor skips the eeh detection hook\n\t *    so the freeze hook so the EEH Detection machinery won't be\n\t *    triggered here. This is to match the usual behaviour of EEH\n\t *    where the HW will asyncronously freeze a PE and it's up to\n\t *    the kernel to notice and deal with it.\n\t *\n\t * 3. Turn Memory space back on. This is more important for VFs\n\t *    since recovery will probably fail if we don't. For normal\n\t *    the COMMAND register is reset as a part of re-initialising\n\t *    the device.\n\t *\n\t * Breaking stuff is the point so who cares if it's racy ;)\n\t */\n\tpci_read_config_word(pdev, pos, &old);\n\n\tmapped = ioremap(bar->start, PAGE_SIZE);\n\tif (!mapped) {\n\t\tpci_err(pdev, \"Unable to map MMIO BAR %pR\\n\", bar);\n\t\treturn -ENXIO;\n\t}\n\n\tpci_write_config_word(pdev, pos, old & ~bit);\n\tin_8(mapped);\n\tpci_write_config_word(pdev, pos, old);\n\n\tiounmap(mapped);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_debugfs_break_device(struct pci_dev *pdev)\n{\n\tstruct resource *bar = NULL;\n\tvoid __iomem *mapped;\n\tu16 old, bit;\n\tint i, pos;\n\n\t/* Do we have an MMIO BAR to disable? */\n\tfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (!r->flags || !r->start)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_IO)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_UNSET)\n\t\t\tcontinue;\n\n\t\tbar = r;\n\t\tbreak;\n\t}\n\n\tif (!bar) {\n\t\tpci_err(pdev, \"Unable to find Memory BAR to cause EEH with\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpci_err(pdev, \"Going to break: %pR\\n\", bar);\n\n\tif (pdev->is_virtfn) {\n#ifndef CONFIG_PCI_IOV\n\t\treturn -ENXIO;\n#else\n\t\t/*\n\t\t * VFs don't have a per-function COMMAND register, so the best\n\t\t * we can do is clear the Memory Space Enable bit in the PF's\n\t\t * SRIOV control reg.\n\t\t *\n\t\t * Unfortunately, this requires that we have a PF (i.e doesn't\n\t\t * work for a passed-through VF) and it has the potential side\n\t\t * effect of also causing an EEH on every other VF under the\n\t\t * PF. Oh well.\n\t\t */\n\t\tpdev = pdev->physfn;\n\t\tif (!pdev)\n\t\t\treturn -ENXIO; /* passed through VFs have no PF */\n\n\t\tpos  = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\t\tpos += PCI_SRIOV_CTRL;\n\t\tbit  = PCI_SRIOV_CTRL_MSE;\n#endif /* !CONFIG_PCI_IOV */\n\t} else {\n\t\tbit = PCI_COMMAND_MEMORY;\n\t\tpos = PCI_COMMAND;\n\t}\n\n\t/*\n\t * Process here is:\n\t *\n\t * 1. Disable Memory space.\n\t *\n\t * 2. Perform an MMIO to the device. This should result in an error\n\t *    (CA  / UR) being raised by the device which results in an EEH\n\t *    PE freeze. Using the in_8() accessor skips the eeh detection hook\n\t *    so the freeze hook so the EEH Detection machinery won't be\n\t *    triggered here. This is to match the usual behaviour of EEH\n\t *    where the HW will asyncronously freeze a PE and it's up to\n\t *    the kernel to notice and deal with it.\n\t *\n\t * 3. Turn Memory space back on. This is more important for VFs\n\t *    since recovery will probably fail if we don't. For normal\n\t *    the COMMAND register is reset as a part of re-initialising\n\t *    the device.\n\t *\n\t * Breaking stuff is the point so who cares if it's racy ;)\n\t */\n\tpci_read_config_word(pdev, pos, &old);\n\n\tmapped = ioremap(bar->start, PAGE_SIZE);\n\tif (!mapped) {\n\t\tpci_err(pdev, \"Unable to map MMIO BAR %pR\\n\", bar);\n\t\treturn -ENXIO;\n\t}\n\n\tpci_write_config_word(pdev, pos, old & ~bit);\n\tin_8(mapped);\n\tpci_write_config_word(pdev, pos, old);\n\n\tiounmap(mapped);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_domain_bus_and_slot",
          "args": [
            "domain",
            "bus",
            "(dev << 3) | fn"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: expected 4 args, got %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%x:%x:%x.%x\"",
            "&domain",
            "&bus",
            "&dev",
            "&fn"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_write_to_buffer",
          "args": [
            "buf",
            "sizeof(buf)-1",
            "ppos",
            "user_buf",
            "count"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic ssize_t eeh_dev_break_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tuint32_t domain, bus, dev, fn;\n\tstruct pci_dev *pdev;\n\tchar buf[20];\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\tret = sscanf(buf, \"%x:%x:%x.%x\", &domain, &bus, &dev, &fn);\n\tif (ret != 4) {\n\t\tpr_err(\"%s: expected 4 args, got %d\\n\", __func__, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tret = eeh_debugfs_break_device(pdev);\n\tpci_dev_put(pdev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}"
  },
  {
    "function_name": "eeh_debugfs_break_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1740-1831",
    "snippet": "static int eeh_debugfs_break_device(struct pci_dev *pdev)\n{\n\tstruct resource *bar = NULL;\n\tvoid __iomem *mapped;\n\tu16 old, bit;\n\tint i, pos;\n\n\t/* Do we have an MMIO BAR to disable? */\n\tfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (!r->flags || !r->start)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_IO)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_UNSET)\n\t\t\tcontinue;\n\n\t\tbar = r;\n\t\tbreak;\n\t}\n\n\tif (!bar) {\n\t\tpci_err(pdev, \"Unable to find Memory BAR to cause EEH with\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpci_err(pdev, \"Going to break: %pR\\n\", bar);\n\n\tif (pdev->is_virtfn) {\n#ifndef CONFIG_PCI_IOV\n\t\treturn -ENXIO;\n#else\n\t\t/*\n\t\t * VFs don't have a per-function COMMAND register, so the best\n\t\t * we can do is clear the Memory Space Enable bit in the PF's\n\t\t * SRIOV control reg.\n\t\t *\n\t\t * Unfortunately, this requires that we have a PF (i.e doesn't\n\t\t * work for a passed-through VF) and it has the potential side\n\t\t * effect of also causing an EEH on every other VF under the\n\t\t * PF. Oh well.\n\t\t */\n\t\tpdev = pdev->physfn;\n\t\tif (!pdev)\n\t\t\treturn -ENXIO; /* passed through VFs have no PF */\n\n\t\tpos  = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\t\tpos += PCI_SRIOV_CTRL;\n\t\tbit  = PCI_SRIOV_CTRL_MSE;\n#endif /* !CONFIG_PCI_IOV */\n\t} else {\n\t\tbit = PCI_COMMAND_MEMORY;\n\t\tpos = PCI_COMMAND;\n\t}\n\n\t/*\n\t * Process here is:\n\t *\n\t * 1. Disable Memory space.\n\t *\n\t * 2. Perform an MMIO to the device. This should result in an error\n\t *    (CA  / UR) being raised by the device which results in an EEH\n\t *    PE freeze. Using the in_8() accessor skips the eeh detection hook\n\t *    so the freeze hook so the EEH Detection machinery won't be\n\t *    triggered here. This is to match the usual behaviour of EEH\n\t *    where the HW will asyncronously freeze a PE and it's up to\n\t *    the kernel to notice and deal with it.\n\t *\n\t * 3. Turn Memory space back on. This is more important for VFs\n\t *    since recovery will probably fail if we don't. For normal\n\t *    the COMMAND register is reset as a part of re-initialising\n\t *    the device.\n\t *\n\t * Breaking stuff is the point so who cares if it's racy ;)\n\t */\n\tpci_read_config_word(pdev, pos, &old);\n\n\tmapped = ioremap(bar->start, PAGE_SIZE);\n\tif (!mapped) {\n\t\tpci_err(pdev, \"Unable to map MMIO BAR %pR\\n\", bar);\n\t\treturn -ENXIO;\n\t}\n\n\tpci_write_config_word(pdev, pos, old & ~bit);\n\tin_8(mapped);\n\tpci_write_config_word(pdev, pos, old);\n\n\tiounmap(mapped);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "mapped"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config_word",
          "args": [
            "pdev",
            "pos",
            "old"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_8",
          "args": [
            "mapped"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config_word",
          "args": [
            "pdev",
            "pos",
            "old & ~bit"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_err",
          "args": [
            "pdev",
            "\"Unable to map MMIO BAR %pR\\n\"",
            "bar"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "bar->start",
            "PAGE_SIZE"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "pdev",
            "pos",
            "&old"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_ext_capability",
          "args": [
            "pdev",
            "PCI_EXT_CAP_ID_SRIOV"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_err",
          "args": [
            "pdev",
            "\"Going to break: %pR\\n\"",
            "bar"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_err",
          "args": [
            "pdev",
            "\"Unable to find Memory BAR to cause EEH with\\n\""
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_debugfs_break_device(struct pci_dev *pdev)\n{\n\tstruct resource *bar = NULL;\n\tvoid __iomem *mapped;\n\tu16 old, bit;\n\tint i, pos;\n\n\t/* Do we have an MMIO BAR to disable? */\n\tfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\n\t\tstruct resource *r = &pdev->resource[i];\n\n\t\tif (!r->flags || !r->start)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_IO)\n\t\t\tcontinue;\n\t\tif (r->flags & IORESOURCE_UNSET)\n\t\t\tcontinue;\n\n\t\tbar = r;\n\t\tbreak;\n\t}\n\n\tif (!bar) {\n\t\tpci_err(pdev, \"Unable to find Memory BAR to cause EEH with\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpci_err(pdev, \"Going to break: %pR\\n\", bar);\n\n\tif (pdev->is_virtfn) {\n#ifndef CONFIG_PCI_IOV\n\t\treturn -ENXIO;\n#else\n\t\t/*\n\t\t * VFs don't have a per-function COMMAND register, so the best\n\t\t * we can do is clear the Memory Space Enable bit in the PF's\n\t\t * SRIOV control reg.\n\t\t *\n\t\t * Unfortunately, this requires that we have a PF (i.e doesn't\n\t\t * work for a passed-through VF) and it has the potential side\n\t\t * effect of also causing an EEH on every other VF under the\n\t\t * PF. Oh well.\n\t\t */\n\t\tpdev = pdev->physfn;\n\t\tif (!pdev)\n\t\t\treturn -ENXIO; /* passed through VFs have no PF */\n\n\t\tpos  = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\t\tpos += PCI_SRIOV_CTRL;\n\t\tbit  = PCI_SRIOV_CTRL_MSE;\n#endif /* !CONFIG_PCI_IOV */\n\t} else {\n\t\tbit = PCI_COMMAND_MEMORY;\n\t\tpos = PCI_COMMAND;\n\t}\n\n\t/*\n\t * Process here is:\n\t *\n\t * 1. Disable Memory space.\n\t *\n\t * 2. Perform an MMIO to the device. This should result in an error\n\t *    (CA  / UR) being raised by the device which results in an EEH\n\t *    PE freeze. Using the in_8() accessor skips the eeh detection hook\n\t *    so the freeze hook so the EEH Detection machinery won't be\n\t *    triggered here. This is to match the usual behaviour of EEH\n\t *    where the HW will asyncronously freeze a PE and it's up to\n\t *    the kernel to notice and deal with it.\n\t *\n\t * 3. Turn Memory space back on. This is more important for VFs\n\t *    since recovery will probably fail if we don't. For normal\n\t *    the COMMAND register is reset as a part of re-initialising\n\t *    the device.\n\t *\n\t * Breaking stuff is the point so who cares if it's racy ;)\n\t */\n\tpci_read_config_word(pdev, pos, &old);\n\n\tmapped = ioremap(bar->start, PAGE_SIZE);\n\tif (!mapped) {\n\t\tpci_err(pdev, \"Unable to map MMIO BAR %pR\\n\", bar);\n\t\treturn -ENXIO;\n\t}\n\n\tpci_write_config_word(pdev, pos, old & ~bit);\n\tin_8(mapped);\n\tpci_write_config_word(pdev, pos, old);\n\n\tiounmap(mapped);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_dev_check_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1692-1731",
    "snippet": "static ssize_t eeh_dev_check_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tuint32_t domain, bus, dev, fn;\n\tstruct pci_dev *pdev;\n\tstruct eeh_dev *edev;\n\tchar buf[20];\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\tret = sscanf(buf, \"%x:%x:%x.%x\", &domain, &bus, &dev, &fn);\n\tif (ret != 4) {\n\t\tpr_err(\"%s: expected 4 args, got %d\\n\", __func__, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev) {\n\t\tpci_err(pdev, \"No eeh_dev for this device!\\n\");\n\t\tpci_dev_put(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tret = eeh_dev_check_failure(edev);\n\tpci_info(pdev, \"eeh_dev_check_failure(%04x:%02x:%02x.%01x) = %d\\n\",\n\t\t\tdomain, bus, dev, fn, ret);\n\n\tpci_dev_put(pdev);\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_info",
          "args": [
            "pdev",
            "\"eeh_dev_check_failure(%04x:%02x:%02x.%01x) = %d\\n\"",
            "domain",
            "bus",
            "dev",
            "fn",
            "ret"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_check_failure",
          "args": [
            "edev"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "440-585",
          "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_MAX_FAILS\t2100000"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct eeh_stats eeh_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_err",
          "args": [
            "pdev",
            "\"No eeh_dev for this device!\\n\""
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_domain_bus_and_slot",
          "args": [
            "domain",
            "bus",
            "(dev << 3) | fn"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: expected 4 args, got %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%x:%x:%x.%x\"",
            "&domain",
            "&bus",
            "&dev",
            "&fn"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_write_to_buffer",
          "args": [
            "buf",
            "sizeof(buf)-1",
            "ppos",
            "user_buf",
            "count"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic ssize_t eeh_dev_check_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tuint32_t domain, bus, dev, fn;\n\tstruct pci_dev *pdev;\n\tstruct eeh_dev *edev;\n\tchar buf[20];\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tret = simple_write_to_buffer(buf, sizeof(buf)-1, ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\tret = sscanf(buf, \"%x:%x:%x.%x\", &domain, &bus, &dev, &fn);\n\tif (ret != 4) {\n\t\tpr_err(\"%s: expected 4 args, got %d\\n\", __func__, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev = pci_get_domain_bus_and_slot(domain, bus, (dev << 3) | fn);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev) {\n\t\tpci_err(pdev, \"No eeh_dev for this device!\\n\");\n\t\tpci_dev_put(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tret = eeh_dev_check_failure(edev);\n\tpci_info(pdev, \"eeh_dev_check_failure(%04x:%02x:%02x.%01x) = %d\\n\",\n\t\t\tdomain, bus, dev, fn, ret);\n\n\tpci_dev_put(pdev);\n\n\treturn count;\n}"
  },
  {
    "function_name": "eeh_debugfs_dev_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1682-1690",
    "snippet": "static ssize_t eeh_debugfs_dev_usage(struct file *filp,\n\t\t\t\tchar __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic const char usage[] = \"input format: <domain>:<bus>:<dev>.<fn>\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       usage, sizeof(usage) - 1);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "usage",
            "sizeof(usage) - 1"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic ssize_t eeh_debugfs_dev_usage(struct file *filp,\n\t\t\t\tchar __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic const char usage[] = \"input format: <domain>:<bus>:<dev>.<fn>\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       usage, sizeof(usage) - 1);\n}"
  },
  {
    "function_name": "eeh_force_recover_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1626-1674",
    "snippet": "static ssize_t eeh_force_recover_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct pci_controller *hose;\n\tuint32_t phbid, pe_no;\n\tstruct eeh_pe *pe;\n\tchar buf[20];\n\tint ret;\n\n\tret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\t/*\n\t * When PE is NULL the event is a \"special\" event. Rather than\n\t * recovering a specific PE it forces the EEH core to scan for failed\n\t * PHBs and recovers each. This needs to be done before any device\n\t * recoveries can occur.\n\t */\n\tif (!strncmp(buf, \"hwcheck\", 7)) {\n\t\t__eeh_send_failure_event(NULL);\n\t\treturn count;\n\t}\n\n\tret = sscanf(buf, \"%x:%x\", &phbid, &pe_no);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\those = pci_find_controller_for_domain(phbid);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\t/* Retrieve PE */\n\tpe = eeh_pe_get(hose, pe_no);\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * We don't do any state checking here since the detection\n\t * process is async to the recovery process. The recovery\n\t * thread *should* not break even if we schedule a recovery\n\t * from an odd state (e.g. PE removed, or recovery of a\n\t * non-isolated PE)\n\t */\n\t__eeh_send_failure_event(pe);\n\n\treturn ret < 0 ? ret : count;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__eeh_send_failure_event",
          "args": [
            "pe"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "102-141",
          "snippet": "int __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
            "static DECLARE_COMPLETION(eeh_eventlist_event);",
            "static LIST_HEAD(eeh_eventlist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic DECLARE_COMPLETION(eeh_eventlist_event);\nstatic LIST_HEAD(eeh_eventlist);\n\nint __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_get",
          "args": [
            "hose",
            "pe_no"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "286-291",
          "snippet": "struct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_pe_get(struct pci_controller *phb, int pe_no)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(phb);\n\n\treturn eeh_pe_traverse(root, __eeh_pe_get, &pe_no);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_find_controller_for_domain",
          "args": [
            "phbid"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "pci_find_controller_for_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "345-354",
          "snippet": "struct pci_controller *pci_find_controller_for_domain(int domain_nr)\n{\n\tstruct pci_controller *hose;\n\n\tlist_for_each_entry(hose, &hose_list, list_node)\n\t\tif (hose->global_number == domain_nr)\n\t\t\treturn hose;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller *pci_find_controller_for_domain(int domain_nr)\n{\n\tstruct pci_controller *hose;\n\n\tlist_for_each_entry(hose, &hose_list, list_node)\n\t\tif (hose->global_number == domain_nr)\n\t\t\treturn hose;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%x:%x\"",
            "&phbid",
            "&pe_no"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"hwcheck\"",
            "7"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_write_to_buffer",
          "args": [
            "buf",
            "sizeof(buf)",
            "ppos",
            "user_buf",
            "count"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic ssize_t eeh_force_recover_write(struct file *filp,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct pci_controller *hose;\n\tuint32_t phbid, pe_no;\n\tstruct eeh_pe *pe;\n\tchar buf[20];\n\tint ret;\n\n\tret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);\n\tif (!ret)\n\t\treturn -EFAULT;\n\n\t/*\n\t * When PE is NULL the event is a \"special\" event. Rather than\n\t * recovering a specific PE it forces the EEH core to scan for failed\n\t * PHBs and recovers each. This needs to be done before any device\n\t * recoveries can occur.\n\t */\n\tif (!strncmp(buf, \"hwcheck\", 7)) {\n\t\t__eeh_send_failure_event(NULL);\n\t\treturn count;\n\t}\n\n\tret = sscanf(buf, \"%x:%x\", &phbid, &pe_no);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\those = pci_find_controller_for_domain(phbid);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\t/* Retrieve PE */\n\tpe = eeh_pe_get(hose, pe_no);\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * We don't do any state checking here since the detection\n\t * process is async to the recovery process. The recovery\n\t * thread *should* not break even if we schedule a recovery\n\t * from an odd state (e.g. PE removed, or recovery of a\n\t * non-isolated PE)\n\t */\n\t__eeh_send_failure_event(pe);\n\n\treturn ret < 0 ? ret : count;\n}"
  },
  {
    "function_name": "eeh_enable_dbgfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1614-1621",
    "snippet": "static int eeh_enable_dbgfs_get(void *data, u64 *val)\n{\n\tif (eeh_enabled())\n\t\t*val = 0x1ul;\n\telse\n\t\t*val = 0x0ul;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_enable_dbgfs_get(void *data, u64 *val)\n{\n\tif (eeh_enabled())\n\t\t*val = 0x1ul;\n\telse\n\t\t*val = 0x0ul;\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_enable_dbgfs_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1604-1612",
    "snippet": "static int eeh_enable_dbgfs_set(void *data, u64 val)\n{\n\tif (val)\n\t\teeh_clear_flag(EEH_FORCE_DISABLED);\n\telse\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_clear_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_enable_dbgfs_set(void *data, u64 val)\n{\n\tif (val)\n\t\teeh_clear_flag(EEH_FORCE_DISABLED);\n\telse\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_eeh_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1576-1601",
    "snippet": "static int proc_eeh_show(struct seq_file *m, void *v)\n{\n\tif (!eeh_enabled()) {\n\t\tseq_printf(m, \"EEH Subsystem is globally disabled\\n\");\n\t\tseq_printf(m, \"eeh_total_mmio_ffs=%llu\\n\", eeh_stats.total_mmio_ffs);\n\t} else {\n\t\tseq_printf(m, \"EEH Subsystem is enabled\\n\");\n\t\tseq_printf(m,\n\t\t\t\t\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\",\n\t\t\t\teeh_stats.no_device,\n\t\t\t\teeh_stats.no_dn,\n\t\t\t\teeh_stats.no_cfg_addr,\n\t\t\t\teeh_stats.ignored_check,\n\t\t\t\teeh_stats.total_mmio_ffs,\n\t\t\t\teeh_stats.false_positives,\n\t\t\t\teeh_stats.slot_resets);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\"",
            "eeh_stats.no_device",
            "eeh_stats.no_dn",
            "eeh_stats.no_cfg_addr",
            "eeh_stats.ignored_check",
            "eeh_stats.total_mmio_ffs",
            "eeh_stats.false_positives",
            "eeh_stats.slot_resets"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EEH Subsystem is enabled\\n\""
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"eeh_total_mmio_ffs=%llu\\n\"",
            "eeh_stats.total_mmio_ffs"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EEH Subsystem is globally disabled\\n\""
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic struct eeh_stats eeh_stats;\n\nstatic int proc_eeh_show(struct seq_file *m, void *v)\n{\n\tif (!eeh_enabled()) {\n\t\tseq_printf(m, \"EEH Subsystem is globally disabled\\n\");\n\t\tseq_printf(m, \"eeh_total_mmio_ffs=%llu\\n\", eeh_stats.total_mmio_ffs);\n\t} else {\n\t\tseq_printf(m, \"EEH Subsystem is enabled\\n\");\n\t\tseq_printf(m,\n\t\t\t\t\"no device=%llu\\n\"\n\t\t\t\t\"no device node=%llu\\n\"\n\t\t\t\t\"no config address=%llu\\n\"\n\t\t\t\t\"check not wanted=%llu\\n\"\n\t\t\t\t\"eeh_total_mmio_ffs=%llu\\n\"\n\t\t\t\t\"eeh_false_positives=%llu\\n\"\n\t\t\t\t\"eeh_slot_resets=%llu\\n\",\n\t\t\t\teeh_stats.no_device,\n\t\t\t\teeh_stats.no_dn,\n\t\t\t\teeh_stats.no_cfg_addr,\n\t\t\t\teeh_stats.ignored_check,\n\t\t\t\teeh_stats.total_mmio_ffs,\n\t\t\t\teeh_stats.false_positives,\n\t\t\t\teeh_stats.slot_resets);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_inject_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1553-1573",
    "snippet": "int eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,\n\t\t      unsigned long addr, unsigned long mask)\n{\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/* Unsupported operation ? */\n\tif (!eeh_ops || !eeh_ops->err_inject)\n\t\treturn -ENOENT;\n\n\t/* Check on PCI error type */\n\tif (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)\n\t\treturn -EINVAL;\n\n\t/* Check on PCI error function */\n\tif (func < EEH_ERR_FUNC_MIN || func > EEH_ERR_FUNC_MAX)\n\t\treturn -EINVAL;\n\n\treturn eeh_ops->err_inject(pe, type, func, addr, mask);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->err_inject",
          "args": [
            "pe",
            "type",
            "func",
            "addr",
            "mask"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_inject_err(struct eeh_pe *pe, int type, int func,\n\t\t      unsigned long addr, unsigned long mask)\n{\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/* Unsupported operation ? */\n\tif (!eeh_ops || !eeh_ops->err_inject)\n\t\treturn -ENOENT;\n\n\t/* Check on PCI error type */\n\tif (type != EEH_ERR_TYPE_32 && type != EEH_ERR_TYPE_64)\n\t\treturn -EINVAL;\n\n\t/* Check on PCI error function */\n\tif (func < EEH_ERR_FUNC_MIN || func > EEH_ERR_FUNC_MAX)\n\t\treturn -EINVAL;\n\n\treturn eeh_ops->err_inject(pe, type, func, addr, mask);\n}"
  },
  {
    "function_name": "eeh_pe_configure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1529-1538",
    "snippet": "int eeh_pe_configure(struct eeh_pe *pe)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_pe_configure(struct eeh_pe *pe)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1479-1518",
    "snippet": "int eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, include_passed);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe, include_passed);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Unsupported option %d\\n\"",
            "__func__",
            "option"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "option"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_reenable_devices",
          "args": [
            "pe",
            "include_passed"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reenable_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1433-1467",
          "snippet": "static int eeh_pe_reenable_devices(struct eeh_pe *pe, bool include_passed)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\tret = eeh_unfreeze_pe(pe);\n\t} else\n\t\tpr_info(\"EEH: Note: Leaving passthrough PHB#%x-PE#%x frozen.\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, include_passed);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_reenable_devices(struct eeh_pe *pe, bool include_passed)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\tret = eeh_unfreeze_pe(pe);\n\t} else\n\t\tpr_info(\"EEH: Note: Leaving passthrough PHB#%x-PE#%x frozen.\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, include_passed);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED",
            "include_passed"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "option"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, include_passed);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe, include_passed);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_reenable_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1433-1467",
    "snippet": "static int eeh_pe_reenable_devices(struct eeh_pe *pe, bool include_passed)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\tret = eeh_unfreeze_pe(pe);\n\t} else\n\t\tpr_info(\"EEH: Note: Leaving passthrough PHB#%x-PE#%x frozen.\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, include_passed);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED",
            "include_passed"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Note: Leaving passthrough PHB#%x-PE#%x frozen.\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1131-1150",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d reenabling %s\\n\"",
            "__func__",
            "ret",
            "pci_name(pdev)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_reenable_device",
          "args": [
            "pdev"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "792-799",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_reenable_devices(struct eeh_pe *pe, bool include_passed)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tint ret = 0;\n\n\teeh_pe_restore_bars(pe);\n\n\t/*\n\t * Reenable PCI devices as the devices passed\n\t * through are always enabled before the reset.\n\t */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tret = pci_reenable_device(pdev);\n\t\tif (ret) {\n\t\t\tpr_warn(\"%s: Failure %d reenabling %s\\n\",\n\t\t\t\t__func__, ret, pci_name(pdev));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* The PE is still in frozen state */\n\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\tret = eeh_unfreeze_pe(pe);\n\t} else\n\t\tpr_info(\"EEH: Note: Leaving passthrough PHB#%x-PE#%x frozen.\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, include_passed);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_get_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1390-1430",
    "snippet": "int eeh_pe_get_state(struct eeh_pe *pe)\n{\n\tint result, ret = 0;\n\tbool rst_active, dma_en, mmio_en;\n\n\t/* Existing PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->get_state)\n\t\treturn -ENOENT;\n\n\t/*\n\t * If the parent PE is owned by the host kernel and is undergoing\n\t * error recovery, we should return the PE state as temporarily\n\t * unavailable so that the error recovery on the guest is suspended\n\t * until the recovery completes on the host.\n\t */\n\tif (pe->parent &&\n\t    !(pe->state & EEH_PE_REMOVED) &&\n\t    (pe->parent->state & (EEH_PE_ISOLATED | EEH_PE_RECOVERING)))\n\t\treturn EEH_PE_STATE_UNAVAIL;\n\n\tresult = eeh_ops->get_state(pe, NULL);\n\trst_active = !!(result & EEH_STATE_RESET_ACTIVE);\n\tdma_en = !!(result & EEH_STATE_DMA_ENABLED);\n\tmmio_en = !!(result & EEH_STATE_MMIO_ENABLED);\n\n\tif (rst_active)\n\t\tret = EEH_PE_STATE_RESET;\n\telse if (dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_NORMAL;\n\telse if (!dma_en && !mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_IO_DMA;\n\telse if (!dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_DMA;\n\telse\n\t\tret = EEH_PE_STATE_UNAVAIL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_get_state(struct eeh_pe *pe)\n{\n\tint result, ret = 0;\n\tbool rst_active, dma_en, mmio_en;\n\n\t/* Existing PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->get_state)\n\t\treturn -ENOENT;\n\n\t/*\n\t * If the parent PE is owned by the host kernel and is undergoing\n\t * error recovery, we should return the PE state as temporarily\n\t * unavailable so that the error recovery on the guest is suspended\n\t * until the recovery completes on the host.\n\t */\n\tif (pe->parent &&\n\t    !(pe->state & EEH_PE_REMOVED) &&\n\t    (pe->parent->state & (EEH_PE_ISOLATED | EEH_PE_RECOVERING)))\n\t\treturn EEH_PE_STATE_UNAVAIL;\n\n\tresult = eeh_ops->get_state(pe, NULL);\n\trst_active = !!(result & EEH_STATE_RESET_ACTIVE);\n\tdma_en = !!(result & EEH_STATE_DMA_ENABLED);\n\tmmio_en = !!(result & EEH_STATE_MMIO_ENABLED);\n\n\tif (rst_active)\n\t\tret = EEH_PE_STATE_RESET;\n\telse if (dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_NORMAL;\n\telse if (!dma_en && !mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_IO_DMA;\n\telse if (!dma_en && mmio_en)\n\t\tret = EEH_PE_STATE_STOPPED_DMA;\n\telse\n\t\tret = EEH_PE_STATE_UNAVAIL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_set_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1340-1380",
    "snippet": "int eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Option %d out of range (%d, %d)\\n\"",
            "__func__",
            "option",
            "EEH_OPT_DISABLE",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "option"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "626-693",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "pe"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1160-1204",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_iommu_group_to_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1307-1327",
    "snippet": "struct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct eeh_dev *edev;\n\tint ret;\n\n\t/* No IOMMU group ? */\n\tif (!group)\n\t\treturn NULL;\n\n\tret = iommu_group_for_each_dev(group, &pdev, dev_has_iommu_table);\n\tif (!ret || !pdev)\n\t\treturn NULL;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\treturn NULL;\n\n\treturn edev->pe;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_for_each_dev",
          "args": [
            "group",
            "&pdev",
            "dev_has_iommu_table"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_iommu_group_to_pe(struct iommu_group *group)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct eeh_dev *edev;\n\tint ret;\n\n\t/* No IOMMU group ? */\n\tif (!group)\n\t\treturn NULL;\n\n\tret = iommu_group_for_each_dev(group, &pdev, dev_has_iommu_table);\n\tif (!ret || !pdev)\n\t\treturn NULL;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\treturn NULL;\n\n\treturn edev->pe;\n}"
  },
  {
    "function_name": "dev_has_iommu_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1285-1299",
    "snippet": "static int dev_has_iommu_table(struct device *dev, void *data)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_dev **ppdev = data;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (device_iommu_mapped(dev)) {\n\t\t*ppdev = pdev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_iommu_mapped",
          "args": [
            "dev"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int dev_has_iommu_table(struct device *dev, void *data)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct pci_dev **ppdev = data;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (device_iommu_mapped(dev)) {\n\t\t*ppdev = pdev;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_dev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1260-1280",
    "snippet": "void eeh_dev_release(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe || !eeh_pe_passed(edev->pe))\n\t\tgoto out;\n\n\t/* Decrease PE's pass through count */\n\tWARN_ON(atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0);\n\teeh_pe_change_owner(edev->pe);\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(eeh_dev_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "edev->pe"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1160-1204",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&edev->pe->pass_dev_cnt"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "edev->pe"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic DEFINE_MUTEX(eeh_dev_mutex);\n\nvoid eeh_dev_release(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe || !eeh_pe_passed(edev->pe))\n\t\tgoto out;\n\n\t/* Decrease PE's pass through count */\n\tWARN_ON(atomic_dec_if_positive(&edev->pe->pass_dev_cnt) < 0);\n\teeh_pe_change_owner(edev->pe);\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n}"
  },
  {
    "function_name": "eeh_dev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1215-1249",
    "snippet": "int eeh_dev_open(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\tgoto out;\n\n\t/*\n\t * The PE might have been put into frozen state, but we\n\t * didn't detect that yet. The passed through PCI devices\n\t * in frozen PE won't work properly. Clear the frozen state\n\t * in advance.\n\t */\n\tret = eeh_pe_change_owner(edev->pe);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Increase PE's pass through count */\n\tatomic_inc(&edev->pe->pass_dev_cnt);\n\tmutex_unlock(&eeh_dev_mutex);\n\n\treturn 0;\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(eeh_dev_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&edev->pe->pass_dev_cnt"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_change_owner",
          "args": [
            "edev->pe"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1160-1204",
          "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "pdev"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&eeh_dev_mutex"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic DEFINE_MUTEX(eeh_dev_mutex);\n\nint eeh_dev_open(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&eeh_dev_mutex);\n\n\t/* No PCI device ? */\n\tif (!pdev)\n\t\tgoto out;\n\n\t/* No EEH device or PE ? */\n\tedev = pci_dev_to_eeh_dev(pdev);\n\tif (!edev || !edev->pe)\n\t\tgoto out;\n\n\t/*\n\t * The PE might have been put into frozen state, but we\n\t * didn't detect that yet. The passed through PCI devices\n\t * in frozen PE won't work properly. Clear the frozen state\n\t * in advance.\n\t */\n\tret = eeh_pe_change_owner(edev->pe);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Increase PE's pass through count */\n\tatomic_inc(&edev->pe->pass_dev_cnt);\n\tmutex_unlock(&eeh_dev_mutex);\n\n\treturn 0;\nout:\n\tmutex_unlock(&eeh_dev_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_change_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1160-1204",
    "snippet": "static int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED",
            "true"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1131-1150",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_reset_and_recover",
          "args": [
            "pe"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reset_and_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "576-611",
          "snippet": "int eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Issue reset */\n\tret = eeh_pe_reset_full(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nint eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Issue reset */\n\tret = eeh_pe_reset_full(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_state_active",
          "args": [
            "ret"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct pci_device_id eeh_reset_ids[] = {\n\t{ PCI_DEVICE(0x19a2, 0x0710) },\t/* Emulex, BE     */\n\t{ PCI_DEVICE(0x10df, 0xe220) },\t/* Emulex, Lancer */\n\t{ PCI_DEVICE(0x14e4, 0x1657) }, /* Broadcom BCM5719 */\n\t{ 0 }\n};\n\nstatic int eeh_pe_change_owner(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\tstruct pci_device_id *id;\n\tint ret;\n\n\t/* Check PE state */\n\tret = eeh_ops->get_state(pe, NULL);\n\tif (ret < 0 || ret == EEH_STATE_NOT_SUPPORT)\n\t\treturn 0;\n\n\t/* Unfrozen PE, nothing to do */\n\tif (eeh_state_active(ret))\n\t\treturn 0;\n\n\t/* Frozen PE, check if it needs PE level reset */\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfor (id = &eeh_reset_ids[0]; id->vendor != 0; id++) {\n\t\t\tif (id->vendor != PCI_ANY_ID &&\n\t\t\t    id->vendor != pdev->vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->device != PCI_ANY_ID &&\n\t\t\t    id->device != pdev->device)\n\t\t\t\tcontinue;\n\t\t\tif (id->subvendor != PCI_ANY_ID &&\n\t\t\t    id->subvendor != pdev->subsystem_vendor)\n\t\t\t\tcontinue;\n\t\t\tif (id->subdevice != PCI_ANY_ID &&\n\t\t\t    id->subdevice != pdev->subsystem_device)\n\t\t\t\tcontinue;\n\n\t\t\treturn eeh_pe_reset_and_recover(pe);\n\t\t}\n\t}\n\n\tret = eeh_unfreeze_pe(pe);\n\tif (!ret)\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_unfreeze_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1131-1150",
    "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\"",
            "__func__",
            "ret",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "626-693",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\"",
            "__func__",
            "ret",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_remove_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1076-1129",
    "snippet": "void eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tdev_dbg(&dev->dev, \"EEH: Removing device\\n\");\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Device not referenced!\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\n\t/*\n\t * eeh_sysfs_remove_device() uses pci_dev_to_eeh_dev() so we need to\n\t * remove the sysfs files before clearing dev.archdata.edev\n\t */\n\tif (edev->mode & EEH_DEV_SYSFS)\n\t\teeh_sysfs_remove_device(dev);\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\n\t/*\n\t * The flag \"in_error\" is used to trace EEH devices for VFs\n\t * in error state or not. It's set in eeh_report_error(). If\n\t * it's not set, eeh_report_{reset,resume}() won't be called\n\t * for the VF EEH device.\n\t */\n\tedev->in_error = false;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_pe_tree_remove(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_tree_remove",
          "args": [
            "edev"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "402-478",
          "snippet": "int eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_rmv_dev",
          "args": [
            "dev"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "243-250",
          "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_sysfs_remove_device",
          "args": [
            "dev"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "158-181",
          "snippet": "void eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "&dev->dev",
            "\"EEH: Device not referenced!\\n\""
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "&dev->dev",
            "\"EEH: Removing device\\n\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nvoid eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tdev_dbg(&dev->dev, \"EEH: Removing device\\n\");\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Device not referenced!\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\n\t/*\n\t * eeh_sysfs_remove_device() uses pci_dev_to_eeh_dev() so we need to\n\t * remove the sysfs files before clearing dev.archdata.edev\n\t */\n\tif (edev->mode & EEH_DEV_SYSFS)\n\t\teeh_sysfs_remove_device(dev);\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\n\t/*\n\t * The flag \"in_error\" is used to trace EEH devices for VFs\n\t * in error state or not. It's set in eeh_report_error(). If\n\t * it's not set, eeh_report_{reset,resume}() won't be called\n\t * for the VF EEH device.\n\t */\n\tedev->in_error = false;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_pe_tree_remove(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n}"
  },
  {
    "function_name": "eeh_probe_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "1016-1064",
    "snippet": "void eeh_probe_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\t/*\n\t * pci_dev_to_eeh_dev() can only work if eeh_probe_dev() was\n\t * already called for this device.\n\t */\n\tif (WARN_ON_ONCE(pci_dev_to_eeh_dev(dev))) {\n\t\tpci_dbg(dev, \"Already bound to an eeh_dev!\\n\");\n\t\treturn;\n\t}\n\n\tedev = eeh_ops->probe(dev);\n\tif (!edev) {\n\t\tpr_debug(\"EEH: Adding device failed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * FIXME: We rely on pcibios_release_device() to remove the\n\t * existing EEH state. The release function is only called if\n\t * the pci_dev's refcount drops to zero so if something is\n\t * keeping a ref to a device (e.g. a filesystem) we need to\n\t * remove the old EEH state.\n\t *\n\t * FIXME: HEY MA, LOOK AT ME, NO LOCKING!\n\t */\n\tif (edev->pdev && edev->pdev != dev) {\n\t\teeh_pe_tree_remove(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\t}\n\n\t/* bind the pdev and the edev together */\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\teeh_addr_cache_insert_dev(dev);\n\teeh_sysfs_add_device(dev);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_sysfs_add_device",
          "args": [
            "dev"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "136-156",
          "snippet": "void eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\trc += eeh_notify_resume_add(pdev);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_add_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\tint rc=0;\n\n\tif (!eeh_enabled())\n\t\treturn;\n\n\tif (edev && (edev->mode & EEH_DEV_SYSFS))\n\t\treturn;\n\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_mode);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\trc += device_create_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\trc += eeh_notify_resume_add(pdev);\n\n\tif (rc)\n\t\tpr_warn(\"EEH: Unable to create sysfs entries\\n\");\n\telse if (edev)\n\t\tedev->mode |= EEH_DEV_SYSFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_insert_dev",
          "args": [
            "dev"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_insert_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "204-211",
          "snippet": "void eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_sysfs_remove_device",
          "args": [
            "edev->pdev"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_sysfs_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_sysfs.c",
          "lines": "158-181",
          "snippet": "void eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}",
          "includes": [
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <linux/stat.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <linux/stat.h>\n#include <linux/pci.h>\n\nvoid eeh_sysfs_remove_device(struct pci_dev *pdev)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(pdev);\n\n\tif (!edev) {\n\t\tWARN_ON(eeh_enabled());\n\t\treturn;\n\t}\n\n\tedev->mode &= ~EEH_DEV_SYSFS;\n\n\t/*\n\t * The parent directory might have been removed. We needn't\n\t * continue for that case.\n\t */\n\tif (!pdev->dev.kobj.sd)\n\t\treturn;\n\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_mode);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_config_addr);\n\tdevice_remove_file(&pdev->dev, &dev_attr_eeh_pe_state);\n\n\teeh_notify_resume_remove(pdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_rmv_dev",
          "args": [
            "edev->pdev"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "243-250",
          "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_tree_remove",
          "args": [
            "edev"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "402-478",
          "snippet": "int eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Adding device failed\\n\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->probe",
          "args": [
            "dev"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dbg",
          "args": [
            "dev",
            "\"Already bound to an eeh_dev!\\n\""
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pci_dev_to_eeh_dev(dev)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Adding device %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_probe_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tpr_debug(\"EEH: Adding device %s\\n\", pci_name(dev));\n\n\t/*\n\t * pci_dev_to_eeh_dev() can only work if eeh_probe_dev() was\n\t * already called for this device.\n\t */\n\tif (WARN_ON_ONCE(pci_dev_to_eeh_dev(dev))) {\n\t\tpci_dbg(dev, \"Already bound to an eeh_dev!\\n\");\n\t\treturn;\n\t}\n\n\tedev = eeh_ops->probe(dev);\n\tif (!edev) {\n\t\tpr_debug(\"EEH: Adding device failed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * FIXME: We rely on pcibios_release_device() to remove the\n\t * existing EEH state. The release function is only called if\n\t * the pci_dev's refcount drops to zero so if something is\n\t * keeping a ref to a device (e.g. a filesystem) we need to\n\t * remove the old EEH state.\n\t *\n\t * FIXME: HEY MA, LOOK AT ME, NO LOCKING!\n\t */\n\tif (edev->pdev && edev->pdev != dev) {\n\t\teeh_pe_tree_remove(edev);\n\t\teeh_addr_cache_rmv_dev(edev->pdev);\n\t\teeh_sysfs_remove_device(edev->pdev);\n\n\t\t/*\n\t\t * We definitely should have the PCI device removed\n\t\t * though it wasn't correctly. So we needn't call\n\t\t * into error handler afterwards.\n\t\t */\n\t\tedev->mode |= EEH_DEV_NO_HANDLER;\n\t}\n\n\t/* bind the pdev and the edev together */\n\tedev->pdev = dev;\n\tdev->dev.archdata.edev = edev;\n\teeh_addr_cache_insert_dev(dev);\n\teeh_sysfs_add_device(dev);\n}"
  },
  {
    "function_name": "eeh_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "972-1007",
    "snippet": "int eeh_init(struct eeh_ops *ops)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint ret = 0;\n\n\t/* the platform should only initialise EEH once */\n\tif (WARN_ON(eeh_ops))\n\t\treturn -EEXIST;\n\tif (WARN_ON(!ops))\n\t\treturn -ENOENT;\n\teeh_ops = ops;\n\n\t/* Register reboot notifier */\n\tret = register_reboot_notifier(&eeh_reboot_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register reboot notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = bus_register_notifier(&pci_bus_type, &eeh_device_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register bus notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t/* Initialize PHB PEs */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\teeh_phb_pe_create(hose);\n\n\teeh_addr_cache_init();\n\n\t/* Initialize EEH event */\n\treturn eeh_event_init();\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct notifier_block eeh_reboot_nb = {\n\t.notifier_call = eeh_reboot_notifier,\n};",
      "static struct notifier_block eeh_device_nb = {\n\t.notifier_call = eeh_device_notifier,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_event_init",
          "args": [],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "78-92",
          "snippet": "int eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nint eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_init",
          "args": [],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "258-261",
          "snippet": "void eeh_addr_cache_init(void)\n{\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_init(void)\n{\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_create",
          "args": [
            "hose"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "79-96",
          "snippet": "int eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nint eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failed to register bus notifier (%d)\\n\"",
            "__func__",
            "ret"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&eeh_device_nb"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Failed to register reboot notifier (%d)\\n\"",
            "__func__",
            "ret"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_reboot_notifier",
          "args": [
            "&eeh_reboot_nb"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ops"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "eeh_ops"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct notifier_block eeh_reboot_nb = {\n\t.notifier_call = eeh_reboot_notifier,\n};\nstatic struct notifier_block eeh_device_nb = {\n\t.notifier_call = eeh_device_notifier,\n};\n\nint eeh_init(struct eeh_ops *ops)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint ret = 0;\n\n\t/* the platform should only initialise EEH once */\n\tif (WARN_ON(eeh_ops))\n\t\treturn -EEXIST;\n\tif (WARN_ON(!ops))\n\t\treturn -ENOENT;\n\teeh_ops = ops;\n\n\t/* Register reboot notifier */\n\tret = register_reboot_notifier(&eeh_reboot_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register reboot notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = bus_register_notifier(&pci_bus_type, &eeh_device_nb);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failed to register bus notifier (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t/* Initialize PHB PEs */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\teeh_phb_pe_create(hose);\n\n\teeh_addr_cache_init();\n\n\t/* Initialize EEH event */\n\treturn eeh_event_init();\n}"
  },
  {
    "function_name": "eeh_device_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "943-961",
    "snippet": "static int eeh_device_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\t/*\n\t * Note: It's not possible to perform EEH device addition (i.e.\n\t * {pseries,pnv}_pcibios_bus_add_device()) here because it depends on\n\t * the device's resources, which have not yet been set up.\n\t */\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\teeh_remove_device(to_pci_dev(dev));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_remove_device",
          "args": [
            "to_pci_dev(dev)"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_remove_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1076-1129",
          "snippet": "void eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tdev_dbg(&dev->dev, \"EEH: Removing device\\n\");\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Device not referenced!\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\n\t/*\n\t * eeh_sysfs_remove_device() uses pci_dev_to_eeh_dev() so we need to\n\t * remove the sysfs files before clearing dev.archdata.edev\n\t */\n\tif (edev->mode & EEH_DEV_SYSFS)\n\t\teeh_sysfs_remove_device(dev);\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\n\t/*\n\t * The flag \"in_error\" is used to trace EEH devices for VFs\n\t * in error state or not. It's set in eeh_report_error(). If\n\t * it's not set, eeh_report_{reset,resume}() won't be called\n\t * for the VF EEH device.\n\t */\n\tedev->in_error = false;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_pe_tree_remove(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nvoid eeh_remove_device(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\n\tif (!dev || !eeh_enabled())\n\t\treturn;\n\tedev = pci_dev_to_eeh_dev(dev);\n\n\t/* Unregister the device with the EEH/PCI address search system */\n\tdev_dbg(&dev->dev, \"EEH: Removing device\\n\");\n\n\tif (!edev || !edev->pdev || !edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Device not referenced!\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * During the hotplug for EEH error recovery, we need the EEH\n\t * device attached to the parent PE in order for BAR restore\n\t * a bit later. So we keep it for BAR restore and remove it\n\t * from the parent PE during the BAR resotre.\n\t */\n\tedev->pdev = NULL;\n\n\t/*\n\t * eeh_sysfs_remove_device() uses pci_dev_to_eeh_dev() so we need to\n\t * remove the sysfs files before clearing dev.archdata.edev\n\t */\n\tif (edev->mode & EEH_DEV_SYSFS)\n\t\teeh_sysfs_remove_device(dev);\n\n\t/*\n\t * We're removing from the PCI subsystem, that means\n\t * the PCI device driver can't support EEH or not\n\t * well. So we rely on hotplug completely to do recovery\n\t * for the specific PCI device.\n\t */\n\tedev->mode |= EEH_DEV_NO_HANDLER;\n\n\teeh_addr_cache_rmv_dev(dev);\n\n\t/*\n\t * The flag \"in_error\" is used to trace EEH devices for VFs\n\t * in error state or not. It's set in eeh_report_error(). If\n\t * it's not set, eeh_report_{reset,resume}() won't be called\n\t * for the VF EEH device.\n\t */\n\tedev->in_error = false;\n\tdev->dev.archdata.edev = NULL;\n\tif (!(edev->pe->state & EEH_PE_KEEP))\n\t\teeh_pe_tree_remove(edev);\n\telse\n\t\tedev->mode |= EEH_DEV_DISCONNECTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_device_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\t/*\n\t * Note: It's not possible to perform EEH device addition (i.e.\n\t * {pseries,pnv}_pcibios_bus_add_device()) here because it depends on\n\t * the device's resources, which have not yet been set up.\n\t */\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\teeh_remove_device(to_pci_dev(dev));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "eeh_reboot_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "932-937",
    "snippet": "static int eeh_reboot_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *unused)\n{\n\teeh_clear_flag(EEH_ENABLED);\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_clear_flag",
          "args": [
            "EEH_ENABLED"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int eeh_reboot_notifier(struct notifier_block *nb,\n\t\t\t       unsigned long action, void *unused)\n{\n\teeh_clear_flag(EEH_ENABLED);\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "eeh_save_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "912-930",
    "snippet": "void eeh_save_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\tif (!edev)\n\t\treturn;\n\n\tfor (i = 0; i < 16; i++)\n\t\teeh_ops->read_config(edev, i * 4, 4, &edev->config_space[i]);\n\n\t/*\n\t * For PCI bridges including root port, we need enable bus\n\t * master explicitly. Otherwise, it can't fetch IODA table\n\t * entries correctly. So we cache the bit in advance so that\n\t * we can restore it after reset, either PHB range or PE range.\n\t */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\tedev->config_space[1] |= PCI_COMMAND_MASTER;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "i * 4",
            "4",
            "&edev->config_space[i]"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nvoid eeh_save_bars(struct eeh_dev *edev)\n{\n\tint i;\n\n\tif (!edev)\n\t\treturn;\n\n\tfor (i = 0; i < 16; i++)\n\t\teeh_ops->read_config(edev, i * 4, 4, &edev->config_space[i]);\n\n\t/*\n\t * For PCI bridges including root port, we need enable bus\n\t * master explicitly. Otherwise, it can't fetch IODA table\n\t * entries correctly. So we cache the bit in advance so that\n\t * we can restore it after reset, either PHB range or PE range.\n\t */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\tedev->config_space[1] |= PCI_COMMAND_MASTER;\n}"
  },
  {
    "function_name": "eeh_pe_reset_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "842-901",
    "snippet": "int eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "reset_state",
            "true"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_refreeze_passed",
          "args": [
            "pe"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_refreeze_passed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "812-828",
          "snippet": "static void eeh_pe_refreeze_passed(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tint state;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (eeh_pe_passed(pe)) {\n\t\t\tstate = eeh_ops->get_state(pe, NULL);\n\t\t\tif (state &\n\t\t\t   (EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED)) {\n\t\t\t\tpr_info(\"EEH: Passed-through PE PHB#%x-PE#%x was thawed by reset, re-freezing for safety.\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\t\teeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void eeh_pe_refreeze_passed(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tint state;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (eeh_pe_passed(pe)) {\n\t\t\tstate = eeh_ops->get_state(pe, NULL);\n\t\t\tif (state &\n\t\t\t   (EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED)) {\n\t\t\t\tpr_info(\"EEH: Passed-through PE PHB#%x-PE#%x was thawed by reset, re-freezing for safety.\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\t\teeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\"",
            "pe->phb->global_number",
            "pe->addr",
            "state",
            "i + 1"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_state_active",
          "args": [
            "state"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_wait_state",
          "args": [
            "pe",
            "PCI_BUS_RESET_WAIT_MSEC"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_wait_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "106-147",
          "snippet": "int eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)",
            "#define EEH_STATE_MIN_WAIT_TIME\t(1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n\nint eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\"",
            "pe->phb->global_number",
            "pe->addr",
            "i + 1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\"",
            "state",
            "pe->phb->global_number",
            "pe->addr",
            "i + 1"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_reset",
          "args": [
            "pe",
            "EEH_RESET_DEACTIVATE",
            "include_passed"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1479-1518",
          "snippet": "int eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, include_passed);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe, include_passed);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_reset(struct eeh_pe *pe, int option, bool include_passed)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\tif (!eeh_ops || !eeh_ops->set_option || !eeh_ops->reset)\n\t\treturn -ENOENT;\n\n\tswitch (option) {\n\tcase EEH_RESET_DEACTIVATE:\n\t\tret = eeh_ops->reset(pe, option);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, include_passed);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = eeh_pe_reenable_devices(pe, include_passed);\n\t\tbreak;\n\tcase EEH_RESET_HOT:\n\tcase EEH_RESET_FUNDAMENTAL:\n\t\t/*\n\t\t * Proactively freeze the PE to drop all MMIO access\n\t\t * during reset, which should be banned as it's always\n\t\t * cause recursive EEH error.\n\t\t */\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\n\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\tret = eeh_ops->reset(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Unsupported option %d\\n\",\n\t\t\t__func__, option);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "reset_state"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_set_dev_freset",
            "&freset"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nint eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_pe_refreeze_passed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "812-828",
    "snippet": "static void eeh_pe_refreeze_passed(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tint state;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (eeh_pe_passed(pe)) {\n\t\t\tstate = eeh_ops->get_state(pe, NULL);\n\t\t\tif (state &\n\t\t\t   (EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED)) {\n\t\t\t\tpr_info(\"EEH: Passed-through PE PHB#%x-PE#%x was thawed by reset, re-freezing for safety.\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\t\teeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_set_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1340-1380",
          "snippet": "int eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pe_set_option(struct eeh_pe *pe, int option)\n{\n\tint ret = 0;\n\n\t/* Invalid PE ? */\n\tif (!pe)\n\t\treturn -ENODEV;\n\n\t/*\n\t * EEH functionality could possibly be disabled, just\n\t * return error for the case. And the EEH functinality\n\t * isn't expected to be disabled on one specific PE.\n\t */\n\tswitch (option) {\n\tcase EEH_OPT_ENABLE:\n\t\tif (eeh_enabled()) {\n\t\t\tret = eeh_pe_change_owner(pe);\n\t\t\tbreak;\n\t\t}\n\t\tret = -EIO;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\t\tbreak;\n\tcase EEH_OPT_THAW_MMIO:\n\tcase EEH_OPT_THAW_DMA:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tif (!eeh_ops || !eeh_ops->set_option) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = eeh_pci_enable(pe, option);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%s: Option %d out of range (%d, %d)\\n\",\n\t\t\t__func__, option, EEH_OPT_DISABLE, EEH_OPT_THAW_DMA);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Passed-through PE PHB#%x-PE#%x was thawed by reset, re-freezing for safety.\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void eeh_pe_refreeze_passed(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tint state;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (eeh_pe_passed(pe)) {\n\t\t\tstate = eeh_ops->get_state(pe, NULL);\n\t\t\tif (state &\n\t\t\t   (EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED)) {\n\t\t\t\tpr_info(\"EEH: Passed-through PE PHB#%x-PE#%x was thawed by reset, re-freezing for safety.\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\t\teeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_set_dev_freset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "802-810",
    "snippet": "static void eeh_set_dev_freset(struct eeh_dev *edev, void *flag)\n{\n\tstruct pci_dev *dev;\n\tunsigned int *freset = (unsigned int *)flag;\n\n\tdev = eeh_dev_to_pci_dev(edev);\n\tif (dev)\n\t\t*freset |= dev->needs_freset;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_dev_freset(struct eeh_dev *edev, void *flag)\n{\n\tstruct pci_dev *dev;\n\tunsigned int *freset = (unsigned int *)flag;\n\n\tdev = eeh_dev_to_pci_dev(edev);\n\tif (dev)\n\t\t*freset |= dev->needs_freset;\n}"
  },
  {
    "function_name": "pcibios_set_pcie_reset_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "746-790",
    "snippet": "int pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\tstruct eeh_pe *pe = eeh_dev_to_pe(edev);\n\n\tif (!pe) {\n\t\tpr_err(\"%s: No PE found on PCI device %s\\n\",\n\t\t\t__func__, pci_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state) {\n\tcase pcie_deassert_reset:\n\t\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n\t\teeh_unfreeze_pe(pe);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\tbreak;\n\tcase pcie_hot_reset:\n\t\teeh_pe_mark_isolated(pe);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\t\tbreak;\n\tcase pcie_warm_reset:\n\t\teeh_pe_mark_isolated(pe);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\t\tbreak;\n\tdefault:\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED, true);\n\t\treturn -EINVAL;\n\t};\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED",
            "true"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_FUNDAMENTAL"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_CFG_BLOCKED"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_disable_and_save_dev_state",
            "dev"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_mark_isolated",
          "args": [
            "pe"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_mark_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "533-550",
          "snippet": "void eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_HOT"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "EEH_OPT_FREEZE_PE"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1131-1150",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->reset",
          "args": [
            "pe",
            "EEH_RESET_DEACTIVATE"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: No PE found on PCI device %s\\n\"",
            "__func__",
            "pci_name(dev)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\n{\n\tstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\n\tstruct eeh_pe *pe = eeh_dev_to_pe(edev);\n\n\tif (!pe) {\n\t\tpr_err(\"%s: No PE found on PCI device %s\\n\",\n\t\t\t__func__, pci_name(dev));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state) {\n\tcase pcie_deassert_reset:\n\t\teeh_ops->reset(pe, EEH_RESET_DEACTIVATE);\n\t\teeh_unfreeze_pe(pe);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_pe_dev_traverse(pe, eeh_restore_dev_state, dev);\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\tbreak;\n\tcase pcie_hot_reset:\n\t\teeh_pe_mark_isolated(pe);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_HOT);\n\t\tbreak;\n\tcase pcie_warm_reset:\n\t\teeh_pe_mark_isolated(pe);\n\t\teeh_pe_state_clear(pe, EEH_PE_CFG_BLOCKED, true);\n\t\teeh_ops->set_option(pe, EEH_OPT_FREEZE_PE);\n\t\teeh_pe_dev_traverse(pe, eeh_disable_and_save_dev_state, dev);\n\t\tif (!(pe->type & EEH_PE_VF))\n\t\t\teeh_pe_state_mark(pe, EEH_PE_CFG_BLOCKED);\n\t\teeh_ops->reset(pe, EEH_RESET_FUNDAMENTAL);\n\t\tbreak;\n\tdefault:\n\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED | EEH_PE_CFG_BLOCKED, true);\n\t\treturn -EINVAL;\n\t};\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_restore_dev_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "721-736",
    "snippet": "static void eeh_restore_dev_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\tif (!pdev)\n\t\treturn;\n\n\t/* Apply customization from firmware */\n\tif (eeh_ops->restore_config)\n\t\teeh_ops->restore_config(edev);\n\n\t/* The caller should restore state for the specified device */\n\tif (pdev != dev)\n\t\tpci_restore_state(pdev);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_restore_state",
          "args": [
            "pdev"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->restore_config",
          "args": [
            "edev"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic void eeh_restore_dev_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\tif (!pdev)\n\t\treturn;\n\n\t/* Apply customization from firmware */\n\tif (eeh_ops->restore_config)\n\t\teeh_ops->restore_config(edev);\n\n\t/* The caller should restore state for the specified device */\n\tif (pdev != dev)\n\t\tpci_restore_state(pdev);\n}"
  },
  {
    "function_name": "eeh_disable_and_save_dev_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "695-719",
    "snippet": "static void eeh_disable_and_save_dev_state(struct eeh_dev *edev,\n\t\t\t\t\t    void *userdata)\n{\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\t/*\n\t * The caller should have disabled and saved the\n\t * state for the specified device\n\t */\n\tif (!pdev || pdev == dev)\n\t\treturn;\n\n\t/* Ensure we have D0 power state */\n\tpci_set_power_state(pdev, PCI_D0);\n\n\t/* Save device state */\n\tpci_save_state(pdev);\n\n\t/*\n\t * Disable device to avoid any DMA traffic and\n\t * interrupt from the device\n\t */\n\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config_word",
          "args": [
            "pdev",
            "PCI_COMMAND",
            "PCI_COMMAND_INTX_DISABLE"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_save_state",
          "args": [
            "pdev"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_set_power_state",
          "args": [
            "pdev",
            "PCI_D0"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_and_save_dev_state(struct eeh_dev *edev,\n\t\t\t\t\t    void *userdata)\n{\n\tstruct pci_dev *pdev = eeh_dev_to_pci_dev(edev);\n\tstruct pci_dev *dev = userdata;\n\n\t/*\n\t * The caller should have disabled and saved the\n\t * state for the specified device\n\t */\n\tif (!pdev || pdev == dev)\n\t\treturn;\n\n\t/* Ensure we have D0 power state */\n\tpci_set_power_state(pdev, PCI_D0);\n\n\t/* Save device state */\n\tpci_save_state(pdev);\n\n\t/*\n\t * Disable device to avoid any DMA traffic and\n\t * interrupt from the device\n\t */\n\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);\n}"
  },
  {
    "function_name": "eeh_pci_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "626-693",
    "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
    ],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_wait_state",
          "args": [
            "pe",
            "PCI_BUS_RESET_WAIT_MSEC"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_wait_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "106-147",
          "snippet": "int eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)",
            "#define EEH_STATE_MIN_WAIT_TIME\t(1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n\nint eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\"",
            "__func__",
            "function",
            "pe->phb->global_number",
            "pe->addr",
            "rc"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->set_option",
          "args": [
            "pe",
            "function"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid function %d\\n\"",
            "__func__",
            "function"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "600-614",
    "snippet": "int eeh_check_failure(const volatile void __iomem *token)\n{\n\tunsigned long addr;\n\tstruct eeh_dev *edev;\n\n\t/* Finding the phys addr + pci device; this is pretty quick. */\n\taddr = eeh_token_to_phys((unsigned long __force) token);\n\tedev = eeh_addr_cache_get_dev(addr);\n\tif (!edev) {\n\t\teeh_stats.no_device++;\n\t\treturn 0;\n\t}\n\n\treturn eeh_dev_check_failure(edev);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_check_failure",
          "args": [
            "edev"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "440-585",
          "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_MAX_FAILS\t2100000"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct eeh_stats eeh_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_addr_cache_get_dev",
          "args": [
            "addr"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_get_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "82-91",
          "snippet": "struct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstruct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_token_to_phys",
          "args": [
            "(unsigned long __force) token"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_token_to_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "347-374",
          "snippet": "static inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = find_init_mm_pte(token, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\n\tpa = pte_pfn(*ptep);\n\n\t/* On radix we can do hugepage mappings for io, so handle that */\n\tif (hugepage_shift) {\n\t\tpa <<= hugepage_shift;\n\t\tpa |= token & ((1ul << hugepage_shift) - 1);\n\t} else {\n\t\tpa <<= PAGE_SHIFT;\n\t\tpa |= token & (PAGE_SIZE - 1);\n\t}\n\n\treturn pa;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = find_init_mm_pte(token, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\n\tpa = pte_pfn(*ptep);\n\n\t/* On radix we can do hugepage mappings for io, so handle that */\n\tif (hugepage_shift) {\n\t\tpa <<= hugepage_shift;\n\t\tpa |= token & ((1ul << hugepage_shift) - 1);\n\t} else {\n\t\tpa <<= PAGE_SHIFT;\n\t\tpa |= token & (PAGE_SIZE - 1);\n\t}\n\n\treturn pa;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic struct eeh_stats eeh_stats;\n\nint eeh_check_failure(const volatile void __iomem *token)\n{\n\tunsigned long addr;\n\tstruct eeh_dev *edev;\n\n\t/* Finding the phys addr + pci device; this is pretty quick. */\n\taddr = eeh_token_to_phys((unsigned long __force) token);\n\tedev = eeh_addr_cache_get_dev(addr);\n\tif (!edev) {\n\t\teeh_stats.no_device++;\n\t\treturn 0;\n\t}\n\n\treturn eeh_dev_check_failure(edev);\n}"
  },
  {
    "function_name": "eeh_dev_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "440-585",
    "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define EEH_MAX_FAILS\t2100000"
    ],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static struct eeh_stats eeh_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_send_failure_event",
          "args": [
            "pe"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "143-155",
          "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\"",
            "__func__",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_mark_isolated",
          "args": [
            "pe"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_mark_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "533-550",
          "snippet": "void eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\"",
            "pe->phb->global_number",
            "pe->addr",
            "pe->phb->global_number",
            "parent_pe->addr"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_state_active",
          "args": [
            "ret"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "parent_pe",
            "NULL"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_state_active",
          "args": [
            "ret"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "pe",
            "NULL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_err",
          "args": [
            "edev",
            "\"Might be infinite loop in %s driver\\n\"",
            "eeh_driver_name(dev)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_driver_name",
          "args": [
            "dev"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_err",
          "args": [
            "edev",
            "\"%d reads ignored for recovering device at location=%s driver=%s\\n\"",
            "pe->check_count",
            "location ? location : \"unknown\"",
            "eeh_driver_name(dev)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_driver_name",
          "args": [
            "dev"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,loc-code\"",
            "NULL"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "dev"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_check_failure",
          "args": [
            "pe"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "381-424",
          "snippet": "static int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%x\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_mark_isolated(phb_pe);\n\teeh_serialize_unlock(flags);\n\n\tpr_debug(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\teeh_send_failure_event(phb_pe);\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%x\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_mark_isolated(phb_pe);\n\teeh_serialize_unlock(flags);\n\n\tpr_debug(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\teeh_send_failure_event(phb_pe);\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "edev",
            "\"Ignored check\\n\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_enabled",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_phb_check_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "381-424",
    "snippet": "static int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%x\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_mark_isolated(phb_pe);\n\teeh_serialize_unlock(flags);\n\n\tpr_debug(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\teeh_send_failure_event(phb_pe);\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_send_failure_event",
          "args": [
            "phb_pe"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "143-155",
          "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: PHB#%x failure detected, location: %s\\n\"",
            "phb_pe->phb->global_number",
            "eeh_pe_loc_get(phb_pe)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_loc_get",
          "args": [
            "phb_pe"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_loc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "810-836",
          "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_mark_isolated",
          "args": [
            "phb_pe"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_mark_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "533-550",
          "snippet": "void eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_state_active",
          "args": [
            "ret"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->get_state",
          "args": [
            "phb_pe",
            "NULL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s Can't find PE for PHB#%x\\n\"",
            "__func__",
            "pe->phb->global_number"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "pe->phb"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "157-172",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_PROBE_MODE_DEV"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic int eeh_phb_check_failure(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *phb_pe;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!eeh_has_flag(EEH_PROBE_MODE_DEV))\n\t\treturn -EPERM;\n\n\t/* Find the PHB PE */\n\tphb_pe = eeh_phb_pe_get(pe->phb);\n\tif (!phb_pe) {\n\t\tpr_warn(\"%s Can't find PE for PHB#%x\\n\",\n\t\t\t__func__, pe->phb->global_number);\n\t\treturn -EEXIST;\n\t}\n\n\t/* If the PHB has been in problematic state */\n\teeh_serialize_lock(&flags);\n\tif (phb_pe->state & EEH_PE_ISOLATED) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Check PHB state */\n\tret = eeh_ops->get_state(phb_pe, NULL);\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Isolate the PHB and send event */\n\teeh_pe_mark_isolated(phb_pe);\n\teeh_serialize_unlock(flags);\n\n\tpr_debug(\"EEH: PHB#%x failure detected, location: %s\\n\",\n\t\tphb_pe->phb->global_number, eeh_pe_loc_get(phb_pe));\n\teeh_send_failure_event(phb_pe);\n\treturn 1;\nout:\n\teeh_serialize_unlock(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "eeh_token_to_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "347-374",
    "snippet": "static inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = find_init_mm_pte(token, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\n\tpa = pte_pfn(*ptep);\n\n\t/* On radix we can do hugepage mappings for io, so handle that */\n\tif (hugepage_shift) {\n\t\tpa <<= hugepage_shift;\n\t\tpa |= token & ((1ul << hugepage_shift) - 1);\n\t} else {\n\t\tpa <<= PAGE_SHIFT;\n\t\tpa |= token & (PAGE_SIZE - 1);\n\t}\n\n\treturn pa;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_init_mm_pte",
          "args": [
            "token",
            "&hugepage_shift"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\n{\n\tpte_t *ptep;\n\tunsigned long pa;\n\tint hugepage_shift;\n\n\t/*\n\t * We won't find hugepages here(this is iomem). Hence we are not\n\t * worried about _PAGE_SPLITTING/collapse. Also we will not hit\n\t * page table free, because of init_mm.\n\t */\n\tptep = find_init_mm_pte(token, &hugepage_shift);\n\tif (!ptep)\n\t\treturn token;\n\n\tpa = pte_pfn(*ptep);\n\n\t/* On radix we can do hugepage mappings for io, so handle that */\n\tif (hugepage_shift) {\n\t\tpa <<= hugepage_shift;\n\t\tpa |= token & ((1ul << hugepage_shift) - 1);\n\t} else {\n\t\tpa <<= PAGE_SHIFT;\n\t\tpa |= token & (PAGE_SIZE - 1);\n\t}\n\n\treturn pa;\n}"
  },
  {
    "function_name": "eeh_slot_error_detail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "291-338",
    "snippet": "void eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t *\n\t * When the @severity is EEH_LOG_PERM, the PE is going to be\n\t * removed. Prior to that, the drivers for devices included in\n\t * the PE will be closed. The drivers rely on working IO path\n\t * to bring the devices to quiet state. Otherwise, PCI traffic\n\t * from those devices after they are removed is like to cause\n\t * another unexpected EEH error.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||\n\t\t    severity == EEH_LOG_PERM)\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;",
      "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->get_log",
          "args": [
            "pe",
            "severity",
            "pci_regs_buf",
            "loglen"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "eeh_dump_pe_log",
            "&loglen"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "211-223",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "792-799",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->configure_bridge",
          "args": [
            "pe"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_MMIO"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "626-693",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_ENABLE_IO_FOR_LOG"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t *\n\t * When the @severity is EEH_LOG_PERM, the PE is going to be\n\t * removed. Prior to that, the drivers for devices included in\n\t * the PE will be closed. The drivers rely on working IO path\n\t * to bring the devices to quiet state. Otherwise, PCI traffic\n\t * from those devices after they are removed is like to cause\n\t * another unexpected EEH error.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||\n\t\t    severity == EEH_LOG_PERM)\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}"
  },
  {
    "function_name": "eeh_dump_pe_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "269-279",
    "snippet": "static void *eeh_dump_pe_log(struct eeh_pe *pe, void *flag)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tsize_t *plen = flag;\n\n\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t*plen += eeh_dump_dev_log(edev, pci_regs_buf + *plen,\n\t\t\t\t\t  EEH_PCI_REGS_LOG_LEN - *plen);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define EEH_PCI_REGS_LOG_LEN 8192"
    ],
    "globals_used": [
      "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dump_dev_log",
          "args": [
            "edev",
            "pci_regs_buf + *plen",
            "EEH_PCI_REGS_LOG_LEN - *plen"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dump_dev_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "168-267",
          "snippet": "static size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x.%01x\\n\",\n\t\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x.%01x\\n\",\n\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\n\teeh_ops->read_config(edev, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(edev, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(edev, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x.%01x\\n\",\n\t\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x.%01x\\n\",\n\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\n\teeh_ops->read_config(edev, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(edev, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(edev, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define EEH_PCI_REGS_LOG_LEN 8192\n\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nstatic void *eeh_dump_pe_log(struct eeh_pe *pe, void *flag)\n{\n\tstruct eeh_dev *edev, *tmp;\n\tsize_t *plen = flag;\n\n\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t*plen += eeh_dump_dev_log(edev, pci_regs_buf + *plen,\n\t\t\t\t\t  EEH_PCI_REGS_LOG_LEN - *plen);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_dump_dev_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "168-267",
    "snippet": "static size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x.%01x\\n\",\n\t\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x.%01x\\n\",\n\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\n\teeh_ops->read_config(edev, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(edev, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(edev, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct eeh_ops *eeh_ops = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer+l",
            "sizeof(buffer)-l",
            "\"%08x \"",
            "cfg"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"EEH: PCI-E AER %02x: %08x \"",
            "4*i",
            "cfg"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%02x:%x\\n\"",
            "4*i",
            "cfg"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap+4*i",
            "4",
            "&cfg"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-E AER capability register set follows:\\n\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pci-e AER:\\n\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer+l",
            "sizeof(buffer)-l",
            "\"%08x \"",
            "cfg"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"EEH: PCI-E %02x: %08x \"",
            "4*i",
            "cfg"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s\\n\"",
            "buffer"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%02x:%x\\n\"",
            "4*i",
            "cfg"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap+4*i",
            "4",
            "&cfg"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-E capabilities and status follow:\\n\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pci-e cap10:\\n\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-X status: %08x\\n\"",
            "cfg"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pcix-stat:%x\\n\"",
            "cfg"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap+4",
            "4",
            "&cfg"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI-X cmd: %08x\\n\"",
            "cfg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"pcix-cmd:%x\\n\"",
            "cfg"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "cap",
            "4",
            "&cfg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Bridge control: %04x\\n\"",
            "cfg"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"brdg ctl:%x\\n\"",
            "cfg"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "PCI_BRIDGE_CONTROL",
            "2",
            "&cfg"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Bridge secondary status: %04x\\n\"",
            "cfg"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"sec stat:%x\\n\"",
            "cfg"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "PCI_SEC_STATUS",
            "2",
            "&cfg"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI cmd/status register: %08x\\n\"",
            "cfg"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"cmd/stat:%x\\n\"",
            "cfg"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "PCI_COMMAND",
            "4",
            "&cfg"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: PCI device/vendor: %08x\\n\"",
            "cfg"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"dev/vend:%08x\\n\"",
            "cfg"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "edev",
            "PCI_VENDOR_ID",
            "4",
            "&cfg"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: of node=%04x:%02x:%02x.%01x\\n\"",
            "edev->pe->phb->global_number",
            "edev->bdfn >> 8",
            "PCI_SLOT(edev->bdfn)",
            "PCI_FUNC(edev->bdfn)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->bdfn"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->bdfn"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf+n",
            "len-n",
            "\"%04x:%02x:%02x.%01x\\n\"",
            "edev->pe->phb->global_number",
            "edev->bdfn >> 8",
            "PCI_SLOT(edev->bdfn)",
            "PCI_FUNC(edev->bdfn)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->bdfn"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->bdfn"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\n\nstatic size_t eeh_dump_dev_log(struct eeh_dev *edev, char *buf, size_t len)\n{\n\tu32 cfg;\n\tint cap, i;\n\tint n = 0, l = 0;\n\tchar buffer[128];\n\n\tn += scnprintf(buf+n, len-n, \"%04x:%02x:%02x.%01x\\n\",\n\t\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\tpr_warn(\"EEH: of node=%04x:%02x:%02x.%01x\\n\",\n\t\tedev->pe->phb->global_number, edev->bdfn >> 8,\n\t\tPCI_SLOT(edev->bdfn), PCI_FUNC(edev->bdfn));\n\n\teeh_ops->read_config(edev, PCI_VENDOR_ID, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"dev/vend:%08x\\n\", cfg);\n\tpr_warn(\"EEH: PCI device/vendor: %08x\\n\", cfg);\n\n\teeh_ops->read_config(edev, PCI_COMMAND, 4, &cfg);\n\tn += scnprintf(buf+n, len-n, \"cmd/stat:%x\\n\", cfg);\n\tpr_warn(\"EEH: PCI cmd/status register: %08x\\n\", cfg);\n\n\t/* Gather bridge-specific registers */\n\tif (edev->mode & EEH_DEV_BRIDGE) {\n\t\teeh_ops->read_config(edev, PCI_SEC_STATUS, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"sec stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge secondary status: %04x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, PCI_BRIDGE_CONTROL, 2, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"brdg ctl:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: Bridge control: %04x\\n\", cfg);\n\t}\n\n\t/* Dump out the PCI-X command and status regs */\n\tcap = edev->pcix_cap;\n\tif (cap) {\n\t\teeh_ops->read_config(edev, cap, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-cmd:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X cmd: %08x\\n\", cfg);\n\n\t\teeh_ops->read_config(edev, cap+4, 4, &cfg);\n\t\tn += scnprintf(buf+n, len-n, \"pcix-stat:%x\\n\", cfg);\n\t\tpr_warn(\"EEH: PCI-X status: %08x\\n\", cfg);\n\t}\n\n\t/* If PCI-E capable, dump PCI-E cap 10 */\n\tcap = edev->pcie_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e cap10:\\n\");\n\t\tpr_warn(\"EEH: PCI-E capabilities and status follow:\\n\");\n\n\t\tfor (i=0; i<=8; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\t/* If AER capable, dump it */\n\tcap = edev->aer_cap;\n\tif (cap) {\n\t\tn += scnprintf(buf+n, len-n, \"pci-e AER:\\n\");\n\t\tpr_warn(\"EEH: PCI-E AER capability register set follows:\\n\");\n\n\t\tfor (i=0; i<=13; i++) {\n\t\t\teeh_ops->read_config(edev, cap+4*i, 4, &cfg);\n\t\t\tn += scnprintf(buf+n, len-n, \"%02x:%x\\n\", 4*i, cfg);\n\n\t\t\tif ((i % 4) == 0) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_warn(\"%s\\n\", buffer);\n\n\t\t\t\tl = scnprintf(buffer, sizeof(buffer),\n\t\t\t\t\t      \"EEH: PCI-E AER %02x: %08x \",\n\t\t\t\t\t      4*i, cfg);\n\t\t\t} else {\n\t\t\t\tl += scnprintf(buffer+l, sizeof(buffer)-l,\n\t\t\t\t\t       \"%08x \", cfg);\n\t\t\t}\n\t\t}\n\n\t\tpr_warn(\"%s\\n\", buffer);\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "eeh_show_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "153-161",
    "snippet": "void eeh_show_enabled(void)\n{\n\tif (eeh_has_flag(EEH_FORCE_DISABLED))\n\t\tpr_info(\"EEH: Recovery disabled by kernel parameter.\\n\");\n\telse if (eeh_has_flag(EEH_ENABLED))\n\t\tpr_info(\"EEH: Capable adapter found: recovery enabled.\\n\");\n\telse\n\t\tpr_info(\"EEH: No capable adapters found: recovery disabled.\\n\");\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: No capable adapters found: recovery disabled.\\n\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Capable adapter found: recovery enabled.\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_ENABLED"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Recovery disabled by kernel parameter.\\n\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nvoid eeh_show_enabled(void)\n{\n\tif (eeh_has_flag(EEH_FORCE_DISABLED))\n\t\tpr_info(\"EEH: Recovery disabled by kernel parameter.\\n\");\n\telse if (eeh_has_flag(EEH_ENABLED))\n\t\tpr_info(\"EEH: Capable adapter found: recovery enabled.\\n\");\n\telse\n\t\tpr_info(\"EEH: No capable adapters found: recovery disabled.\\n\");\n}"
  },
  {
    "function_name": "eeh_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
    "lines": "142-150",
    "snippet": "static int __init eeh_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\telse if (!strcmp(str, \"early_log\"))\n\t\teeh_add_flag(EEH_EARLY_DUMP_LOG);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/pte-walk.h>",
      "#include <asm/rtas.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/iommu.h>",
      "#include <asm/io.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_EARLY_DUMP_LOG"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"early_log\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_add_flag",
          "args": [
            "EEH_FORCE_DISABLED"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstatic int __init eeh_setup(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\teeh_add_flag(EEH_FORCE_DISABLED);\n\telse if (!strcmp(str, \"early_log\"))\n\t\teeh_add_flag(EEH_EARLY_DUMP_LOG);\n\n\treturn 1;\n}"
  }
]