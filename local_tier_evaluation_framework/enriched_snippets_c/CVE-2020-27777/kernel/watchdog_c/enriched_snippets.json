[
  {
    "function_name": "watchdog_nmi_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "418-431",
    "snippet": "int __init watchdog_nmi_probe(void)\n{\n\tint err;\n\n\terr = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"powerpc/watchdog:online\",\n\t\t\t\t\tstart_watchdog_on_cpu,\n\t\t\t\t\tstop_watchdog_on_cpu);\n\tif (err < 0) {\n\t\tpr_warn(\"could not be initialized\");\n\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"could not be initialized\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"powerpc/watchdog:online\"",
            "start_watchdog_on_cpu",
            "stop_watchdog_on_cpu"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nint __init watchdog_nmi_probe(void)\n{\n\tint err;\n\n\terr = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\"powerpc/watchdog:online\",\n\t\t\t\t\tstart_watchdog_on_cpu,\n\t\t\t\t\tstop_watchdog_on_cpu);\n\tif (err < 0) {\n\t\tpr_warn(\"could not be initialized\");\n\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog_nmi_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "406-413",
    "snippet": "void watchdog_nmi_start(void)\n{\n\tint cpu;\n\n\twatchdog_calc_timeouts();\n\tfor_each_cpu_and(cpu, cpu_online_mask, &watchdog_cpumask)\n\t\tstart_watchdog_on_cpu(cpu);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_watchdog_on_cpu",
          "args": [
            "cpu"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "start_watchdog_on_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "359-362",
          "snippet": "static int start_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, start_watchdog, NULL, true);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic int start_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, start_watchdog, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "cpu",
            "cpu_online_mask",
            "&watchdog_cpumask"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog_calc_timeouts",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_calc_timeouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "387-396",
          "snippet": "static void watchdog_calc_timeouts(void)\n{\n\twd_panic_timeout_tb = watchdog_thresh * ppc_tb_freq;\n\n\t/* Have the SMP detector trigger a bit later */\n\twd_smp_panic_timeout_tb = wd_panic_timeout_tb * 3 / 2;\n\n\t/* 2/5 is the factor that the perf based detector uses */\n\twd_timer_period_ms = watchdog_thresh * 1000 * 2 / 5;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_panic_timeout_tb",
            "static u64 wd_smp_panic_timeout_tb",
            "static u64 wd_timer_period_ms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_panic_timeout_tb;\nstatic u64 wd_smp_panic_timeout_tb;\nstatic u64 wd_timer_period_ms;\n\nstatic void watchdog_calc_timeouts(void)\n{\n\twd_panic_timeout_tb = watchdog_thresh * ppc_tb_freq;\n\n\t/* Have the SMP detector trigger a bit later */\n\twd_smp_panic_timeout_tb = wd_panic_timeout_tb * 3 / 2;\n\n\t/* 2/5 is the factor that the perf based detector uses */\n\twd_timer_period_ms = watchdog_thresh * 1000 * 2 / 5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nvoid watchdog_nmi_start(void)\n{\n\tint cpu;\n\n\twatchdog_calc_timeouts();\n\tfor_each_cpu_and(cpu, cpu_online_mask, &watchdog_cpumask)\n\t\tstart_watchdog_on_cpu(cpu);\n}"
  },
  {
    "function_name": "watchdog_nmi_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "398-404",
    "snippet": "void watchdog_nmi_stop(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &wd_cpus_enabled)\n\t\tstop_watchdog_on_cpu(cpu);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop_watchdog_on_cpu",
          "args": [
            "cpu"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "stop_watchdog_on_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "382-385",
          "snippet": "static int stop_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, stop_watchdog, NULL, true);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic int stop_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, stop_watchdog, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\n\nvoid watchdog_nmi_stop(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &wd_cpus_enabled)\n\t\tstop_watchdog_on_cpu(cpu);\n}"
  },
  {
    "function_name": "watchdog_calc_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "387-396",
    "snippet": "static void watchdog_calc_timeouts(void)\n{\n\twd_panic_timeout_tb = watchdog_thresh * ppc_tb_freq;\n\n\t/* Have the SMP detector trigger a bit later */\n\twd_smp_panic_timeout_tb = wd_panic_timeout_tb * 3 / 2;\n\n\t/* 2/5 is the factor that the perf based detector uses */\n\twd_timer_period_ms = watchdog_thresh * 1000 * 2 / 5;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 wd_panic_timeout_tb",
      "static u64 wd_smp_panic_timeout_tb",
      "static u64 wd_timer_period_ms"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_panic_timeout_tb;\nstatic u64 wd_smp_panic_timeout_tb;\nstatic u64 wd_timer_period_ms;\n\nstatic void watchdog_calc_timeouts(void)\n{\n\twd_panic_timeout_tb = watchdog_thresh * ppc_tb_freq;\n\n\t/* Have the SMP detector trigger a bit later */\n\twd_smp_panic_timeout_tb = wd_panic_timeout_tb * 3 / 2;\n\n\t/* 2/5 is the factor that the perf based detector uses */\n\twd_timer_period_ms = watchdog_thresh * 1000 * 2 / 5;\n}"
  },
  {
    "function_name": "stop_watchdog_on_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "382-385",
    "snippet": "static int stop_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, stop_watchdog, NULL, true);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "stop_watchdog",
            "NULL",
            "true"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic int stop_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, stop_watchdog, NULL, true);\n}"
  },
  {
    "function_name": "stop_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "364-380",
    "snippet": "static void stop_watchdog(void *arg)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&wd_hrtimer);\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\n\tif (!cpumask_test_cpu(cpu, &wd_cpus_enabled))\n\t\treturn; /* Can happen in CPU unplug case */\n\n\thrtimer_cancel(hrtimer);\n\n\twd_smp_lock(&flags);\n\tcpumask_clear_cpu(cpu, &wd_cpus_enabled);\n\twd_smp_unlock(&flags);\n\n\twd_smp_clear_cpu_pending(cpu, get_tb());\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled",
      "static DEFINE_PER_CPU(struct hrtimer, wd_hrtimer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wd_smp_clear_cpu_pending",
          "args": [
            "cpu",
            "get_tb()"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_clear_cpu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "201-236",
          "snippet": "static void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_t wd_cpus_enabled",
            "static cpumask_t wd_smp_cpus_pending;",
            "static cpumask_t wd_smp_cpus_stuck;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_unlock",
          "args": [
            "&flags"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "106-110",
          "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_lock",
          "args": [
            "&flags"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "89-104",
          "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "hrtimer"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&wd_hrtimer"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic DEFINE_PER_CPU(struct hrtimer, wd_hrtimer);\n\nstatic void stop_watchdog(void *arg)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&wd_hrtimer);\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\n\tif (!cpumask_test_cpu(cpu, &wd_cpus_enabled))\n\t\treturn; /* Can happen in CPU unplug case */\n\n\thrtimer_cancel(hrtimer);\n\n\twd_smp_lock(&flags);\n\tcpumask_clear_cpu(cpu, &wd_cpus_enabled);\n\twd_smp_unlock(&flags);\n\n\twd_smp_clear_cpu_pending(cpu, get_tb());\n}"
  },
  {
    "function_name": "start_watchdog_on_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "359-362",
    "snippet": "static int start_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, start_watchdog, NULL, true);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "start_watchdog",
            "NULL",
            "true"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic int start_watchdog_on_cpu(unsigned int cpu)\n{\n\treturn smp_call_function_single(cpu, start_watchdog, NULL, true);\n}"
  },
  {
    "function_name": "start_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "326-357",
    "snippet": "static void start_watchdog(void *arg)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&wd_hrtimer);\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\n\tif (cpumask_test_cpu(cpu, &wd_cpus_enabled)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))\n\t\treturn;\n\n\tif (!cpumask_test_cpu(cpu, &watchdog_cpumask))\n\t\treturn;\n\n\twd_smp_lock(&flags);\n\tcpumask_set_cpu(cpu, &wd_cpus_enabled);\n\tif (cpumask_weight(&wd_cpus_enabled) == 1) {\n\t\tcpumask_set_cpu(cpu, &wd_smp_cpus_pending);\n\t\twd_smp_last_reset_tb = get_tb();\n\t}\n\twd_smp_unlock(&flags);\n\n\t*this_cpu_ptr(&wd_timer_tb) = get_tb();\n\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ms_to_ktime(wd_timer_period_ms),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled",
      "static u64 wd_timer_period_ms",
      "static DEFINE_PER_CPU(struct hrtimer, wd_hrtimer);",
      "static DEFINE_PER_CPU(u64, wd_timer_tb);",
      "static cpumask_t wd_smp_cpus_pending;",
      "static u64 wd_smp_last_reset_tb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "hrtimer",
            "ms_to_ktime(wd_timer_period_ms)",
            "HRTIMER_MODE_REL_PINNED"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms_to_ktime",
          "args": [
            "wd_timer_period_ms"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "hrtimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&wd_timer_tb"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_unlock",
          "args": [
            "&flags"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "106-110",
          "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_pending"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "&wd_cpus_enabled"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_lock",
          "args": [
            "&flags"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "89-104",
          "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&watchdog_cpumask"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&wd_hrtimer"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic u64 wd_timer_period_ms;\nstatic DEFINE_PER_CPU(struct hrtimer, wd_hrtimer);\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void start_watchdog(void *arg)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&wd_hrtimer);\n\tint cpu = smp_processor_id();\n\tunsigned long flags;\n\n\tif (cpumask_test_cpu(cpu, &wd_cpus_enabled)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))\n\t\treturn;\n\n\tif (!cpumask_test_cpu(cpu, &watchdog_cpumask))\n\t\treturn;\n\n\twd_smp_lock(&flags);\n\tcpumask_set_cpu(cpu, &wd_cpus_enabled);\n\tif (cpumask_weight(&wd_cpus_enabled) == 1) {\n\t\tcpumask_set_cpu(cpu, &wd_smp_cpus_pending);\n\t\twd_smp_last_reset_tb = get_tb();\n\t}\n\twd_smp_unlock(&flags);\n\n\t*this_cpu_ptr(&wd_timer_tb) = get_tb();\n\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ms_to_ktime(wd_timer_period_ms),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}"
  },
  {
    "function_name": "arch_touch_nmi_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "313-323",
    "snippet": "void arch_touch_nmi_watchdog(void)\n{\n\tunsigned long ticks = tb_ticks_per_usec * wd_timer_period_ms * 1000;\n\tint cpu = smp_processor_id();\n\tu64 tb = get_tb();\n\n\tif (tb - per_cpu(wd_timer_tb, cpu) >= ticks) {\n\t\tper_cpu(wd_timer_tb, cpu) = tb;\n\t\twd_smp_clear_cpu_pending(cpu, tb);\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 wd_timer_period_ms",
      "static DEFINE_PER_CPU(u64, wd_timer_tb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wd_smp_clear_cpu_pending",
          "args": [
            "cpu",
            "tb"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_clear_cpu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "201-236",
          "snippet": "static void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_t wd_cpus_enabled",
            "static cpumask_t wd_smp_cpus_pending;",
            "static cpumask_t wd_smp_cpus_stuck;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_timer_period_ms;\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\n\nvoid arch_touch_nmi_watchdog(void)\n{\n\tunsigned long ticks = tb_ticks_per_usec * wd_timer_period_ms * 1000;\n\tint cpu = smp_processor_id();\n\tu64 tb = get_tb();\n\n\tif (tb - per_cpu(wd_timer_tb, cpu) >= ticks) {\n\t\tper_cpu(wd_timer_tb, cpu) = tb;\n\t\twd_smp_clear_cpu_pending(cpu, tb);\n\t}\n}"
  },
  {
    "function_name": "watchdog_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "296-311",
    "snippet": "static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))\n\t\treturn HRTIMER_NORESTART;\n\n\tif (!cpumask_test_cpu(cpu, &watchdog_cpumask))\n\t\treturn HRTIMER_NORESTART;\n\n\twatchdog_timer_interrupt(cpu);\n\n\thrtimer_forward_now(hrtimer, ms_to_ktime(wd_timer_period_ms));\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 wd_timer_period_ms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "hrtimer",
            "ms_to_ktime(wd_timer_period_ms)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms_to_ktime",
          "args": [
            "wd_timer_period_ms"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog_timer_interrupt",
          "args": [
            "cpu"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_timer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "238-248",
          "snippet": "static void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static DEFINE_PER_CPU(u64, wd_timer_tb);",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&watchdog_cpumask"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_timer_period_ms;\n\nstatic enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tint cpu = smp_processor_id();\n\n\tif (!(watchdog_enabled & NMI_WATCHDOG_ENABLED))\n\t\treturn HRTIMER_NORESTART;\n\n\tif (!cpumask_test_cpu(cpu, &watchdog_cpumask))\n\t\treturn HRTIMER_NORESTART;\n\n\twatchdog_timer_interrupt(cpu);\n\n\thrtimer_forward_now(hrtimer, ms_to_ktime(wd_timer_period_ms));\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "soft_nmi_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "250-294",
    "snippet": "void soft_nmi_interrupt(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\tu64 tb;\n\n\tif (!cpumask_test_cpu(cpu, &wd_cpus_enabled))\n\t\treturn;\n\n\tnmi_enter();\n\n\t__this_cpu_inc(irq_stat.soft_nmi_irqs);\n\n\ttb = get_tb();\n\tif (tb - per_cpu(wd_timer_tb, cpu) >= wd_panic_timeout_tb) {\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_stuck)) {\n\t\t\twd_smp_unlock(&flags);\n\t\t\tgoto out;\n\t\t}\n\t\tset_cpu_stuck(cpu, tb);\n\n\t\tpr_emerg(\"CPU %d self-detected hard LOCKUP @ %pS\\n\",\n\t\t\t cpu, (void *)regs->nip);\n\t\tpr_emerg(\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t\t cpu, tb, per_cpu(wd_timer_tb, cpu),\n\t\t\t tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000);\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tshow_regs(regs);\n\n\t\twd_smp_unlock(&flags);\n\n\t\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\n\t\tif (hardlockup_panic)\n\t\t\tnmi_panic(regs, \"Hard LOCKUP\");\n\t}\n\tif (wd_panic_timeout_tb < 0x7fffffff)\n\t\tmtspr(SPRN_DEC, wd_panic_timeout_tb);\n\nout:\n\tnmi_exit();\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled",
      "static u64 wd_panic_timeout_tb",
      "static DEFINE_PER_CPU(u64, wd_timer_tb);",
      "static cpumask_t wd_smp_cpus_stuck;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nmi_exit",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DEC",
            "wd_panic_timeout_tb"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_panic",
          "args": [
            "regs",
            "\"Hard LOCKUP\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_allbutself_cpu_backtrace",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_unlock",
          "args": [
            "&flags"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "106-110",
          "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1469-1519",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\"",
            "cpu",
            "tb",
            "per_cpu(wd_timer_tb, cpu)",
            "tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tb_to_ns",
          "args": [
            "tb - per_cpu(wd_timer_tb, cpu)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "tb_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "684-687",
          "snippet": "unsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 tb_to_ns_scale"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nstatic u64 tb_to_ns_scale;\n\nunsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d self-detected hard LOCKUP @ %pS\\n\"",
            "cpu",
            "(void *)regs->nip"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_stuck",
          "args": [
            "cpu",
            "tb"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_stuck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "142-145",
          "snippet": "static void set_cpu_stuck(int cpu, u64 tb)\n{\n\tset_cpumask_stuck(cpumask_of(cpu), tb);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic void set_cpu_stuck(int cpu, u64 tb)\n{\n\tset_cpumask_stuck(cpumask_of(cpu), tb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_stuck"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_lock",
          "args": [
            "&flags"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "89-104",
          "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.soft_nmi_irqs"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_enter",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_cpus_enabled"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic u64 wd_panic_timeout_tb;\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\nstatic cpumask_t wd_smp_cpus_stuck;\n\nvoid soft_nmi_interrupt(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tint cpu = raw_smp_processor_id();\n\tu64 tb;\n\n\tif (!cpumask_test_cpu(cpu, &wd_cpus_enabled))\n\t\treturn;\n\n\tnmi_enter();\n\n\t__this_cpu_inc(irq_stat.soft_nmi_irqs);\n\n\ttb = get_tb();\n\tif (tb - per_cpu(wd_timer_tb, cpu) >= wd_panic_timeout_tb) {\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_stuck)) {\n\t\t\twd_smp_unlock(&flags);\n\t\t\tgoto out;\n\t\t}\n\t\tset_cpu_stuck(cpu, tb);\n\n\t\tpr_emerg(\"CPU %d self-detected hard LOCKUP @ %pS\\n\",\n\t\t\t cpu, (void *)regs->nip);\n\t\tpr_emerg(\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t\t cpu, tb, per_cpu(wd_timer_tb, cpu),\n\t\t\t tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000);\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tshow_regs(regs);\n\n\t\twd_smp_unlock(&flags);\n\n\t\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\n\t\tif (hardlockup_panic)\n\t\t\tnmi_panic(regs, \"Hard LOCKUP\");\n\t}\n\tif (wd_panic_timeout_tb < 0x7fffffff)\n\t\tmtspr(SPRN_DEC, wd_panic_timeout_tb);\n\nout:\n\tnmi_exit();\n}"
  },
  {
    "function_name": "watchdog_timer_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "238-248",
    "snippet": "static void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 wd_smp_panic_timeout_tb",
      "static DEFINE_PER_CPU(u64, wd_timer_tb);",
      "static u64 wd_smp_last_reset_tb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_smp_panic",
          "args": [
            "cpu",
            "tb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_smp_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "147-199",
          "snippet": "static void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static cpumask_t wd_smp_cpus_pending;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tb - wd_smp_last_reset_tb"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_clear_cpu_pending",
          "args": [
            "cpu",
            "tb"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_clear_cpu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "201-236",
          "snippet": "static void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_t wd_cpus_enabled",
            "static cpumask_t wd_smp_cpus_pending;",
            "static cpumask_t wd_smp_cpus_stuck;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}"
  },
  {
    "function_name": "wd_smp_clear_cpu_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "201-236",
    "snippet": "static void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled",
      "static cpumask_t wd_smp_cpus_pending;",
      "static cpumask_t wd_smp_cpus_stuck;",
      "static u64 wd_smp_last_reset_tb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wd_smp_unlock",
          "args": [
            "&flags"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "106-110",
          "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "&wd_smp_cpus_pending",
            "&wd_cpus_enabled",
            "&wd_smp_cpus_stuck"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&wd_smp_cpus_pending"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_lock",
          "args": [
            "&flags"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "89-104",
          "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&wd_smp_cpus_pending"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_pending"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_stuck"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1469-1519",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d became unstuck TB:%lld\\n\"",
            "cpu",
            "tb"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpumask_test_cpu(cpu, &wd_smp_cpus_stuck)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_stuck"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_pending"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void wd_smp_clear_cpu_pending(int cpu, u64 tb)\n{\n\tif (!cpumask_test_cpu(cpu, &wd_smp_cpus_pending)) {\n\t\tif (unlikely(cpumask_test_cpu(cpu, &wd_smp_cpus_stuck))) {\n\t\t\tstruct pt_regs *regs = get_irq_regs();\n\t\t\tunsigned long flags;\n\n\t\t\twd_smp_lock(&flags);\n\n\t\t\tpr_emerg(\"CPU %d became unstuck TB:%lld\\n\",\n\t\t\t\t cpu, tb);\n\t\t\tprint_irqtrace_events(current);\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\n\t\t\tcpumask_clear_cpu(cpu, &wd_smp_cpus_stuck);\n\t\t\twd_smp_unlock(&flags);\n\t\t}\n\t\treturn;\n\t}\n\tcpumask_clear_cpu(cpu, &wd_smp_cpus_pending);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\tunsigned long flags;\n\n\t\twd_smp_lock(&flags);\n\t\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\t\twd_smp_last_reset_tb = tb;\n\t\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t\t&wd_smp_cpus_stuck);\n\t\t}\n\t\twd_smp_unlock(&flags);\n\t}\n}"
  },
  {
    "function_name": "watchdog_smp_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "147-199",
    "snippet": "static void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 wd_smp_panic_timeout_tb",
      "static cpumask_t wd_smp_cpus_pending;",
      "static u64 wd_smp_last_reset_tb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wd_smp_unlock",
          "args": [
            "&flags"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "106-110",
          "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nmi_panic",
          "args": [
            "NULL",
            "\"Hard LOCKUP\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_allbutself_cpu_backtrace",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_safe_flush",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpumask_stuck",
          "args": [
            "&wd_smp_cpus_pending",
            "tb"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpumask_stuck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "131-141",
          "snippet": "static void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_t wd_cpus_enabled",
            "static cpumask_t wd_smp_cpus_pending;",
            "static cpumask_t wd_smp_cpus_stuck;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_send_nmi_ipi",
          "args": [
            "c",
            "wd_lockup_ipi",
            "1000000"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "smp_send_nmi_ipi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp.c",
          "lines": "539-542",
          "snippet": "int smp_send_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us)\n{\n\treturn __smp_send_nmi_ipi(cpu, fn, delay_us, false);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kup.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/dbell.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/stackprotector.h>",
            "#include <linux/random.h>",
            "#include <linux/processor.h>",
            "#include <linux/profile.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kup.h>\n#include <asm/ftrace.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/asm-prototypes.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/dbell.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/pgtable.h>\n#include <linux/stackprotector.h>\n#include <linux/random.h>\n#include <linux/processor.h>\n#include <linux/profile.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint smp_send_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us)\n{\n\treturn __smp_send_nmi_ipi(cpu, fn, delay_us, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "c",
            "&wd_smp_cpus_pending"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\"",
            "cpu",
            "tb",
            "wd_smp_last_reset_tb",
            "tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tb_to_ns",
          "args": [
            "tb - wd_smp_last_reset_tb"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "tb_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "684-687",
          "snippet": "unsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 tb_to_ns_scale"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nstatic u64 tb_to_ns_scale;\n\nunsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\"",
            "cpu",
            "cpumask_pr_args(&wd_smp_cpus_pending)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&wd_smp_cpus_pending"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "&wd_smp_cpus_pending"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&wd_smp_cpus_pending"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tb - wd_smp_last_reset_tb"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wd_smp_lock",
          "args": [
            "&flags"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "wd_smp_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "89-104",
          "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long __wd_smp_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}"
  },
  {
    "function_name": "set_cpu_stuck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "142-145",
    "snippet": "static void set_cpu_stuck(int cpu, u64 tb)\n{\n\tset_cpumask_stuck(cpumask_of(cpu), tb);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpumask_stuck",
          "args": [
            "cpumask_of(cpu)",
            "tb"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpumask_stuck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "131-141",
          "snippet": "static void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_t wd_cpus_enabled",
            "static cpumask_t wd_smp_cpus_pending;",
            "static cpumask_t wd_smp_cpus_stuck;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic void set_cpu_stuck(int cpu, u64 tb)\n{\n\tset_cpumask_stuck(cpumask_of(cpu), tb);\n}"
  },
  {
    "function_name": "set_cpumask_stuck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "131-141",
    "snippet": "static void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_t wd_cpus_enabled",
      "static cpumask_t wd_smp_cpus_pending;",
      "static cpumask_t wd_smp_cpus_stuck;",
      "static u64 wd_smp_last_reset_tb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "&wd_smp_cpus_pending",
            "&wd_cpus_enabled",
            "&wd_smp_cpus_stuck"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&wd_smp_cpus_pending"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "&wd_smp_cpus_pending",
            "&wd_smp_cpus_pending",
            "cpumask"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "&wd_smp_cpus_stuck",
            "&wd_smp_cpus_stuck",
            "cpumask"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic cpumask_t wd_cpus_enabled;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic cpumask_t wd_smp_cpus_stuck;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void set_cpumask_stuck(const struct cpumask *cpumask, u64 tb)\n{\n\tcpumask_or(&wd_smp_cpus_stuck, &wd_smp_cpus_stuck, cpumask);\n\tcpumask_andnot(&wd_smp_cpus_pending, &wd_smp_cpus_pending, cpumask);\n\tif (cpumask_empty(&wd_smp_cpus_pending)) {\n\t\twd_smp_last_reset_tb = tb;\n\t\tcpumask_andnot(&wd_smp_cpus_pending,\n\t\t\t\t&wd_cpus_enabled,\n\t\t\t\t&wd_smp_cpus_stuck);\n\t}\n}"
  },
  {
    "function_name": "wd_lockup_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "112-129",
    "snippet": "static void wd_lockup_ipi(struct pt_regs *regs)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 tb = get_tb();\n\n\tpr_emerg(\"CPU %d Hard LOCKUP\\n\", cpu);\n\tpr_emerg(\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, per_cpu(wd_timer_tb, cpu),\n\t\t tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000);\n\tprint_modules();\n\tprint_irqtrace_events(current);\n\tif (regs)\n\t\tshow_regs(regs);\n\telse\n\t\tdump_stack();\n\n\t/* Do not panic from here because that can recurse into NMI IPI layer */\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(u64, wd_timer_tb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "show_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1469-1519",
          "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define LAST_VOLATILE\t12",
            "#define REGS_PER_LINE\t8",
            "#define REG\t\t\"%08lx\"",
            "#define LAST_VOLATILE\t13",
            "#define REGS_PER_LINE\t4",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP:  \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %px TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR:  \"REG\" \", regs->msr);\n\tprint_msr_bits(regs->msr);\n\tpr_cont(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif (!trap_is_syscall(regs) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tpr_cont(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600) {\n\t\tif (IS_ENABLED(CONFIG_4xx) || IS_ENABLED(CONFIG_BOOKE))\n\t\t\tpr_cont(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n\t\telse\n\t\t\tpr_cont(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n\t}\n\n#ifdef CONFIG_PPC64\n\tpr_cont(\"IRQMASK: %lx \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tpr_cont(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tpr_cont(\"\\nGPR%02d: \", i);\n\t\tpr_cont(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tpr_cont(\"\\n\");\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tif (IS_ENABLED(CONFIG_KALLSYMS)) {\n\t\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\t\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n\t}\n\tshow_stack(current, (unsigned long *) regs->gpr[1], KERN_DEFAULT);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\"",
            "cpu",
            "tb",
            "per_cpu(wd_timer_tb, cpu)",
            "tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tb_to_ns",
          "args": [
            "tb - per_cpu(wd_timer_tb, cpu)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "tb_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "684-687",
          "snippet": "unsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 tb_to_ns_scale"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nstatic u64 tb_to_ns_scale;\n\nunsigned long long tb_to_ns(unsigned long long ticks)\n{\n\treturn mulhdu(ticks, tb_to_ns_scale) << tb_to_ns_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wd_timer_tb",
            "cpu"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"CPU %d Hard LOCKUP\\n\"",
            "cpu"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\n\nstatic void wd_lockup_ipi(struct pt_regs *regs)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 tb = get_tb();\n\n\tpr_emerg(\"CPU %d Hard LOCKUP\\n\", cpu);\n\tpr_emerg(\"CPU %d TB:%lld, last heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, per_cpu(wd_timer_tb, cpu),\n\t\t tb_to_ns(tb - per_cpu(wd_timer_tb, cpu)) / 1000000);\n\tprint_modules();\n\tprint_irqtrace_events(current);\n\tif (regs)\n\t\tshow_regs(regs);\n\telse\n\t\tdump_stack();\n\n\t/* Do not panic from here because that can recurse into NMI IPI layer */\n}"
  },
  {
    "function_name": "wd_smp_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "106-110",
    "snippet": "static inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long __wd_smp_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "*flags"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&__wd_smp_lock"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_unlock(unsigned long *flags)\n{\n\tclear_bit_unlock(0, &__wd_smp_lock);\n\traw_local_irq_restore(*flags);\n}"
  },
  {
    "function_name": "wd_smp_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
    "lines": "89-104",
    "snippet": "static inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <linux/smp.h>",
      "#include <linux/delay.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/slab.h>",
      "#include <linux/reboot.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/module.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/init.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long __wd_smp_lock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "*flags"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_until_cond",
          "args": [
            "!test_bit(0, &__wd_smp_lock)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "0",
            "&__wd_smp_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_restore",
          "args": [
            "*flags"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_and_set_bit_lock(0, &__wd_smp_lock)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_lock",
          "args": [
            "0",
            "&__wd_smp_lock"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_local_irq_save",
          "args": [
            "*flags"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic unsigned long __wd_smp_lock;\n\nstatic inline void wd_smp_lock(unsigned long *flags)\n{\n\t/*\n\t * Avoid locking layers if possible.\n\t * This may be called from low level interrupt handlers at some\n\t * point in future.\n\t */\n\traw_local_irq_save(*flags);\n\thard_irq_disable(); /* Make it soft-NMI safe */\n\twhile (unlikely(test_and_set_bit_lock(0, &__wd_smp_lock))) {\n\t\traw_local_irq_restore(*flags);\n\t\tspin_until_cond(!test_bit(0, &__wd_smp_lock));\n\t\traw_local_irq_save(*flags);\n\t\thard_irq_disable();\n\t}\n}"
  }
]