[
  {
    "function_name": "rtas_flash_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "755-773",
    "snippet": "static void __exit rtas_flash_cleanup(void)\n{\n\tint i;\n\n\trtas_flash_term_hook = NULL;\n\n\tif (rtas_firmware_flash_list) {\n\t\tfree_flash_list(rtas_firmware_flash_list);\n\t\trtas_firmware_flash_list = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tremove_proc_entry(f->filename, NULL);\n\t}\n\n\tkmem_cache_destroy(flash_block_cache);\n\tkfree(rtas_validate_flash_data.buf);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flash_block_list *rtas_firmware_flash_list;",
      "static struct kmem_cache *flash_block_cache = NULL;",
      "static struct rtas_validate_flash_t rtas_validate_flash_data;",
      "static const struct rtas_flash_file rtas_flash_files[] = {\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_msg,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_UPDATE_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_num,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" VALIDATE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,validate-flash-image\",\n\t\t.status\t\t= &rtas_validate_flash_data.status,\n\t\t.ops.proc_read\t= validate_flash_read,\n\t\t.ops.proc_write\t= validate_flash_write,\n\t\t.ops.proc_release = validate_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" MANAGE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,manage-flash-image\",\n\t\t.status\t\t= &rtas_manage_flash_data.status,\n\t\t.ops.proc_read\t= manage_flash_read,\n\t\t.ops.proc_write\t= manage_flash_write,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rtas_validate_flash_data.buf"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "flash_block_cache"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "f->filename",
            "NULL"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rtas_flash_files"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_flash_list",
          "args": [
            "rtas_firmware_flash_list"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "free_flash_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "194-206",
          "snippet": "static void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flash_block_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *flash_block_cache = NULL;\n\nstatic void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct flash_block_list *rtas_firmware_flash_list;\nstatic struct kmem_cache *flash_block_cache = NULL;\nstatic struct rtas_validate_flash_t rtas_validate_flash_data;\nstatic const struct rtas_flash_file rtas_flash_files[] = {\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_msg,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_UPDATE_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_num,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" VALIDATE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,validate-flash-image\",\n\t\t.status\t\t= &rtas_validate_flash_data.status,\n\t\t.ops.proc_read\t= validate_flash_read,\n\t\t.ops.proc_write\t= validate_flash_write,\n\t\t.ops.proc_release = validate_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" MANAGE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,manage-flash-image\",\n\t\t.status\t\t= &rtas_manage_flash_data.status,\n\t\t.ops.proc_read\t= manage_flash_read,\n\t\t.ops.proc_write\t= manage_flash_write,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t}\n};\n\nstatic void __exit rtas_flash_cleanup(void)\n{\n\tint i;\n\n\trtas_flash_term_hook = NULL;\n\n\tif (rtas_firmware_flash_list) {\n\t\tfree_flash_list(rtas_firmware_flash_list);\n\t\trtas_firmware_flash_list = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tremove_proc_entry(f->filename, NULL);\n\t}\n\n\tkmem_cache_destroy(flash_block_cache);\n\tkfree(rtas_validate_flash_data.buf);\n}"
  },
  {
    "function_name": "rtas_flash_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "699-753",
    "snippet": "static int __init rtas_flash_init(void)\n{\n\tint i;\n\n\tif (rtas_token(\"ibm,update-flash-64-and-reboot\") ==\n\t\t       RTAS_UNKNOWN_SERVICE) {\n\t\tpr_info(\"rtas_flash: no firmware flash support\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtas_validate_flash_data.buf = kzalloc(VALIDATE_BUF_SIZE, GFP_KERNEL);\n\tif (!rtas_validate_flash_data.buf)\n\t\treturn -ENOMEM;\n\n\tflash_block_cache = kmem_cache_create(\"rtas_flash_cache\",\n\t\t\t\t\t      RTAS_BLK_SIZE, RTAS_BLK_SIZE, 0,\n\t\t\t\t\t      NULL);\n\tif (!flash_block_cache) {\n\t\tprintk(KERN_ERR \"%s: failed to create block cache\\n\",\n\t\t\t\t__func__);\n\t\tgoto enomem_buf;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tint token;\n\n\t\tif (!proc_create(f->filename, 0600, NULL, &f->ops))\n\t\t\tgoto enomem;\n\n\t\t/*\n\t\t * This code assumes that the status int is the first member of the\n\t\t * struct\n\t\t */\n\t\ttoken = rtas_token(f->rtas_call_name);\n\t\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\t\t*f->status = FLASH_AUTH;\n\t\telse\n\t\t\t*f->status = FLASH_NO_OP;\n\t}\n\n\trtas_flash_term_hook = rtas_flash_firmware;\n\treturn 0;\n\nenomem:\n\twhile (--i >= 0) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tremove_proc_entry(f->filename, NULL);\n\t}\n\n\tkmem_cache_destroy(flash_block_cache);\nenomem_buf:\n\tkfree(rtas_validate_flash_data.buf);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_BLK_SIZE 4096",
      "#define VALIDATE_BUF_SIZE 4096",
      "#define FLASH_NO_OP          -1099 /* No operation initiated by user */",
      "#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [
      "static struct kmem_cache *flash_block_cache = NULL;",
      "static struct rtas_validate_flash_t rtas_validate_flash_data;",
      "static const struct rtas_flash_file rtas_flash_files[] = {\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_msg,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_UPDATE_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_num,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" VALIDATE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,validate-flash-image\",\n\t\t.status\t\t= &rtas_validate_flash_data.status,\n\t\t.ops.proc_read\t= validate_flash_read,\n\t\t.ops.proc_write\t= validate_flash_write,\n\t\t.ops.proc_release = validate_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" MANAGE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,manage-flash-image\",\n\t\t.status\t\t= &rtas_manage_flash_data.status,\n\t\t.ops.proc_read\t= manage_flash_read,\n\t\t.ops.proc_write\t= manage_flash_write,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rtas_validate_flash_data.buf"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "flash_block_cache"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "f->filename",
            "NULL"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "f->rtas_call_name"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "f->filename",
            "0600",
            "NULL",
            "&f->ops"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "rtas_flash_files"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: failed to create block cache\\n\"",
            "__func__"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"rtas_flash_cache\"",
            "RTAS_BLK_SIZE",
            "RTAS_BLK_SIZE",
            "0",
            "NULL"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "VALIDATE_BUF_SIZE",
            "GFP_KERNEL"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"rtas_flash: no firmware flash support\\n\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_BLK_SIZE 4096\n#define VALIDATE_BUF_SIZE 4096\n#define FLASH_NO_OP          -1099 /* No operation initiated by user */\n#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */\n\nstatic struct kmem_cache *flash_block_cache = NULL;\nstatic struct rtas_validate_flash_t rtas_validate_flash_data;\nstatic const struct rtas_flash_file rtas_flash_files[] = {\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_msg,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" FIRMWARE_UPDATE_NAME,\n\t\t.rtas_call_name\t= \"ibm,update-flash-64-and-reboot\",\n\t\t.status\t\t= &rtas_update_flash_data.status,\n\t\t.ops.proc_read\t= rtas_flash_read_num,\n\t\t.ops.proc_write\t= rtas_flash_write,\n\t\t.ops.proc_release = rtas_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" VALIDATE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,validate-flash-image\",\n\t\t.status\t\t= &rtas_validate_flash_data.status,\n\t\t.ops.proc_read\t= validate_flash_read,\n\t\t.ops.proc_write\t= validate_flash_write,\n\t\t.ops.proc_release = validate_flash_release,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t},\n\t{\n\t\t.filename\t= \"powerpc/rtas/\" MANAGE_FLASH_NAME,\n\t\t.rtas_call_name\t= \"ibm,manage-flash-image\",\n\t\t.status\t\t= &rtas_manage_flash_data.status,\n\t\t.ops.proc_read\t= manage_flash_read,\n\t\t.ops.proc_write\t= manage_flash_write,\n\t\t.ops.proc_lseek\t= default_llseek,\n\t}\n};\n\nstatic int __init rtas_flash_init(void)\n{\n\tint i;\n\n\tif (rtas_token(\"ibm,update-flash-64-and-reboot\") ==\n\t\t       RTAS_UNKNOWN_SERVICE) {\n\t\tpr_info(\"rtas_flash: no firmware flash support\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtas_validate_flash_data.buf = kzalloc(VALIDATE_BUF_SIZE, GFP_KERNEL);\n\tif (!rtas_validate_flash_data.buf)\n\t\treturn -ENOMEM;\n\n\tflash_block_cache = kmem_cache_create(\"rtas_flash_cache\",\n\t\t\t\t\t      RTAS_BLK_SIZE, RTAS_BLK_SIZE, 0,\n\t\t\t\t\t      NULL);\n\tif (!flash_block_cache) {\n\t\tprintk(KERN_ERR \"%s: failed to create block cache\\n\",\n\t\t\t\t__func__);\n\t\tgoto enomem_buf;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtas_flash_files); i++) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tint token;\n\n\t\tif (!proc_create(f->filename, 0600, NULL, &f->ops))\n\t\t\tgoto enomem;\n\n\t\t/*\n\t\t * This code assumes that the status int is the first member of the\n\t\t * struct\n\t\t */\n\t\ttoken = rtas_token(f->rtas_call_name);\n\t\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\t\t*f->status = FLASH_AUTH;\n\t\telse\n\t\t\t*f->status = FLASH_NO_OP;\n\t}\n\n\trtas_flash_term_hook = rtas_flash_firmware;\n\treturn 0;\n\nenomem:\n\twhile (--i >= 0) {\n\t\tconst struct rtas_flash_file *f = &rtas_flash_files[i];\n\t\tremove_proc_entry(f->filename, NULL);\n\t}\n\n\tkmem_cache_destroy(flash_block_cache);\nenomem_buf:\n\tkfree(rtas_validate_flash_data.buf);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "rtas_flash_firmware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "557-649",
    "snippet": "static void rtas_flash_firmware(int reboot_type)\n{\n\tunsigned long image_size;\n\tstruct flash_block_list *f, *next, *flist;\n\tunsigned long rtas_block_list;\n\tint i, status, update_token;\n\n\tif (rtas_firmware_flash_list == NULL)\n\t\treturn;\t\t/* nothing to do */\n\n\tif (reboot_type != SYS_RESTART) {\n\t\tprintk(KERN_ALERT \"FLASH: firmware flash requires a reboot\\n\");\n\t\tprintk(KERN_ALERT \"FLASH: the firmware image will NOT be flashed\\n\");\n\t\treturn;\n\t}\n\n\tupdate_token = rtas_token(\"ibm,update-flash-64-and-reboot\");\n\tif (update_token == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ALERT \"FLASH: ibm,update-flash-64-and-reboot \"\n\t\t       \"is not available -- not a service partition?\\n\");\n\t\tprintk(KERN_ALERT \"FLASH: firmware will not be flashed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Just before starting the firmware flash, cancel the event scan work\n\t * to avoid any soft lockup issues.\n\t */\n\trtas_cancel_event_scan();\n\n\t/*\n\t * NOTE: the \"first\" block must be under 4GB, so we create\n\t * an entry with no data blocks in the reserved buffer in\n\t * the kernel data segment.\n\t */\n\tspin_lock(&rtas_data_buf_lock);\n\tflist = (struct flash_block_list *)&rtas_data_buf[0];\n\tflist->num_blocks = 0;\n\tflist->next = rtas_firmware_flash_list;\n\trtas_block_list = __pa(flist);\n\tif (rtas_block_list >= 4UL*1024*1024*1024) {\n\t\tprintk(KERN_ALERT \"FLASH: kernel bug...flash list header addr above 4GB\\n\");\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t\treturn;\n\t}\n\n\tprintk(KERN_ALERT \"FLASH: preparing saved firmware image for flash\\n\");\n\t/* Update the block_list in place. */\n\trtas_firmware_flash_list = NULL; /* too hard to backout on error */\n\timage_size = 0;\n\tfor (f = flist; f; f = next) {\n\t\t/* Translate data addrs to absolute */\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tf->blocks[i].data = (char *)cpu_to_be64(__pa(f->blocks[i].data));\n\t\t\timage_size += f->blocks[i].length;\n\t\t\tf->blocks[i].length = cpu_to_be64(f->blocks[i].length);\n\t\t}\n\t\tnext = f->next;\n\t\t/* Don't translate NULL pointer for last entry */\n\t\tif (f->next)\n\t\t\tf->next = (struct flash_block_list *)cpu_to_be64(__pa(f->next));\n\t\telse\n\t\t\tf->next = NULL;\n\t\t/* make num_blocks into the version/length field */\n\t\tf->num_blocks = (FLASH_BLOCK_LIST_VERSION << 56) | ((f->num_blocks+1)*16);\n\t\tf->num_blocks = cpu_to_be64(f->num_blocks);\n\t}\n\n\tprintk(KERN_ALERT \"FLASH: flash image is %ld bytes\\n\", image_size);\n\tprintk(KERN_ALERT \"FLASH: performing flash and reboot\\n\");\n\trtas_progress(\"Flashing        \\n\", 0x0);\n\trtas_progress(\"Please Wait...  \", 0x0);\n\tprintk(KERN_ALERT \"FLASH: this will take several minutes.  Do not power off!\\n\");\n\tstatus = rtas_call(update_token, 1, 1, NULL, rtas_block_list);\n\tswitch (status) {\t/* should only get \"bad\" status */\n\t    case 0:\n\t\tprintk(KERN_ALERT \"FLASH: success\\n\");\n\t\tbreak;\n\t    case -1:\n\t\tprintk(KERN_ALERT \"FLASH: hardware error.  Firmware may not be not flashed\\n\");\n\t\tbreak;\n\t    case -3:\n\t\tprintk(KERN_ALERT \"FLASH: image is corrupt or not correct for this platform.  Firmware not flashed\\n\");\n\t\tbreak;\n\t    case -4:\n\t\tprintk(KERN_ALERT \"FLASH: flash failed when partially complete.  System may not reboot\\n\");\n\t\tbreak;\n\t    default:\n\t\tprintk(KERN_ALERT \"FLASH: unknown flash return code %d\\n\", status);\n\t\tbreak;\n\t}\n\tspin_unlock(&rtas_data_buf_lock);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FLASH_BLOCK_LIST_VERSION (1UL)"
    ],
    "globals_used": [
      "static struct flash_block_list *rtas_firmware_flash_list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rtas_data_buf_lock"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: unknown flash return code %d\\n\"",
            "status"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: flash failed when partially complete.  System may not reboot\\n\""
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: image is corrupt or not correct for this platform.  Firmware not flashed\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: hardware error.  Firmware may not be not flashed\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: success\\n\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "update_token",
            "1",
            "1",
            "NULL",
            "rtas_block_list"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: this will take several minutes.  Do not power off!\\n\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_progress",
          "args": [
            "\"Please Wait...  \"",
            "0x0"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "197-314",
          "snippet": "void rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nvoid rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: performing flash and reboot\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "f->num_blocks"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "__pa(f->next)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "f->next"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "f->blocks[i].length"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "__pa(f->blocks[i].data)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: preparing saved firmware image for flash\\n\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rtas_data_buf_lock"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: kernel bug...flash list header addr above 4GB\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rtas_data_buf_lock"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_cancel_event_scan",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_cancel_event_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "495-498",
          "snippet": "void rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nvoid rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: firmware will not be flashed\\n\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: ibm,update-flash-64-and-reboot \"\n\t\t       \"is not available -- not a service partition?\\n\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,update-flash-64-and-reboot\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: the firmware image will NOT be flashed\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"FLASH: firmware flash requires a reboot\\n\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define FLASH_BLOCK_LIST_VERSION (1UL)\n\nstatic struct flash_block_list *rtas_firmware_flash_list;\n\nstatic void rtas_flash_firmware(int reboot_type)\n{\n\tunsigned long image_size;\n\tstruct flash_block_list *f, *next, *flist;\n\tunsigned long rtas_block_list;\n\tint i, status, update_token;\n\n\tif (rtas_firmware_flash_list == NULL)\n\t\treturn;\t\t/* nothing to do */\n\n\tif (reboot_type != SYS_RESTART) {\n\t\tprintk(KERN_ALERT \"FLASH: firmware flash requires a reboot\\n\");\n\t\tprintk(KERN_ALERT \"FLASH: the firmware image will NOT be flashed\\n\");\n\t\treturn;\n\t}\n\n\tupdate_token = rtas_token(\"ibm,update-flash-64-and-reboot\");\n\tif (update_token == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ALERT \"FLASH: ibm,update-flash-64-and-reboot \"\n\t\t       \"is not available -- not a service partition?\\n\");\n\t\tprintk(KERN_ALERT \"FLASH: firmware will not be flashed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Just before starting the firmware flash, cancel the event scan work\n\t * to avoid any soft lockup issues.\n\t */\n\trtas_cancel_event_scan();\n\n\t/*\n\t * NOTE: the \"first\" block must be under 4GB, so we create\n\t * an entry with no data blocks in the reserved buffer in\n\t * the kernel data segment.\n\t */\n\tspin_lock(&rtas_data_buf_lock);\n\tflist = (struct flash_block_list *)&rtas_data_buf[0];\n\tflist->num_blocks = 0;\n\tflist->next = rtas_firmware_flash_list;\n\trtas_block_list = __pa(flist);\n\tif (rtas_block_list >= 4UL*1024*1024*1024) {\n\t\tprintk(KERN_ALERT \"FLASH: kernel bug...flash list header addr above 4GB\\n\");\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t\treturn;\n\t}\n\n\tprintk(KERN_ALERT \"FLASH: preparing saved firmware image for flash\\n\");\n\t/* Update the block_list in place. */\n\trtas_firmware_flash_list = NULL; /* too hard to backout on error */\n\timage_size = 0;\n\tfor (f = flist; f; f = next) {\n\t\t/* Translate data addrs to absolute */\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tf->blocks[i].data = (char *)cpu_to_be64(__pa(f->blocks[i].data));\n\t\t\timage_size += f->blocks[i].length;\n\t\t\tf->blocks[i].length = cpu_to_be64(f->blocks[i].length);\n\t\t}\n\t\tnext = f->next;\n\t\t/* Don't translate NULL pointer for last entry */\n\t\tif (f->next)\n\t\t\tf->next = (struct flash_block_list *)cpu_to_be64(__pa(f->next));\n\t\telse\n\t\t\tf->next = NULL;\n\t\t/* make num_blocks into the version/length field */\n\t\tf->num_blocks = (FLASH_BLOCK_LIST_VERSION << 56) | ((f->num_blocks+1)*16);\n\t\tf->num_blocks = cpu_to_be64(f->num_blocks);\n\t}\n\n\tprintk(KERN_ALERT \"FLASH: flash image is %ld bytes\\n\", image_size);\n\tprintk(KERN_ALERT \"FLASH: performing flash and reboot\\n\");\n\trtas_progress(\"Flashing        \\n\", 0x0);\n\trtas_progress(\"Please Wait...  \", 0x0);\n\tprintk(KERN_ALERT \"FLASH: this will take several minutes.  Do not power off!\\n\");\n\tstatus = rtas_call(update_token, 1, 1, NULL, rtas_block_list);\n\tswitch (status) {\t/* should only get \"bad\" status */\n\t    case 0:\n\t\tprintk(KERN_ALERT \"FLASH: success\\n\");\n\t\tbreak;\n\t    case -1:\n\t\tprintk(KERN_ALERT \"FLASH: hardware error.  Firmware may not be not flashed\\n\");\n\t\tbreak;\n\t    case -3:\n\t\tprintk(KERN_ALERT \"FLASH: image is corrupt or not correct for this platform.  Firmware not flashed\\n\");\n\t\tbreak;\n\t    case -4:\n\t\tprintk(KERN_ALERT \"FLASH: flash failed when partially complete.  System may not reboot\\n\");\n\t\tbreak;\n\t    default:\n\t\tprintk(KERN_ALERT \"FLASH: unknown flash return code %d\\n\", status);\n\t\tbreak;\n\t}\n\tspin_unlock(&rtas_data_buf_lock);\n}"
  },
  {
    "function_name": "validate_flash_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "538-552",
    "snippet": "static int validate_flash_release(struct inode *inode, struct file *file)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\n\tif (args_buf->status == VALIDATE_READY) {\n\t\targs_buf->buf_size = VALIDATE_BUF_SIZE;\n\t\tvalidate_flash(args_buf);\n\t}\n\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VALIDATE_BUF_SIZE 4096",
      "#define VALIDATE_READY\t       -1001 /* Firmware image ready for validation */"
    ],
    "globals_used": [
      "static struct rtas_validate_flash_t rtas_validate_flash_data;",
      "static DEFINE_MUTEX(rtas_validate_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_flash",
          "args": [
            "args_buf"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "validate_flash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "445-463",
          "snippet": "static void validate_flash(struct rtas_validate_flash_t *args_buf)\n{\n\tint token = rtas_token(\"ibm,validate-flash-image\");\n\tint update_results;\n\ts32 rc;\t\n\n\trc = 0;\n\tdo {\n\t\tspin_lock(&rtas_data_buf_lock);\n\t\tmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\n\t\trc = rtas_call(token, 2, 2, &update_results, \n\t\t\t       (u32) __pa(rtas_data_buf), args_buf->buf_size);\n\t\tmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n\targs_buf->update_results = update_results;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VALIDATE_BUF_SIZE 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_BUF_SIZE 4096\n\nstatic void validate_flash(struct rtas_validate_flash_t *args_buf)\n{\n\tint token = rtas_token(\"ibm,validate-flash-image\");\n\tint update_results;\n\ts32 rc;\t\n\n\trc = 0;\n\tdo {\n\t\tspin_lock(&rtas_data_buf_lock);\n\t\tmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\n\t\trc = rtas_call(token, 2, 2, &update_results, \n\t\t\t       (u32) __pa(rtas_data_buf), args_buf->buf_size);\n\t\tmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n\targs_buf->update_results = update_results;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_BUF_SIZE 4096\n#define VALIDATE_READY\t       -1001 /* Firmware image ready for validation */\n\nstatic struct rtas_validate_flash_t rtas_validate_flash_data;\nstatic DEFINE_MUTEX(rtas_validate_flash_mutex);\n\nstatic int validate_flash_release(struct inode *inode, struct file *file)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\n\tif (args_buf->status == VALIDATE_READY) {\n\t\targs_buf->buf_size = VALIDATE_BUF_SIZE;\n\t\tvalidate_flash(args_buf);\n\t}\n\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "validate_flash_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "497-536",
    "snippet": "static ssize_t validate_flash_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *off)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\tint rc;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\n\t/* We are only interested in the first 4K of the\n\t * candidate image */\n\tif ((*off >= VALIDATE_BUF_SIZE) || \n\t\t(args_buf->status == VALIDATE_AUTH)) {\n\t\t*off += count;\n\t\tmutex_unlock(&rtas_validate_flash_mutex);\n\t\treturn count;\n\t}\n\n\tif (*off + count >= VALIDATE_BUF_SIZE)  {\n\t\tcount = VALIDATE_BUF_SIZE - *off;\n\t\targs_buf->status = VALIDATE_READY;\t\n\t} else {\n\t\targs_buf->status = VALIDATE_INCOMPLETE;\n\t}\n\n\tif (!access_ok(buf, count)) {\n\t\trc = -EFAULT;\n\t\tgoto done;\n\t}\n\tif (copy_from_user(args_buf->buf + *off, buf, count)) {\n\t\trc = -EFAULT;\n\t\tgoto done;\n\t}\n\n\t*off += count;\n\trc = count;\ndone:\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VALIDATE_BUF_SIZE 4096",
      "#define VALIDATE_READY\t       -1001 /* Firmware image ready for validation */",
      "#define VALIDATE_INCOMPLETE    -1002 /* User copied < VALIDATE_BUF_SIZE */",
      "#define VALIDATE_AUTH          -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [
      "static struct rtas_validate_flash_t rtas_validate_flash_data;",
      "static DEFINE_MUTEX(rtas_validate_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "args_buf->buf + *off",
            "buf",
            "count"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "buf",
            "count"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_BUF_SIZE 4096\n#define VALIDATE_READY\t       -1001 /* Firmware image ready for validation */\n#define VALIDATE_INCOMPLETE    -1002 /* User copied < VALIDATE_BUF_SIZE */\n#define VALIDATE_AUTH          -9002 /* RTAS Not Service Authority Partition */\n\nstatic struct rtas_validate_flash_t rtas_validate_flash_data;\nstatic DEFINE_MUTEX(rtas_validate_flash_mutex);\n\nstatic ssize_t validate_flash_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *off)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\tint rc;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\n\t/* We are only interested in the first 4K of the\n\t * candidate image */\n\tif ((*off >= VALIDATE_BUF_SIZE) || \n\t\t(args_buf->status == VALIDATE_AUTH)) {\n\t\t*off += count;\n\t\tmutex_unlock(&rtas_validate_flash_mutex);\n\t\treturn count;\n\t}\n\n\tif (*off + count >= VALIDATE_BUF_SIZE)  {\n\t\tcount = VALIDATE_BUF_SIZE - *off;\n\t\targs_buf->status = VALIDATE_READY;\t\n\t} else {\n\t\targs_buf->status = VALIDATE_INCOMPLETE;\n\t}\n\n\tif (!access_ok(buf, count)) {\n\t\trc = -EFAULT;\n\t\tgoto done;\n\t}\n\tif (copy_from_user(args_buf->buf + *off, buf, count)) {\n\t\trc = -EFAULT;\n\t\tgoto done;\n\t}\n\n\t*off += count;\n\trc = count;\ndone:\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "validate_flash_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "482-495",
    "snippet": "static ssize_t validate_flash_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\tchar msg[VALIDATE_MSG_LEN];\n\tint msglen;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\tmsglen = get_validate_flash_msg(args_buf, msg, VALIDATE_MSG_LEN);\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\n\treturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VALIDATE_MSG_LEN  256"
    ],
    "globals_used": [
      "static struct rtas_validate_flash_t rtas_validate_flash_data;",
      "static DEFINE_MUTEX(rtas_validate_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "msg",
            "msglen"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_validate_flash_msg",
          "args": [
            "args_buf",
            "msg",
            "VALIDATE_MSG_LEN"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "get_validate_flash_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "465-480",
          "snippet": "static int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf, \n\t\t                   char *msg, int msglen)\n{\n\tint n;\n\n\tif (args_buf->status >= VALIDATE_TMP_UPDATE) { \n\t\tn = sprintf(msg, \"%d\\n\", args_buf->update_results);\n\t\tif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\n\t\t    (args_buf->update_results == VALIDATE_TMP_UPDATE))\n\t\t\tn += snprintf(msg + n, msglen - n, \"%s\\n\",\n\t\t\t\t\targs_buf->buf);\n\t} else {\n\t\tn = sprintf(msg, \"%d\\n\", args_buf->status);\n\t}\n\treturn n;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define VALIDATE_CUR_UNKNOWN   3     /* Current fixpack level is unknown */",
            "#define VALIDATE_TMP_UPDATE    0     /* T side will be updated */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_CUR_UNKNOWN   3     /* Current fixpack level is unknown */\n#define VALIDATE_TMP_UPDATE    0     /* T side will be updated */\n\nstatic int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf, \n\t\t                   char *msg, int msglen)\n{\n\tint n;\n\n\tif (args_buf->status >= VALIDATE_TMP_UPDATE) { \n\t\tn = sprintf(msg, \"%d\\n\", args_buf->update_results);\n\t\tif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\n\t\t    (args_buf->update_results == VALIDATE_TMP_UPDATE))\n\t\t\tn += snprintf(msg + n, msglen - n, \"%s\\n\",\n\t\t\t\t\targs_buf->buf);\n\t} else {\n\t\tn = sprintf(msg, \"%d\\n\", args_buf->status);\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_validate_flash_mutex"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_MSG_LEN  256\n\nstatic struct rtas_validate_flash_t rtas_validate_flash_data;\nstatic DEFINE_MUTEX(rtas_validate_flash_mutex);\n\nstatic ssize_t validate_flash_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rtas_validate_flash_t *const args_buf =\n\t\t&rtas_validate_flash_data;\n\tchar msg[VALIDATE_MSG_LEN];\n\tint msglen;\n\n\tmutex_lock(&rtas_validate_flash_mutex);\n\tmsglen = get_validate_flash_msg(args_buf, msg, VALIDATE_MSG_LEN);\n\tmutex_unlock(&rtas_validate_flash_mutex);\n\n\treturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\n}"
  },
  {
    "function_name": "get_validate_flash_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "465-480",
    "snippet": "static int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf, \n\t\t                   char *msg, int msglen)\n{\n\tint n;\n\n\tif (args_buf->status >= VALIDATE_TMP_UPDATE) { \n\t\tn = sprintf(msg, \"%d\\n\", args_buf->update_results);\n\t\tif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\n\t\t    (args_buf->update_results == VALIDATE_TMP_UPDATE))\n\t\t\tn += snprintf(msg + n, msglen - n, \"%s\\n\",\n\t\t\t\t\targs_buf->buf);\n\t} else {\n\t\tn = sprintf(msg, \"%d\\n\", args_buf->status);\n\t}\n\treturn n;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VALIDATE_CUR_UNKNOWN   3     /* Current fixpack level is unknown */",
      "#define VALIDATE_TMP_UPDATE    0     /* T side will be updated */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msg",
            "\"%d\\n\"",
            "args_buf->status"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg + n",
            "msglen - n",
            "\"%s\\n\"",
            "args_buf->buf"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msg",
            "\"%d\\n\"",
            "args_buf->update_results"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_CUR_UNKNOWN   3     /* Current fixpack level is unknown */\n#define VALIDATE_TMP_UPDATE    0     /* T side will be updated */\n\nstatic int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf, \n\t\t                   char *msg, int msglen)\n{\n\tint n;\n\n\tif (args_buf->status >= VALIDATE_TMP_UPDATE) { \n\t\tn = sprintf(msg, \"%d\\n\", args_buf->update_results);\n\t\tif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\n\t\t    (args_buf->update_results == VALIDATE_TMP_UPDATE))\n\t\t\tn += snprintf(msg + n, msglen - n, \"%s\\n\",\n\t\t\t\t\targs_buf->buf);\n\t} else {\n\t\tn = sprintf(msg, \"%d\\n\", args_buf->status);\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "validate_flash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "445-463",
    "snippet": "static void validate_flash(struct rtas_validate_flash_t *args_buf)\n{\n\tint token = rtas_token(\"ibm,validate-flash-image\");\n\tint update_results;\n\ts32 rc;\t\n\n\trc = 0;\n\tdo {\n\t\tspin_lock(&rtas_data_buf_lock);\n\t\tmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\n\t\trc = rtas_call(token, 2, 2, &update_results, \n\t\t\t       (u32) __pa(rtas_data_buf), args_buf->buf_size);\n\t\tmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n\targs_buf->update_results = update_results;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define VALIDATE_BUF_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rtas_data_buf_lock"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args_buf->buf",
            "rtas_data_buf",
            "VALIDATE_BUF_SIZE"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "&update_results",
            "(u32) __pa(rtas_data_buf)",
            "args_buf->buf_size"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "rtas_data_buf"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rtas_data_buf_lock"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,validate-flash-image\""
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define VALIDATE_BUF_SIZE 4096\n\nstatic void validate_flash(struct rtas_validate_flash_t *args_buf)\n{\n\tint token = rtas_token(\"ibm,validate-flash-image\");\n\tint update_results;\n\ts32 rc;\t\n\n\trc = 0;\n\tdo {\n\t\tspin_lock(&rtas_data_buf_lock);\n\t\tmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\n\t\trc = rtas_call(token, 2, 2, &update_results, \n\t\t\t       (u32) __pa(rtas_data_buf), args_buf->buf_size);\n\t\tmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\n\t\tspin_unlock(&rtas_data_buf_lock);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n\targs_buf->update_results = update_results;\n}"
  },
  {
    "function_name": "manage_flash_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "401-440",
    "snippet": "static ssize_t manage_flash_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\tstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\n\tstatic const char reject_str[] = \"0\";\n\tstatic const char commit_str[] = \"1\";\n\tchar stkbuf[10];\n\tint op, rc;\n\n\tmutex_lock(&rtas_manage_flash_mutex);\n\n\tif ((args_buf->status == MANAGE_AUTH) || (count == 0))\n\t\tgoto out;\n\t\t\n\top = -1;\n\tif (buf) {\n\t\tif (count > 9) count = 9;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user (stkbuf, buf, count))\n\t\t\tgoto error;\n\t\tif (strncmp(stkbuf, reject_str, strlen(reject_str)) == 0) \n\t\t\top = RTAS_REJECT_TMP_IMG;\n\t\telse if (strncmp(stkbuf, commit_str, strlen(commit_str)) == 0) \n\t\t\top = RTAS_COMMIT_TMP_IMG;\n\t}\n\t\n\tif (op == -1) {   /* buf is empty, or contains invalid string */\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tmanage_flash(args_buf, op);\nout:\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\treturn count;\n\nerror:\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_COMMIT_TMP_IMG   1",
      "#define RTAS_REJECT_TMP_IMG   0",
      "#define MANAGE_AUTH          -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [
      "static struct rtas_manage_flash_t rtas_manage_flash_data;",
      "static DEFINE_MUTEX(rtas_manage_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_manage_flash_mutex"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_manage_flash_mutex"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manage_flash",
          "args": [
            "args_buf",
            "op"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "manage_flash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "374-384",
          "snippet": "static void manage_flash(struct rtas_manage_flash_t *args_buf, unsigned int op)\n{\n\ts32 rc;\n\n\tdo {\n\t\trc = rtas_call(rtas_token(\"ibm,manage-flash-image\"), 1, 1,\n\t\t\t       NULL, op);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void manage_flash(struct rtas_manage_flash_t *args_buf, unsigned int op)\n{\n\ts32 rc;\n\n\tdo {\n\t\trc = rtas_call(rtas_token(\"ibm,manage-flash-image\"), 1, 1,\n\t\t\t       NULL, op);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "stkbuf",
            "commit_str",
            "strlen(commit_str)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "commit_str"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "270-277",
          "snippet": "static size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "stkbuf",
            "buf",
            "count"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_manage_flash_mutex"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_COMMIT_TMP_IMG   1\n#define RTAS_REJECT_TMP_IMG   0\n#define MANAGE_AUTH          -9002 /* RTAS Not Service Authority Partition */\n\nstatic struct rtas_manage_flash_t rtas_manage_flash_data;\nstatic DEFINE_MUTEX(rtas_manage_flash_mutex);\n\nstatic ssize_t manage_flash_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\tstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\n\tstatic const char reject_str[] = \"0\";\n\tstatic const char commit_str[] = \"1\";\n\tchar stkbuf[10];\n\tint op, rc;\n\n\tmutex_lock(&rtas_manage_flash_mutex);\n\n\tif ((args_buf->status == MANAGE_AUTH) || (count == 0))\n\t\tgoto out;\n\t\t\n\top = -1;\n\tif (buf) {\n\t\tif (count > 9) count = 9;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user (stkbuf, buf, count))\n\t\t\tgoto error;\n\t\tif (strncmp(stkbuf, reject_str, strlen(reject_str)) == 0) \n\t\t\top = RTAS_REJECT_TMP_IMG;\n\t\telse if (strncmp(stkbuf, commit_str, strlen(commit_str)) == 0) \n\t\t\top = RTAS_COMMIT_TMP_IMG;\n\t}\n\t\n\tif (op == -1) {   /* buf is empty, or contains invalid string */\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tmanage_flash(args_buf, op);\nout:\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\treturn count;\n\nerror:\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "manage_flash_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "386-399",
    "snippet": "static ssize_t manage_flash_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tint msglen, status;\n\n\tmutex_lock(&rtas_manage_flash_mutex);\n\tstatus = args_buf->status;\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\n\tmsglen = sprintf(msg, \"%d\\n\", status);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_MSG_MAXLEN   64"
    ],
    "globals_used": [
      "static struct rtas_manage_flash_t rtas_manage_flash_data;",
      "static DEFINE_MUTEX(rtas_manage_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "msg",
            "msglen"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msg",
            "\"%d\\n\"",
            "status"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_manage_flash_mutex"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_manage_flash_mutex"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_MSG_MAXLEN   64\n\nstatic struct rtas_manage_flash_t rtas_manage_flash_data;\nstatic DEFINE_MUTEX(rtas_manage_flash_mutex);\n\nstatic ssize_t manage_flash_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rtas_manage_flash_t *const args_buf = &rtas_manage_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tint msglen, status;\n\n\tmutex_lock(&rtas_manage_flash_mutex);\n\tstatus = args_buf->status;\n\tmutex_unlock(&rtas_manage_flash_mutex);\n\n\tmsglen = sprintf(msg, \"%d\\n\", status);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\n}"
  },
  {
    "function_name": "manage_flash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "374-384",
    "snippet": "static void manage_flash(struct rtas_manage_flash_t *args_buf, unsigned int op)\n{\n\ts32 rc;\n\n\tdo {\n\t\trc = rtas_call(rtas_token(\"ibm,manage-flash-image\"), 1, 1,\n\t\t\t       NULL, op);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "509-519",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"ibm,manage-flash-image\")",
            "1",
            "1",
            "NULL",
            "op"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,manage-flash-image\""
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void manage_flash(struct rtas_manage_flash_t *args_buf, unsigned int op)\n{\n\ts32 rc;\n\n\tdo {\n\t\trc = rtas_call(rtas_token(\"ibm,manage-flash-image\"), 1, 1,\n\t\t\t       NULL, op);\n\t} while (rtas_busy_delay(rc));\n\n\targs_buf->status = rc;\n}"
  },
  {
    "function_name": "rtas_flash_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "310-369",
    "snippet": "static ssize_t rtas_flash_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar *p;\n\tint next_free, rc;\n\tstruct flash_block_list *fl;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\n\tif (uf->status == FLASH_AUTH || count == 0)\n\t\tgoto out;\t/* discard data */\n\n\t/* In the case that the image is not ready for flashing, the memory\n\t * allocated for the block list will be freed upon the release of the \n\t * proc file\n\t */\n\tif (uf->flist == NULL) {\n\t\tuf->flist = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\t\tif (!uf->flist)\n\t\t\tgoto nomem;\n\t}\n\n\tfl = uf->flist;\n\twhile (fl->next)\n\t\tfl = fl->next; /* seek to last block_list for append */\n\tnext_free = fl->num_blocks;\n\tif (next_free == FLASH_BLOCKS_PER_NODE) {\n\t\t/* Need to allocate another block_list */\n\t\tfl->next = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\t\tif (!fl->next)\n\t\t\tgoto nomem;\n\t\tfl = fl->next;\n\t\tnext_free = 0;\n\t}\n\n\tif (count > RTAS_BLK_SIZE)\n\t\tcount = RTAS_BLK_SIZE;\n\tp = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\tif (!p)\n\t\tgoto nomem;\n\t\n\tif(copy_from_user(p, buffer, count)) {\n\t\tkmem_cache_free(flash_block_cache, p);\n\t\trc = -EFAULT;\n\t\tgoto error;\n\t}\n\tfl->blocks[next_free].data = p;\n\tfl->blocks[next_free].length = count;\n\tfl->num_blocks++;\nout:\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn count;\n\nnomem:\n\trc = -ENOMEM;\nerror:\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FLASH_BLOCKS_PER_NODE ((RTAS_BLKLIST_LENGTH - 16) / sizeof(struct flash_block))",
      "#define RTAS_BLK_SIZE 4096",
      "#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [
      "static struct kmem_cache *flash_block_cache = NULL;",
      "static struct rtas_update_flash_t rtas_update_flash_data;",
      "static DEFINE_MUTEX(rtas_update_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flash_block_cache",
            "p"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "p",
            "buffer",
            "count"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "flash_block_cache",
            "GFP_KERNEL"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "flash_block_cache",
            "GFP_KERNEL"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "flash_block_cache",
            "GFP_KERNEL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define FLASH_BLOCKS_PER_NODE ((RTAS_BLKLIST_LENGTH - 16) / sizeof(struct flash_block))\n#define RTAS_BLK_SIZE 4096\n#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */\n\nstatic struct kmem_cache *flash_block_cache = NULL;\nstatic struct rtas_update_flash_t rtas_update_flash_data;\nstatic DEFINE_MUTEX(rtas_update_flash_mutex);\n\nstatic ssize_t rtas_flash_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar *p;\n\tint next_free, rc;\n\tstruct flash_block_list *fl;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\n\tif (uf->status == FLASH_AUTH || count == 0)\n\t\tgoto out;\t/* discard data */\n\n\t/* In the case that the image is not ready for flashing, the memory\n\t * allocated for the block list will be freed upon the release of the \n\t * proc file\n\t */\n\tif (uf->flist == NULL) {\n\t\tuf->flist = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\t\tif (!uf->flist)\n\t\t\tgoto nomem;\n\t}\n\n\tfl = uf->flist;\n\twhile (fl->next)\n\t\tfl = fl->next; /* seek to last block_list for append */\n\tnext_free = fl->num_blocks;\n\tif (next_free == FLASH_BLOCKS_PER_NODE) {\n\t\t/* Need to allocate another block_list */\n\t\tfl->next = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\t\tif (!fl->next)\n\t\t\tgoto nomem;\n\t\tfl = fl->next;\n\t\tnext_free = 0;\n\t}\n\n\tif (count > RTAS_BLK_SIZE)\n\t\tcount = RTAS_BLK_SIZE;\n\tp = kmem_cache_zalloc(flash_block_cache, GFP_KERNEL);\n\tif (!p)\n\t\tgoto nomem;\n\t\n\tif(copy_from_user(p, buffer, count)) {\n\t\tkmem_cache_free(flash_block_cache, p);\n\t\trc = -EFAULT;\n\t\tgoto error;\n\t}\n\tfl->blocks[next_free].data = p;\n\tfl->blocks[next_free].length = count;\n\tfl->num_blocks++;\nout:\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn count;\n\nnomem:\n\trc = -ENOMEM;\nerror:\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_flash_read_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "289-303",
    "snippet": "static ssize_t rtas_flash_read_num(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tint status;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\tstatus = uf->status;\n\tmutex_unlock(&rtas_update_flash_mutex);\n\n\t/* Read as number */\n\tsprintf(msg, \"%d\\n\", status);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, strlen(msg));\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_MSG_MAXLEN   64"
    ],
    "globals_used": [
      "static struct rtas_update_flash_t rtas_update_flash_data;",
      "static DEFINE_MUTEX(rtas_update_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "msg",
            "strlen(msg)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "270-277",
          "snippet": "static size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msg",
            "\"%d\\n\"",
            "status"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_MSG_MAXLEN   64\n\nstatic struct rtas_update_flash_t rtas_update_flash_data;\nstatic DEFINE_MUTEX(rtas_update_flash_mutex);\n\nstatic ssize_t rtas_flash_read_num(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tint status;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\tstatus = uf->status;\n\tmutex_unlock(&rtas_update_flash_mutex);\n\n\t/* Read as number */\n\tsprintf(msg, \"%d\\n\", status);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, strlen(msg));\n}"
  },
  {
    "function_name": "rtas_flash_read_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "272-287",
    "snippet": "static ssize_t rtas_flash_read_msg(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tsize_t len;\n\tint status;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\tstatus = uf->status;\n\tmutex_unlock(&rtas_update_flash_mutex);\n\n\t/* Read as text message */\n\tlen = get_flash_status_msg(status, msg);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, len);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_MSG_MAXLEN   64"
    ],
    "globals_used": [
      "static struct rtas_update_flash_t rtas_update_flash_data;",
      "static DEFINE_MUTEX(rtas_update_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "msg",
            "len"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_flash_status_msg",
          "args": [
            "status",
            "msg"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "get_flash_status_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "237-269",
          "snippet": "static size_t get_flash_status_msg(int status, char *buf)\n{\n\tconst char *msg;\n\tsize_t len;\n\n\tswitch (status) {\n\tcase FLASH_AUTH:\n\t\tmsg = \"error: this partition does not have service authority\\n\";\n\t\tbreak;\n\tcase FLASH_NO_OP:\n\t\tmsg = \"info: no firmware image for flash\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_SHORT:\n\t\tmsg = \"error: flash image short\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_BAD_LEN:\n\t\tmsg = \"error: internal error bad length\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_NULL_DATA:\n\t\tmsg = \"error: internal error null data\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_READY:\n\t\tmsg = \"ready: firmware image ready for flash on reboot\\n\";\n\t\tbreak;\n\tdefault:\n\t\treturn sprintf(buf, \"error: unexpected status value %d\\n\",\n\t\t\t       status);\n\t}\n\n\tlen = strlen(msg);\n\tmemcpy(buf, msg, len + 1);\n\treturn len;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */",
            "#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */",
            "#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */",
            "#define FLASH_IMG_SHORT\t     -1005 /* Flash image shorter than expected */",
            "#define FLASH_NO_OP          -1099 /* No operation initiated by user */",
            "#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */\n#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */\n#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */\n#define FLASH_IMG_SHORT\t     -1005 /* Flash image shorter than expected */\n#define FLASH_NO_OP          -1099 /* No operation initiated by user */\n#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */\n\nstatic size_t get_flash_status_msg(int status, char *buf)\n{\n\tconst char *msg;\n\tsize_t len;\n\n\tswitch (status) {\n\tcase FLASH_AUTH:\n\t\tmsg = \"error: this partition does not have service authority\\n\";\n\t\tbreak;\n\tcase FLASH_NO_OP:\n\t\tmsg = \"info: no firmware image for flash\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_SHORT:\n\t\tmsg = \"error: flash image short\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_BAD_LEN:\n\t\tmsg = \"error: internal error bad length\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_NULL_DATA:\n\t\tmsg = \"error: internal error null data\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_READY:\n\t\tmsg = \"ready: firmware image ready for flash on reboot\\n\";\n\t\tbreak;\n\tdefault:\n\t\treturn sprintf(buf, \"error: unexpected status value %d\\n\",\n\t\t\t       status);\n\t}\n\n\tlen = strlen(msg);\n\tmemcpy(buf, msg, len + 1);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_MSG_MAXLEN   64\n\nstatic struct rtas_update_flash_t rtas_update_flash_data;\nstatic DEFINE_MUTEX(rtas_update_flash_mutex);\n\nstatic ssize_t rtas_flash_read_msg(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\tchar msg[RTAS_MSG_MAXLEN];\n\tsize_t len;\n\tint status;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\tstatus = uf->status;\n\tmutex_unlock(&rtas_update_flash_mutex);\n\n\t/* Read as text message */\n\tlen = get_flash_status_msg(status, msg);\n\treturn simple_read_from_buffer(buf, count, ppos, msg, len);\n}"
  },
  {
    "function_name": "get_flash_status_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "237-269",
    "snippet": "static size_t get_flash_status_msg(int status, char *buf)\n{\n\tconst char *msg;\n\tsize_t len;\n\n\tswitch (status) {\n\tcase FLASH_AUTH:\n\t\tmsg = \"error: this partition does not have service authority\\n\";\n\t\tbreak;\n\tcase FLASH_NO_OP:\n\t\tmsg = \"info: no firmware image for flash\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_SHORT:\n\t\tmsg = \"error: flash image short\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_BAD_LEN:\n\t\tmsg = \"error: internal error bad length\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_NULL_DATA:\n\t\tmsg = \"error: internal error null data\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_READY:\n\t\tmsg = \"ready: firmware image ready for flash on reboot\\n\";\n\t\tbreak;\n\tdefault:\n\t\treturn sprintf(buf, \"error: unexpected status value %d\\n\",\n\t\t\t       status);\n\t}\n\n\tlen = strlen(msg);\n\tmemcpy(buf, msg, len + 1);\n\treturn len;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */",
      "#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */",
      "#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */",
      "#define FLASH_IMG_SHORT\t     -1005 /* Flash image shorter than expected */",
      "#define FLASH_NO_OP          -1099 /* No operation initiated by user */",
      "#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "msg",
            "len + 1"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "270-277",
          "snippet": "static size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"error: unexpected status value %d\\n\"",
            "status"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */\n#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */\n#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */\n#define FLASH_IMG_SHORT\t     -1005 /* Flash image shorter than expected */\n#define FLASH_NO_OP          -1099 /* No operation initiated by user */\n#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */\n\nstatic size_t get_flash_status_msg(int status, char *buf)\n{\n\tconst char *msg;\n\tsize_t len;\n\n\tswitch (status) {\n\tcase FLASH_AUTH:\n\t\tmsg = \"error: this partition does not have service authority\\n\";\n\t\tbreak;\n\tcase FLASH_NO_OP:\n\t\tmsg = \"info: no firmware image for flash\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_SHORT:\n\t\tmsg = \"error: flash image short\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_BAD_LEN:\n\t\tmsg = \"error: internal error bad length\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_NULL_DATA:\n\t\tmsg = \"error: internal error null data\\n\";\n\t\tbreak;\n\tcase FLASH_IMG_READY:\n\t\tmsg = \"ready: firmware image ready for flash on reboot\\n\";\n\t\tbreak;\n\tdefault:\n\t\treturn sprintf(buf, \"error: unexpected status value %d\\n\",\n\t\t\t       status);\n\t}\n\n\tlen = strlen(msg);\n\tmemcpy(buf, msg, len + 1);\n\treturn len;\n}"
  },
  {
    "function_name": "rtas_flash_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "208-235",
    "snippet": "static int rtas_flash_release(struct inode *inode, struct file *file)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\n\tif (uf->flist) {    \n\t\t/* File was opened in write mode for a new flash attempt */\n\t\t/* Clear saved list */\n\t\tif (rtas_firmware_flash_list) {\n\t\t\tfree_flash_list(rtas_firmware_flash_list);\n\t\t\trtas_firmware_flash_list = NULL;\n\t\t}\n\n\t\tif (uf->status != FLASH_AUTH)  \n\t\t\tuf->status = flash_list_valid(uf->flist);\n\n\t\tif (uf->status == FLASH_IMG_READY) \n\t\t\trtas_firmware_flash_list = uf->flist;\n\t\telse\n\t\t\tfree_flash_list(uf->flist);\n\n\t\tuf->flist = NULL;\n\t}\n\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */",
      "#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */"
    ],
    "globals_used": [
      "static struct flash_block_list *rtas_firmware_flash_list;",
      "static struct rtas_update_flash_t rtas_update_flash_data;",
      "static DEFINE_MUTEX(rtas_update_flash_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_flash_list",
          "args": [
            "uf->flist"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "free_flash_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "194-206",
          "snippet": "static void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flash_block_cache = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *flash_block_cache = NULL;\n\nstatic void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flash_list_valid",
          "args": [
            "uf->flist"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "flash_list_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
          "lines": "163-192",
          "snippet": "static int flash_list_valid(struct flash_block_list *flist)\n{\n\tstruct flash_block_list *f;\n\tint i;\n\tunsigned long block_size, image_size;\n\n\t/* Paranoid self test here.  We also collect the image size. */\n\timage_size = 0;\n\tfor (f = flist; f; f = f->next) {\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tif (f->blocks[i].data == NULL) {\n\t\t\t\treturn FLASH_IMG_NULL_DATA;\n\t\t\t}\n\t\t\tblock_size = f->blocks[i].length;\n\t\t\tif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\n\t\t\t\treturn FLASH_IMG_BAD_LEN;\n\t\t\t}\n\t\t\timage_size += block_size;\n\t\t}\n\t}\n\n\tif (image_size < (256 << 10)) {\n\t\tif (image_size < 2) \n\t\t\treturn FLASH_NO_OP;\n\t}\n\n\tprintk(KERN_INFO \"FLASH: flash image with %ld bytes stored for hardware flash on reboot\\n\", image_size);\n\n\treturn FLASH_IMG_READY;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RTAS_BLK_SIZE 4096",
            "#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */",
            "#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */",
            "#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */",
            "#define FLASH_NO_OP          -1099 /* No operation initiated by user */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_BLK_SIZE 4096\n#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */\n#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */\n#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */\n#define FLASH_NO_OP          -1099 /* No operation initiated by user */\n\nstatic int flash_list_valid(struct flash_block_list *flist)\n{\n\tstruct flash_block_list *f;\n\tint i;\n\tunsigned long block_size, image_size;\n\n\t/* Paranoid self test here.  We also collect the image size. */\n\timage_size = 0;\n\tfor (f = flist; f; f = f->next) {\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tif (f->blocks[i].data == NULL) {\n\t\t\t\treturn FLASH_IMG_NULL_DATA;\n\t\t\t}\n\t\t\tblock_size = f->blocks[i].length;\n\t\t\tif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\n\t\t\t\treturn FLASH_IMG_BAD_LEN;\n\t\t\t}\n\t\t\timage_size += block_size;\n\t\t}\n\t}\n\n\tif (image_size < (256 << 10)) {\n\t\tif (image_size < 2) \n\t\t\treturn FLASH_NO_OP;\n\t}\n\n\tprintk(KERN_INFO \"FLASH: flash image with %ld bytes stored for hardware flash on reboot\\n\", image_size);\n\n\treturn FLASH_IMG_READY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rtas_update_flash_mutex"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */\n#define FLASH_AUTH           -9002 /* RTAS Not Service Authority Partition */\n\nstatic struct flash_block_list *rtas_firmware_flash_list;\nstatic struct rtas_update_flash_t rtas_update_flash_data;\nstatic DEFINE_MUTEX(rtas_update_flash_mutex);\n\nstatic int rtas_flash_release(struct inode *inode, struct file *file)\n{\n\tstruct rtas_update_flash_t *const uf = &rtas_update_flash_data;\n\n\tmutex_lock(&rtas_update_flash_mutex);\n\n\tif (uf->flist) {    \n\t\t/* File was opened in write mode for a new flash attempt */\n\t\t/* Clear saved list */\n\t\tif (rtas_firmware_flash_list) {\n\t\t\tfree_flash_list(rtas_firmware_flash_list);\n\t\t\trtas_firmware_flash_list = NULL;\n\t\t}\n\n\t\tif (uf->status != FLASH_AUTH)  \n\t\t\tuf->status = flash_list_valid(uf->flist);\n\n\t\tif (uf->status == FLASH_IMG_READY) \n\t\t\trtas_firmware_flash_list = uf->flist;\n\t\telse\n\t\t\tfree_flash_list(uf->flist);\n\n\t\tuf->flist = NULL;\n\t}\n\n\tmutex_unlock(&rtas_update_flash_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_flash_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "194-206",
    "snippet": "static void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *flash_block_cache = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flash_block_cache",
            "f"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "flash_block_cache",
            "f->blocks[i].data"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *flash_block_cache = NULL;\n\nstatic void free_flash_list(struct flash_block_list *f)\n{\n\tstruct flash_block_list *next;\n\tint i;\n\n\twhile (f) {\n\t\tfor (i = 0; i < f->num_blocks; i++)\n\t\t\tkmem_cache_free(flash_block_cache, f->blocks[i].data);\n\t\tnext = f->next;\n\t\tkmem_cache_free(flash_block_cache, f);\n\t\tf = next;\n\t}\n}"
  },
  {
    "function_name": "flash_list_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_flash.c",
    "lines": "163-192",
    "snippet": "static int flash_list_valid(struct flash_block_list *flist)\n{\n\tstruct flash_block_list *f;\n\tint i;\n\tunsigned long block_size, image_size;\n\n\t/* Paranoid self test here.  We also collect the image size. */\n\timage_size = 0;\n\tfor (f = flist; f; f = f->next) {\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tif (f->blocks[i].data == NULL) {\n\t\t\t\treturn FLASH_IMG_NULL_DATA;\n\t\t\t}\n\t\t\tblock_size = f->blocks[i].length;\n\t\t\tif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\n\t\t\t\treturn FLASH_IMG_BAD_LEN;\n\t\t\t}\n\t\t\timage_size += block_size;\n\t\t}\n\t}\n\n\tif (image_size < (256 << 10)) {\n\t\tif (image_size < 2) \n\t\t\treturn FLASH_NO_OP;\n\t}\n\n\tprintk(KERN_INFO \"FLASH: flash image with %ld bytes stored for hardware flash on reboot\\n\", image_size);\n\n\treturn FLASH_IMG_READY;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define RTAS_BLK_SIZE 4096",
      "#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */",
      "#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */",
      "#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */",
      "#define FLASH_NO_OP          -1099 /* No operation initiated by user */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"FLASH: flash image with %ld bytes stored for hardware flash on reboot\\n\"",
            "image_size"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <linux/reboot.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define RTAS_BLK_SIZE 4096\n#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */\n#define FLASH_IMG_NULL_DATA  -1003 /* Bad data value in flash list block */\n#define FLASH_IMG_BAD_LEN    -1004 /* Bad length value in flash list block */\n#define FLASH_NO_OP          -1099 /* No operation initiated by user */\n\nstatic int flash_list_valid(struct flash_block_list *flist)\n{\n\tstruct flash_block_list *f;\n\tint i;\n\tunsigned long block_size, image_size;\n\n\t/* Paranoid self test here.  We also collect the image size. */\n\timage_size = 0;\n\tfor (f = flist; f; f = f->next) {\n\t\tfor (i = 0; i < f->num_blocks; i++) {\n\t\t\tif (f->blocks[i].data == NULL) {\n\t\t\t\treturn FLASH_IMG_NULL_DATA;\n\t\t\t}\n\t\t\tblock_size = f->blocks[i].length;\n\t\t\tif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\n\t\t\t\treturn FLASH_IMG_BAD_LEN;\n\t\t\t}\n\t\t\timage_size += block_size;\n\t\t}\n\t}\n\n\tif (image_size < (256 << 10)) {\n\t\tif (image_size < 2) \n\t\t\treturn FLASH_NO_OP;\n\t}\n\n\tprintk(KERN_INFO \"FLASH: flash image with %ld bytes stored for hardware flash on reboot\\n\", image_size);\n\n\treturn FLASH_IMG_READY;\n}"
  }
]