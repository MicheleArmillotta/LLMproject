[
  {
    "function_name": "nvram_scan_partitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "982-1053",
    "snippet": "int __init nvram_scan_partitions(void)\n{\n\tloff_t cur_index = 0;\n\tstruct nvram_header phead;\n\tstruct nvram_partition * tmp_part;\n\tunsigned char c_sum;\n\tchar * header;\n\tint total_size;\n\tint err;\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn -ENODEV;\n\ttotal_size = ppc_md.nvram_size();\n\t\n\theader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\n\tif (!header) {\n\t\tprintk(KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (cur_index < total_size) {\n\n\t\terr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\n\t\tif (err != NVRAM_HEADER_LEN) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcur_index -= NVRAM_HEADER_LEN; /* nvram_read will advance us */\n\n\t\tmemcpy(&phead, header, NVRAM_HEADER_LEN);\n\n\t\tphead.length = be16_to_cpu(phead.length);\n\n\t\terr = 0;\n\t\tc_sum = nvram_checksum(&phead);\n\t\tif (c_sum != phead.checksum) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\",\n\t\t\t       phead.checksum, c_sum);\n\t\t\tprintk(KERN_WARNING \"Terminating nvram partition scan\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!phead.length) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttmp_part = kmalloc(sizeof(*tmp_part), GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (!tmp_part) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\n\t\ttmp_part->index = cur_index;\n\t\tlist_add_tail(&tmp_part->partition, &nvram_partitions);\n\t\t\n\t\tcur_index += phead.length * NVRAM_BLOCK_LEN;\n\t}\n\terr = 0;\n\n#ifdef DEBUG_NVRAM\n\tnvram_print_partitions(\"NVRAM Partitions\");\n#endif\n\n out:\n\tkfree(header);\n\treturn err;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_print_partitions",
          "args": [
            "\"NVRAM Partitions\""
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_print_partitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "706-718",
          "snippet": "static void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nstatic void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tmp_part->partition",
            "&nvram_partitions"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp_part->header",
            "&phead",
            "NVRAM_HEADER_LEN"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\""
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*tmp_part)",
            "GFP_KERNEL"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\""
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Terminating nvram partition scan\\n\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\"",
            "phead.checksum",
            "c_sum"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&phead"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "738-750",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "phead.length"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "header",
            "NVRAM_HEADER_LEN",
            "&cur_index"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NVRAM_HEADER_LEN",
            "GFP_KERNEL"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_scan_partitions(void)\n{\n\tloff_t cur_index = 0;\n\tstruct nvram_header phead;\n\tstruct nvram_partition * tmp_part;\n\tunsigned char c_sum;\n\tchar * header;\n\tint total_size;\n\tint err;\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn -ENODEV;\n\ttotal_size = ppc_md.nvram_size();\n\t\n\theader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\n\tif (!header) {\n\t\tprintk(KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (cur_index < total_size) {\n\n\t\terr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\n\t\tif (err != NVRAM_HEADER_LEN) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcur_index -= NVRAM_HEADER_LEN; /* nvram_read will advance us */\n\n\t\tmemcpy(&phead, header, NVRAM_HEADER_LEN);\n\n\t\tphead.length = be16_to_cpu(phead.length);\n\n\t\terr = 0;\n\t\tc_sum = nvram_checksum(&phead);\n\t\tif (c_sum != phead.checksum) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\",\n\t\t\t       phead.checksum, c_sum);\n\t\t\tprintk(KERN_WARNING \"Terminating nvram partition scan\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!phead.length) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttmp_part = kmalloc(sizeof(*tmp_part), GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (!tmp_part) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\n\t\ttmp_part->index = cur_index;\n\t\tlist_add_tail(&tmp_part->partition, &nvram_partitions);\n\t\t\n\t\tcur_index += phead.length * NVRAM_BLOCK_LEN;\n\t}\n\terr = 0;\n\n#ifdef DEBUG_NVRAM\n\tnvram_print_partitions(\"NVRAM Partitions\");\n#endif\n\n out:\n\tkfree(header);\n\treturn err;\n}"
  },
  {
    "function_name": "nvram_find_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "966-980",
    "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p->header.name",
            "name",
            "12"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&nvram_partitions",
            "partition"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_get_partition_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "948-957",
    "snippet": "int nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "nvram_create_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "841-940",
    "snippet": "loff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = ALIGN(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = ALIGN(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kzalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tmemcpy(new_part->header.name, name, strnlen(name, sizeof(new_part->header.name)));\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "nv_init_vals",
            "NVRAM_BLOCK_LEN",
            "&tmp_index"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free_part"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&free_part->partition"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write_header failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_write_header",
          "args": [
            "free_part"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "722-735",
          "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&free_part->header"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "738-750",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_part->partition",
            "&free_part->partition"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_part"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write_header failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_part->header.name",
            "name",
            "strnlen(name, sizeof(new_part->header.name))"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "name",
            "sizeof(new_part->header.name)"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: kmalloc failed\\n\"",
            "__func__"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new_part)",
            "GFP_KERNEL"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "min_size",
            "NVRAM_BLOCK_LEN"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "req_size",
            "NVRAM_BLOCK_LEN"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "NVRAM_BLOCK_LEN != 16"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = ALIGN(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = ALIGN(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kzalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tmemcpy(new_part->header.name, name, strnlen(name, sizeof(new_part->header.name)));\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}"
  },
  {
    "function_name": "nvram_remove_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "783-826",
    "snippet": "int __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tmemset(part->header.name, 'w', 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&prev->header);\n\t\t\trc = nvram_write_header(prev);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "part"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&part->partition"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\"",
            "rc"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_write_header",
          "args": [
            "prev"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "722-735",
          "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&prev->header"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "738-750",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "part",
            "tmp",
            "&nvram_partitions",
            "partition"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "part->header.name",
            "'w'",
            "12"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_can_remove_partition",
          "args": [
            "part",
            "name",
            "sig",
            "exceptions"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_can_remove_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "756-772",
          "snippet": "static int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tmemset(part->header.name, 'w', 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&prev->header);\n\t\t\trc = nvram_write_header(prev);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_can_remove_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "756-772",
    "snippet": "static int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*except",
            "part->header.name",
            "12"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nvram_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "738-750",
    "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
  },
  {
    "function_name": "nvram_write_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "722-735",
    "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "(char *)&phead",
            "NVRAM_HEADER_LEN",
            "&tmp_index"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "phead.length"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&phead",
            "&part->header",
            "NVRAM_HEADER_LEN"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "nvram_print_partitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "706-718",
    "snippet": "static void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\"",
            "tmp_part->index",
            "tmp_part->header.signature",
            "tmp_part->header.checksum",
            "tmp_part->header.length",
            "tmp_part->header.name"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp_part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"--------%s---------\\n\"",
            "label"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nstatic void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}"
  },
  {
    "function_name": "oops_to_nvram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "645-703",
    "snippet": "static void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tstatic unsigned int oops_count = 0;\n\tstatic bool panicking = false;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tsize_t text_len;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\tint rc = -1;\n\n\tswitch (reason) {\n\tcase KMSG_DUMP_SHUTDOWN:\n\t\t/* These are almost always orderly shutdowns. */\n\t\treturn;\n\tcase KMSG_DUMP_OOPS:\n\t\tbreak;\n\tcase KMSG_DUMP_PANIC:\n\t\tpanicking = true;\n\t\tbreak;\n\tcase KMSG_DUMP_EMERG:\n\t\tif (panicking)\n\t\t\t/* Panic report already captured. */\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\",\n\t\t       __func__, (int) reason);\n\t\treturn;\n\t}\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn;\n\n\tif (!spin_trylock_irqsave(&lock, flags))\n\t\treturn;\n\n\tif (big_oops_buf) {\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     big_oops_buf, big_oops_buf_sz, &text_len);\n\t\trc = zip_oops(text_len);\n\t}\n\tif (rc != 0) {\n\t\tkmsg_dump_rewind(dumper);\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     oops_data, oops_data_sz, &text_len);\n\t\terr_type = ERR_TYPE_KERNEL_PANIC;\n\t\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\t\toops_hdr->report_length = cpu_to_be16(text_len);\n\t\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\t}\n\n\t(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + text_len), err_type,\n\t\t++oops_count);\n\n\tspin_unlock_irqrestore(&lock, flags);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);",
      "static size_t big_oops_buf_sz;",
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_write_os_partition",
          "args": [
            "&oops_log_partition",
            "oops_buf",
            "(int) (sizeof(*oops_hdr) + text_len)",
            "err_type",
            "++oops_count"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "180-213",
          "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "text_len"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "false",
            "oops_data",
            "oops_data_sz",
            "&text_len"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_rewind",
          "args": [
            "dumper"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zip_oops",
          "args": [
            "text_len"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "zip_oops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "353-367",
          "snippet": "static int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *big_oops_buf, *oops_buf;",
            "static char *oops_data;",
            "static size_t oops_data_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "false",
            "big_oops_buf",
            "big_oops_buf_sz",
            "&text_len"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clobbering_unread_rtas_event",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\"",
            "__func__",
            "(int) reason"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);\nstatic size_t big_oops_buf_sz;\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tstatic unsigned int oops_count = 0;\n\tstatic bool panicking = false;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tsize_t text_len;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\tint rc = -1;\n\n\tswitch (reason) {\n\tcase KMSG_DUMP_SHUTDOWN:\n\t\t/* These are almost always orderly shutdowns. */\n\t\treturn;\n\tcase KMSG_DUMP_OOPS:\n\t\tbreak;\n\tcase KMSG_DUMP_PANIC:\n\t\tpanicking = true;\n\t\tbreak;\n\tcase KMSG_DUMP_EMERG:\n\t\tif (panicking)\n\t\t\t/* Panic report already captured. */\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\",\n\t\t       __func__, (int) reason);\n\t\treturn;\n\t}\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn;\n\n\tif (!spin_trylock_irqsave(&lock, flags))\n\t\treturn;\n\n\tif (big_oops_buf) {\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     big_oops_buf, big_oops_buf_sz, &text_len);\n\t\trc = zip_oops(text_len);\n\t}\n\tif (rc != 0) {\n\t\tkmsg_dump_rewind(dumper);\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     oops_data, oops_data_sz, &text_len);\n\t\terr_type = ERR_TYPE_KERNEL_PANIC;\n\t\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\t\toops_hdr->report_length = cpu_to_be16(text_len);\n\t\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\t}\n\n\t(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + text_len), err_type,\n\t\t++oops_count);\n\n\tspin_unlock_irqrestore(&lock, flags);\n}"
  },
  {
    "function_name": "nvram_init_oops_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "571-636",
    "snippet": "void __init nvram_init_oops_partition(int rtas_partition_exists)\n{\n\tint rc;\n\n\trc = nvram_init_os_partition(&oops_log_partition);\n\tif (rc != 0) {\n#ifdef CONFIG_PPC_PSERIES\n\t\tif (!rtas_partition_exists) {\n\t\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\",\n\t\t\trtas_log_partition.name);\n\t\tmemcpy(&oops_log_partition, &rtas_log_partition,\n\t\t\t\t\t\tsizeof(rtas_log_partition));\n#else\n\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\treturn;\n#endif\n\t}\n\toops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\n\tif (!oops_buf) {\n\t\tpr_err(\"nvram: No memory for %s partition\\n\",\n\t\t\t\t\t\toops_log_partition.name);\n\t\treturn;\n\t}\n\toops_data = oops_buf + sizeof(struct oops_log_info);\n\toops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\n\n\trc = nvram_pstore_init();\n\n\tif (!rc)\n\t\treturn;\n\n\t/*\n\t * Figure compression (preceded by elimination of each line's <n>\n\t * severity prefix) will reduce the oops/panic report to at most\n\t * 45% of its original size.\n\t */\n\tbig_oops_buf_sz = (oops_data_sz * 100) / 45;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tstream.workspace =  kmalloc(zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\",\n\t\t\t\toops_log_partition.name);\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\", oops_log_partition.name);\n\t\tstream.workspace = NULL;\n\t}\n\n\trc = kmsg_dump_register(&nvram_kmsg_dumper);\n\tif (rc != 0) {\n\t\tpr_err(\"nvram: kmsg_dump_register() failed; returned %d\\n\", rc);\n\t\tkfree(oops_buf);\n\t\tkfree(big_oops_buf);\n\t\tkfree(stream.workspace);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12"
    ],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static struct kmsg_dumper nvram_kmsg_dumper = {\n\t.dump = oops_to_nvram\n};",
      "static size_t big_oops_buf_sz;",
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;",
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stream.workspace"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "big_oops_buf"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oops_buf"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: kmsg_dump_register() failed; returned %d\\n\"",
            "rc"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_register",
          "args": [
            "&nvram_kmsg_dumper"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\"",
            "oops_log_partition.name"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "big_oops_buf"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\"",
            "oops_log_partition.name"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL)",
            "GFP_KERNEL"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate_workspacesize",
          "args": [
            "WINDOW_BITS",
            "MEM_LEVEL"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "big_oops_buf_sz",
            "GFP_KERNEL"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_pstore_init",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_pstore_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "565-568",
          "snippet": "static int nvram_pstore_init(void)\n{\n\treturn -1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int nvram_pstore_init(void)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: No memory for %s partition\\n\"",
            "oops_log_partition.name"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "oops_log_partition.size",
            "GFP_KERNEL"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to initialize oops partition!\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&oops_log_partition",
            "&rtas_log_partition",
            "sizeof(rtas_log_partition)"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\"",
            "rtas_log_partition.name"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to initialize oops partition!\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_init_os_partition",
          "args": [
            "&oops_log_partition"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_init_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "274-315",
          "snippet": "int __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};\n\nint __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic struct kmsg_dumper nvram_kmsg_dumper = {\n\t.dump = oops_to_nvram\n};\nstatic size_t big_oops_buf_sz;\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\nstatic struct z_stream_s stream;\n\nvoid __init nvram_init_oops_partition(int rtas_partition_exists)\n{\n\tint rc;\n\n\trc = nvram_init_os_partition(&oops_log_partition);\n\tif (rc != 0) {\n#ifdef CONFIG_PPC_PSERIES\n\t\tif (!rtas_partition_exists) {\n\t\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\",\n\t\t\trtas_log_partition.name);\n\t\tmemcpy(&oops_log_partition, &rtas_log_partition,\n\t\t\t\t\t\tsizeof(rtas_log_partition));\n#else\n\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\treturn;\n#endif\n\t}\n\toops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\n\tif (!oops_buf) {\n\t\tpr_err(\"nvram: No memory for %s partition\\n\",\n\t\t\t\t\t\toops_log_partition.name);\n\t\treturn;\n\t}\n\toops_data = oops_buf + sizeof(struct oops_log_info);\n\toops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\n\n\trc = nvram_pstore_init();\n\n\tif (!rc)\n\t\treturn;\n\n\t/*\n\t * Figure compression (preceded by elimination of each line's <n>\n\t * severity prefix) will reduce the oops/panic report to at most\n\t * 45% of its original size.\n\t */\n\tbig_oops_buf_sz = (oops_data_sz * 100) / 45;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tstream.workspace =  kmalloc(zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\",\n\t\t\t\toops_log_partition.name);\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\", oops_log_partition.name);\n\t\tstream.workspace = NULL;\n\t}\n\n\trc = kmsg_dump_register(&nvram_kmsg_dumper);\n\tif (rc != 0) {\n\t\tpr_err(\"nvram: kmsg_dump_register() failed; returned %d\\n\", rc);\n\t\tkfree(oops_buf);\n\t\tkfree(big_oops_buf);\n\t\tkfree(stream.workspace);\n\t}\n}"
  },
  {
    "function_name": "nvram_pstore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "565-568",
    "snippet": "static int nvram_pstore_init(void)\n{\n\treturn -1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int nvram_pstore_init(void)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "nvram_pstore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "543-563",
    "snippet": "static int nvram_pstore_init(void)\n{\n\tint rc = 0;\n\n\tif (machine_is(pseries)) {\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_RTAS;\n\t\tnvram_type_ids[3] = PSTORE_TYPE_PPC_OF;\n\t} else\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_OPAL;\n\n\tnvram_pstore_info.buf = oops_data;\n\tnvram_pstore_info.bufsize = oops_data_sz;\n\n\trc = pstore_register(&nvram_pstore_info);\n\tif (rc && (rc != -EPERM))\n\t\t/* Print error only when pstore.backend == nvram */\n\t\tpr_err(\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\"",
            "rc"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_register",
          "args": [
            "&nvram_pstore_info"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int nvram_pstore_init(void)\n{\n\tint rc = 0;\n\n\tif (machine_is(pseries)) {\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_RTAS;\n\t\tnvram_type_ids[3] = PSTORE_TYPE_PPC_OF;\n\t} else\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_OPAL;\n\n\tnvram_pstore_info.buf = oops_data;\n\tnvram_pstore_info.bufsize = oops_data_sz;\n\n\trc = pstore_register(&nvram_pstore_info);\n\tif (rc && (rc != -EPERM))\n\t\t/* Print error only when pstore.backend == nvram */\n\t\tpr_err(\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "nvram_pstore_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "421-532",
    "snippet": "static ssize_t nvram_pstore_read(struct pstore_record *record)\n{\n\tstruct oops_log_info *oops_hdr;\n\tunsigned int err_type, id_no, size = 0;\n\tstruct nvram_os_partition *part = NULL;\n\tchar *buff = NULL;\n\tint sig = 0;\n\tloff_t p;\n\n\tread_type++;\n\n\tswitch (nvram_type_ids[read_type]) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tpart = &oops_log_partition;\n\t\trecord->type = PSTORE_TYPE_DMESG;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tsig = NVRAM_SIG_SYS;\n\t\tpart = &common_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_COMMON;\n\t\trecord->id = PSTORE_TYPE_PPC_COMMON;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#ifdef CONFIG_PPC_PSERIES\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tpart = &rtas_log_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_RTAS;\n\t\trecord->time.tv_sec = last_rtas_event;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tsig = NVRAM_SIG_OF;\n\t\tpart = &of_config_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_OF;\n\t\trecord->id = PSTORE_TYPE_PPC_OF;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#endif\n#ifdef CONFIG_PPC_POWERNV\n\tcase PSTORE_TYPE_PPC_OPAL:\n\t\tsig = NVRAM_SIG_FW;\n\t\tpart = &skiboot_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_OPAL;\n\t\trecord->id = PSTORE_TYPE_PPC_OPAL;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!part->os_partition) {\n\t\tp = nvram_find_partition(part->name, sig, &size);\n\t\tif (p <= 0) {\n\t\t\tpr_err(\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\", part->name, (int)p);\n\t\t\treturn 0;\n\t\t}\n\t\tpart->index = p;\n\t\tpart->size = size;\n\t}\n\n\tbuff = kmalloc(part->size, GFP_KERNEL);\n\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\n\t\tkfree(buff);\n\t\treturn 0;\n\t}\n\n\trecord->count = 0;\n\n\tif (part->os_partition)\n\t\trecord->id = id_no;\n\n\tif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\n\t\tsize_t length, hdr_size;\n\n\t\toops_hdr = (struct oops_log_info *)buff;\n\t\tif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\n\t\t\t/* Old format oops header had 2-byte record size */\n\t\t\thdr_size = sizeof(u16);\n\t\t\tlength = be16_to_cpu(oops_hdr->version);\n\t\t\trecord->time.tv_sec = 0;\n\t\t\trecord->time.tv_nsec = 0;\n\t\t} else {\n\t\t\thdr_size = sizeof(*oops_hdr);\n\t\t\tlength = be16_to_cpu(oops_hdr->report_length);\n\t\t\trecord->time.tv_sec = be64_to_cpu(oops_hdr->timestamp);\n\t\t\trecord->time.tv_nsec = 0;\n\t\t}\n\t\trecord->buf = kmemdup(buff + hdr_size, length, GFP_KERNEL);\n\t\tkfree(buff);\n\t\tif (record->buf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\trecord->ecc_notice_size = 0;\n\t\tif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\n\t\t\trecord->compressed = true;\n\t\telse\n\t\t\trecord->compressed = false;\n\t\treturn length;\n\t}\n\n\trecord->buf = buff;\n\treturn part->size;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "buff + hdr_size",
            "length",
            "GFP_KERNEL"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oops_hdr->timestamp"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->report_length"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->version"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->version"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_read_partition",
          "args": [
            "part",
            "buff",
            "part->size",
            "&err_type",
            "&id_no"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_read_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "219-255",
          "snippet": "int nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info, sizeof(info), &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nint nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info, sizeof(info), &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "part->size",
            "GFP_KERNEL"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\"",
            "part->name",
            "(int)p"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_find_partition",
          "args": [
            "part->name",
            "sig",
            "&size"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_find_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "966-980",
          "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\n\nstatic ssize_t nvram_pstore_read(struct pstore_record *record)\n{\n\tstruct oops_log_info *oops_hdr;\n\tunsigned int err_type, id_no, size = 0;\n\tstruct nvram_os_partition *part = NULL;\n\tchar *buff = NULL;\n\tint sig = 0;\n\tloff_t p;\n\n\tread_type++;\n\n\tswitch (nvram_type_ids[read_type]) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tpart = &oops_log_partition;\n\t\trecord->type = PSTORE_TYPE_DMESG;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tsig = NVRAM_SIG_SYS;\n\t\tpart = &common_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_COMMON;\n\t\trecord->id = PSTORE_TYPE_PPC_COMMON;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#ifdef CONFIG_PPC_PSERIES\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tpart = &rtas_log_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_RTAS;\n\t\trecord->time.tv_sec = last_rtas_event;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tsig = NVRAM_SIG_OF;\n\t\tpart = &of_config_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_OF;\n\t\trecord->id = PSTORE_TYPE_PPC_OF;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#endif\n#ifdef CONFIG_PPC_POWERNV\n\tcase PSTORE_TYPE_PPC_OPAL:\n\t\tsig = NVRAM_SIG_FW;\n\t\tpart = &skiboot_partition;\n\t\trecord->type = PSTORE_TYPE_PPC_OPAL;\n\t\trecord->id = PSTORE_TYPE_PPC_OPAL;\n\t\trecord->time.tv_sec = 0;\n\t\trecord->time.tv_nsec = 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!part->os_partition) {\n\t\tp = nvram_find_partition(part->name, sig, &size);\n\t\tif (p <= 0) {\n\t\t\tpr_err(\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\", part->name, (int)p);\n\t\t\treturn 0;\n\t\t}\n\t\tpart->index = p;\n\t\tpart->size = size;\n\t}\n\n\tbuff = kmalloc(part->size, GFP_KERNEL);\n\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\n\t\tkfree(buff);\n\t\treturn 0;\n\t}\n\n\trecord->count = 0;\n\n\tif (part->os_partition)\n\t\trecord->id = id_no;\n\n\tif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\n\t\tsize_t length, hdr_size;\n\n\t\toops_hdr = (struct oops_log_info *)buff;\n\t\tif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\n\t\t\t/* Old format oops header had 2-byte record size */\n\t\t\thdr_size = sizeof(u16);\n\t\t\tlength = be16_to_cpu(oops_hdr->version);\n\t\t\trecord->time.tv_sec = 0;\n\t\t\trecord->time.tv_nsec = 0;\n\t\t} else {\n\t\t\thdr_size = sizeof(*oops_hdr);\n\t\t\tlength = be16_to_cpu(oops_hdr->report_length);\n\t\t\trecord->time.tv_sec = be64_to_cpu(oops_hdr->timestamp);\n\t\t\trecord->time.tv_nsec = 0;\n\t\t}\n\t\trecord->buf = kmemdup(buff + hdr_size, length, GFP_KERNEL);\n\t\tkfree(buff);\n\t\tif (record->buf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\trecord->ecc_notice_size = 0;\n\t\tif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\n\t\t\trecord->compressed = true;\n\t\telse\n\t\t\trecord->compressed = false;\n\t\treturn length;\n\t}\n\n\trecord->buf = buff;\n\treturn part->size;\n}"
  },
  {
    "function_name": "nvram_pstore_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "385-414",
    "snippet": "static int nvram_pstore_write(struct pstore_record *record)\n{\n\tint rc;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\n\n\t/* part 1 has the recent messages from printk buffer */\n\tif (record->part > 1 || (record->type != PSTORE_TYPE_DMESG))\n\t\treturn -1;\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn -1;\n\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(record->size);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\n\tif (record->compressed)\n\t\terr_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\n\trc = nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + record->size), err_type,\n\t\trecord->count);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\trecord->id = record->part;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static char *big_oops_buf, *oops_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvram_write_os_partition",
          "args": [
            "&oops_log_partition",
            "oops_buf",
            "(int) (sizeof(*oops_hdr) + record->size)",
            "err_type",
            "record->count"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "180-213",
          "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "record->size"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clobbering_unread_rtas_event",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic char *big_oops_buf, *oops_buf;\n\nstatic int nvram_pstore_write(struct pstore_record *record)\n{\n\tint rc;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\n\n\t/* part 1 has the recent messages from printk buffer */\n\tif (record->part > 1 || (record->type != PSTORE_TYPE_DMESG))\n\t\treturn -1;\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn -1;\n\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(record->size);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\n\tif (record->compressed)\n\t\terr_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\n\trc = nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + record->size), err_type,\n\t\trecord->count);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\trecord->id = record->part;\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_pstore_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "370-375",
    "snippet": "static int nvram_pstore_open(struct pstore_info *psi)\n{\n\t/* Reset the iterator to start reading partitions again */\n\tread_type = -1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int nvram_pstore_open(struct pstore_info *psi)\n{\n\t/* Reset the iterator to start reading partitions again */\n\tread_type = -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "zip_oops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "353-367",
    "snippet": "static int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "zipped_len"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: logging uncompressed oops/panic report\\n\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: compression failed; returned %d\\n\"",
            "zipped_len"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_compress",
          "args": [
            "big_oops_buf",
            "oops_data",
            "text_len",
            "oops_data_sz"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "318-350",
          "snippet": "static int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MEM_LEVEL 4",
            "#define WINDOW_BITS 12",
            "#define COMPR_LEVEL 6"
          ],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "318-350",
    "snippet": "static int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12",
      "#define COMPR_LEVEL 6"
    ],
    "globals_used": [
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zlib_deflateEnd",
          "args": [
            "&stream"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate",
          "args": [
            "&stream",
            "Z_FINISH"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflateInit2",
          "args": [
            "&stream",
            "COMPR_LEVEL",
            "Z_DEFLATED",
            "WINDOW_BITS",
            "MEM_LEVEL",
            "Z_DEFAULT_STRATEGY"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "nvram_init_os_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "274-315",
    "snippet": "int __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvram_get_partition_size",
          "args": [
            "p"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_get_partition_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "948-957",
          "snippet": "int nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\"",
            "part->name",
            "(int)p"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_create_partition",
          "args": [
            "part->name",
            "NVRAM_SIG_OS",
            "part->req_size",
            "part->min_size"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_create_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "841-940",
          "snippet": "loff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = ALIGN(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = ALIGN(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kzalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tmemcpy(new_part->header.name, name, strnlen(name, sizeof(new_part->header.name)));\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = ALIGN(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = ALIGN(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kzalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tmemcpy(new_part->header.name, name, strnlen(name, sizeof(new_part->header.name)));\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_remove_partition",
          "args": [
            "NULL",
            "NVRAM_SIG_OS",
            "nvram_os_partitions"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_remove_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "783-826",
          "snippet": "int __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tmemset(part->header.name, 'w', 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&prev->header);\n\t\t\trc = nvram_write_header(prev);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tmemset(part->header.name, 'w', 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&prev->header);\n\t\t\trc = nvram_write_header(prev);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\"",
            "part->name"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\"",
            "part->name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_find_partition",
          "args": [
            "part->name",
            "NVRAM_SIG_OS",
            "&size"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_find_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "966-980",
          "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};\n\nint __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_read_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "219-255",
    "snippet": "int nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info, sizeof(info), &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "info.error_type"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "info.seq_num"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_read (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "buff",
            "length",
            "&tmp_index"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_read (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "(char *)&info",
            "sizeof(info)",
            "&tmp_index"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nint nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info, sizeof(info), &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_write_os_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "180-213",
    "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_write (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "buff",
            "length",
            "&tmp_index"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_write (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "(char *)&info",
            "sizeof(info)",
            "&tmp_index"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "error_log_cnt"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "err_type"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <linux/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/pagemap.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(info), &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  }
]