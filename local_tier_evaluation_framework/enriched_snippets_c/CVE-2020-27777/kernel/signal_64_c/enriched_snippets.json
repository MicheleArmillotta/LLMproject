[
  {
    "function_name": "handle_rt_signal64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "813-922",
    "snippet": "int handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\tstruct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *frame;\n\tunsigned long newsp = 0;\n\tlong err = 0;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 0);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __save_altstack(&frame->uc.uc_stack, regs->gpr[1]);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* The ucontext_t passed to userland points to the second\n\t\t * ucontext_t (for transactional state) with its uc_link ptr.\n\t\t */\n\t\terr |= __put_user(&frame->uc_transact, &frame->uc.uc_link);\n\t\terr |= setup_tm_sigcontexts(&frame->uc.uc_mcontext,\n\t\t\t\t\t    &frame->uc_transact.uc_mcontext,\n\t\t\t\t\t    tsk, ksig->sig, NULL,\n\t\t\t\t\t    (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t    msr);\n\t} else\n#endif\n\t{\n\t\terr |= __put_user(0, &frame->uc.uc_link);\n\t\terr |= setup_sigcontext(&frame->uc.uc_mcontext, tsk, ksig->sig,\n\t\t\t\t\tNULL, (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t1);\n\t}\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Make sure signal handler doesn't get spurious FP exceptions */\n\ttsk->thread.fp_state.fpscr = 0;\n\n\t/* Set up to return from userspace. */\n\tif (vdso64_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tregs->nip = tsk->mm->context.vdso_base + vdso64_rt_sigtramp;\n\t} else {\n\t\terr |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);\n\t\tif (err)\n\t\t\tgoto badframe;\n\t\tregs->nip = (unsigned long) &frame->tramp[0];\n\t}\n\n\t/* Allocate a dummy caller frame for the signal handler. */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\terr |= put_user(regs->gpr[1], (unsigned long __user *)newsp);\n\n\t/* Set up \"regs\" so we \"return\" to the signal handler. */\n\tif (is_elf2_task()) {\n\t\tregs->ctr = (unsigned long) ksig->ka.sa.sa_handler;\n\t\tregs->gpr[12] = regs->ctr;\n\t} else {\n\t\t/* Handler is *really* a pointer to the function descriptor for\n\t\t * the signal routine.  The first entry in the function\n\t\t * descriptor is the entry address of signal and the second\n\t\t * entry is the TOC value we need to use.\n\t\t */\n\t\tfunc_descr_t __user *funct_desc_ptr =\n\t\t\t(func_descr_t __user *) ksig->ka.sa.sa_handler;\n\n\t\terr |= get_user(regs->ctr, &funct_desc_ptr->entry);\n\t\terr |= get_user(regs->gpr[2], &funct_desc_ptr->toc);\n\t}\n\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->result = 0;\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\terr |= get_user(regs->gpr[4], (unsigned long __user *)&frame->pinfo);\n\t\terr |= get_user(regs->gpr[5], (unsigned long __user *)&frame->puc);\n\t\tregs->gpr[6] = (unsigned long) frame;\n\t} else {\n\t\tregs->gpr[4] = (unsigned long)&frame->uc.uc_mcontext;\n\t}\n\tif (err)\n\t\tgoto badframe;\n\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   tsk->comm, tsk->pid, \"setup_rt_frame\",\n\t\t\t\t   (long)frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";",
      "static const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "regs->msr & MSR_64BIT ? fmt64 : fmt32",
            "tsk->comm",
            "tsk->pid",
            "\"setup_rt_frame\"",
            "(long)frame",
            "regs->nip",
            "regs->link"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "regs->gpr[5]",
            "(unsigned long __user *)&frame->puc"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "135-138",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_elf2_task",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(unsigned long __user *)newsp"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_trampoline",
          "args": [
            "__NR_rt_sigreturn",
            "&frame->tramp[0]"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "setup_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "599-623",
          "snippet": "static long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* bctrl # call the handler */\n\terr |= __put_user(PPC_INST_BCTRL, &tramp[0]);\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(PPC_INST_ADDI | __PPC_RT(R1) | __PPC_RA(R1) |\n\t\t\t  (__SIGNAL_FRAMESIZE & 0xffff), &tramp[1]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(PPC_INST_ADDI | (syscall & 0xffff), &tramp[2]);\n\t/* sc */\n\terr |= __put_user(PPC_INST_SC, &tramp[3]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TRAMP_SIZE\t7",
            "#define TRAMP_TRACEBACK\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define TRAMP_SIZE\t7\n#define TRAMP_TRACEBACK\t4\n\nstatic long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* bctrl # call the handler */\n\terr |= __put_user(PPC_INST_BCTRL, &tramp[0]);\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(PPC_INST_ADDI | __PPC_RT(R1) | __PPC_RA(R1) |\n\t\t\t  (__SIGNAL_FRAMESIZE & 0xffff), &tramp[1]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(PPC_INST_ADDI | (syscall & 0xffff), &tramp[2]);\n\t/* sc */\n\terr |= __put_user(PPC_INST_SC, &tramp[3]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->uc.uc_sigmask",
            "set",
            "sizeof(*set)"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_sigcontext",
          "args": [
            "&frame->uc.uc_mcontext",
            "tsk",
            "ksig->sig",
            "NULL",
            "(unsigned long)ksig->ka.sa.sa_handler",
            "1"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "setup_sigcontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "91-178",
          "snippet": "static long setup_sigcontext(struct sigcontext __user *sc,\n\t\tstruct task_struct *tsk, int signr, sigset_t *set,\n\t\tunsigned long handler, int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\tunsigned long vrsave;\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\tunsigned long softe = 0x1;\n\n\tBUG_ON(tsk != current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\tflush_altivec_to_thread(tsk);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tvrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC)) {\n\t\tvrsave = mfspr(SPRN_VRSAVE);\n\t\ttsk->thread.vrsave = vrsave;\n\t}\n\n\terr |= __put_user(vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(tsk);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, tsk);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(tsk);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, tsk);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(softe, &sc->gp_regs[PT_SOFTE]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_sigcontext(struct sigcontext __user *sc,\n\t\tstruct task_struct *tsk, int signr, sigset_t *set,\n\t\tunsigned long handler, int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\tunsigned long vrsave;\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\tunsigned long softe = 0x1;\n\n\tBUG_ON(tsk != current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\tflush_altivec_to_thread(tsk);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tvrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC)) {\n\t\tvrsave = mfspr(SPRN_VRSAVE);\n\t\ttsk->thread.vrsave = vrsave;\n\t}\n\n\terr |= __put_user(vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(tsk);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, tsk);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(tsk);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, tsk);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(softe, &sc->gp_regs[PT_SOFTE]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&frame->uc.uc_link"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_tm_sigcontexts",
          "args": [
            "&frame->uc.uc_mcontext",
            "&frame->uc_transact.uc_mcontext",
            "tsk",
            "ksig->sig",
            "NULL",
            "(unsigned long)ksig->ka.sa.sa_handler",
            "msr"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "setup_tm_sigcontexts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "192-314",
          "snippet": "static long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct task_struct *tsk,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t\t\t unsigned long msr)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tlong err = 0;\n\n\tBUG_ON(tsk != current);\n\n\tBUG_ON(!MSR_TM_ACTIVE(msr));\n\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Restore checkpointed FP, VEC, and VSX bits from ckpt_regs as\n\t * it contains the correct FP, VEC, VSX state after we treclaimed\n\t * the transaction and giveup_all() was called on reclaiming.\n\t */\n\tmsr |= tsk->thread.ckpt_regs.msr & (MSR_FP | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.ckvr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.ckvr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\ttsk->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(tsk->thread.ckvrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_ckfpr_to_user(&sc->fp_regs, tsk);\n\tif (msr & MSR_FP)\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, tsk);\n\telse\n\t\terr |= copy_ckfpr_to_user(&tm_sc->fp_regs, tsk);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_ckvsx_to_user(v_regs, tsk);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, tsk);\n\t\telse\n\t\t\terr |= copy_ckvsx_to_user(tm_v_regs, tsk);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &tsk->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct task_struct *tsk,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t\t\t unsigned long msr)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tlong err = 0;\n\n\tBUG_ON(tsk != current);\n\n\tBUG_ON(!MSR_TM_ACTIVE(msr));\n\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Restore checkpointed FP, VEC, and VSX bits from ckpt_regs as\n\t * it contains the correct FP, VEC, VSX state after we treclaimed\n\t * the transaction and giveup_all() was called on reclaiming.\n\t */\n\tmsr |= tsk->thread.ckpt_regs.msr & (MSR_FP | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.ckvr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.ckvr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\ttsk->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(tsk->thread.ckvrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_ckfpr_to_user(&sc->fp_regs, tsk);\n\tif (msr & MSR_FP)\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, tsk);\n\telse\n\t\terr |= copy_ckfpr_to_user(&tm_sc->fp_regs, tsk);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_ckvsx_to_user(v_regs, tsk);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, tsk);\n\t\telse\n\t\t\terr |= copy_ckvsx_to_user(tm_v_regs, tsk);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &tsk->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->uc_transact",
            "&frame->uc.uc_link"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_altstack",
          "args": [
            "&frame->uc.uc_stack",
            "regs->gpr[1]"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&frame->uc.uc_flags"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "&frame->info",
            "&ksig->info"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->uc",
            "&frame->puc"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->info",
            "&frame->pinfo"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "frame == NULL"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(tsk)",
            "sizeof(*frame)",
            "0"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "177-192",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "tsk"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "338-385",
          "snippet": "unsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";\nstatic const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";\n\nint handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\tstruct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *frame;\n\tunsigned long newsp = 0;\n\tlong err = 0;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 0);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __save_altstack(&frame->uc.uc_stack, regs->gpr[1]);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* The ucontext_t passed to userland points to the second\n\t\t * ucontext_t (for transactional state) with its uc_link ptr.\n\t\t */\n\t\terr |= __put_user(&frame->uc_transact, &frame->uc.uc_link);\n\t\terr |= setup_tm_sigcontexts(&frame->uc.uc_mcontext,\n\t\t\t\t\t    &frame->uc_transact.uc_mcontext,\n\t\t\t\t\t    tsk, ksig->sig, NULL,\n\t\t\t\t\t    (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t    msr);\n\t} else\n#endif\n\t{\n\t\terr |= __put_user(0, &frame->uc.uc_link);\n\t\terr |= setup_sigcontext(&frame->uc.uc_mcontext, tsk, ksig->sig,\n\t\t\t\t\tNULL, (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t1);\n\t}\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Make sure signal handler doesn't get spurious FP exceptions */\n\ttsk->thread.fp_state.fpscr = 0;\n\n\t/* Set up to return from userspace. */\n\tif (vdso64_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tregs->nip = tsk->mm->context.vdso_base + vdso64_rt_sigtramp;\n\t} else {\n\t\terr |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);\n\t\tif (err)\n\t\t\tgoto badframe;\n\t\tregs->nip = (unsigned long) &frame->tramp[0];\n\t}\n\n\t/* Allocate a dummy caller frame for the signal handler. */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\terr |= put_user(regs->gpr[1], (unsigned long __user *)newsp);\n\n\t/* Set up \"regs\" so we \"return\" to the signal handler. */\n\tif (is_elf2_task()) {\n\t\tregs->ctr = (unsigned long) ksig->ka.sa.sa_handler;\n\t\tregs->gpr[12] = regs->ctr;\n\t} else {\n\t\t/* Handler is *really* a pointer to the function descriptor for\n\t\t * the signal routine.  The first entry in the function\n\t\t * descriptor is the entry address of signal and the second\n\t\t * entry is the TOC value we need to use.\n\t\t */\n\t\tfunc_descr_t __user *funct_desc_ptr =\n\t\t\t(func_descr_t __user *) ksig->ka.sa.sa_handler;\n\n\t\terr |= get_user(regs->ctr, &funct_desc_ptr->entry);\n\t\terr |= get_user(regs->gpr[2], &funct_desc_ptr->toc);\n\t}\n\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->result = 0;\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\terr |= get_user(regs->gpr[4], (unsigned long __user *)&frame->pinfo);\n\t\terr |= get_user(regs->gpr[5], (unsigned long __user *)&frame->puc);\n\t\tregs->gpr[6] = (unsigned long) frame;\n\t} else {\n\t\tregs->gpr[4] = (unsigned long)&frame->uc.uc_mcontext;\n\t}\n\tif (err)\n\t\tgoto badframe;\n\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   tsk->comm, tsk->pid, \"setup_rt_frame\",\n\t\t\t\t   (long)frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "599-623",
    "snippet": "static long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* bctrl # call the handler */\n\terr |= __put_user(PPC_INST_BCTRL, &tramp[0]);\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(PPC_INST_ADDI | __PPC_RT(R1) | __PPC_RA(R1) |\n\t\t\t  (__SIGNAL_FRAMESIZE & 0xffff), &tramp[1]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(PPC_INST_ADDI | (syscall & 0xffff), &tramp[2]);\n\t/* sc */\n\terr |= __put_user(PPC_INST_SC, &tramp[3]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define TRAMP_SIZE\t7",
      "#define TRAMP_TRACEBACK\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &tramp[0]",
            "(unsigned long) &tramp[TRAMP_SIZE]"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tramp[i]"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_SC",
            "&tramp[3]"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_ADDI | (syscall & 0xffff)",
            "&tramp[2]"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_ADDI | __PPC_RT(R1) | __PPC_RA(R1) |\n\t\t\t  (__SIGNAL_FRAMESIZE & 0xffff)",
            "&tramp[1]"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RA",
          "args": [
            "R1"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R1"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_BCTRL",
            "&tramp[0]"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define TRAMP_SIZE\t7\n#define TRAMP_TRACEBACK\t4\n\nstatic long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* bctrl # call the handler */\n\terr |= __put_user(PPC_INST_BCTRL, &tramp[0]);\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(PPC_INST_ADDI | __PPC_RT(R1) | __PPC_RA(R1) |\n\t\t\t  (__SIGNAL_FRAMESIZE & 0xffff), &tramp[1]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(PPC_INST_ADDI | (syscall & 0xffff), &tramp[2]);\n\t/* sc */\n\terr |= __put_user(PPC_INST_SC, &tramp[3]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}"
  },
  {
    "function_name": "restore_tm_sigcontexts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "418-593",
    "snippet": "static long restore_tm_sigcontexts(struct task_struct *tsk,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\tif (tm_suspend_disabled)\n\t\treturn -EINVAL;\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&tsk->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(tsk->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(tsk->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(tsk->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(tsk->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(tsk->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\t/* Don't allow userspace to set SOFTE */\n\tset_trap_norestart(regs);\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into tsk->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&tsk->thread.ckvr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&tsk->thread.vr_state, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\tcurrent->thread.used_vr = true;\n\t}\n\telse if (tsk->thread.used_vr) {\n\t\tmemset(&tsk->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&tsk->thread.ckvr_state, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\ttsk->thread.vrsave = 0;\n\t\ttsk->thread.ckvrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, tsk->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(tsk, &tm_sc->fp_regs);\n\terr |= copy_ckfpr_from_user(tsk, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(tsk, tm_v_regs);\n\t\terr |= copy_ckvsx_from_user(tsk, v_regs);\n\t\ttsk->thread.used_vsr = true;\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\ttsk->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\ttsk->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\ttsk->thread.tm_texasr |= TEXASR_FS;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/* pull in MSR TS bits from user context */\n\tregs->msr |= msr & MSR_TS_MASK;\n\n\t/*\n\t * Ensure that TM is enabled in regs->msr before we leave the signal\n\t * handler. It could be the case that (a) user disabled the TM bit\n\t * through the manipulation of the MSR bits in uc_mcontext or (b) the\n\t * TM bit was disabled because a sufficient number of context switches\n\t * happened whilst in the signal handler and load_tm overflowed,\n\t * disabling the TM bit. In either case we can end up with an illegal\n\t * TM state leading to a TM Bad Thing when we return to userspace.\n\t *\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t */\n\tregs->msr |= MSR_TM;\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&tsk->thread);\n\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&tsk->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | tsk->thread.fpexc_mode);\n\t}\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&tsk->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n\n\tpreempt_enable();\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_vr_state",
          "args": [
            "&tsk->thread.vr_state"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_fp_state",
          "args": [
            "&tsk->thread.fp_state"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msr_check_and_set",
          "args": [
            "msr & (MSR_FP | MSR_VEC)"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "msr_check_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "120-134",
          "snippet": "unsigned long notrace msr_check_and_set(unsigned long bits)\n{\n\tunsigned long oldmsr = mfmsr();\n\tunsigned long newmsr;\n\n\tnewmsr = oldmsr | bits;\n\n\tif (cpu_has_feature(CPU_FTR_VSX) && (bits & MSR_FP))\n\t\tnewmsr |= MSR_VSX;\n\n\tif (oldmsr != newmsr)\n\t\tmtmsr_isync(newmsr);\n\n\treturn newmsr;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long notrace msr_check_and_set(unsigned long bits)\n{\n\tunsigned long oldmsr = mfmsr();\n\tunsigned long newmsr;\n\n\tnewmsr = oldmsr | bits;\n\n\tif (cpu_has_feature(CPU_FTR_VSX) && (bits & MSR_FP))\n\t\tnewmsr |= MSR_VSX;\n\n\tif (oldmsr != newmsr)\n\t\tmtmsr_isync(newmsr);\n\n\treturn newmsr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&tsk->thread"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1033-1069",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_ckvsx_from_user",
          "args": [
            "tsk",
            "v_regs"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckvsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "123-134",
          "snippet": "unsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "tsk",
            "tm_v_regs"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "69-80",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_ckfpr_from_user",
          "args": [
            "tsk",
            "&sc->fp_regs"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckfpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "159-164",
          "snippet": "inline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "tsk",
            "&tm_sc->fp_regs"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "144-149",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "tsk->thread.vrsave"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.vrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.ckvrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tsk->thread.ckvr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&tsk->thread.vr_state",
            "tm_v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&tsk->thread.ckvr_state",
            "v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "tm_v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tm_v_regs",
            "&tm_sc->v_regs"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->result",
            "&sc->gp_regs[PT_RESULT]"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dsisr",
            "&sc->gp_regs[PT_DSISR]"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dar",
            "&sc->gp_regs[PT_DAR]"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trap_norestart",
          "args": [
            "regs"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.ckpt_regs.ccr",
            "&sc->gp_regs[PT_CCR]"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.ckpt_regs.xer",
            "&sc->gp_regs[PT_XER]"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.ckpt_regs.link",
            "&sc->gp_regs[PT_LNK]"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.ckpt_regs.ctr",
            "&sc->gp_regs[PT_CTR]"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ccr",
            "&tm_sc->gp_regs[PT_CCR]"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->xer",
            "&tm_sc->gp_regs[PT_XER]"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->link",
            "&tm_sc->gp_regs[PT_LNK]"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ctr",
            "&tm_sc->gp_regs[PT_CTR]"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_RESV",
          "args": [
            "msr"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.tm_tfhar",
            "&sc->gp_regs[PT_NIP]"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->nip",
            "&tm_sc->gp_regs[PT_NIP]"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&tsk->thread.ckpt_regs",
            "sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs->gpr",
            "tm_sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_tm_sigcontexts(struct task_struct *tsk,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\tif (tm_suspend_disabled)\n\t\treturn -EINVAL;\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&tsk->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(tsk->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(tsk->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(tsk->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(tsk->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(tsk->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\t/* Don't allow userspace to set SOFTE */\n\tset_trap_norestart(regs);\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into tsk->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&tsk->thread.ckvr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&tsk->thread.vr_state, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\tcurrent->thread.used_vr = true;\n\t}\n\telse if (tsk->thread.used_vr) {\n\t\tmemset(&tsk->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&tsk->thread.ckvr_state, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\ttsk->thread.vrsave = 0;\n\t\ttsk->thread.ckvrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, tsk->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(tsk, &tm_sc->fp_regs);\n\terr |= copy_ckfpr_from_user(tsk, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(tsk, tm_v_regs);\n\t\terr |= copy_ckvsx_from_user(tsk, v_regs);\n\t\ttsk->thread.used_vsr = true;\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\ttsk->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\ttsk->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\ttsk->thread.tm_texasr |= TEXASR_FS;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/* pull in MSR TS bits from user context */\n\tregs->msr |= msr & MSR_TS_MASK;\n\n\t/*\n\t * Ensure that TM is enabled in regs->msr before we leave the signal\n\t * handler. It could be the case that (a) user disabled the TM bit\n\t * through the manipulation of the MSR bits in uc_mcontext or (b) the\n\t * TM bit was disabled because a sufficient number of context switches\n\t * happened whilst in the signal handler and load_tm overflowed,\n\t * disabling the TM bit. In either case we can end up with an illegal\n\t * TM state leading to a TM Bad Thing when we return to userspace.\n\t *\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t */\n\tregs->msr |= MSR_TM;\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&tsk->thread);\n\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&tsk->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | tsk->thread.fpexc_mode);\n\t}\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&tsk->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n\n\tpreempt_enable();\n\n\treturn err;\n}"
  },
  {
    "function_name": "restore_sigcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "321-411",
    "snippet": "static long restore_sigcontext(struct task_struct *tsk, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* Don't allow userspace to set SOFTE */\n\tset_trap_norestart(regs);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into tsk->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&tsk->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\ttsk->thread.used_vr = true;\n\t} else if (tsk->thread.used_vr) {\n\t\tmemset(&tsk->thread.vr_state, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(tsk->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\ttsk->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, tsk->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(tsk, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0) {\n\t\terr |= copy_vsx_from_user(tsk, v_regs);\n\t\ttsk->thread.used_vsr = true;\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttsk->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t}\n#endif\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "tsk",
            "v_regs"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "69-80",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "tsk",
            "&sc->fp_regs"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "144-149",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "tsk->thread.vrsave"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tsk->thread.vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tsk->thread.vr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&tsk->thread.vr_state",
            "v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->result",
            "&sc->gp_regs[PT_RESULT]"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dsisr",
            "&sc->gp_regs[PT_DSISR]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dar",
            "&sc->gp_regs[PT_DAR]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trap_norestart",
          "args": [
            "regs"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ccr",
            "&sc->gp_regs[PT_CCR]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->xer",
            "&sc->gp_regs[PT_XER]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->link",
            "&sc->gp_regs[PT_LNK]"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ctr",
            "&sc->gp_regs[PT_CTR]"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->orig_gpr3",
            "&sc->gp_regs[PT_ORIG_R3]"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->nip",
            "&sc->gp_regs[PT_NIP]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs->gpr",
            "sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_sigcontext(struct task_struct *tsk, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* Don't allow userspace to set SOFTE */\n\tset_trap_norestart(regs);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into tsk->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&tsk->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\ttsk->thread.used_vr = true;\n\t} else if (tsk->thread.used_vr) {\n\t\tmemset(&tsk->thread.vr_state, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(tsk->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\ttsk->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, tsk->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(tsk, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0) {\n\t\terr |= copy_vsx_from_user(tsk, v_regs);\n\t\ttsk->thread.used_vsr = true;\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttsk->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t}\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "setup_tm_sigcontexts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "192-314",
    "snippet": "static long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct task_struct *tsk,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t\t\t unsigned long msr)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tlong err = 0;\n\n\tBUG_ON(tsk != current);\n\n\tBUG_ON(!MSR_TM_ACTIVE(msr));\n\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Restore checkpointed FP, VEC, and VSX bits from ckpt_regs as\n\t * it contains the correct FP, VEC, VSX state after we treclaimed\n\t * the transaction and giveup_all() was called on reclaiming.\n\t */\n\tmsr |= tsk->thread.ckpt_regs.msr & (MSR_FP | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.ckvr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.ckvr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\ttsk->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(tsk->thread.ckvrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_ckfpr_to_user(&sc->fp_regs, tsk);\n\tif (msr & MSR_FP)\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, tsk);\n\telse\n\t\terr |= copy_ckfpr_to_user(&tm_sc->fp_regs, tsk);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_ckvsx_to_user(v_regs, tsk);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, tsk);\n\t\telse\n\t\t\terr |= copy_ckvsx_to_user(tm_v_regs, tsk);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &tsk->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "handler",
            "&sc->handler"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "signr",
            "&sc->signal"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&tm_sc->gp_regs[PT_MSR]"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&sc->gp_regs",
            "&tsk->thread.ckpt_regs",
            "GP_REGS_SIZE"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_sc->gp_regs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&tm_sc->gp_regs",
            "&tm_sc->regs"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&sc->gp_regs",
            "&sc->regs"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_ckvsx_to_user",
          "args": [
            "tm_v_regs",
            "tsk"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckvsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "111-121",
          "snippet": "unsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "tm_v_regs",
            "tsk"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "57-67",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_ckfpr_to_user",
          "args": [
            "&tm_sc->fp_regs",
            "tsk"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckfpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "152-157",
          "snippet": "inline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&tm_sc->fp_regs",
            "tsk"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "137-142",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tm_sc->v_regs"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&sc->v_regs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tsk->thread.ckvrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tsk->thread.vrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tsk->thread.ckvrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "tm_v_regs",
            "&tsk->thread.ckvr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "tm_v_regs",
            "&tsk->thread.vr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "v_regs",
            "&tsk->thread.ckvr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tm_v_regs",
            "&tm_sc->v_regs"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tm_suspend_disabled"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!MSR_TM_ACTIVE(msr)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigcontext_vmx_regs",
          "args": [
            "tm_sc"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sigcontext_vmx_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "81-84",
          "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct task_struct *tsk,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t\t\t unsigned long msr)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tlong err = 0;\n\n\tBUG_ON(tsk != current);\n\n\tBUG_ON(!MSR_TM_ACTIVE(msr));\n\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Restore checkpointed FP, VEC, and VSX bits from ckpt_regs as\n\t * it contains the correct FP, VEC, VSX state after we treclaimed\n\t * the transaction and giveup_all() was called on reclaiming.\n\t */\n\tmsr |= tsk->thread.ckpt_regs.msr & (MSR_FP | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.ckvr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &tsk->thread.ckvr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\ttsk->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(tsk->thread.ckvrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(tsk->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(tsk->thread.ckvrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_ckfpr_to_user(&sc->fp_regs, tsk);\n\tif (msr & MSR_FP)\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, tsk);\n\telse\n\t\terr |= copy_ckfpr_to_user(&tm_sc->fp_regs, tsk);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_ckvsx_to_user(v_regs, tsk);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, tsk);\n\t\telse\n\t\t\terr |= copy_ckvsx_to_user(tm_v_regs, tsk);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &tsk->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
  },
  {
    "function_name": "setup_sigcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "91-178",
    "snippet": "static long setup_sigcontext(struct sigcontext __user *sc,\n\t\tstruct task_struct *tsk, int signr, sigset_t *set,\n\t\tunsigned long handler, int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\tunsigned long vrsave;\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\tunsigned long softe = 0x1;\n\n\tBUG_ON(tsk != current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\tflush_altivec_to_thread(tsk);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tvrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC)) {\n\t\tvrsave = mfspr(SPRN_VRSAVE);\n\t\ttsk->thread.vrsave = vrsave;\n\t}\n\n\terr |= __put_user(vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(tsk);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, tsk);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(tsk);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, tsk);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(softe, &sc->gp_regs[PT_SOFTE]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "handler",
            "&sc->handler"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "signr",
            "&sc->signal"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "softe",
            "&sc->gp_regs[PT_SOFTE]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&sc->gp_regs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&sc->gp_regs",
            "&sc->regs"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "v_regs",
            "tsk"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "57-67",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "tsk"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&sc->fp_regs",
            "tsk"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "137-142",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "tsk"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&sc->v_regs"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "v_regs",
            "&tsk->thread.vr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "tsk"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigcontext_vmx_regs",
          "args": [
            "sc"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sigcontext_vmx_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "81-84",
          "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_sigcontext(struct sigcontext __user *sc,\n\t\tstruct task_struct *tsk, int signr, sigset_t *set,\n\t\tunsigned long handler, int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\tunsigned long vrsave;\n#endif\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\tunsigned long softe = 0x1;\n\n\tBUG_ON(tsk != current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (tsk->thread.used_vr) {\n\t\tflush_altivec_to_thread(tsk);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &tsk->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tvrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC)) {\n\t\tvrsave = mfspr(SPRN_VRSAVE);\n\t\ttsk->thread.vrsave = vrsave;\n\t}\n\n\terr |= __put_user(vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(tsk);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, tsk);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (tsk->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(tsk);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, tsk);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(softe, &sc->gp_regs[PT_SOFTE]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
  },
  {
    "function_name": "sigcontext_vmx_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "81-84",
    "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
  },
  {
    "function_name": "swapcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "635-697",
    "snippet": "SYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\tstruct ucontext __user *, new_ctx, long, ctx_size)\n{\n\tsigset_t set;\n\tunsigned long new_msr = 0;\n\tint ctx_has_vsx_region = 0;\n\n\tif (new_ctx &&\n\t    get_user(new_msr, &new_ctx->uc_mcontext.gp_regs[PT_MSR]))\n\t\treturn -EFAULT;\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n\n\tif (old_ctx != NULL) {\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || setup_sigcontext(&old_ctx->uc_mcontext, current, 0, NULL, 0,\n\t\t\t\t\tctx_has_vsx_region)\n\t\t    || __copy_to_user(&old_ctx->uc_sigmask,\n\t\t\t\t      &current->blocked, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\n\tif (__copy_from_user(&set, &new_ctx->uc_sigmask, sizeof(set)))\n\t\tdo_exit(SIGSEGV);\n\tset_current_blocked(&set);\n\tif (restore_sigcontext(current, NULL, 0, &new_ctx->uc_mcontext))\n\t\tdo_exit(SIGSEGV);\n\n\t/* This returns like rt_sigreturn */\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - 32*sizeof(long))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - 32*sizeof(long))\n\nSYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\tstruct ucontext __user *, new_ctx, long, ctx_size)\n{\n\tsigset_t set;\n\tunsigned long new_msr = 0;\n\tint ctx_has_vsx_region = 0;\n\n\tif (new_ctx &&\n\t    get_user(new_msr, &new_ctx->uc_mcontext.gp_regs[PT_MSR]))\n\t\treturn -EFAULT;\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n\n\tif (old_ctx != NULL) {\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || setup_sigcontext(&old_ctx->uc_mcontext, current, 0, NULL, 0,\n\t\t\t\t\tctx_has_vsx_region)\n\t\t    || __copy_to_user(&old_ctx->uc_sigmask,\n\t\t\t\t      &current->blocked, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\n\tif (__copy_from_user(&set, &new_ctx->uc_sigmask, sizeof(set)))\n\t\tdo_exit(SIGSEGV);\n\tset_current_blocked(&set);\n\tif (restore_sigcontext(current, NULL, 0, &new_ctx->uc_mcontext))\n\t\tdo_exit(SIGSEGV);\n\n\t/* This returns like rt_sigreturn */\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "704-811",
    "snippet": "SYSCALL_DEFINE0(rt_sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\t/*\n\t * Disable MSR[TS] bit also, so, if there is an exception in the\n\t * code below (as a page fault in copy_ckvsx_to_user()), it does\n\t * not recheckpoint this task if there was a context switch inside\n\t * the exception.\n\t *\n\t * A major page fault can indirectly call schedule(). A reschedule\n\t * process in the middle of an exception can have a side effect\n\t * (Changing the CPU MSR[TS] state), since schedule() is called\n\t * with the CPU MSR[TS] disable and returns with MSR[TS]=Suspended\n\t * (switch_to() calls tm_recheckpoint() for the 'new' process). In\n\t * this case, the process continues to be the same in the CPU, but\n\t * the CPU state just changed.\n\t *\n\t * This can cause a TM Bad Thing, since the MSR in the stack will\n\t * have the MSR[TS]=0, and this is what will be used to RFID.\n\t *\n\t * Clearing MSR[TS] state here will avoid a recheckpoint if there\n\t * is any process reschedule in kernel space. The MSR[TS] state\n\t * does not need to be saved also, since it will be replaced with\n\t * the MSR[TS] that came from user context later, at\n\t * restore_tm_sigcontexts.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\n\t\t/* Trying to start TM on non TM system */\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(current, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\t/*\n\t\t * Fall through, for non-TM restore\n\t\t *\n\t\t * Unset MSR[TS] on the thread regs since MSR from user\n\t\t * context does not have MSR active, and recheckpoint was\n\t\t * not called since restore_tm_sigcontexts() was not called\n\t\t * also.\n\t\t *\n\t\t * If not unsetting it, the code can RFID to userspace with\n\t\t * MSR[TS] set, but without CPU in the proper state,\n\t\t * causing a TM bad thing.\n\t\t */\n\t\tcurrent->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tif (restore_sigcontext(current, NULL, 1, &uc->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";",
      "static const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";\nstatic const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";\n\nSYSCALL_DEFINE0(rt_sigreturn)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\t/*\n\t * Disable MSR[TS] bit also, so, if there is an exception in the\n\t * code below (as a page fault in copy_ckvsx_to_user()), it does\n\t * not recheckpoint this task if there was a context switch inside\n\t * the exception.\n\t *\n\t * A major page fault can indirectly call schedule(). A reschedule\n\t * process in the middle of an exception can have a side effect\n\t * (Changing the CPU MSR[TS] state), since schedule() is called\n\t * with the CPU MSR[TS] disable and returns with MSR[TS]=Suspended\n\t * (switch_to() calls tm_recheckpoint() for the 'new' process). In\n\t * this case, the process continues to be the same in the CPU, but\n\t * the CPU state just changed.\n\t *\n\t * This can cause a TM Bad Thing, since the MSR in the stack will\n\t * have the MSR[TS]=0, and this is what will be used to RFID.\n\t *\n\t * Clearing MSR[TS] state here will avoid a recheckpoint if there\n\t * is any process reschedule in kernel space. The MSR[TS] state\n\t * does not need to be saved also, since it will be replaced with\n\t * the MSR[TS] that came from user context later, at\n\t * restore_tm_sigcontexts.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\n\t\t/* Trying to start TM on non TM system */\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(current, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\t/*\n\t\t * Fall through, for non-TM restore\n\t\t *\n\t\t * Unset MSR[TS] on the thread regs since MSR from user\n\t\t * context does not have MSR active, and recheckpoint was\n\t\t * not called since restore_tm_sigcontexts() was not called\n\t\t * also.\n\t\t *\n\t\t * If not unsetting it, the code can RFID to userspace with\n\t\t * MSR[TS] set, but without CPU in the proper state,\n\t\t * causing a TM bad thing.\n\t\t */\n\t\tcurrent->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tif (restore_sigcontext(current, NULL, 1, &uc->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}"
  }
]