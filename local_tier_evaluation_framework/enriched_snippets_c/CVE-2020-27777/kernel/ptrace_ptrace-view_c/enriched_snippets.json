[
  {
    "function_name": "task_user_regset_view",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "854-859",
    "snippet": "const struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n\tif (IS_ENABLED(CONFIG_PPC64) && test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n\treturn &user_ppc_native_view;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};",
      "static const struct user_regset_view user_ppc_compat_view = {\n\t.name = \"ppc\", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,\n\t.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_32BIT"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC64"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nconst struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\nstatic const struct user_regset_view user_ppc_compat_view = {\n\t.name = \"ppc\", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,\n\t.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)\n};\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n\tif (IS_ENABLED(CONFIG_PPC64) && test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n\treturn &user_ppc_native_view;\n}"
  },
  {
    "function_name": "gpr32_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "739-750",
    "snippet": "static int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gpr32_set_common",
          "args": [
            "target",
            "regset",
            "pos",
            "count",
            "kbuf",
            "ubuf",
            "&target->thread.regs->gpr[0]"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "gpr32_set_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "650-716",
          "snippet": "int gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}"
  },
  {
    "function_name": "gpr32_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "718-737",
    "snippet": "static int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/*\n\t\t * We have a partial register set.\n\t\t * Fill 14-31 with bogus values.\n\t\t */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\treturn gpr32_get_common(target, regset, to,\n\t\t\t&target->thread.regs->gpr[0]);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gpr32_get_common",
          "args": [
            "target",
            "regset",
            "to",
            "&target->thread.regs->gpr[0]"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "gpr32_get_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "636-648",
          "snippet": "int gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/*\n\t\t * We have a partial register set.\n\t\t * Fill 14-31 with bogus values.\n\t\t */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\treturn gpr32_get_common(target, regset, to,\n\t\t\t&target->thread.regs->gpr[0]);\n}"
  },
  {
    "function_name": "gpr32_set_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "650-716",
    "snippet": "int gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_TRAP + 1) * sizeof(reg)",
            "-1"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "target",
            "reg"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "150-154",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "target",
            "reg"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "114-119",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}"
  },
  {
    "function_name": "gpr32_get_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "636-648",
    "snippet": "int gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_zero",
          "args": [
            "&to",
            "(ELF_NGREG - PT_REGS_COUNT) * sizeof(u32)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "(u32)regs[i]"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "(u32)get_user_msr(target)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "target"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "109-112",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "(u32)regs[i]"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}"
  },
  {
    "function_name": "pkey_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "482-514",
    "snippet": "static int pkey_set(struct task_struct *target, const struct user_regset *regset,\n\t\t    unsigned int pos, unsigned int count, const void *kbuf,\n\t\t    const void __user *ubuf)\n{\n\tu64 new_amr;\n\tint ret;\n\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\t/* Only the AMR can be set from userspace */\n\tif (pos != 0 || count != sizeof(new_amr))\n\t\treturn -EINVAL;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &new_amr, 0, sizeof(new_amr));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * UAMOR determines which bits of the AMR can be set from userspace.\n\t * UAMOR value 0b11 indicates that the AMR value can be modified\n\t * from userspace. If the kernel is using a specific key, we avoid\n\t * userspace modifying the AMR value for that key by masking them\n\t * via UAMOR 0b00.\n\t *\n\t * Pick the AMR values for the keys that kernel is using. This\n\t * will be indicated by the ~default_uamor bits.\n\t */\n\ttarget->thread.amr = (new_amr & default_uamor) | (target->thread.amr & ~default_uamor);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&new_amr",
            "0",
            "sizeof(new_amr)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_pkeys_enabled",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pkey_set(struct task_struct *target, const struct user_regset *regset,\n\t\t    unsigned int pos, unsigned int count, const void *kbuf,\n\t\t    const void __user *ubuf)\n{\n\tu64 new_amr;\n\tint ret;\n\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\t/* Only the AMR can be set from userspace */\n\tif (pos != 0 || count != sizeof(new_amr))\n\t\treturn -EINVAL;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &new_amr, 0, sizeof(new_amr));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * UAMOR determines which bits of the AMR can be set from userspace.\n\t * UAMOR value 0b11 indicates that the AMR value can be modified\n\t * from userspace. If the kernel is using a specific key, we avoid\n\t * userspace modifying the AMR value for that key by masking them\n\t * via UAMOR 0b00.\n\t *\n\t * Pick the AMR values for the keys that kernel is using. This\n\t * will be indicated by the ~default_uamor bits.\n\t */\n\ttarget->thread.amr = (new_amr & default_uamor) | (target->thread.amr & ~default_uamor);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pkey_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "470-480",
    "snippet": "static int pkey_get(struct task_struct *target, const struct user_regset *regset,\n\t\t    struct membuf to)\n{\n\tBUILD_BUG_ON(TSO(amr) + sizeof(unsigned long) != TSO(iamr));\n\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\tmembuf_write(&to, &target->thread.amr, 2 * sizeof(unsigned long));\n\treturn membuf_store(&to, default_uamor);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "default_uamor"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.amr",
            "2 * sizeof(unsigned long)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_pkeys_enabled",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(amr) + sizeof(unsigned long) != TSO(iamr)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "iamr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "amr"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pkey_get(struct task_struct *target, const struct user_regset *regset,\n\t\t    struct membuf to)\n{\n\tBUILD_BUG_ON(TSO(amr) + sizeof(unsigned long) != TSO(iamr));\n\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\tmembuf_write(&to, &target->thread.amr, 2 * sizeof(unsigned long));\n\treturn membuf_store(&to, default_uamor);\n}"
  },
  {
    "function_name": "pkey_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "462-468",
    "snippet": "static int pkey_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_pkeys_enabled",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pkey_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!arch_pkeys_enabled())\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "pmu_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "420-458",
    "snippet": "static int pmu_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.siar,\n\t\t\t\t 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.sdar, sizeof(unsigned long),\n\t\t\t\t\t 2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.sier, 2 * sizeof(unsigned long),\n\t\t\t\t\t 3 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.mmcr2, 3 * sizeof(unsigned long),\n\t\t\t\t\t 4 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.mmcr0, 4 * sizeof(unsigned long),\n\t\t\t\t\t 5 * sizeof(unsigned long));\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.mmcr0",
            "4 * sizeof(unsigned long)",
            "5 * sizeof(unsigned long)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.mmcr2",
            "3 * sizeof(unsigned long)",
            "4 * sizeof(unsigned long)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.sier",
            "2 * sizeof(unsigned long)",
            "3 * sizeof(unsigned long)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.sdar",
            "sizeof(unsigned long)",
            "2 * sizeof(unsigned long)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.siar",
            "0",
            "sizeof(unsigned long)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr2"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(sier) + sizeof(unsigned long) != TSO(mmcr2)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr2"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sier"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(sdar) + sizeof(unsigned long) != TSO(sier)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sier"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sdar"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(siar) + sizeof(unsigned long) != TSO(sdar)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sdar"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "siar"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pmu_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.siar,\n\t\t\t\t 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.sdar, sizeof(unsigned long),\n\t\t\t\t\t 2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.sier, 2 * sizeof(unsigned long),\n\t\t\t\t\t 3 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.mmcr2, 3 * sizeof(unsigned long),\n\t\t\t\t\t 4 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.mmcr0, 4 * sizeof(unsigned long),\n\t\t\t\t\t 5 * sizeof(unsigned long));\n\treturn ret;\n}"
  },
  {
    "function_name": "pmu_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "405-418",
    "snippet": "static int pmu_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn membuf_write(&to, &target->thread.siar, 5 * sizeof(unsigned long));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.siar",
            "5 * sizeof(unsigned long)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr2"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(sier) + sizeof(unsigned long) != TSO(mmcr2)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "mmcr2"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sier"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(sdar) + sizeof(unsigned long) != TSO(sier)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sier"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sdar"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(siar) + sizeof(unsigned long) != TSO(sdar)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "sdar"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "siar"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pmu_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn membuf_write(&to, &target->thread.siar, 5 * sizeof(unsigned long));\n}"
  },
  {
    "function_name": "pmu_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "397-403",
    "snippet": "static int pmu_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int pmu_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "ebb_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "366-396",
    "snippet": "static int ebb_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.ebbrr,\n\t\t\t\t 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ebbhr, sizeof(unsigned long),\n\t\t\t\t\t 2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.bescr, 2 * sizeof(unsigned long),\n\t\t\t\t\t 3 * sizeof(unsigned long));\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.bescr",
            "2 * sizeof(unsigned long)",
            "3 * sizeof(unsigned long)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.ebbhr",
            "sizeof(unsigned long)",
            "2 * sizeof(unsigned long)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.ebbrr",
            "0",
            "sizeof(unsigned long)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "bescr"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbhr"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbhr"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbrr"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int ebb_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.ebbrr,\n\t\t\t\t 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ebbhr, sizeof(unsigned long),\n\t\t\t\t\t 2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.bescr, 2 * sizeof(unsigned long),\n\t\t\t\t\t 3 * sizeof(unsigned long));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ebb_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "350-364",
    "snippet": "static int ebb_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (!target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.ebbrr, 3 * sizeof(unsigned long));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.ebbrr",
            "3 * sizeof(unsigned long)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "bescr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbhr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbhr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ebbrr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int ebb_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (!target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.ebbrr, 3 * sizeof(unsigned long));\n}"
  },
  {
    "function_name": "ebb_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "339-348",
    "snippet": "static int ebb_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn regset->n;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int ebb_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn regset->n;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tar_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "331-337",
    "snippet": "static int tar_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.tar, 0, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tar",
            "0",
            "sizeof(u64)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int tar_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.tar, 0, sizeof(u64));\n}"
  },
  {
    "function_name": "tar_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "326-330",
    "snippet": "static int tar_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.tar, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tar",
            "sizeof(u64)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int tar_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.tar, sizeof(u64));\n}"
  },
  {
    "function_name": "dscr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "317-323",
    "snippet": "static int dscr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t    unsigned int pos, unsigned int count, const void *kbuf,\n\t\t    const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.dscr, 0, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.dscr",
            "0",
            "sizeof(u64)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int dscr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t    unsigned int pos, unsigned int count, const void *kbuf,\n\t\t    const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.dscr, 0, sizeof(u64));\n}"
  },
  {
    "function_name": "dscr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "312-316",
    "snippet": "static int dscr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t    struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.dscr, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.dscr",
            "sizeof(u64)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int dscr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t    struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.dscr, sizeof(u64));\n}"
  },
  {
    "function_name": "ppr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "304-310",
    "snippet": "static int ppr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.regs->ppr, 0, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.regs->ppr",
            "0",
            "sizeof(u64)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int ppr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.regs->ppr, 0, sizeof(u64));\n}"
  },
  {
    "function_name": "ppr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "298-302",
    "snippet": "static int ppr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.regs->ppr, sizeof(u64));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.regs->ppr",
            "sizeof(u64)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int ppr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\treturn membuf_write(&to, &target->thread.regs->ppr, sizeof(u64));\n}"
  },
  {
    "function_name": "gpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "244-295",
    "snippet": "static int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\t\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_TRAP + 1) * sizeof(reg)",
            "-1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "target",
            "reg"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "150-154",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_TRAP * sizeof(reg)",
            "(PT_TRAP + 1) * sizeof(reg)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)",
            "PT_TRAP * sizeof(reg)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.regs->orig_gpr3",
            "PT_ORIG_R3 * sizeof(reg)",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "target",
            "reg"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "114-119",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_MSR * sizeof(reg)",
            "(PT_MSR + 1) * sizeof(reg)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "target->thread.regs",
            "0",
            "PT_MSR * sizeof(reg)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count, const void *kbuf,\n\t\t   const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\t\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "gpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "217-242",
    "snippet": "static int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tmembuf_write(&to, target->thread.regs, offsetof(struct pt_regs, msr));\n\tmembuf_store(&to, get_user_msr(target));\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tmembuf_write(&to, &target->thread.regs->orig_gpr3,\n\t\t\tsizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3));\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(unsigned long) -\n\t\t\t\t sizeof(struct user_pt_regs));\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_zero",
          "args": [
            "&to",
            "ELF_NGREG * sizeof(unsigned long) -\n\t\t\t\t sizeof(struct user_pt_regs)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.regs->orig_gpr3",
            "sizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "get_user_msr(target)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "target"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "109-112",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "target->thread.regs",
            "offsetof(struct pt_regs, msr)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   struct membuf to)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tmembuf_write(&to, target->thread.regs, offsetof(struct pt_regs, msr));\n\tmembuf_store(&to, get_user_msr(target));\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tmembuf_write(&to, &target->thread.regs->orig_gpr3,\n\t\t\tsizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3));\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(unsigned long) -\n\t\t\t\t sizeof(struct user_pt_regs));\n}"
  },
  {
    "function_name": "ptrace_put_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "197-215",
    "snippet": "int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\tregno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "regno",
            "PT_MAX_PUT_REG + 1"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_dscr",
          "args": [
            "task",
            "data"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "140-143",
          "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "task",
            "data"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "150-154",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "task",
            "data"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "114-119",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\tregno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ptrace_get_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "159-192",
    "snippet": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tunsigned int regs_max;\n\n\tif (task->thread.regs == NULL || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\t/*\n\t * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is\n\t * no more used as a flag, lets force usr to alway see the softe value as 1\n\t * which means interrupts are not soft disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {\n\t\t*data = 1;\n\t\treturn  0;\n\t}\n\n\tregs_max = sizeof(struct user_pt_regs) / sizeof(unsigned long);\n\tif (regno < regs_max) {\n\t\tregno = array_index_nospec(regno, regs_max);\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "regno",
            "regs_max"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC64"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_dscr",
          "args": [
            "task",
            "data"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "135-138",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "task"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "109-112",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tunsigned int regs_max;\n\n\tif (task->thread.regs == NULL || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\t/*\n\t * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is\n\t * no more used as a flag, lets force usr to alway see the softe value as 1\n\t * which means interrupts are not soft disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {\n\t\t*data = 1;\n\t\treturn  0;\n\t}\n\n\tregs_max = sizeof(struct user_pt_regs) / sizeof(unsigned long);\n\tif (regno < regs_max) {\n\t\tregno = array_index_nospec(regno, regs_max);\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "set_user_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "150-154",
    "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_trap",
          "args": [
            "task->thread.regs",
            "trap"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(task->thread.regs, trap);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "140-143",
    "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "get_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "135-138",
    "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "set_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "128-133",
    "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "122-126",
    "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "114-119",
    "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_user_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "109-112",
    "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
  },
  {
    "function_name": "regs_query_register_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "95-102",
    "snippet": "const char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}"
  },
  {
    "function_name": "regs_query_register_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
    "lines": "79-86",
    "snippet": "int regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include \"ptrace-decl.h\"",
      "#include <linux/pkeys.h>",
      "#include <linux/nospec.h>",
      "#include <linux/elf.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "roff->name",
            "name"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\nint regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}"
  }
]