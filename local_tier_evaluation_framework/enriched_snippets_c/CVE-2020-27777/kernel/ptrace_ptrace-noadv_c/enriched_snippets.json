[
  {
    "function_name": "ppc_del_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "272-302",
    "snippet": "long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &child->thread;\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (data < 1 || data > nr_wp_slots())\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[data - 1];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[data - 1] = NULL;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (!(child->thread.hw_brk[data - 1].flags & HW_BRK_FLAG_DISABLED) &&\n\t    child->thread.hw_brk[data - 1].address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk[data - 1].address = 0;\n\tchild->thread.hw_brk[data - 1].type = 0;\n\tchild->thread.hw_brk[data - 1].flags = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "352-368",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &child->thread;\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (data < 1 || data > nr_wp_slots())\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[data - 1];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[data - 1] = NULL;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (!(child->thread.hw_brk[data - 1].flags & HW_BRK_FLAG_DISABLED) &&\n\t    child->thread.hw_brk[data - 1].address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk[data - 1].address = 0;\n\tchild->thread.hw_brk[data - 1].type = 0;\n\tchild->thread.hw_brk[data - 1].flags = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_set_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "197-270",
    "snippet": "long ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint i;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &child->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tstruct arch_hw_breakpoint brk;\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = ALIGN_DOWN(bp_info->addr, HW_BREAKPOINT_SIZE);\n\tbrk.type = HW_BRK_TYPE_TRANSLATE | HW_BRK_TYPE_PRIV_ALL;\n\tbrk.len = DABR_MAX_LEN;\n\tbrk.hw_len = DABR_MAX_LEN;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\n\ti = find_empty_ptrace_bp(thread);\n\tif (i < 0)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tbp = register_user_hw_breakpoint(&attr, ptrace_triggered, NULL, child);\n\tthread->ptrace_bps[i] = bp;\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[i] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn i + 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\ti = find_empty_hw_brk(&child->thread);\n\tif (i < 0)\n\t\treturn -ENOSPC;\n\n\tif (!ppc_breakpoint_available())\n\t\treturn -ENODEV;\n\n\tchild->thread.hw_brk[i] = brk;\n\n\treturn i + 1;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_breakpoint_available",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_breakpoint_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "897-905",
          "snippet": "bool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nbool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_empty_hw_brk",
          "args": [
            "&child->thread"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "find_empty_hw_brk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
          "lines": "186-195",
          "snippet": "static int find_empty_hw_brk(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->hw_brk[i].address)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/debug.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int find_empty_hw_brk(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->hw_brk[i].address)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_user_hw_breakpoint",
          "args": [
            "&attr",
            "ptrace_triggered",
            "NULL",
            "child"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bp_generic_fields",
          "args": [
            "brk.type",
            "&attr.bp_type"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "arch_bp_generic_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "378-388",
          "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_init",
          "args": [
            "&attr"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_empty_ptrace_bp",
          "args": [
            "thread"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "find_empty_ptrace_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
          "lines": "174-183",
          "snippet": "static int find_empty_ptrace_bp(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->ptrace_bps[i])\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/debug.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int find_empty_ptrace_bp(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->ptrace_bps[i])\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "bp_info->addr",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint i;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &child->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tstruct arch_hw_breakpoint brk;\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = ALIGN_DOWN(bp_info->addr, HW_BREAKPOINT_SIZE);\n\tbrk.type = HW_BRK_TYPE_TRANSLATE | HW_BRK_TYPE_PRIV_ALL;\n\tbrk.len = DABR_MAX_LEN;\n\tbrk.hw_len = DABR_MAX_LEN;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\n\ti = find_empty_ptrace_bp(thread);\n\tif (i < 0)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tbp = register_user_hw_breakpoint(&attr, ptrace_triggered, NULL, child);\n\tthread->ptrace_bps[i] = bp;\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[i] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn i + 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\ti = find_empty_hw_brk(&child->thread);\n\tif (i < 0)\n\t\treturn -ENOSPC;\n\n\tif (!ppc_breakpoint_available())\n\t\treturn -ENODEV;\n\n\tchild->thread.hw_brk[i] = brk;\n\n\treturn i + 1;\n}"
  },
  {
    "function_name": "find_empty_hw_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "186-195",
    "snippet": "static int find_empty_hw_brk(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->hw_brk[i].address)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int find_empty_hw_brk(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->hw_brk[i].address)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "find_empty_ptrace_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "174-183",
    "snippet": "static int find_empty_ptrace_bp(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->ptrace_bps[i])\n\t\t\treturn i;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int find_empty_ptrace_bp(struct thread_struct *thread)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!thread->ptrace_bps[i])\n\t\t\treturn i;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "ptrace_set_debugreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "82-171",
    "snippet": "int ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tbool set_bp = true;\n\tstruct arch_hw_breakpoint hw_brk;\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = DABR_MAX_LEN;\n\thw_brk.hw_len = DABR_MAX_LEN;\n\tset_bp = (data) && (hw_brk.type & HW_BRK_TYPE_RDWR);\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (!set_bp) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tattr.bp_len = DABR_MAX_LEN;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk[0] = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tattr.bp_len = DABR_MAX_LEN;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#else /* !CONFIG_HAVE_HW_BREAKPOINT */\n\tif (set_bp && (!ppc_breakpoint_available()))\n\t\treturn -ENODEV;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk[0] = hw_brk;\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_breakpoint_available",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_breakpoint_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "897-905",
          "snippet": "bool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nbool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_user_hw_breakpoint",
          "args": [
            "&attr",
            "ptrace_triggered",
            "NULL",
            "task"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bp_generic_fields",
          "args": [
            "hw_brk.type",
            "&attr.bp_type"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "arch_bp_generic_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "378-388",
          "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_init",
          "args": [
            "&attr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint",
          "args": [
            "bp",
            "&attr"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "352-368",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\tbool set_bp = true;\n\tstruct arch_hw_breakpoint hw_brk;\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = DABR_MAX_LEN;\n\thw_brk.hw_len = DABR_MAX_LEN;\n\tset_bp = (data) && (hw_brk.type & HW_BRK_TYPE_RDWR);\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (!set_bp) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tattr.bp_len = DABR_MAX_LEN;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk[0] = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tattr.bp_len = DABR_MAX_LEN;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#else /* !CONFIG_HAVE_HW_BREAKPOINT */\n\tif (set_bp && (!ppc_breakpoint_available()))\n\t\treturn -ENODEV;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk[0] = hw_brk;\n\treturn 0;\n}"
  },
  {
    "function_name": "ptrace_get_debugreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "64-75",
    "snippet": "int ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\tunsigned long dabr_fake;\n\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\tdabr_fake = ((child->thread.hw_brk[0].address & (~HW_BRK_TYPE_DABR)) |\n\t\t     (child->thread.hw_brk[0].type & HW_BRK_TYPE_DABR));\n\treturn put_user(dabr_fake, datalp);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "dabr_fake",
            "datalp"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\tunsigned long dabr_fake;\n\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\tdabr_fake = ((child->thread.hw_brk[0].address & (~HW_BRK_TYPE_DABR)) |\n\t\t     (child->thread.hw_brk[0].type & HW_BRK_TYPE_DABR));\n\treturn put_user(dabr_fake, datalp);\n}"
  },
  {
    "function_name": "ppc_gethwdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "42-62",
    "snippet": "void ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = 0;\n\tif (ppc_breakpoint_available())\n\t\tdbginfo->num_data_bps = nr_wp_slots();\n\telse\n\t\tdbginfo->num_data_bps = 0;\n\tdbginfo->num_condition_regs = 0;\n\tdbginfo->data_bp_alignment = sizeof(long);\n\tdbginfo->sizeof_condition = 0;\n\tif (IS_ENABLED(CONFIG_HAVE_HW_BREAKPOINT)) {\n\t\tdbginfo->features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (dawr_enabled())\n\t\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n\t} else {\n\t\tdbginfo->features = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ARCH_31))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_ARCH_31;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_31"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dawr_enabled",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_HW_BREAKPOINT"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_breakpoint_available",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_breakpoint_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "897-905",
          "snippet": "bool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nbool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = 0;\n\tif (ppc_breakpoint_available())\n\t\tdbginfo->num_data_bps = nr_wp_slots();\n\telse\n\t\tdbginfo->num_data_bps = 0;\n\tdbginfo->num_condition_regs = 0;\n\tdbginfo->data_bp_alignment = sizeof(long);\n\tdbginfo->sizeof_condition = 0;\n\tif (IS_ENABLED(CONFIG_HAVE_HW_BREAKPOINT)) {\n\t\tdbginfo->features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (dawr_enabled())\n\t\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n\t} else {\n\t\tdbginfo->features = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ARCH_31))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_ARCH_31;\n}"
  },
  {
    "function_name": "user_disable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "32-40",
    "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL)\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL)\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_block_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "21-30",
    "snippet": "void user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-noadv.c",
    "lines": "10-19",
    "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/debug.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/debug.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  }
]