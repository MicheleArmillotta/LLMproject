[
  {
    "function_name": "eeh_cache_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "282-287",
    "snippet": "void eeh_cache_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"eeh_address_cache\", 0400,\n\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t&eeh_addr_cache_fops);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"eeh_address_cache\"",
            "0400",
            "powerpc_debugfs_root",
            "NULL",
            "&eeh_addr_cache_fops"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nvoid eeh_cache_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"eeh_address_cache\", 0400,\n\t\t\tpowerpc_debugfs_root, NULL,\n\t\t\t&eeh_addr_cache_fops);\n}"
  },
  {
    "function_name": "eeh_addr_cache_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "263-279",
    "snippet": "static int eeh_addr_cache_show(struct seq_file *s, void *v)\n{\n\tstruct pci_io_addr_range *piar;\n\tstruct rb_node *n;\n\n\tspin_lock(&pci_io_addr_cache_root.piar_lock);\n\tfor (n = rb_first(&pci_io_addr_cache_root.rb_root); n; n = rb_next(n)) {\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tseq_printf(s, \"%s addr range [%pap-%pap]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\",\n\t\t       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));\n\t}\n\tspin_unlock(&pci_io_addr_cache_root.piar_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pci_io_addr_cache_root.piar_lock"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s addr range [%pap-%pap]: %s\\n\"",
            "(piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\"",
            "&piar->addr_lo",
            "&piar->addr_hi",
            "pci_name(piar->pcidev)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "piar->pcidev"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pci_io_addr_cache_root.piar_lock"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic int eeh_addr_cache_show(struct seq_file *s, void *v)\n{\n\tstruct pci_io_addr_range *piar;\n\tstruct rb_node *n;\n\n\tspin_lock(&pci_io_addr_cache_root.piar_lock);\n\tfor (n = rb_first(&pci_io_addr_cache_root.rb_root); n; n = rb_next(n)) {\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tseq_printf(s, \"%s addr range [%pap-%pap]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\",\n\t\t       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));\n\t}\n\tspin_unlock(&pci_io_addr_cache_root.piar_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_addr_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "258-261",
    "snippet": "void eeh_addr_cache_init(void)\n{\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pci_io_addr_cache_root.piar_lock"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_init(void)\n{\n\tspin_lock_init(&pci_io_addr_cache_root.piar_lock);\n}"
  },
  {
    "function_name": "eeh_addr_cache_rmv_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "243-250",
    "snippet": "void eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_rmv_dev",
          "args": [
            "dev"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_rmv_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "213-232",
          "snippet": "static inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\teeh_edev_dbg(piar->edev, \"PIAR: remove range=[%pap:%pap]\\n\",\n\t\t\t\t &piar->addr_lo, &piar->addr_hi);\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\teeh_edev_dbg(piar->edev, \"PIAR: remove range=[%pap:%pap]\\n\",\n\t\t\t\t &piar->addr_lo, &piar->addr_hi);\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_rmv_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
  },
  {
    "function_name": "__eeh_addr_cache_rmv_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "213-232",
    "snippet": "static inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\teeh_edev_dbg(piar->edev, \"PIAR: remove range=[%pap:%pap]\\n\",\n\t\t\t\t &piar->addr_lo, &piar->addr_hi);\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "piar"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "piar->edev",
            "\"PIAR: remove range=[%pap:%pap]\\n\"",
            "&piar->addr_lo",
            "&piar->addr_hi"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\n{\n\tstruct rb_node *n;\n\nrestart:\n\tn = rb_first(&pci_io_addr_cache_root.rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (piar->pcidev == dev) {\n\t\t\teeh_edev_dbg(piar->edev, \"PIAR: remove range=[%pap:%pap]\\n\",\n\t\t\t\t &piar->addr_lo, &piar->addr_hi);\n\t\t\trb_erase(n, &pci_io_addr_cache_root.rb_root);\n\t\t\tkfree(piar);\n\t\t\tgoto restart;\n\t\t}\n\t\tn = rb_next(n);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_insert_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "204-211",
    "snippet": "void eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_insert_dev",
          "args": [
            "dev"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_insert_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "160-194",
          "snippet": "static void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tedev = pci_dev_to_eeh_dev(dev);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Walk resources on this device, poke the first 7 (6 normal BAR and 1\n\t * ROM BAR) into the tree.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tedev = pci_dev_to_eeh_dev(dev);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Walk resources on this device, poke the first 7 (6 normal BAR and 1\n\t * ROM BAR) into the tree.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\t__eeh_addr_cache_insert_dev(dev);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n}"
  },
  {
    "function_name": "__eeh_addr_cache_insert_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "160-194",
    "snippet": "static void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tedev = pci_dev_to_eeh_dev(dev);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Walk resources on this device, poke the first 7 (6 normal BAR and 1\n\t * ROM BAR) into the tree.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_addr_cache_insert",
          "args": [
            "dev",
            "start",
            "end",
            "flags"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_addr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "117-158",
          "snippet": "static struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n\teeh_edev_dbg(piar->edev, \"PIAR: insert range=[%pap:%pap]\\n\",\n\t\t &alo, &ahi);\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n\teeh_edev_dbg(piar->edev, \"PIAR: insert range=[%pap:%pap]\\n\",\n\t\t &alo, &ahi);\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_resource_flags",
          "args": [
            "dev",
            "i"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_resource_end",
          "args": [
            "dev",
            "i"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_resource_start",
          "args": [
            "dev",
            "i"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_dbg",
          "args": [
            "&dev->dev",
            "\"EEH: Skip building address cache\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PCI: no EEH dev found for %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\n{\n\tstruct eeh_dev *edev;\n\tint i;\n\n\tedev = pci_dev_to_eeh_dev(dev);\n\tif (!edev) {\n\t\tpr_warn(\"PCI: no EEH dev found for %s\\n\",\n\t\t\tpci_name(dev));\n\t\treturn;\n\t}\n\n\t/* Skip any devices for which EEH is not enabled. */\n\tif (!edev->pe) {\n\t\tdev_dbg(&dev->dev, \"EEH: Skip building address cache\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Walk resources on this device, poke the first 7 (6 normal BAR and 1\n\t * ROM BAR) into the tree.\n\t */\n\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\tresource_size_t start = pci_resource_start(dev,i);\n\t\tresource_size_t end = pci_resource_end(dev,i);\n\t\tunsigned long flags = pci_resource_flags(dev,i);\n\n\t\t/* We are interested only bus addresses, not dma or other stuff */\n\t\tif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\n\t\t\tcontinue;\n\t\tif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\n\t\t\t continue;\n\t\teeh_addr_cache_insert(dev, start, end, flags);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "117-158",
    "snippet": "static struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n\teeh_edev_dbg(piar->edev, \"PIAR: insert range=[%pap:%pap]\\n\",\n\t\t &alo, &ahi);\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&piar->rb_node",
            "&pci_io_addr_cache_root.rb_root"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&piar->rb_node",
            "parent",
            "p"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_dbg",
          "args": [
            "piar->edev",
            "\"PIAR: insert range=[%pap:%pap]\\n\"",
            "&alo",
            "&ahi"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_to_eeh_dev",
          "args": [
            "dev"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pci_io_addr_range)",
            "GFP_ATOMIC"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PIAR: overlapping address range\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic struct pci_io_addr_range *\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\n\t\t      resource_size_t ahi, unsigned long flags)\n{\n\tstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pci_io_addr_range *piar;\n\n\t/* Walk tree, find a place to insert into tree */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\n\t\tif (ahi < piar->addr_lo) {\n\t\t\tp = &parent->rb_left;\n\t\t} else if (alo > piar->addr_hi) {\n\t\t\tp = &parent->rb_right;\n\t\t} else {\n\t\t\tif (dev != piar->pcidev ||\n\t\t\t    alo != piar->addr_lo || ahi != piar->addr_hi) {\n\t\t\t\tpr_warn(\"PIAR: overlapping address range\\n\");\n\t\t\t}\n\t\t\treturn piar;\n\t\t}\n\t}\n\tpiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\n\tif (!piar)\n\t\treturn NULL;\n\n\tpiar->addr_lo = alo;\n\tpiar->addr_hi = ahi;\n\tpiar->edev = pci_dev_to_eeh_dev(dev);\n\tpiar->pcidev = dev;\n\tpiar->flags = flags;\n\n\teeh_edev_dbg(piar->edev, \"PIAR: insert range=[%pap:%pap]\\n\",\n\t\t &alo, &ahi);\n\n\trb_link_node(&piar->rb_node, parent, p);\n\trb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\n\n\treturn piar;\n}"
  },
  {
    "function_name": "eeh_addr_cache_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "98-113",
    "snippet": "static void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_info(\"PCI: %s addr range %d [%pap-%pap]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"PCI: %s addr range %d [%pap-%pap]: %s\\n\"",
            "(piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\"",
            "cnt",
            "&piar->addr_lo",
            "&piar->addr_hi",
            "pci_name(piar->pcidev)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "piar->pcidev"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&cache->rb_root"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\n{\n\tstruct rb_node *n;\n\tint cnt = 0;\n\n\tn = rb_first(&cache->rb_root);\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\t\tpr_info(\"PCI: %s addr range %d [%pap-%pap]: %s\\n\",\n\t\t       (piar->flags & IORESOURCE_IO) ? \"i/o\" : \"mem\", cnt,\n\t\t       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));\n\t\tcnt++;\n\t\tn = rb_next(n);\n\t}\n}"
  },
  {
    "function_name": "eeh_addr_cache_get_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "82-91",
    "snippet": "struct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__eeh_addr_cache_get_device",
          "args": [
            "addr"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_get_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "54-71",
          "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pci_io_addr_cache_root.piar_lock",
            "flags"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstruct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\n{\n\tstruct eeh_dev *edev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\n\tedev = __eeh_addr_cache_get_device(addr);\n\tspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\n\treturn edev;\n}"
  },
  {
    "function_name": "__eeh_addr_cache_get_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
    "lines": "54-71",
    "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/pci.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structpci_io_addr_range",
            "rb_node"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
  }
]