[
  {
    "function_name": "emulate_altivec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "262-351",
    "snippet": "int emulate_altivec(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tunsigned int i, word;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user_instr(instr, (void __user *)regs->nip))\n\t\treturn -EFAULT;\n\n\tword = ppc_inst_val(instr);\n\tif (ppc_inst_primary_opcode(instr) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (word >> 21) & 0x1f;\n\tva = (word >> 16) & 0x1f;\n\tvb = (word >> 11) & 0x1f;\n\tvc = (word >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (word & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vnmsubfp",
          "args": [
            "&vrs[vd]",
            "&vrs[va]",
            "&vrs[vb]",
            "&vrs[vc]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmaddfp",
          "args": [
            "&vrs[vd]",
            "&vrs[va]",
            "&vrs[vb]",
            "&vrs[vc]"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctsxs",
          "args": [
            "vrs[vb].u[i]",
            "va",
            "&current->thread.vr_state.vscr.u[3]"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ctsxs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "157-177",
          "snippet": "static int ctsxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp, mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (exp >= 31) {\n\t\t/* saturate, unless the result would be -2^31 */\n\t\tif (x + (scale << 23) != 0xcf000000)\n\t\t\t*vscrp |= VSCR_SAT;\n\t\treturn (x & 0x80000000)? 0x80000000: 0x7fffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 7) >> (30 - exp);\n\treturn (x & 0x80000000)? -mant: mant;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define VSCR_SAT\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\n#define VSCR_SAT\t1\n\nstatic int ctsxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp, mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (exp >= 31) {\n\t\t/* saturate, unless the result would be -2^31 */\n\t\tif (x + (scale << 23) != 0xcf000000)\n\t\t\t*vscrp |= VSCR_SAT;\n\t\treturn (x & 0x80000000)? 0x80000000: 0x7fffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 7) >> (30 - exp);\n\treturn (x & 0x80000000)? -mant: mant;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctuxs",
          "args": [
            "vrs[vb].u[i]",
            "va",
            "&current->thread.vr_state.vscr.u[3]"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ctuxs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "179-204",
          "snippet": "static unsigned int ctuxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp;\n\tunsigned int mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (x & 0x80000000) {\n\t\t/* negative => saturate to 0 */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0;\n\t}\n\tif (exp >= 32) {\n\t\t/* saturate */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0xffffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 8) >> (31 - exp);\n\treturn mant;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define VSCR_SAT\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\n#define VSCR_SAT\t1\n\nstatic unsigned int ctuxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp;\n\tunsigned int mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (x & 0x80000000) {\n\t\t/* negative => saturate to 0 */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0;\n\t}\n\tif (exp >= 32) {\n\t\t/* saturate */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0xffffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 8) >> (31 - exp);\n\treturn mant;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfiz",
          "args": [
            "x"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rfiz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "207-219",
          "snippet": "static unsigned int rfiz(unsigned int x)\n{\n\tint exp;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < 0)\n\t\treturn x & 0x80000000;\t/* |x| < 1.0 rounds to 0 */\n\treturn x & ~(0x7fffff >> exp);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfiz(unsigned int x)\n{\n\tint exp;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < 0)\n\t\treturn x & 0x80000000;\t/* |x| < 1.0 rounds to 0 */\n\treturn x & ~(0x7fffff >> exp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfii",
          "args": [
            "x"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rfii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "222-240",
          "snippet": "static unsigned int rfii(unsigned int x)\n{\n\tint exp, mask;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif ((x & 0x7fffffff) == 0)\n\t\treturn x;\t\t/* +/-0 -> +/-0 */\n\tif (exp < 0)\n\t\t/* 0 < |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\tmask = 0x7fffff >> exp;\n\t/* mantissa overflows into exponent - that's OK,\n\t   it can't overflow into the sign bit */\n\treturn (x + mask) & ~mask;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfii(unsigned int x)\n{\n\tint exp, mask;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif ((x & 0x7fffffff) == 0)\n\t\treturn x;\t\t/* +/-0 -> +/-0 */\n\tif (exp < 0)\n\t\t/* 0 < |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\tmask = 0x7fffff >> exp;\n\t/* mantissa overflows into exponent - that's OK,\n\t   it can't overflow into the sign bit */\n\treturn (x + mask) & ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfin",
          "args": [
            "vrs[vb].u[i]"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "rfin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "243-260",
          "snippet": "static unsigned int rfin(unsigned int x)\n{\n\tint exp, half;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < -1)\n\t\treturn x & 0x80000000;\t/* |x| < 0.5 -> +/-0 */\n\tif (exp == -1)\n\t\t/* 0.5 <= |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\thalf = 0x400000 >> exp;\n\t/* add 0.5 to the magnitude and chop off the fraction bits */\n\treturn (x + half) & ~(0x7fffff >> exp);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfin(unsigned int x)\n{\n\tint exp, half;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < -1)\n\t\treturn x & 0x80000000;\t/* |x| < 0.5 -> +/-0 */\n\tif (exp == -1)\n\t\t/* 0.5 <= |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\thalf = 0x400000 >> exp;\n\t/* add 0.5 to the magnitude and chop off the fraction bits */\n\treturn (x + half) & ~(0x7fffff >> exp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog2",
          "args": [
            "vrs[vb].u[i]"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "elog2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "94-153",
          "snippet": "static unsigned int elog2(unsigned int s)\n{\n\tint exp, mant, lz, frac;\n\n\texp = s & 0x7f800000;\n\tmant = s & 0x7fffff;\n\tif (exp == 0x7f800000) {\t/* Inf or NaN */\n\t\tif (mant != 0)\n\t\t\ts |= 0x400000;\t/* turn NaN into QNaN */\n\t\treturn s;\n\t}\n\tif ((exp | mant) == 0)\t\t/* +0 or -0 */\n\t\treturn 0xff800000;\t/* return -Inf */\n\n\tif (exp == 0) {\n\t\t/* denormalized */\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (mant));\n\t\tmant <<= lz - 8;\n\t\texp = (-118 - lz) << 23;\n\t} else {\n\t\tmant |= 0x800000;\n\t\texp -= 127 << 23;\n\t}\n\n\tif (mant >= 0xb504f3) {\t\t\t\t/* 2^0.5 * 2^23 */\n\t\texp |= 0x400000;\t\t\t/* 0.5 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xb504f334));\t/* 2^-0.5 * 2^32 */\n\t}\n\tif (mant >= 0x9837f0) {\t\t\t\t/* 2^0.25 * 2^23 */\n\t\texp |= 0x200000;\t\t\t/* 0.25 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xd744fccb));\t/* 2^-0.25 * 2^32 */\n\t}\n\tif (mant >= 0x8b95c2) {\t\t\t\t/* 2^0.125 * 2^23 */\n\t\texp |= 0x100000;\t\t\t/* 0.125 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xeac0c6e8));\t/* 2^-0.125 * 2^32 */\n\t}\n\tif (mant > 0x800000) {\t\t\t\t/* 1.0 * 2^23 */\n\t\t/* calculate (mant - 1) * 1.381097463 */\n\t\t/* 1.381097463 == 0.125 / (2^0.125 - 1) */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t\t    : \"r\" ((mant - 0x800000) << 1), \"r\" (0xb0c7cd3a));\n\t\texp += frac;\n\t}\n\ts = exp & 0x80000000;\n\tif (exp != 0) {\n\t\tif (s)\n\t\t\texp = -exp;\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (exp));\n\t\tlz = 8 - lz;\n\t\tif (lz > 0)\n\t\t\texp >>= lz;\n\t\telse if (lz < 0)\n\t\t\texp <<= -lz;\n\t\ts += ((lz + 126) << 23) + exp;\n\t}\n\treturn s;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int elog2(unsigned int s)\n{\n\tint exp, mant, lz, frac;\n\n\texp = s & 0x7f800000;\n\tmant = s & 0x7fffff;\n\tif (exp == 0x7f800000) {\t/* Inf or NaN */\n\t\tif (mant != 0)\n\t\t\ts |= 0x400000;\t/* turn NaN into QNaN */\n\t\treturn s;\n\t}\n\tif ((exp | mant) == 0)\t\t/* +0 or -0 */\n\t\treturn 0xff800000;\t/* return -Inf */\n\n\tif (exp == 0) {\n\t\t/* denormalized */\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (mant));\n\t\tmant <<= lz - 8;\n\t\texp = (-118 - lz) << 23;\n\t} else {\n\t\tmant |= 0x800000;\n\t\texp -= 127 << 23;\n\t}\n\n\tif (mant >= 0xb504f3) {\t\t\t\t/* 2^0.5 * 2^23 */\n\t\texp |= 0x400000;\t\t\t/* 0.5 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xb504f334));\t/* 2^-0.5 * 2^32 */\n\t}\n\tif (mant >= 0x9837f0) {\t\t\t\t/* 2^0.25 * 2^23 */\n\t\texp |= 0x200000;\t\t\t/* 0.25 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xd744fccb));\t/* 2^-0.25 * 2^32 */\n\t}\n\tif (mant >= 0x8b95c2) {\t\t\t\t/* 2^0.125 * 2^23 */\n\t\texp |= 0x100000;\t\t\t/* 0.125 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xeac0c6e8));\t/* 2^-0.125 * 2^32 */\n\t}\n\tif (mant > 0x800000) {\t\t\t\t/* 1.0 * 2^23 */\n\t\t/* calculate (mant - 1) * 1.381097463 */\n\t\t/* 1.381097463 == 0.125 / (2^0.125 - 1) */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t\t    : \"r\" ((mant - 0x800000) << 1), \"r\" (0xb0c7cd3a));\n\t\texp += frac;\n\t}\n\ts = exp & 0x80000000;\n\tif (exp != 0) {\n\t\tif (s)\n\t\t\texp = -exp;\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (exp));\n\t\tlz = 8 - lz;\n\t\tif (lz > 0)\n\t\t\texp >>= lz;\n\t\telse if (lz < 0)\n\t\t\texp <<= -lz;\n\t\ts += ((lz + 126) << 23) + exp;\n\t}\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eexp2",
          "args": [
            "vrs[vb].u[i]"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "eexp2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
          "lines": "39-88",
          "snippet": "static unsigned int eexp2(unsigned int s)\n{\n\tint exp, pwr;\n\tunsigned int mant, frac;\n\n\t/* extract exponent field from input */\n\texp = ((s >> 23) & 0xff) - 127;\n\tif (exp > 7) {\n\t\t/* check for NaN input */\n\t\tif (exp == 128 && (s & 0x7fffff) != 0)\n\t\t\treturn s | 0x400000;\t/* return QNaN */\n\t\t/* 2^-big = 0, 2^+big = +Inf */\n\t\treturn (s & 0x80000000)? 0: 0x7f800000;\t/* 0 or +Inf */\n\t}\n\tif (exp < -23)\n\t\treturn 0x3f800000;\t/* 1.0 */\n\n\t/* convert to fixed point integer in 9.23 representation */\n\tpwr = (s & 0x7fffff) | 0x800000;\n\tif (exp > 0)\n\t\tpwr <<= exp;\n\telse\n\t\tpwr >>= -exp;\n\tif (s & 0x80000000)\n\t\tpwr = -pwr;\n\n\t/* extract integer part, which becomes exponent part of result */\n\texp = (pwr >> 23) + 126;\n\tif (exp >= 254)\n\t\treturn 0x7f800000;\n\tif (exp < -23)\n\t\treturn 0;\n\n\t/* table lookup on top 3 bits of fraction to get mantissa */\n\tmant = exp2s[(pwr >> 20) & 7];\n\n\t/* linear interpolation using remaining 20 bits of fraction */\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t    : \"r\" (pwr << 12), \"r\" (0x172b83ff));\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac) : \"r\" (frac), \"r\" (mant));\n\tmant += frac;\n\n\tif (exp >= 0)\n\t\treturn mant + (exp << 23);\n\n\t/* denormalized result */\n\texp = -exp;\n\tmant += 1 << (exp - 1);\n\treturn mant >> exp;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int exp2s[8] = {\n\t0x800000,\n\t0x8b95c2,\n\t0x9837f0,\n\t0xa5fed7,\n\t0xb504f3,\n\t0xc5672a,\n\t0xd744fd,\n\t0xeac0c7\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int exp2s[8] = {\n\t0x800000,\n\t0x8b95c2,\n\t0x9837f0,\n\t0xa5fed7,\n\t0xb504f3,\n\t0xc5672a,\n\t0xd744fd,\n\t0xeac0c7\n};\n\nstatic unsigned int eexp2(unsigned int s)\n{\n\tint exp, pwr;\n\tunsigned int mant, frac;\n\n\t/* extract exponent field from input */\n\texp = ((s >> 23) & 0xff) - 127;\n\tif (exp > 7) {\n\t\t/* check for NaN input */\n\t\tif (exp == 128 && (s & 0x7fffff) != 0)\n\t\t\treturn s | 0x400000;\t/* return QNaN */\n\t\t/* 2^-big = 0, 2^+big = +Inf */\n\t\treturn (s & 0x80000000)? 0: 0x7f800000;\t/* 0 or +Inf */\n\t}\n\tif (exp < -23)\n\t\treturn 0x3f800000;\t/* 1.0 */\n\n\t/* convert to fixed point integer in 9.23 representation */\n\tpwr = (s & 0x7fffff) | 0x800000;\n\tif (exp > 0)\n\t\tpwr <<= exp;\n\telse\n\t\tpwr >>= -exp;\n\tif (s & 0x80000000)\n\t\tpwr = -pwr;\n\n\t/* extract integer part, which becomes exponent part of result */\n\texp = (pwr >> 23) + 126;\n\tif (exp >= 254)\n\t\treturn 0x7f800000;\n\tif (exp < -23)\n\t\treturn 0;\n\n\t/* table lookup on top 3 bits of fraction to get mantissa */\n\tmant = exp2s[(pwr >> 20) & 7];\n\n\t/* linear interpolation using remaining 20 bits of fraction */\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t    : \"r\" (pwr << 12), \"r\" (0x172b83ff));\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac) : \"r\" (frac), \"r\" (mant));\n\tmant += frac;\n\n\tif (exp >= 0)\n\t\treturn mant + (exp << 23);\n\n\t/* denormalized result */\n\texp = -exp;\n\tmant += 1 << (exp - 1);\n\treturn mant >> exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vrsqrtefp",
          "args": [
            "&vrs[vd]",
            "&vrs[vb]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vrefp",
          "args": [
            "&vrs[vd]",
            "&vrs[vb]"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsubfp",
          "args": [
            "&vrs[vd]",
            "&vrs[va]",
            "&vrs[vb]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vaddfp",
          "args": [
            "&vrs[vd]",
            "&vrs[va]",
            "&vrs[vb]"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_primary_opcode",
          "args": [
            "instr"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "instr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_instr",
          "args": [
            "instr",
            "(void __user *)regs->nip"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint emulate_altivec(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tunsigned int i, word;\n\tunsigned int va, vb, vc, vd;\n\tvector128 *vrs;\n\n\tif (get_user_instr(instr, (void __user *)regs->nip))\n\t\treturn -EFAULT;\n\n\tword = ppc_inst_val(instr);\n\tif (ppc_inst_primary_opcode(instr) != 4)\n\t\treturn -EINVAL;\t\t/* not an altivec instruction */\n\tvd = (word >> 21) & 0x1f;\n\tva = (word >> 16) & 0x1f;\n\tvb = (word >> 11) & 0x1f;\n\tvc = (word >> 6) & 0x1f;\n\n\tvrs = current->thread.vr_state.vr;\n\tswitch (word & 0x3f) {\n\tcase 10:\n\t\tswitch (vc) {\n\t\tcase 0:\t/* vaddfp */\n\t\t\tvaddfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 1:\t/* vsubfp */\n\t\t\tvsubfp(&vrs[vd], &vrs[va], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 4:\t/* vrefp */\n\t\t\tvrefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 5:\t/* vrsqrtefp */\n\t\t\tvrsqrtefp(&vrs[vd], &vrs[vb]);\n\t\t\tbreak;\n\t\tcase 6:\t/* vexptefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = eexp2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 7:\t/* vlogefp */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = elog2(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 8:\t\t/* vrfin */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfin(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 9:\t\t/* vrfiz */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = rfiz(vrs[vb].u[i]);\n\t\t\tbreak;\n\t\tcase 10:\t/* vrfip */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfiz(x): rfii(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 11:\t/* vrfim */\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tu32 x = vrs[vb].u[i];\n\t\t\t\tx = (x & 0x80000000)? rfii(x): rfiz(x);\n\t\t\t\tvrs[vd].u[i] = x;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 14:\t/* vctuxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctuxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tcase 15:\t/* vctsxs */\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tvrs[vd].u[i] = ctsxs(vrs[vb].u[i], va,\n\t\t\t\t\t&current->thread.vr_state.vscr.u[3]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 46:\t/* vmaddfp */\n\t\tvmaddfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tcase 47:\t/* vnmsubfp */\n\t\tvnmsubfp(&vrs[vd], &vrs[va], &vrs[vb], &vrs[vc]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rfin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "243-260",
    "snippet": "static unsigned int rfin(unsigned int x)\n{\n\tint exp, half;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < -1)\n\t\treturn x & 0x80000000;\t/* |x| < 0.5 -> +/-0 */\n\tif (exp == -1)\n\t\t/* 0.5 <= |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\thalf = 0x400000 >> exp;\n\t/* add 0.5 to the magnitude and chop off the fraction bits */\n\treturn (x + half) & ~(0x7fffff >> exp);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfin(unsigned int x)\n{\n\tint exp, half;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < -1)\n\t\treturn x & 0x80000000;\t/* |x| < 0.5 -> +/-0 */\n\tif (exp == -1)\n\t\t/* 0.5 <= |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\thalf = 0x400000 >> exp;\n\t/* add 0.5 to the magnitude and chop off the fraction bits */\n\treturn (x + half) & ~(0x7fffff >> exp);\n}"
  },
  {
    "function_name": "rfii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "222-240",
    "snippet": "static unsigned int rfii(unsigned int x)\n{\n\tint exp, mask;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif ((x & 0x7fffffff) == 0)\n\t\treturn x;\t\t/* +/-0 -> +/-0 */\n\tif (exp < 0)\n\t\t/* 0 < |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\tmask = 0x7fffff >> exp;\n\t/* mantissa overflows into exponent - that's OK,\n\t   it can't overflow into the sign bit */\n\treturn (x + mask) & ~mask;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfii(unsigned int x)\n{\n\tint exp, mask;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif ((x & 0x7fffffff) == 0)\n\t\treturn x;\t\t/* +/-0 -> +/-0 */\n\tif (exp < 0)\n\t\t/* 0 < |x| < 1.0 rounds to +/- 1.0 */\n\t\treturn (x & 0x80000000) | 0x3f800000;\n\tmask = 0x7fffff >> exp;\n\t/* mantissa overflows into exponent - that's OK,\n\t   it can't overflow into the sign bit */\n\treturn (x + mask) & ~mask;\n}"
  },
  {
    "function_name": "rfiz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "207-219",
    "snippet": "static unsigned int rfiz(unsigned int x)\n{\n\tint exp;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < 0)\n\t\treturn x & 0x80000000;\t/* |x| < 1.0 rounds to 0 */\n\treturn x & ~(0x7fffff >> exp);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int rfiz(unsigned int x)\n{\n\tint exp;\n\n\texp = ((x >> 23) & 0xff) - 127;\n\tif (exp == 128 && (x & 0x7fffff) != 0)\n\t\treturn x | 0x400000;\t/* NaN -> make it a QNaN */\n\tif (exp >= 23)\n\t\treturn x;\t\t/* it's an integer already (or Inf) */\n\tif (exp < 0)\n\t\treturn x & 0x80000000;\t/* |x| < 1.0 rounds to 0 */\n\treturn x & ~(0x7fffff >> exp);\n}"
  },
  {
    "function_name": "ctuxs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "179-204",
    "snippet": "static unsigned int ctuxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp;\n\tunsigned int mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (x & 0x80000000) {\n\t\t/* negative => saturate to 0 */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0;\n\t}\n\tif (exp >= 32) {\n\t\t/* saturate */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0xffffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 8) >> (31 - exp);\n\treturn mant;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VSCR_SAT\t1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\n#define VSCR_SAT\t1\n\nstatic unsigned int ctuxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp;\n\tunsigned int mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (x & 0x80000000) {\n\t\t/* negative => saturate to 0 */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0;\n\t}\n\tif (exp >= 32) {\n\t\t/* saturate */\n\t\t*vscrp |= VSCR_SAT;\n\t\treturn 0xffffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 8) >> (31 - exp);\n\treturn mant;\n}"
  },
  {
    "function_name": "ctsxs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "157-177",
    "snippet": "static int ctsxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp, mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (exp >= 31) {\n\t\t/* saturate, unless the result would be -2^31 */\n\t\tif (x + (scale << 23) != 0xcf000000)\n\t\t\t*vscrp |= VSCR_SAT;\n\t\treturn (x & 0x80000000)? 0x80000000: 0x7fffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 7) >> (30 - exp);\n\treturn (x & 0x80000000)? -mant: mant;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VSCR_SAT\t1"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\n#define VSCR_SAT\t1\n\nstatic int ctsxs(unsigned int x, int scale, unsigned int *vscrp)\n{\n\tint exp, mant;\n\n\texp = (x >> 23) & 0xff;\n\tmant = x & 0x7fffff;\n\tif (exp == 255 && mant != 0)\n\t\treturn 0;\t\t/* NaN -> 0 */\n\texp = exp - 127 + scale;\n\tif (exp < 0)\n\t\treturn 0;\t\t/* round towards zero */\n\tif (exp >= 31) {\n\t\t/* saturate, unless the result would be -2^31 */\n\t\tif (x + (scale << 23) != 0xcf000000)\n\t\t\t*vscrp |= VSCR_SAT;\n\t\treturn (x & 0x80000000)? 0x80000000: 0x7fffffff;\n\t}\n\tmant |= 0x800000;\n\tmant = (mant << 7) >> (30 - exp);\n\treturn (x & 0x80000000)? -mant: mant;\n}"
  },
  {
    "function_name": "elog2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "94-153",
    "snippet": "static unsigned int elog2(unsigned int s)\n{\n\tint exp, mant, lz, frac;\n\n\texp = s & 0x7f800000;\n\tmant = s & 0x7fffff;\n\tif (exp == 0x7f800000) {\t/* Inf or NaN */\n\t\tif (mant != 0)\n\t\t\ts |= 0x400000;\t/* turn NaN into QNaN */\n\t\treturn s;\n\t}\n\tif ((exp | mant) == 0)\t\t/* +0 or -0 */\n\t\treturn 0xff800000;\t/* return -Inf */\n\n\tif (exp == 0) {\n\t\t/* denormalized */\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (mant));\n\t\tmant <<= lz - 8;\n\t\texp = (-118 - lz) << 23;\n\t} else {\n\t\tmant |= 0x800000;\n\t\texp -= 127 << 23;\n\t}\n\n\tif (mant >= 0xb504f3) {\t\t\t\t/* 2^0.5 * 2^23 */\n\t\texp |= 0x400000;\t\t\t/* 0.5 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xb504f334));\t/* 2^-0.5 * 2^32 */\n\t}\n\tif (mant >= 0x9837f0) {\t\t\t\t/* 2^0.25 * 2^23 */\n\t\texp |= 0x200000;\t\t\t/* 0.25 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xd744fccb));\t/* 2^-0.25 * 2^32 */\n\t}\n\tif (mant >= 0x8b95c2) {\t\t\t\t/* 2^0.125 * 2^23 */\n\t\texp |= 0x100000;\t\t\t/* 0.125 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xeac0c6e8));\t/* 2^-0.125 * 2^32 */\n\t}\n\tif (mant > 0x800000) {\t\t\t\t/* 1.0 * 2^23 */\n\t\t/* calculate (mant - 1) * 1.381097463 */\n\t\t/* 1.381097463 == 0.125 / (2^0.125 - 1) */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t\t    : \"r\" ((mant - 0x800000) << 1), \"r\" (0xb0c7cd3a));\n\t\texp += frac;\n\t}\n\ts = exp & 0x80000000;\n\tif (exp != 0) {\n\t\tif (s)\n\t\t\texp = -exp;\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (exp));\n\t\tlz = 8 - lz;\n\t\tif (lz > 0)\n\t\t\texp >>= lz;\n\t\telse if (lz < 0)\n\t\t\texp <<= -lz;\n\t\ts += ((lz + 126) << 23) + exp;\n\t}\n\treturn s;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int elog2(unsigned int s)\n{\n\tint exp, mant, lz, frac;\n\n\texp = s & 0x7f800000;\n\tmant = s & 0x7fffff;\n\tif (exp == 0x7f800000) {\t/* Inf or NaN */\n\t\tif (mant != 0)\n\t\t\ts |= 0x400000;\t/* turn NaN into QNaN */\n\t\treturn s;\n\t}\n\tif ((exp | mant) == 0)\t\t/* +0 or -0 */\n\t\treturn 0xff800000;\t/* return -Inf */\n\n\tif (exp == 0) {\n\t\t/* denormalized */\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (mant));\n\t\tmant <<= lz - 8;\n\t\texp = (-118 - lz) << 23;\n\t} else {\n\t\tmant |= 0x800000;\n\t\texp -= 127 << 23;\n\t}\n\n\tif (mant >= 0xb504f3) {\t\t\t\t/* 2^0.5 * 2^23 */\n\t\texp |= 0x400000;\t\t\t/* 0.5 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xb504f334));\t/* 2^-0.5 * 2^32 */\n\t}\n\tif (mant >= 0x9837f0) {\t\t\t\t/* 2^0.25 * 2^23 */\n\t\texp |= 0x200000;\t\t\t/* 0.25 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xd744fccb));\t/* 2^-0.25 * 2^32 */\n\t}\n\tif (mant >= 0x8b95c2) {\t\t\t\t/* 2^0.125 * 2^23 */\n\t\texp |= 0x100000;\t\t\t/* 0.125 * 2^23 */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (mant)\n\t\t    : \"r\" (mant), \"r\" (0xeac0c6e8));\t/* 2^-0.125 * 2^32 */\n\t}\n\tif (mant > 0x800000) {\t\t\t\t/* 1.0 * 2^23 */\n\t\t/* calculate (mant - 1) * 1.381097463 */\n\t\t/* 1.381097463 == 0.125 / (2^0.125 - 1) */\n\t\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t\t    : \"r\" ((mant - 0x800000) << 1), \"r\" (0xb0c7cd3a));\n\t\texp += frac;\n\t}\n\ts = exp & 0x80000000;\n\tif (exp != 0) {\n\t\tif (s)\n\t\t\texp = -exp;\n\t\tasm(\"cntlzw %0,%1\" : \"=r\" (lz) : \"r\" (exp));\n\t\tlz = 8 - lz;\n\t\tif (lz > 0)\n\t\t\texp >>= lz;\n\t\telse if (lz < 0)\n\t\t\texp <<= -lz;\n\t\ts += ((lz + 126) << 23) + exp;\n\t}\n\treturn s;\n}"
  },
  {
    "function_name": "eexp2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vecemu.c",
    "lines": "39-88",
    "snippet": "static unsigned int eexp2(unsigned int s)\n{\n\tint exp, pwr;\n\tunsigned int mant, frac;\n\n\t/* extract exponent field from input */\n\texp = ((s >> 23) & 0xff) - 127;\n\tif (exp > 7) {\n\t\t/* check for NaN input */\n\t\tif (exp == 128 && (s & 0x7fffff) != 0)\n\t\t\treturn s | 0x400000;\t/* return QNaN */\n\t\t/* 2^-big = 0, 2^+big = +Inf */\n\t\treturn (s & 0x80000000)? 0: 0x7f800000;\t/* 0 or +Inf */\n\t}\n\tif (exp < -23)\n\t\treturn 0x3f800000;\t/* 1.0 */\n\n\t/* convert to fixed point integer in 9.23 representation */\n\tpwr = (s & 0x7fffff) | 0x800000;\n\tif (exp > 0)\n\t\tpwr <<= exp;\n\telse\n\t\tpwr >>= -exp;\n\tif (s & 0x80000000)\n\t\tpwr = -pwr;\n\n\t/* extract integer part, which becomes exponent part of result */\n\texp = (pwr >> 23) + 126;\n\tif (exp >= 254)\n\t\treturn 0x7f800000;\n\tif (exp < -23)\n\t\treturn 0;\n\n\t/* table lookup on top 3 bits of fraction to get mantissa */\n\tmant = exp2s[(pwr >> 20) & 7];\n\n\t/* linear interpolation using remaining 20 bits of fraction */\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t    : \"r\" (pwr << 12), \"r\" (0x172b83ff));\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac) : \"r\" (frac), \"r\" (mant));\n\tmant += frac;\n\n\tif (exp >= 0)\n\t\treturn mant + (exp << 23);\n\n\t/* denormalized result */\n\texp = -exp;\n\tmant += 1 << (exp - 1);\n\treturn mant >> exp;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int exp2s[8] = {\n\t0x800000,\n\t0x8b95c2,\n\t0x9837f0,\n\t0xa5fed7,\n\t0xb504f3,\n\t0xc5672a,\n\t0xd744fd,\n\t0xeac0c7\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <linux/uaccess.h>\n#include <asm/switch_to.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic unsigned int exp2s[8] = {\n\t0x800000,\n\t0x8b95c2,\n\t0x9837f0,\n\t0xa5fed7,\n\t0xb504f3,\n\t0xc5672a,\n\t0xd744fd,\n\t0xeac0c7\n};\n\nstatic unsigned int eexp2(unsigned int s)\n{\n\tint exp, pwr;\n\tunsigned int mant, frac;\n\n\t/* extract exponent field from input */\n\texp = ((s >> 23) & 0xff) - 127;\n\tif (exp > 7) {\n\t\t/* check for NaN input */\n\t\tif (exp == 128 && (s & 0x7fffff) != 0)\n\t\t\treturn s | 0x400000;\t/* return QNaN */\n\t\t/* 2^-big = 0, 2^+big = +Inf */\n\t\treturn (s & 0x80000000)? 0: 0x7f800000;\t/* 0 or +Inf */\n\t}\n\tif (exp < -23)\n\t\treturn 0x3f800000;\t/* 1.0 */\n\n\t/* convert to fixed point integer in 9.23 representation */\n\tpwr = (s & 0x7fffff) | 0x800000;\n\tif (exp > 0)\n\t\tpwr <<= exp;\n\telse\n\t\tpwr >>= -exp;\n\tif (s & 0x80000000)\n\t\tpwr = -pwr;\n\n\t/* extract integer part, which becomes exponent part of result */\n\texp = (pwr >> 23) + 126;\n\tif (exp >= 254)\n\t\treturn 0x7f800000;\n\tif (exp < -23)\n\t\treturn 0;\n\n\t/* table lookup on top 3 bits of fraction to get mantissa */\n\tmant = exp2s[(pwr >> 20) & 7];\n\n\t/* linear interpolation using remaining 20 bits of fraction */\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac)\n\t    : \"r\" (pwr << 12), \"r\" (0x172b83ff));\n\tasm(\"mulhwu %0,%1,%2\" : \"=r\" (frac) : \"r\" (frac), \"r\" (mant));\n\tmant += frac;\n\n\tif (exp >= 0)\n\t\treturn mant + (exp << 23);\n\n\t/* denormalized result */\n\texp = -exp;\n\tmant += 1 << (exp - 1);\n\treturn mant >> exp;\n}"
  }
]