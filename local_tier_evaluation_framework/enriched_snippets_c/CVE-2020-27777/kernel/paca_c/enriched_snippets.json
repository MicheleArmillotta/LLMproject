[
  {
    "function_name": "copy_mm_to_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "344-364",
    "snippet": "void copy_mm_to_paca(struct mm_struct *mm)\n{\n#ifdef CONFIG_PPC_BOOK3S\n\tmm_context_t *context = &mm->context;\n\n\tget_paca()->mm_ctx_id = context->id;\n#ifdef CONFIG_PPC_MM_SLICES\n\tVM_BUG_ON(!mm_ctx_slb_addr_limit(context));\n\tget_paca()->mm_ctx_slb_addr_limit = mm_ctx_slb_addr_limit(context);\n\tmemcpy(&get_paca()->mm_ctx_low_slices_psize, mm_ctx_low_slices(context),\n\t       LOW_SLICE_ARRAY_SZ);\n\tmemcpy(&get_paca()->mm_ctx_high_slices_psize, mm_ctx_high_slices(context),\n\t       TASK_SLICE_ARRAY_SZ(context));\n#else /* CONFIG_PPC_MM_SLICES */\n\tget_paca()->mm_ctx_user_psize = context->user_psize;\n\tget_paca()->mm_ctx_sllp = context->sllp;\n#endif\n#else /* !CONFIG_PPC_BOOK3S */\n\treturn;\n#endif\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&get_paca()->mm_ctx_high_slices_psize",
            "mm_ctx_high_slices(context)",
            "TASK_SLICE_ARRAY_SZ(context)"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TASK_SLICE_ARRAY_SZ",
          "args": [
            "context"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_ctx_high_slices",
          "args": [
            "context"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_ctx_low_slices",
          "args": [
            "context"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_ctx_slb_addr_limit",
          "args": [
            "context"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!mm_ctx_slb_addr_limit(context)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_ctx_slb_addr_limit",
          "args": [
            "context"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid copy_mm_to_paca(struct mm_struct *mm)\n{\n#ifdef CONFIG_PPC_BOOK3S\n\tmm_context_t *context = &mm->context;\n\n\tget_paca()->mm_ctx_id = context->id;\n#ifdef CONFIG_PPC_MM_SLICES\n\tVM_BUG_ON(!mm_ctx_slb_addr_limit(context));\n\tget_paca()->mm_ctx_slb_addr_limit = mm_ctx_slb_addr_limit(context);\n\tmemcpy(&get_paca()->mm_ctx_low_slices_psize, mm_ctx_low_slices(context),\n\t       LOW_SLICE_ARRAY_SZ);\n\tmemcpy(&get_paca()->mm_ctx_high_slices_psize, mm_ctx_high_slices(context),\n\t       TASK_SLICE_ARRAY_SZ(context));\n#else /* CONFIG_PPC_MM_SLICES */\n\tget_paca()->mm_ctx_user_psize = context->user_psize;\n\tget_paca()->mm_ctx_sllp = context->sllp;\n#endif\n#else /* !CONFIG_PPC_BOOK3S */\n\treturn;\n#endif\n}"
  },
  {
    "function_name": "free_unused_pacas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "319-342",
    "snippet": "void __init free_unused_pacas(void)\n{\n\tint new_ptrs_size;\n\n\tnew_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tif (new_ptrs_size < paca_ptrs_size)\n\t\tmemblock_free(__pa(paca_ptrs) + new_ptrs_size,\n\t\t\t\t\tpaca_ptrs_size - new_ptrs_size);\n\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\tpaca_ptrs_size = new_ptrs_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (early_radix_enabled()) {\n\t\t/* Ugly fixup, see new_slb_shadow() */\n\t\tmemblock_free(__pa(paca_ptrs[boot_cpuid]->slb_shadow_ptr),\n\t\t\t\tsizeof(struct slb_shadow));\n\t\tpaca_ptrs[boot_cpuid]->slb_shadow_ptr = NULL;\n\t}\n#endif\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %u pacas\\n\",\n\t\t\tpaca_ptrs_size + paca_struct_size, nr_cpu_ids);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define boot_cpuid 0"
    ],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Allocated %u bytes for %u pacas\\n\"",
            "paca_ptrs_size + paca_struct_size",
            "nr_cpu_ids"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "__pa(paca_ptrs[boot_cpuid]->slb_shadow_ptr)",
            "sizeof(struct slb_shadow)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "paca_ptrs[boot_cpuid]->slb_shadow_ptr"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_radix_enabled",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free",
          "args": [
            "__pa(paca_ptrs) + new_ptrs_size",
            "paca_ptrs_size - new_ptrs_size"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nvoid __init free_unused_pacas(void)\n{\n\tint new_ptrs_size;\n\n\tnew_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tif (new_ptrs_size < paca_ptrs_size)\n\t\tmemblock_free(__pa(paca_ptrs) + new_ptrs_size,\n\t\t\t\t\tpaca_ptrs_size - new_ptrs_size);\n\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\tpaca_ptrs_size = new_ptrs_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (early_radix_enabled()) {\n\t\t/* Ugly fixup, see new_slb_shadow() */\n\t\tmemblock_free(__pa(paca_ptrs[boot_cpuid]->slb_shadow_ptr),\n\t\t\t\tsizeof(struct slb_shadow));\n\t\tpaca_ptrs[boot_cpuid]->slb_shadow_ptr = NULL;\n\t}\n#endif\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %u pacas\\n\",\n\t\t\tpaca_ptrs_size + paca_struct_size, nr_cpu_ids);\n}"
  },
  {
    "function_name": "allocate_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "285-317",
    "snippet": "void __init allocate_paca(int cpu)\n{\n\tu64 limit;\n\tstruct paca_struct *paca;\n\n\tBUG_ON(cpu >= paca_nr_cpu_ids);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We access pacas in real mode, and cannot take SLB faults\n\t * on them when in virtual mode, so allocate them accordingly.\n\t */\n\tlimit = min(ppc64_bolted_size(), ppc64_rma_size);\n#else\n\tlimit = ppc64_rma_size;\n#endif\n\n\tpaca = alloc_paca_data(sizeof(struct paca_struct), L1_CACHE_BYTES,\n\t\t\t\tlimit, cpu);\n\tpaca_ptrs[cpu] = paca;\n\n\tinitialise_paca(paca, cpu);\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->lppaca_ptr = new_lppaca(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tpaca->slb_shadow_ptr = new_slb_shadow(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->rtas_args_reentrant = new_rtas_args(cpu, limit);\n#endif\n\tpaca_struct_size += sizeof(struct paca_struct);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_rtas_args",
          "args": [
            "cpu",
            "limit"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "new_rtas_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "187-196",
          "snippet": "static struct rtas_args * __init new_rtas_args(int cpu, unsigned long limit)\n{\n\tlimit = min_t(unsigned long, limit, RTAS_INSTANTIATE_MAX);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\treturn alloc_paca_data(sizeof(struct rtas_args), L1_CACHE_BYTES,\n\t\t\t       limit, cpu);\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nstatic struct rtas_args * __init new_rtas_args(int cpu, unsigned long limit)\n{\n\tlimit = min_t(unsigned long, limit, RTAS_INSTANTIATE_MAX);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\treturn alloc_paca_data(sizeof(struct rtas_args), L1_CACHE_BYTES,\n\t\t\t       limit, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_slb_shadow",
          "args": [
            "cpu",
            "limit"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "new_slb_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "151-171",
          "snippet": "static struct slb_shadow * __init new_slb_shadow(int cpu, unsigned long limit)\n{\n\tstruct slb_shadow *s;\n\n\tif (cpu != boot_cpuid) {\n\t\t/*\n\t\t * Boot CPU comes here before early_radix_enabled\n\t\t * is parsed (e.g., for disable_radix). So allocate\n\t\t * always and this will be fixed up in free_unused_pacas.\n\t\t */\n\t\tif (early_radix_enabled())\n\t\t\treturn NULL;\n\t}\n\n\ts = alloc_paca_data(sizeof(*s), L1_CACHE_BYTES, limit, cpu);\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define boot_cpuid 0"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic struct slb_shadow * __init new_slb_shadow(int cpu, unsigned long limit)\n{\n\tstruct slb_shadow *s;\n\n\tif (cpu != boot_cpuid) {\n\t\t/*\n\t\t * Boot CPU comes here before early_radix_enabled\n\t\t * is parsed (e.g., for disable_radix). So allocate\n\t\t * always and this will be fixed up in free_unused_pacas.\n\t\t */\n\t\tif (early_radix_enabled())\n\t\t\treturn NULL;\n\t}\n\n\ts = alloc_paca_data(sizeof(*s), L1_CACHE_BYTES, limit, cpu);\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_lppaca",
          "args": [
            "cpu",
            "limit"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "new_lppaca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "122-139",
          "snippet": "static struct lppaca * __init new_lppaca(int cpu, unsigned long limit)\n{\n\tstruct lppaca *lp;\n\n\tBUILD_BUG_ON(sizeof(struct lppaca) > LPPACA_SIZE);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\tif (is_secure_guest())\n\t\tlp = alloc_shared_lppaca(LPPACA_SIZE, limit, cpu);\n\telse\n\t\tlp = alloc_paca_data(LPPACA_SIZE, 0x400, limit, cpu);\n\n\tinit_lppaca(lp);\n\n\treturn lp;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define LPPACA_SIZE 0x400"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nvoid __init;\n\nstatic struct lppaca * __init new_lppaca(int cpu, unsigned long limit)\n{\n\tstruct lppaca *lp;\n\n\tBUILD_BUG_ON(sizeof(struct lppaca) > LPPACA_SIZE);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\tif (is_secure_guest())\n\t\tlp = alloc_shared_lppaca(LPPACA_SIZE, limit, cpu);\n\telse\n\t\tlp = alloc_paca_data(LPPACA_SIZE, 0x400, limit, cpu);\n\n\tinit_lppaca(lp);\n\n\treturn lp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialise_paca",
          "args": [
            "paca",
            "cpu"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "initialise_paca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "211-241",
          "snippet": "__nostackprotector initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->lppaca_ptr = NULL;\n#endif\n#ifdef CONFIG_PPC_BOOK3E\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc_addr();\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tnew_paca->slb_shadow_ptr = NULL;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->rtas_args_reentrant = NULL;\n#endif\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n__nostackprotector initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->lppaca_ptr = NULL;\n#endif\n#ifdef CONFIG_PPC_BOOK3E\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc_addr();\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tnew_paca->slb_shadow_ptr = NULL;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->rtas_args_reentrant = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_paca_data",
          "args": [
            "sizeof(struct paca_struct)",
            "L1_CACHE_BYTES",
            "limit",
            "cpu"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_paca_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "27-54",
          "snippet": "static void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define boot_cpuid 0"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ppc64_bolted_size()",
            "ppc64_rma_size"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64_bolted_size",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64_bolted_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/setup_64.c",
          "lines": "633-652",
          "snippet": "__init u64 ppc64_bolted_size(void)\n{\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Freescale BookE bolts the entire linear mapping */\n\t/* XXX: BookE ppc64_rma_limit setup seems to disagree? */\n\tif (early_mmu_has_feature(MMU_FTR_TYPE_FSL_E))\n\t\treturn linear_map_top;\n\t/* Other BookE, we assume the first GB is bolted */\n\treturn 1ul << 30;\n#else\n\t/* BookS radix, does not take faults on linear mapping */\n\tif (early_radix_enabled())\n\t\treturn ULONG_MAX;\n\n\t/* BookS hash, the first segment is bolted */\n\tif (early_mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\treturn 1UL << SID_SHIFT_1T;\n\treturn 1UL << SID_SHIFT;\n#endif\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/early_ioremap.h>",
            "#include <asm/kup.h>",
            "#include <asm/feature-fixups.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/opal.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/kexec.h>",
            "#include <asm/udbg.h>",
            "#include <asm/xmon.h>",
            "#include <asm/firmware.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/sections.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/paca.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memory.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/pci.h>",
            "#include <linux/memblock.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/tty.h>",
            "#include <linux/utsname.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/pgalloc.h>\n#include <asm/early_ioremap.h>\n#include <asm/kup.h>\n#include <asm/feature-fixups.h>\n#include <asm/hw_irq.h>\n#include <asm/cputhreads.h>\n#include <asm/opal.h>\n#include <asm/livepatch.h>\n#include <asm/code-patching.h>\n#include <asm/kexec.h>\n#include <asm/udbg.h>\n#include <asm/xmon.h>\n#include <asm/firmware.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/sections.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/paca.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/pgtable.h>\n#include <linux/nmi.h>\n#include <linux/memory.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/memblock.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/tty.h>\n#include <linux/utsname.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nvoid __init;\n\n__init u64 ppc64_bolted_size(void)\n{\n#ifdef CONFIG_PPC_BOOK3E\n\t/* Freescale BookE bolts the entire linear mapping */\n\t/* XXX: BookE ppc64_rma_limit setup seems to disagree? */\n\tif (early_mmu_has_feature(MMU_FTR_TYPE_FSL_E))\n\t\treturn linear_map_top;\n\t/* Other BookE, we assume the first GB is bolted */\n\treturn 1ul << 30;\n#else\n\t/* BookS radix, does not take faults on linear mapping */\n\tif (early_radix_enabled())\n\t\treturn ULONG_MAX;\n\n\t/* BookS hash, the first segment is bolted */\n\tif (early_mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\treturn 1UL << SID_SHIFT_1T;\n\treturn 1UL << SID_SHIFT;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu >= paca_nr_cpu_ids"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nvoid __init allocate_paca(int cpu)\n{\n\tu64 limit;\n\tstruct paca_struct *paca;\n\n\tBUG_ON(cpu >= paca_nr_cpu_ids);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We access pacas in real mode, and cannot take SLB faults\n\t * on them when in virtual mode, so allocate them accordingly.\n\t */\n\tlimit = min(ppc64_bolted_size(), ppc64_rma_size);\n#else\n\tlimit = ppc64_rma_size;\n#endif\n\n\tpaca = alloc_paca_data(sizeof(struct paca_struct), L1_CACHE_BYTES,\n\t\t\t\tlimit, cpu);\n\tpaca_ptrs[cpu] = paca;\n\n\tinitialise_paca(paca, cpu);\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->lppaca_ptr = new_lppaca(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tpaca->slb_shadow_ptr = new_slb_shadow(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->rtas_args_reentrant = new_rtas_args(cpu, limit);\n#endif\n\tpaca_struct_size += sizeof(struct paca_struct);\n}"
  },
  {
    "function_name": "allocate_paca_ptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "272-283",
    "snippet": "void __init allocate_paca_ptrs(void)\n{\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\n\tpaca_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tpaca_ptrs = memblock_alloc_raw(paca_ptrs_size, SMP_CACHE_BYTES);\n\tif (!paca_ptrs)\n\t\tpanic(\"Failed to allocate %d bytes for paca pointers\\n\",\n\t\t      paca_ptrs_size);\n\n\tmemset(paca_ptrs, 0x88, paca_ptrs_size);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "paca_ptrs",
            "0x88",
            "paca_ptrs_size"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to allocate %d bytes for paca pointers\\n\"",
            "paca_ptrs_size"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_smp_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "147-199",
          "snippet": "static void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static cpumask_t wd_smp_cpus_pending;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_raw",
          "args": [
            "paca_ptrs_size",
            "SMP_CACHE_BYTES"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nvoid __init allocate_paca_ptrs(void)\n{\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\n\tpaca_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tpaca_ptrs = memblock_alloc_raw(paca_ptrs_size, SMP_CACHE_BYTES);\n\tif (!paca_ptrs)\n\t\tpanic(\"Failed to allocate %d bytes for paca pointers\\n\",\n\t\t      paca_ptrs_size);\n\n\tmemset(paca_ptrs, 0x88, paca_ptrs_size);\n}"
  },
  {
    "function_name": "setup_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "244-266",
    "snippet": "void __nostackprotector setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/*\n\t * In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied.\n\t *\n\t * Normally you should test against CPU_FTR_HVMODE, but CPU features\n\t * are not yet set up when we first reach here.\n\t */\n\tif (mfmsr() & MSR_HV)\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_PACA",
            "local_paca"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_HPACA",
            "local_paca"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_TLB_EXFRAME",
            "local_paca->extlb"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __nostackprotector setup_paca(struct paca_struct *new_paca)\n{\n\t/* Setup r13 */\n\tlocal_paca = new_paca;\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* On Book3E, initialize the TLB miss exception frames */\n\tmtspr(SPRN_SPRG_TLB_EXFRAME, local_paca->extlb);\n#else\n\t/*\n\t * In HV mode, we setup both HPACA and PACA to avoid problems\n\t * if we do a GET_PACA() before the feature fixups have been\n\t * applied.\n\t *\n\t * Normally you should test against CPU_FTR_HVMODE, but CPU features\n\t * are not yet set up when we first reach here.\n\t */\n\tif (mfmsr() & MSR_HV)\n\t\tmtspr(SPRN_SPRG_HPACA, local_paca);\n#endif\n\tmtspr(SPRN_SPRG_PACA, local_paca);\n\n}"
  },
  {
    "function_name": "initialise_paca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "211-241",
    "snippet": "__nostackprotector initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->lppaca_ptr = NULL;\n#endif\n#ifdef CONFIG_PPC_BOOK3E\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc_addr();\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tnew_paca->slb_shadow_ptr = NULL;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->rtas_args_reentrant = NULL;\n#endif\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_toc_addr",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n__nostackprotector initialise_paca(struct paca_struct *new_paca, int cpu)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->lppaca_ptr = NULL;\n#endif\n#ifdef CONFIG_PPC_BOOK3E\n\tnew_paca->kernel_pgd = swapper_pg_dir;\n#endif\n\tnew_paca->lock_token = 0x8000;\n\tnew_paca->paca_index = cpu;\n\tnew_paca->kernel_toc = kernel_toc_addr();\n\tnew_paca->kernelbase = (unsigned long) _stext;\n\t/* Only set MSR:IR/DR when MMU is initialized */\n\tnew_paca->kernel_msr = MSR_KERNEL & ~(MSR_IR | MSR_DR);\n\tnew_paca->hw_cpu_id = 0xffff;\n\tnew_paca->kexec_state = KEXEC_STATE_NONE;\n\tnew_paca->__current = &init_task;\n\tnew_paca->data_offset = 0xfeeeeeeeeeeeeeeeULL;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tnew_paca->slb_shadow_ptr = NULL;\n#endif\n\n#ifdef CONFIG_PPC_BOOK3E\n\t/* For now -- if we have threads this will be adjusted later */\n\tnew_paca->tcd_ptr = &new_paca->tcd;\n#endif\n\n#ifdef CONFIG_PPC_PSERIES\n\tnew_paca->rtas_args_reentrant = NULL;\n#endif\n}"
  },
  {
    "function_name": "new_rtas_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "187-196",
    "snippet": "static struct rtas_args * __init new_rtas_args(int cpu, unsigned long limit)\n{\n\tlimit = min_t(unsigned long, limit, RTAS_INSTANTIATE_MAX);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\treturn alloc_paca_data(sizeof(struct rtas_args), L1_CACHE_BYTES,\n\t\t\t       limit, cpu);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_paca_data",
          "args": [
            "sizeof(struct rtas_args)",
            "L1_CACHE_BYTES",
            "limit",
            "cpu"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_paca_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "27-54",
          "snippet": "static void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define boot_cpuid 0"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "limit",
            "RTAS_INSTANTIATE_MAX"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nstatic struct rtas_args * __init new_rtas_args(int cpu, unsigned long limit)\n{\n\tlimit = min_t(unsigned long, limit, RTAS_INSTANTIATE_MAX);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\treturn alloc_paca_data(sizeof(struct rtas_args), L1_CACHE_BYTES,\n\t\t\t       limit, cpu);\n}"
  },
  {
    "function_name": "new_slb_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "151-171",
    "snippet": "static struct slb_shadow * __init new_slb_shadow(int cpu, unsigned long limit)\n{\n\tstruct slb_shadow *s;\n\n\tif (cpu != boot_cpuid) {\n\t\t/*\n\t\t * Boot CPU comes here before early_radix_enabled\n\t\t * is parsed (e.g., for disable_radix). So allocate\n\t\t * always and this will be fixed up in free_unused_pacas.\n\t\t */\n\t\tif (early_radix_enabled())\n\t\t\treturn NULL;\n\t}\n\n\ts = alloc_paca_data(sizeof(*s), L1_CACHE_BYTES, limit, cpu);\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define boot_cpuid 0"
    ],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sizeof(*s)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "SLB_NUM_BOLTED"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_paca_data",
          "args": [
            "sizeof(*s)",
            "L1_CACHE_BYTES",
            "limit",
            "cpu"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_paca_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "27-54",
          "snippet": "static void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define boot_cpuid 0"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_radix_enabled",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic struct slb_shadow * __init new_slb_shadow(int cpu, unsigned long limit)\n{\n\tstruct slb_shadow *s;\n\n\tif (cpu != boot_cpuid) {\n\t\t/*\n\t\t * Boot CPU comes here before early_radix_enabled\n\t\t * is parsed (e.g., for disable_radix). So allocate\n\t\t * always and this will be fixed up in free_unused_pacas.\n\t\t */\n\t\tif (early_radix_enabled())\n\t\t\treturn NULL;\n\t}\n\n\ts = alloc_paca_data(sizeof(*s), L1_CACHE_BYTES, limit, cpu);\n\n\ts->persistent = cpu_to_be32(SLB_NUM_BOLTED);\n\ts->buffer_length = cpu_to_be32(sizeof(*s));\n\n\treturn s;\n}"
  },
  {
    "function_name": "new_lppaca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "122-139",
    "snippet": "static struct lppaca * __init new_lppaca(int cpu, unsigned long limit)\n{\n\tstruct lppaca *lp;\n\n\tBUILD_BUG_ON(sizeof(struct lppaca) > LPPACA_SIZE);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\tif (is_secure_guest())\n\t\tlp = alloc_shared_lppaca(LPPACA_SIZE, limit, cpu);\n\telse\n\t\tlp = alloc_paca_data(LPPACA_SIZE, 0x400, limit, cpu);\n\n\tinit_lppaca(lp);\n\n\treturn lp;\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define LPPACA_SIZE 0x400"
    ],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_lppaca",
          "args": [
            "lp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "init_lppaca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "109-120",
          "snippet": "static inline void init_lppaca(struct lppaca *lppaca)\n{\n\tBUILD_BUG_ON(sizeof(struct lppaca) != 640);\n\n\t*lppaca = (struct lppaca) {\n\t\t.desc = cpu_to_be32(0xd397d781),\t/* \"LpPa\" */\n\t\t.size = cpu_to_be16(LPPACA_SIZE),\n\t\t.fpregs_in_use = 1,\n\t\t.slb_count = cpu_to_be16(64),\n\t\t.vmxregs_in_use = 0,\n\t\t.page_ins = 0, };\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define LPPACA_SIZE 0x400"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nstatic inline void init_lppaca(struct lppaca *lppaca)\n{\n\tBUILD_BUG_ON(sizeof(struct lppaca) != 640);\n\n\t*lppaca = (struct lppaca) {\n\t\t.desc = cpu_to_be32(0xd397d781),\t/* \"LpPa\" */\n\t\t.size = cpu_to_be16(LPPACA_SIZE),\n\t\t.fpregs_in_use = 1,\n\t\t.slb_count = cpu_to_be16(64),\n\t\t.vmxregs_in_use = 0,\n\t\t.page_ins = 0, };\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_paca_data",
          "args": [
            "LPPACA_SIZE",
            "0x400",
            "limit",
            "cpu"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_paca_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "27-54",
          "snippet": "static void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define boot_cpuid 0"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_shared_lppaca",
          "args": [
            "LPPACA_SIZE",
            "limit",
            "cpu"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_shared_lppaca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "60-100",
          "snippet": "static void *__init alloc_shared_lppaca(unsigned long size, unsigned long limit,\n\t\t\t\t\tint cpu)\n{\n\tsize_t shared_lppaca_total_size = PAGE_ALIGN(nr_cpu_ids * LPPACA_SIZE);\n\tstatic unsigned long shared_lppaca_size;\n\tstatic void *shared_lppaca;\n\tvoid *ptr;\n\n\tif (!shared_lppaca) {\n\t\tmemblock_set_bottom_up(true);\n\n\t\t/*\n\t\t * See Documentation/powerpc/ultravisor.rst for more details.\n\t\t *\n\t\t * UV/HV data sharing is in PAGE_SIZE granularity. In order to\n\t\t * minimize the number of pages shared, align the allocation to\n\t\t * PAGE_SIZE.\n\t\t */\n\t\tshared_lppaca =\n\t\t\tmemblock_alloc_try_nid(shared_lppaca_total_size,\n\t\t\t\t\t       PAGE_SIZE, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t\t       limit, NUMA_NO_NODE);\n\t\tif (!shared_lppaca)\n\t\t\tpanic(\"cannot allocate shared data\");\n\n\t\tmemblock_set_bottom_up(false);\n\t\tuv_share_page(PHYS_PFN(__pa(shared_lppaca)),\n\t\t\t      shared_lppaca_total_size >> PAGE_SHIFT);\n\t}\n\n\tptr = shared_lppaca + shared_lppaca_size;\n\tshared_lppaca_size += size;\n\n\t/*\n\t * This is very early in boot, so no harm done if the kernel crashes at\n\t * this point.\n\t */\n\tBUG_ON(shared_lppaca_size > shared_lppaca_total_size);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define LPPACA_SIZE 0x400"
          ],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nvoid __init;\n\nstatic void *__init alloc_shared_lppaca(unsigned long size, unsigned long limit,\n\t\t\t\t\tint cpu)\n{\n\tsize_t shared_lppaca_total_size = PAGE_ALIGN(nr_cpu_ids * LPPACA_SIZE);\n\tstatic unsigned long shared_lppaca_size;\n\tstatic void *shared_lppaca;\n\tvoid *ptr;\n\n\tif (!shared_lppaca) {\n\t\tmemblock_set_bottom_up(true);\n\n\t\t/*\n\t\t * See Documentation/powerpc/ultravisor.rst for more details.\n\t\t *\n\t\t * UV/HV data sharing is in PAGE_SIZE granularity. In order to\n\t\t * minimize the number of pages shared, align the allocation to\n\t\t * PAGE_SIZE.\n\t\t */\n\t\tshared_lppaca =\n\t\t\tmemblock_alloc_try_nid(shared_lppaca_total_size,\n\t\t\t\t\t       PAGE_SIZE, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t\t       limit, NUMA_NO_NODE);\n\t\tif (!shared_lppaca)\n\t\t\tpanic(\"cannot allocate shared data\");\n\n\t\tmemblock_set_bottom_up(false);\n\t\tuv_share_page(PHYS_PFN(__pa(shared_lppaca)),\n\t\t\t      shared_lppaca_total_size >> PAGE_SHIFT);\n\t}\n\n\tptr = shared_lppaca + shared_lppaca_size;\n\tshared_lppaca_size += size;\n\n\t/*\n\t * This is very early in boot, so no harm done if the kernel crashes at\n\t * this point.\n\t */\n\tBUG_ON(shared_lppaca_size > shared_lppaca_total_size);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_secure_guest",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct lppaca) > LPPACA_SIZE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nvoid __init;\n\nstatic struct lppaca * __init new_lppaca(int cpu, unsigned long limit)\n{\n\tstruct lppaca *lp;\n\n\tBUILD_BUG_ON(sizeof(struct lppaca) > LPPACA_SIZE);\n\n\tif (early_cpu_has_feature(CPU_FTR_HVMODE))\n\t\treturn NULL;\n\n\tif (is_secure_guest())\n\t\tlp = alloc_shared_lppaca(LPPACA_SIZE, limit, cpu);\n\telse\n\t\tlp = alloc_paca_data(LPPACA_SIZE, 0x400, limit, cpu);\n\n\tinit_lppaca(lp);\n\n\treturn lp;\n}"
  },
  {
    "function_name": "init_lppaca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "109-120",
    "snippet": "static inline void init_lppaca(struct lppaca *lppaca)\n{\n\tBUILD_BUG_ON(sizeof(struct lppaca) != 640);\n\n\t*lppaca = (struct lppaca) {\n\t\t.desc = cpu_to_be32(0xd397d781),\t/* \"LpPa\" */\n\t\t.size = cpu_to_be16(LPPACA_SIZE),\n\t\t.fpregs_in_use = 1,\n\t\t.slb_count = cpu_to_be16(64),\n\t\t.vmxregs_in_use = 0,\n\t\t.page_ins = 0, };\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define LPPACA_SIZE 0x400"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "64"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "LPPACA_SIZE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0xd397d781"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct lppaca) != 640"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nstatic inline void init_lppaca(struct lppaca *lppaca)\n{\n\tBUILD_BUG_ON(sizeof(struct lppaca) != 640);\n\n\t*lppaca = (struct lppaca) {\n\t\t.desc = cpu_to_be32(0xd397d781),\t/* \"LpPa\" */\n\t\t.size = cpu_to_be16(LPPACA_SIZE),\n\t\t.fpregs_in_use = 1,\n\t\t.slb_count = cpu_to_be16(64),\n\t\t.vmxregs_in_use = 0,\n\t\t.page_ins = 0, };\n}"
  },
  {
    "function_name": "alloc_shared_lppaca",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "60-100",
    "snippet": "static void *__init alloc_shared_lppaca(unsigned long size, unsigned long limit,\n\t\t\t\t\tint cpu)\n{\n\tsize_t shared_lppaca_total_size = PAGE_ALIGN(nr_cpu_ids * LPPACA_SIZE);\n\tstatic unsigned long shared_lppaca_size;\n\tstatic void *shared_lppaca;\n\tvoid *ptr;\n\n\tif (!shared_lppaca) {\n\t\tmemblock_set_bottom_up(true);\n\n\t\t/*\n\t\t * See Documentation/powerpc/ultravisor.rst for more details.\n\t\t *\n\t\t * UV/HV data sharing is in PAGE_SIZE granularity. In order to\n\t\t * minimize the number of pages shared, align the allocation to\n\t\t * PAGE_SIZE.\n\t\t */\n\t\tshared_lppaca =\n\t\t\tmemblock_alloc_try_nid(shared_lppaca_total_size,\n\t\t\t\t\t       PAGE_SIZE, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t\t       limit, NUMA_NO_NODE);\n\t\tif (!shared_lppaca)\n\t\t\tpanic(\"cannot allocate shared data\");\n\n\t\tmemblock_set_bottom_up(false);\n\t\tuv_share_page(PHYS_PFN(__pa(shared_lppaca)),\n\t\t\t      shared_lppaca_total_size >> PAGE_SHIFT);\n\t}\n\n\tptr = shared_lppaca + shared_lppaca_size;\n\tshared_lppaca_size += size;\n\n\t/*\n\t * This is very early in boot, so no harm done if the kernel crashes at\n\t * this point.\n\t */\n\tBUG_ON(shared_lppaca_size > shared_lppaca_total_size);\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define LPPACA_SIZE 0x400"
    ],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "shared_lppaca_size > shared_lppaca_total_size"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uv_share_page",
          "args": [
            "PHYS_PFN(__pa(shared_lppaca))",
            "shared_lppaca_total_size >> PAGE_SHIFT"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "__pa(shared_lppaca)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "shared_lppaca"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_set_bottom_up",
          "args": [
            "false"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cannot allocate shared data\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid",
          "args": [
            "shared_lppaca_total_size",
            "PAGE_SIZE",
            "MEMBLOCK_LOW_LIMIT",
            "limit",
            "NUMA_NO_NODE"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_set_bottom_up",
          "args": [
            "true"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "nr_cpu_ids * LPPACA_SIZE"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define LPPACA_SIZE 0x400\n\nvoid __init;\n\nstatic void *__init alloc_shared_lppaca(unsigned long size, unsigned long limit,\n\t\t\t\t\tint cpu)\n{\n\tsize_t shared_lppaca_total_size = PAGE_ALIGN(nr_cpu_ids * LPPACA_SIZE);\n\tstatic unsigned long shared_lppaca_size;\n\tstatic void *shared_lppaca;\n\tvoid *ptr;\n\n\tif (!shared_lppaca) {\n\t\tmemblock_set_bottom_up(true);\n\n\t\t/*\n\t\t * See Documentation/powerpc/ultravisor.rst for more details.\n\t\t *\n\t\t * UV/HV data sharing is in PAGE_SIZE granularity. In order to\n\t\t * minimize the number of pages shared, align the allocation to\n\t\t * PAGE_SIZE.\n\t\t */\n\t\tshared_lppaca =\n\t\t\tmemblock_alloc_try_nid(shared_lppaca_total_size,\n\t\t\t\t\t       PAGE_SIZE, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t\t       limit, NUMA_NO_NODE);\n\t\tif (!shared_lppaca)\n\t\t\tpanic(\"cannot allocate shared data\");\n\n\t\tmemblock_set_bottom_up(false);\n\t\tuv_share_page(PHYS_PFN(__pa(shared_lppaca)),\n\t\t\t      shared_lppaca_total_size >> PAGE_SHIFT);\n\t}\n\n\tptr = shared_lppaca + shared_lppaca_size;\n\tshared_lppaca_size += size;\n\n\t/*\n\t * This is very early in boot, so no harm done if the kernel crashes at\n\t * this point.\n\t */\n\tBUG_ON(shared_lppaca_size > shared_lppaca_total_size);\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "alloc_paca_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
    "lines": "27-54",
    "snippet": "static void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/rtas.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/svm.h>",
      "#include <asm/kexec.h>",
      "#include <asm/sections.h>",
      "#include <asm/paca.h>",
      "#include <asm/lppaca.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/numa.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/memblock.h>",
      "#include <linux/export.h>",
      "#include <linux/smp.h>"
    ],
    "macros_used": [
      "#define boot_cpuid 0"
    ],
    "globals_used": [
      "void __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_set_bottom_up",
          "args": [
            "false"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cannot allocate paca data\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid",
          "args": [
            "size",
            "align",
            "MEMBLOCK_LOW_LIMIT",
            "limit",
            "nid"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_set_bottom_up",
          "args": [
            "true"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\n#define boot_cpuid 0\n\nvoid __init;\n\nstatic void *__init alloc_paca_data(unsigned long size, unsigned long align,\n\t\t\t\tunsigned long limit, int cpu)\n{\n\tvoid *ptr;\n\tint nid;\n\n\t/*\n\t * boot_cpuid paca is allocated very early before cpu_to_node is up.\n\t * Set bottom-up mode, because the boot CPU should be on node-0,\n\t * which will put its paca in the right place.\n\t */\n\tif (cpu == boot_cpuid) {\n\t\tnid = NUMA_NO_NODE;\n\t\tmemblock_set_bottom_up(true);\n\t} else {\n\t\tnid = early_cpu_to_node(cpu);\n\t}\n\n\tptr = memblock_alloc_try_nid(size, align, MEMBLOCK_LOW_LIMIT,\n\t\t\t\t     limit, nid);\n\tif (!ptr)\n\t\tpanic(\"cannot allocate paca data\");\n\n\tif (cpu == boot_cpuid)\n\t\tmemblock_set_bottom_up(false);\n\n\treturn ptr;\n}"
  }
]