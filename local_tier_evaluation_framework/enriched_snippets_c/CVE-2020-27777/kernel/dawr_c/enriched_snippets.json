[
  {
    "function_name": "dawr_force_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
    "lines": "93-109",
    "snippet": "static int __init dawr_force_setup(void)\n{\n\tif (cpu_has_feature(CPU_FTR_DAWR)) {\n\t\t/* Don't setup sysfs file for user control on P8 */\n\t\tdawr_force_enable = true;\n\t\treturn 0;\n\t}\n\n\tif (PVR_VER(mfspr(SPRN_PVR)) == PVR_POWER9) {\n\t\t/* Turn DAWR off by default, but allow admin to turn it on */\n\t\tdebugfs_create_file_unsafe(\"dawr_enable_dangerous\", 0600,\n\t\t\t\t\t   powerpc_debugfs_root,\n\t\t\t\t\t   &dawr_force_enable,\n\t\t\t\t\t   &dawr_enable_fops);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/machdep.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool dawr_force_enable;",
      "static const struct file_operations dawr_enable_fops = {\n\t.read =\t\tdebugfs_read_file_bool,\n\t.write =\tdawr_write_file_bool,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"dawr_enable_dangerous\"",
            "0600",
            "powerpc_debugfs_root",
            "&dawr_force_enable",
            "&dawr_enable_fops"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PVR_VER",
          "args": [
            "mfspr(SPRN_PVR)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DAWR"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nbool dawr_force_enable;\nstatic const struct file_operations dawr_enable_fops = {\n\t.read =\t\tdebugfs_read_file_bool,\n\t.write =\tdawr_write_file_bool,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic int __init dawr_force_setup(void)\n{\n\tif (cpu_has_feature(CPU_FTR_DAWR)) {\n\t\t/* Don't setup sysfs file for user control on P8 */\n\t\tdawr_force_enable = true;\n\t\treturn 0;\n\t}\n\n\tif (PVR_VER(mfspr(SPRN_PVR)) == PVR_POWER9) {\n\t\t/* Turn DAWR off by default, but allow admin to turn it on */\n\t\tdebugfs_create_file_unsafe(\"dawr_enable_dangerous\", 0600,\n\t\t\t\t\t   powerpc_debugfs_root,\n\t\t\t\t\t   &dawr_force_enable,\n\t\t\t\t\t   &dawr_enable_fops);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dawr_write_file_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
    "lines": "62-84",
    "snippet": "static ssize_t dawr_write_file_bool(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tsize_t rc;\n\n\t/* Send error to user if they hypervisor won't allow us to write DAWR */\n\tif (!dawr_force_enable &&\n\t    firmware_has_feature(FW_FEATURE_LPAR) &&\n\t    set_dawr(0, &null_brk) != H_SUCCESS)\n\t\treturn -ENODEV;\n\n\trc = debugfs_write_file_bool(file, user_buf, count, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\t/* If we are clearing, make sure all CPUs have the DAWR cleared */\n\tif (!dawr_force_enable)\n\t\tsmp_call_function(disable_dawrs_cb, NULL, 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/machdep.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool dawr_force_enable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "disable_dawrs_cb",
            "NULL",
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_write_file_bool",
          "args": [
            "file",
            "user_buf",
            "count",
            "ppos"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dawr",
          "args": [
            "0",
            "&null_brk"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "set_dawr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
          "lines": "19-51",
          "snippet": "int set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/machdep.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nint set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_LPAR"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nbool dawr_force_enable;\n\nstatic ssize_t dawr_write_file_bool(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tsize_t rc;\n\n\t/* Send error to user if they hypervisor won't allow us to write DAWR */\n\tif (!dawr_force_enable &&\n\t    firmware_has_feature(FW_FEATURE_LPAR) &&\n\t    set_dawr(0, &null_brk) != H_SUCCESS)\n\t\treturn -ENODEV;\n\n\trc = debugfs_write_file_bool(file, user_buf, count, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\t/* If we are clearing, make sure all CPUs have the DAWR cleared */\n\tif (!dawr_force_enable)\n\t\tsmp_call_function(disable_dawrs_cb, NULL, 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "disable_dawrs_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
    "lines": "53-60",
    "snippet": "static void disable_dawrs_cb(void *info)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++)\n\t\tset_dawr(i, &null_brk);\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/machdep.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dawr",
          "args": [
            "i",
            "&null_brk"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "set_dawr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
          "lines": "19-51",
          "snippet": "int set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/hvcall.h>",
            "#include <asm/machdep.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nint set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nstatic void disable_dawrs_cb(void *info)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++)\n\t\tset_dawr(i, &null_brk);\n}"
  },
  {
    "function_name": "set_dawr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dawr.c",
    "lines": "19-51",
    "snippet": "int set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/hvcall.h>",
      "#include <asm/machdep.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWRX1",
            "dawrx"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWR1",
            "dawr"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWRX0",
            "dawrx"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWR0",
            "dawr"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.set_dawr",
          "args": [
            "nr",
            "dawr",
            "dawrx"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/hvcall.h>\n#include <asm/machdep.h>\n#include <asm/debugfs.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/types.h>\n\nint set_dawr(int nr, struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE))\n\t\t<< (63 - 58);\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) << (63 - 59);\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) >> 3;\n\t/*\n\t * DAWR length is stored in field MDR bits 48:53.  Matches range in\n\t * doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t * 0b111111=64DW.\n\t * brk->hw_len is in bytes.\n\t * This aligns up to double word size, shifts and does the bias.\n\t */\n\tmrd = ((brk->hw_len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(nr, dawr, dawrx);\n\n\tif (nr == 0) {\n\t\tmtspr(SPRN_DAWR0, dawr);\n\t\tmtspr(SPRN_DAWRX0, dawrx);\n\t} else {\n\t\tmtspr(SPRN_DAWR1, dawr);\n\t\tmtspr(SPRN_DAWRX1, dawrx);\n\t}\n\n\treturn 0;\n}"
  }
]