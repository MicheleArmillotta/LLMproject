[
  {
    "function_name": "fix_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/align.c",
    "lines": "296-359",
    "snippet": "int fix_alignment(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tstruct instruction_op op;\n\tint r, type;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tif (unlikely(__get_user_instr(instr, (void __user *)regs->nip)))\n\t\treturn -EFAULT;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\t/* We don't handle PPC little-endian any more... */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\treturn -EIO;\n\t\tinstr = ppc_inst_swab(instr);\n\t}\n\n#ifdef CONFIG_SPE\n\tif (ppc_inst_primary_opcode(instr) == 0x4) {\n\t\tint reg = (ppc_inst_val(instr) >> 21) & 0x1f;\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\n\t/*\n\t * ISA 3.0 (such as P9) copy, copy_first, paste and paste_last alignment\n\t * check.\n\t *\n\t * Send a SIGBUS to the process that caused the fault.\n\t *\n\t * We do not emulate these because paste may contain additional metadata\n\t * when pasting to a co-processor. Furthermore, paste_last is the\n\t * synchronisation point for preceding copy/paste sequences.\n\t */\n\tif ((ppc_inst_val(instr) & 0xfc0006fe) == (PPC_INST_COPY & 0xfc0006fe))\n\t\treturn -EIO;\n\n\tr = analyse_instr(&op, regs, instr);\n\tif (r < 0)\n\t\treturn -EINVAL;\n\n\ttype = GETTYPE(op.type);\n\tif (!OP_IS_LOAD_STORE(type)) {\n\t\tif (op.type != CACHEOP + DCBZ)\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\tr = emulate_dcbz(op.ea, regs);\n\t} else {\n\t\tif (type == LARX || type == STCX)\n\t\t\treturn -EIO;\n\t\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\t\tr = emulate_loadstore(regs, &op);\n\t}\n\n\tif (!r)\n\t\treturn 1;\n\treturn r;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_loadstore",
          "args": [
            "regs",
            "&op"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "unaligned",
            "regs"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_dcbz",
          "args": [
            "op.ea",
            "regs"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "dcbz",
            "regs"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OP_IS_LOAD_STORE",
          "args": [
            "type"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETTYPE",
          "args": [
            "op.type"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "analyse_instr",
          "args": [
            "&op",
            "regs",
            "instr"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "instr"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_spe",
          "args": [
            "regs",
            "reg",
            "instr"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_spe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/align.c",
          "lines": "107-283",
          "snippet": "static int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       struct ppc_inst ppc_instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags, instr;\n\n\tinstr = ppc_inst_val(ppc_instr);\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok(addr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define\tEVSTWWO\t\t0x1E",
            "#define\tEVSTWWE\t\t0x1C",
            "#define\tEVSTWHO\t\t0x1A",
            "#define\tEVSTWHE\t\t0x18",
            "#define\tEVSTDH\t\t0x12",
            "#define\tEVSTDW\t\t0x11",
            "#define\tEVSTDD\t\t0x10",
            "#define\tEVLWHSPLAT\t0x0E",
            "#define\tEVLWWSPLAT\t0x0C",
            "#define\tEVLWHOS\t\t0x0B",
            "#define\tEVLWHOU\t\t0x0A",
            "#define\tEVLWHE\t\t0x08",
            "#define\tEVLHHOSSPLAT\t0x07",
            "#define\tEVLHHOUSPLAT\t0x06",
            "#define\tEVLHHESPLAT\t0x04",
            "#define\tEVLDH\t\t0x02",
            "#define\tEVLDW\t\t0x01",
            "#define\tEVLDD\t\t0x00",
            "#define E8\t0x80\t/* SPE endianness is double word */",
            "#define E4\t0x40\t/* SPE endianness is word */",
            "#define SW\t0x20\t/* byte swap */",
            "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sstep.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define\tEVSTWWO\t\t0x1E\n#define\tEVSTWWE\t\t0x1C\n#define\tEVSTWHO\t\t0x1A\n#define\tEVSTWHE\t\t0x18\n#define\tEVSTDH\t\t0x12\n#define\tEVSTDW\t\t0x11\n#define\tEVSTDD\t\t0x10\n#define\tEVLWHSPLAT\t0x0E\n#define\tEVLWWSPLAT\t0x0C\n#define\tEVLWHOS\t\t0x0B\n#define\tEVLWHOU\t\t0x0A\n#define\tEVLWHE\t\t0x08\n#define\tEVLHHOSSPLAT\t0x07\n#define\tEVLHHOUSPLAT\t0x06\n#define\tEVLHHESPLAT\t0x04\n#define\tEVLDH\t\t0x02\n#define\tEVLDW\t\t0x01\n#define\tEVLDD\t\t0x00\n#define E8\t0x80\t/* SPE endianness is double word */\n#define E4\t0x40\t/* SPE endianness is word */\n#define SW\t0x20\t/* byte swap */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n\nstatic int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       struct ppc_inst ppc_instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags, instr;\n\n\tinstr = ppc_inst_val(ppc_instr);\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok(addr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "spe",
            "regs"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "instr"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_primary_opcode",
          "args": [
            "instr"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_swab",
          "args": [
            "instr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_PPC_LE"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__get_user_instr(instr, (void __user *)regs->nip)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_instr",
          "args": [
            "instr",
            "(void __user *)regs->nip"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sstep.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint fix_alignment(struct pt_regs *regs)\n{\n\tstruct ppc_inst instr;\n\tstruct instruction_op op;\n\tint r, type;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tif (unlikely(__get_user_instr(instr, (void __user *)regs->nip)))\n\t\treturn -EFAULT;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\t/* We don't handle PPC little-endian any more... */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\treturn -EIO;\n\t\tinstr = ppc_inst_swab(instr);\n\t}\n\n#ifdef CONFIG_SPE\n\tif (ppc_inst_primary_opcode(instr) == 0x4) {\n\t\tint reg = (ppc_inst_val(instr) >> 21) & 0x1f;\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\n\t/*\n\t * ISA 3.0 (such as P9) copy, copy_first, paste and paste_last alignment\n\t * check.\n\t *\n\t * Send a SIGBUS to the process that caused the fault.\n\t *\n\t * We do not emulate these because paste may contain additional metadata\n\t * when pasting to a co-processor. Furthermore, paste_last is the\n\t * synchronisation point for preceding copy/paste sequences.\n\t */\n\tif ((ppc_inst_val(instr) & 0xfc0006fe) == (PPC_INST_COPY & 0xfc0006fe))\n\t\treturn -EIO;\n\n\tr = analyse_instr(&op, regs, instr);\n\tif (r < 0)\n\t\treturn -EINVAL;\n\n\ttype = GETTYPE(op.type);\n\tif (!OP_IS_LOAD_STORE(type)) {\n\t\tif (op.type != CACHEOP + DCBZ)\n\t\t\treturn -EINVAL;\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\tr = emulate_dcbz(op.ea, regs);\n\t} else {\n\t\tif (type == LARX || type == STCX)\n\t\t\treturn -EIO;\n\t\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\t\tr = emulate_loadstore(regs, &op);\n\t}\n\n\tif (!r)\n\t\treturn 1;\n\treturn r;\n}"
  },
  {
    "function_name": "emulate_spe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/align.c",
    "lines": "107-283",
    "snippet": "static int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       struct ppc_inst ppc_instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags, instr;\n\n\tinstr = ppc_inst_val(ppc_instr);\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok(addr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define\tEVSTWWO\t\t0x1E",
      "#define\tEVSTWWE\t\t0x1C",
      "#define\tEVSTWHO\t\t0x1A",
      "#define\tEVSTWHE\t\t0x18",
      "#define\tEVSTDH\t\t0x12",
      "#define\tEVSTDW\t\t0x11",
      "#define\tEVSTDD\t\t0x10",
      "#define\tEVLWHSPLAT\t0x0E",
      "#define\tEVLWWSPLAT\t0x0C",
      "#define\tEVLWHOS\t\t0x0B",
      "#define\tEVLWHOU\t\t0x0A",
      "#define\tEVLWHE\t\t0x08",
      "#define\tEVLHHOSSPLAT\t0x07",
      "#define\tEVLHHOUSPLAT\t0x06",
      "#define\tEVLHHESPLAT\t0x04",
      "#define\tEVLDH\t\t0x02",
      "#define\tEVLDW\t\t0x01",
      "#define\tEVLDD\t\t0x00",
      "#define E8\t0x80\t/* SPE endianness is double word */",
      "#define E4\t0x40\t/* SPE endianness is word */",
      "#define SW\t0x20\t/* byte swap */",
      "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[7]",
            "p++"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[6]",
            "p++"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[5]",
            "p++"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[4]",
            "p++"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[3]",
            "p++"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[2]",
            "p++"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[1]",
            "p++"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[0]",
            "p++"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[3]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[2]"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[1]"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[0]"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "data.w[1]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "data.w[0]"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab64",
          "args": [
            "data.ll"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[7]",
            "p++"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[6]",
            "p++"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[5]",
            "p++"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[4]",
            "p++"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[3]",
            "p++"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[2]",
            "p++"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[1]",
            "p++"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[0]",
            "p++"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "393-404",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!user_mode(regs)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "user_mode(regs) &&\n\t\t     !access_ok(addr, nb)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "addr",
            "nb"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "ppc_instr"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sstep.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define\tEVSTWWO\t\t0x1E\n#define\tEVSTWWE\t\t0x1C\n#define\tEVSTWHO\t\t0x1A\n#define\tEVSTWHE\t\t0x18\n#define\tEVSTDH\t\t0x12\n#define\tEVSTDW\t\t0x11\n#define\tEVSTDD\t\t0x10\n#define\tEVLWHSPLAT\t0x0E\n#define\tEVLWWSPLAT\t0x0C\n#define\tEVLWHOS\t\t0x0B\n#define\tEVLWHOU\t\t0x0A\n#define\tEVLWHE\t\t0x08\n#define\tEVLHHOSSPLAT\t0x07\n#define\tEVLHHOUSPLAT\t0x06\n#define\tEVLHHESPLAT\t0x04\n#define\tEVLDH\t\t0x02\n#define\tEVLDW\t\t0x01\n#define\tEVLDD\t\t0x00\n#define E8\t0x80\t/* SPE endianness is double word */\n#define E4\t0x40\t/* SPE endianness is word */\n#define SW\t0x20\t/* byte swap */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n\nstatic int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       struct ppc_inst ppc_instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags, instr;\n\n\tinstr = ppc_inst_val(ppc_instr);\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok(addr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}"
  }
]