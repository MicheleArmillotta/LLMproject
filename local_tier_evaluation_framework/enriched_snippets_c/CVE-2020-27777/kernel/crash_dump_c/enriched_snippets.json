[
  {
    "function_name": "crash_free_reserved_phys_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "125-146",
    "snippet": "void crash_free_reserved_phys_range(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tconst __be32 *basep, *sizep;\n\tunsigned int rtas_start = 0, rtas_end = 0;\n\n\tbasep = of_get_property(rtas.dev, \"linux,rtas-base\", NULL);\n\tsizep = of_get_property(rtas.dev, \"rtas-size\", NULL);\n\n\tif (basep && sizep) {\n\t\trtas_start = be32_to_cpup(basep);\n\t\trtas_end = rtas_start + be32_to_cpup(sizep);\n\t}\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/* Does this page overlap with the RTAS region? */\n\t\tif (addr <= rtas_end && ((addr + PAGE_SIZE) > rtas_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "pfn_to_page(addr >> PAGE_SHIFT)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "addr >> PAGE_SHIFT"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "sizep"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "basep"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"rtas-size\"",
            "NULL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"linux,rtas-base\"",
            "NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid crash_free_reserved_phys_range(unsigned long begin, unsigned long end)\n{\n\tunsigned long addr;\n\tconst __be32 *basep, *sizep;\n\tunsigned int rtas_start = 0, rtas_end = 0;\n\n\tbasep = of_get_property(rtas.dev, \"linux,rtas-base\", NULL);\n\tsizep = of_get_property(rtas.dev, \"rtas-size\", NULL);\n\n\tif (basep && sizep) {\n\t\trtas_start = be32_to_cpup(basep);\n\t\trtas_end = rtas_start + be32_to_cpup(sizep);\n\t}\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE) {\n\t\t/* Does this page overlap with the RTAS region? */\n\t\tif (addr <= rtas_end && ((addr + PAGE_SIZE) > rtas_start))\n\t\t\tcontinue;\n\n\t\tfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\n\t}\n}"
  },
  {
    "function_name": "copy_oldmem_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "96-118",
    "snippet": "ssize_t copy_oldmem_page(unsigned long pfn, char *buf,\n\t\t\tsize_t csize, unsigned long offset, int userbuf)\n{\n\tvoid  *vaddr;\n\tphys_addr_t paddr;\n\n\tif (!csize)\n\t\treturn 0;\n\n\tcsize = min_t(size_t, csize, PAGE_SIZE);\n\tpaddr = pfn << PAGE_SHIFT;\n\n\tif (memblock_is_region_memory(paddr, csize)) {\n\t\tvaddr = __va(paddr);\n\t\tcsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\n\t} else {\n\t\tvaddr = ioremap_cache(paddr, PAGE_SIZE);\n\t\tcsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\n\t\tiounmap(vaddr);\n\t}\n\n\treturn csize;\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "vaddr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_oldmem_vaddr",
          "args": [
            "vaddr",
            "buf",
            "csize",
            "offset",
            "userbuf"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "copy_oldmem_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
          "lines": "71-81",
          "snippet": "static size_t copy_oldmem_vaddr(void *vaddr, char *buf, size_t csize,\n                               unsigned long offset, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *)buf, (vaddr + offset), csize))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemcpy(buf, (vaddr + offset), csize);\n\n\treturn csize;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/inst.h>",
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/memblock.h>",
            "#include <linux/io.h>",
            "#include <linux/crash_dump.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nstatic size_t copy_oldmem_vaddr(void *vaddr, char *buf, size_t csize,\n                               unsigned long offset, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *)buf, (vaddr + offset), csize))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemcpy(buf, (vaddr + offset), csize);\n\n\treturn csize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioremap_cache",
          "args": [
            "paddr",
            "PAGE_SIZE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "paddr"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_region_memory",
          "args": [
            "paddr",
            "csize"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "csize",
            "PAGE_SIZE"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nssize_t copy_oldmem_page(unsigned long pfn, char *buf,\n\t\t\tsize_t csize, unsigned long offset, int userbuf)\n{\n\tvoid  *vaddr;\n\tphys_addr_t paddr;\n\n\tif (!csize)\n\t\treturn 0;\n\n\tcsize = min_t(size_t, csize, PAGE_SIZE);\n\tpaddr = pfn << PAGE_SHIFT;\n\n\tif (memblock_is_region_memory(paddr, csize)) {\n\t\tvaddr = __va(paddr);\n\t\tcsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\n\t} else {\n\t\tvaddr = ioremap_cache(paddr, PAGE_SIZE);\n\t\tcsize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);\n\t\tiounmap(vaddr);\n\t}\n\n\treturn csize;\n}"
  },
  {
    "function_name": "copy_oldmem_vaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "71-81",
    "snippet": "static size_t copy_oldmem_vaddr(void *vaddr, char *buf, size_t csize,\n                               unsigned long offset, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *)buf, (vaddr + offset), csize))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemcpy(buf, (vaddr + offset), csize);\n\n\treturn csize;\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "(vaddr + offset)",
            "csize"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(char __user *)buf",
            "(vaddr + offset)",
            "csize"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nstatic size_t copy_oldmem_vaddr(void *vaddr, char *buf, size_t csize,\n                               unsigned long offset, int userbuf)\n{\n\tif (userbuf) {\n\t\tif (copy_to_user((char __user *)buf, (vaddr + offset), csize))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemcpy(buf, (vaddr + offset), csize);\n\n\treturn csize;\n}"
  },
  {
    "function_name": "setup_kdump_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "52-68",
    "snippet": "void __init setup_kdump_trampoline(void)\n{\n\tunsigned long i;\n\n\tDBG(\" -> setup_kdump_trampoline()\\n\");\n\n\tfor (i = KDUMP_TRAMPOLINE_START; i < KDUMP_TRAMPOLINE_END; i += 8) {\n\t\tcreate_trampoline(i);\n\t}\n\n#ifdef CONFIG_PPC_PSERIES\n\tcreate_trampoline(__pa(system_reset_fwnmi) - PHYSICAL_START);\n\tcreate_trampoline(__pa(machine_check_fwnmi) - PHYSICAL_START);\n#endif /* CONFIG_PPC_PSERIES */\n\n\tDBG(\" <- setup_kdump_trampoline()\\n\");\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" <- setup_kdump_trampoline()\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_trampoline",
          "args": [
            "__pa(machine_check_fwnmi) - PHYSICAL_START"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "create_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
          "lines": "36-50",
          "snippet": "static void __init create_trampoline(unsigned long addr)\n{\n\tstruct ppc_inst *p = (struct ppc_inst *)addr;\n\n\t/* The maximum range of a single instruction branch, is the current\n\t * instruction's address + (32 MB - 4) bytes. For the trampoline we\n\t * need to branch to current address + 32 MB. So we insert a nop at\n\t * the trampoline address, then the next instruction (+ 4 bytes)\n\t * does a branch to (32 MB - 4). The net effect is that when we\n\t * branch to \"addr\" we jump to (\"addr\" + 32 MB). Although it requires\n\t * two instructions it doesn't require any registers.\n\t */\n\tpatch_instruction(p, ppc_inst(PPC_INST_NOP));\n\tpatch_branch((void *)p + 4, addr + PHYSICAL_START, 0);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/inst.h>",
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/memblock.h>",
            "#include <linux/io.h>",
            "#include <linux/crash_dump.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nstatic void __init create_trampoline(unsigned long addr)\n{\n\tstruct ppc_inst *p = (struct ppc_inst *)addr;\n\n\t/* The maximum range of a single instruction branch, is the current\n\t * instruction's address + (32 MB - 4) bytes. For the trampoline we\n\t * need to branch to current address + 32 MB. So we insert a nop at\n\t * the trampoline address, then the next instruction (+ 4 bytes)\n\t * does a branch to (32 MB - 4). The net effect is that when we\n\t * branch to \"addr\" we jump to (\"addr\" + 32 MB). Although it requires\n\t * two instructions it doesn't require any registers.\n\t */\n\tpatch_instruction(p, ppc_inst(PPC_INST_NOP));\n\tpatch_branch((void *)p + 4, addr + PHYSICAL_START, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "machine_check_fwnmi"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> setup_kdump_trampoline()\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid __init setup_kdump_trampoline(void)\n{\n\tunsigned long i;\n\n\tDBG(\" -> setup_kdump_trampoline()\\n\");\n\n\tfor (i = KDUMP_TRAMPOLINE_START; i < KDUMP_TRAMPOLINE_END; i += 8) {\n\t\tcreate_trampoline(i);\n\t}\n\n#ifdef CONFIG_PPC_PSERIES\n\tcreate_trampoline(__pa(system_reset_fwnmi) - PHYSICAL_START);\n\tcreate_trampoline(__pa(machine_check_fwnmi) - PHYSICAL_START);\n#endif /* CONFIG_PPC_PSERIES */\n\n\tDBG(\" <- setup_kdump_trampoline()\\n\");\n}"
  },
  {
    "function_name": "create_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "36-50",
    "snippet": "static void __init create_trampoline(unsigned long addr)\n{\n\tstruct ppc_inst *p = (struct ppc_inst *)addr;\n\n\t/* The maximum range of a single instruction branch, is the current\n\t * instruction's address + (32 MB - 4) bytes. For the trampoline we\n\t * need to branch to current address + 32 MB. So we insert a nop at\n\t * the trampoline address, then the next instruction (+ 4 bytes)\n\t * does a branch to (32 MB - 4). The net effect is that when we\n\t * branch to \"addr\" we jump to (\"addr\" + 32 MB). Although it requires\n\t * two instructions it doesn't require any registers.\n\t */\n\tpatch_instruction(p, ppc_inst(PPC_INST_NOP));\n\tpatch_branch((void *)p + 4, addr + PHYSICAL_START, 0);\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "(void *)p + 4",
            "addr + PHYSICAL_START",
            "0"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "p",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nstatic void __init create_trampoline(unsigned long addr)\n{\n\tstruct ppc_inst *p = (struct ppc_inst *)addr;\n\n\t/* The maximum range of a single instruction branch, is the current\n\t * instruction's address + (32 MB - 4) bytes. For the trampoline we\n\t * need to branch to current address + 32 MB. So we insert a nop at\n\t * the trampoline address, then the next instruction (+ 4 bytes)\n\t * does a branch to (32 MB - 4). The net effect is that when we\n\t * branch to \"addr\" we jump to (\"addr\" + 32 MB). Although it requires\n\t * two instructions it doesn't require any registers.\n\t */\n\tpatch_instruction(p, ppc_inst(PPC_INST_NOP));\n\tpatch_branch((void *)p + 4, addr + PHYSICAL_START, 0);\n}"
  },
  {
    "function_name": "reserve_kdump_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
    "lines": "31-34",
    "snippet": "void __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}",
    "includes": [
      "#include <asm/udbg.h>",
      "#include <asm/inst.h>",
      "#include <asm/rtas.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/firmware.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/memblock.h>",
      "#include <linux/io.h>",
      "#include <linux/crash_dump.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "0",
            "KDUMP_RESERVE_LIMIT"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}"
  }
]