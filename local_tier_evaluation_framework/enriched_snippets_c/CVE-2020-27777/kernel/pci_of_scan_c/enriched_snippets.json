[
  {
    "function_name": "of_rescan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "442-445",
    "snippet": "void of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__of_scan_bus",
          "args": [
            "node",
            "bus",
            "1"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "395-421",
          "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}"
  },
  {
    "function_name": "of_scan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "428-431",
    "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__of_scan_bus",
          "args": [
            "node",
            "bus",
            "0"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "395-421",
          "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
  },
  {
    "function_name": "__of_scan_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "395-421",
    "snippet": "static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_scan_pci_bridge",
          "args": [
            "dev"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_pci_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "250-345",
          "snippet": "void of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%pOF)\\n\", node);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %pOF\\n\",\n\t\t\t       node);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%pOF)\\n\", node);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %pOF\\n\",\n\t\t\t       node);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pci_bridge",
          "args": [
            "dev",
            "bus"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_bus_self",
          "args": [
            "bus"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1052-1070",
          "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    dev header type: %x\\n\"",
            "dev->hdr_type"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_pci_dev",
          "args": [
            "bus",
            "child"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_pci_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "348-387",
          "snippet": "static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %pOF\\n\", dn);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %pOF\\n\", dn);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_child_of_node",
          "args": [
            "node",
            "child"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"of_scan_bus(%pOF) bus no %d...\\n\"",
            "node",
            "bus->number"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void __of_scan_bus(struct device_node *node, struct pci_bus *bus,\n\t\t\t  int rescan_existing)\n{\n\tstruct device_node *child;\n\tstruct pci_dev *dev;\n\n\tpr_debug(\"of_scan_bus(%pOF) bus no %d...\\n\",\n\t\t node, bus->number);\n\n\t/* Scan direct children */\n\tfor_each_child_of_node(node, child) {\n\t\tdev = of_scan_pci_dev(bus, child);\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tpr_debug(\"    dev header type: %x\\n\", dev->hdr_type);\n\t}\n\n\t/* Apply all fixups necessary. We don't fixup the bus \"self\"\n\t * for an existing bridge that is being rescanned\n\t */\n\tif (!rescan_existing)\n\t\tpcibios_setup_bus_self(bus);\n\n\t/* Now scan child busses */\n\tfor_each_pci_bridge(dev, bus)\n\t\tof_scan_pci_bridge(dev);\n}"
  },
  {
    "function_name": "of_scan_pci_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "348-387",
    "snippet": "static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %pOF\\n\", dn);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  dev header type: %x\\n\"",
            "dev->hdr_type"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_create_pci_dev",
          "args": [
            "dn",
            "bus",
            "devfn"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "of_create_pci_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "175-239",
          "snippet": "struct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn,\n\t\t of_node_get_device_type(node));\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (of_node_is_type(node, \"pci\") || of_node_is_type(node, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (of_node_is_type(node, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = 0;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\treturn dev;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstruct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn,\n\t\t of_node_get_device_type(node));\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (of_node_is_type(node, \"pci\") || of_node_is_type(node, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (of_node_is_type(node, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = 0;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_slot",
          "args": [
            "bus",
            "devfn"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "reg",
            "1"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"reg\"",
            "&reglen"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "dn"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  * %pOF\\n\"",
            "dn"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "PCI_DN(dn)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,\n\t\t\t    struct device_node *dn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint reglen, devfn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));\n#endif\n\n\tpr_debug(\"  * %pOF\\n\", dn);\n\tif (!of_device_is_available(dn))\n\t\treturn NULL;\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tif (reg == NULL || reglen < 20)\n\t\treturn NULL;\n\tdevfn = (of_read_number(reg, 1) >> 8) & 0xff;\n\n\t/* Check if the PCI device is already there */\n\tdev = pci_get_slot(bus, devfn);\n\tif (dev) {\n\t\tpci_dev_put(dev);\n\t\treturn dev;\n\t}\n\n\t/* Device removed permanently ? */\n#ifdef CONFIG_EEH\n\tif (edev && (edev->mode & EEH_DEV_REMOVED))\n\t\treturn NULL;\n#endif\n\n\t/* create a new pci_dev for this device */\n\tdev = of_create_pci_dev(dn, bus, devfn);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"  dev header type: %x\\n\", dev->hdr_type);\n\treturn dev;\n}"
  },
  {
    "function_name": "of_scan_pci_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "250-345",
    "snippet": "void of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%pOF)\\n\", node);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %pOF\\n\",\n\t\t\t       node);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_scan_child_bus",
          "args": [
            "bus"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_bus",
          "args": [
            "node",
            "bus"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "428-431",
          "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    probe mode: %d\\n\"",
            "mode"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    bus name: %s\\n\"",
            "bus->name"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "bus->name",
            "\"PCI Bus %04x:%02x\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_bus_to_resource",
          "args": [
            "dev->bus",
            "res",
            "&region"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&ranges[1]",
            "2"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %pOF\\n\"",
            "node"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&ranges[6]",
            "2"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_parse_of_flags",
          "args": [
            "of_read_number(ranges, 1)",
            "1"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "pci_parse_of_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "75-107",
          "snippet": "unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [
            "#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL",
            "#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)",
            "#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)",
            "#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)",
            "#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)",
            "#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)",
            "#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL\n#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)\n#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)\n#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)\n#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)\n\nunsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "ranges",
            "1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_insert_busn_res",
          "args": [
            "bus",
            "of_read_number(busrange, 1)",
            "of_read_number(busrange+1, 1)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange+1",
            "1"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_new_bus",
          "args": [
            "dev->bus",
            "dev",
            "of_read_number(busrange, 1)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_bus",
          "args": [
            "pci_domain_nr(dev->bus)",
            "of_read_number(busrange, 1)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "busrange",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"ranges\"",
            "&len"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"bus-range\"",
            "&len"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"of_scan_pci_bridge(%pOF)\\n\"",
            "node"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_pci_bridge(struct pci_dev *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *phb;\n\tconst __be32 *busrange, *ranges;\n\tint len, i, mode;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tunsigned int flags;\n\tu64 size;\n\n\tpr_debug(\"of_scan_pci_bridge(%pOF)\\n\", node);\n\n\t/* parse bus-range property */\n\tbusrange = of_get_property(node, \"bus-range\", &len);\n\tif (busrange == NULL || len != 8) {\n\t\tprintk(KERN_DEBUG \"Can't get bus-range for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\tranges = of_get_property(node, \"ranges\", &len);\n\tif (ranges == NULL) {\n\t\tprintk(KERN_DEBUG \"Can't get ranges for PCI-PCI bridge %pOF\\n\",\n\t\t       node);\n\t\treturn;\n\t}\n\n\tbus = pci_find_bus(pci_domain_nr(dev->bus),\n\t\t\t   of_read_number(busrange, 1));\n\tif (!bus) {\n\t\tbus = pci_add_new_bus(dev->bus, dev,\n\t\t\t\t      of_read_number(busrange, 1));\n\t\tif (!bus) {\n\t\t\tprintk(KERN_ERR \"Failed to create pci bus for %pOF\\n\",\n\t\t\t       node);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbus->primary = dev->bus->number;\n\tpci_bus_insert_busn_res(bus, of_read_number(busrange, 1),\n\t\t\t\tof_read_number(busrange+1, 1));\n\tbus->bridge_ctl = 0;\n\n\t/* parse ranges property */\n\t/* PCI #address-cells == 3 and #size-cells == 2 always */\n\tres = &dev->resource[PCI_BRIDGE_RESOURCES];\n\tfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\n\t\tres->flags = 0;\n\t\tbus->resource[i] = res;\n\t\t++res;\n\t}\n\ti = 1;\n\tfor (; len >= 32; len -= 32, ranges += 8) {\n\t\tflags = pci_parse_of_flags(of_read_number(ranges, 1), 1);\n\t\tsize = of_read_number(&ranges[6], 2);\n\t\tif (flags == 0 || size == 0)\n\t\t\tcontinue;\n\t\tif (flags & IORESOURCE_IO) {\n\t\t\tres = bus->resource[0];\n\t\t\tif (res->flags) {\n\t\t\t\tprintk(KERN_ERR \"PCI: ignoring extra I/O range\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\n\t\t\t\tprintk(KERN_ERR \"PCI: too many memory ranges\"\n\t\t\t\t       \" for bridge %pOF\\n\", node);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres = bus->resource[i];\n\t\t\t++i;\n\t\t}\n\t\tres->flags = flags;\n\t\tregion.start = of_read_number(&ranges[1], 2);\n\t\tregion.end = region.start + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n\tsprintf(bus->name, \"PCI Bus %04x:%02x\", pci_domain_nr(bus),\n\t\tbus->number);\n\tpr_debug(\"    bus name: %s\\n\", bus->name);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\telse if (mode == PCI_PROBE_NORMAL)\n\t\tpci_scan_child_bus(bus);\n}"
  },
  {
    "function_name": "of_create_pci_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "175-239",
    "snippet": "struct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn,\n\t\t of_node_get_device_type(node));\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (of_node_is_type(node, \"pci\") || of_node_is_type(node, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (of_node_is_type(node, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = 0;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\treturn dev;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_device_add",
          "args": [
            "dev",
            "bus"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    adding to system ...\\n\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_pci_parse_addrs",
          "args": [
            "node",
            "dev"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "of_pci_parse_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "117-167",
          "snippet": "static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\tbool mark_unset = false;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs || !proplen) {\n\t\taddrs = of_get_property(node, \"reg\", &proplen);\n\t\tif (!addrs || !proplen)\n\t\t\treturn;\n\t\tmark_unset = true;\n\t}\n\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tif (mark_unset)\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\tbool mark_unset = false;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs || !proplen) {\n\t\taddrs = of_get_property(node, \"reg\", &proplen);\n\t\tif (!addrs || !proplen)\n\t\t\treturn;\n\t\tmark_unset = true;\n\t}\n\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tif (mark_unset)\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "node",
            "\"cardbus\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pcie_hotplug_bridge",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "node",
            "\"pciex\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "node",
            "\"pci\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_fixup_device",
          "args": [
            "pci_fixup_early",
            "dev"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    revision: 0x%x\\n\"",
            "dev->revision"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    class: 0x%x\\n\"",
            "dev->class"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "node",
            "\"revision-id\"",
            "0"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "22-31",
          "snippet": "static u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&dev->dev",
            "\"%04x:%02x:%02x.%d\"",
            "pci_domain_nr(bus)",
            "dev->bus->number",
            "PCI_SLOT(devfn)",
            "PCI_FUNC(devfn)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "devfn"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "devfn"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_cfg_space_size",
          "args": [
            "dev"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_assign_slot",
          "args": [
            "dev"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pcie_port_type",
          "args": [
            "dev"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "node"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    create device, devfn: %x, type: %s\\n\"",
            "devfn",
            "of_node_get_device_type(node)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get_device_type",
          "args": [
            "node"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_alloc_dev",
          "args": [
            "bus"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstruct pci_dev *of_create_pci_dev(struct device_node *node,\n\t\t\t\t struct pci_bus *bus, int devfn)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pci_alloc_dev(bus);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpr_debug(\"    create device, devfn: %x, type: %s\\n\", devfn,\n\t\t of_node_get_device_type(node));\n\n\tdev->dev.of_node = of_node_get(node);\n\tdev->dev.parent = bus->bridge;\n\tdev->dev.bus = &pci_bus_type;\n\tdev->devfn = devfn;\n\tdev->multifunction = 0;\t\t/* maybe a lie? */\n\tdev->needs_freset = 0;\t\t/* pcie fundamental reset required */\n\tset_pcie_port_type(dev);\n\n\tpci_dev_assign_slot(dev);\n\tdev->vendor = get_int_prop(node, \"vendor-id\", 0xffff);\n\tdev->device = get_int_prop(node, \"device-id\", 0xffff);\n\tdev->subsystem_vendor = get_int_prop(node, \"subsystem-vendor-id\", 0);\n\tdev->subsystem_device = get_int_prop(node, \"subsystem-id\", 0);\n\n\tdev->cfg_size = pci_cfg_space_size(dev);\n\n\tdev_set_name(&dev->dev, \"%04x:%02x:%02x.%d\", pci_domain_nr(bus),\n\t\tdev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\n\tdev->class = get_int_prop(node, \"class-code\", 0);\n\tdev->revision = get_int_prop(node, \"revision-id\", 0);\n\n\tpr_debug(\"    class: 0x%x\\n\", dev->class);\n\tpr_debug(\"    revision: 0x%x\\n\", dev->revision);\n\n\tdev->current_state = PCI_UNKNOWN;\t/* unknown power state */\n\tdev->error_state = pci_channel_io_normal;\n\tdev->dma_mask = 0xffffffff;\n\n\t/* Early fixups, before probing the BARs */\n\tpci_fixup_device(pci_fixup_early, dev);\n\n\tif (of_node_is_type(node, \"pci\") || of_node_is_type(node, \"pciex\")) {\n\t\t/* a PCI-PCI bridge */\n\t\tdev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS1;\n\t\tset_pcie_hotplug_bridge(dev);\n\t} else if (of_node_is_type(node, \"cardbus\")) {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\n\t} else {\n\t\tdev->hdr_type = PCI_HEADER_TYPE_NORMAL;\n\t\tdev->rom_base_reg = PCI_ROM_ADDRESS;\n\t\t/* Maybe do a default OF mapping here */\n\t\tdev->irq = 0;\n\t}\n\n\tof_pci_parse_addrs(node, dev);\n\n\tpr_debug(\"    adding to system ...\\n\");\n\n\tpci_device_add(dev, bus);\n\n\treturn dev;\n}"
  },
  {
    "function_name": "of_pci_parse_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "117-167",
    "snippet": "static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\tbool mark_unset = false;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs || !proplen) {\n\t\taddrs = of_get_property(node, \"reg\", &proplen);\n\t\tif (!addrs || !proplen)\n\t\t\treturn;\n\t\tmark_unset = true;\n\t}\n\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tif (mark_unset)\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_bus_to_resource",
          "args": [
            "dev->bus",
            "res",
            "&region"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\"",
            "i"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  base: %llx, size: %llx, i: %x\\n\"",
            "(unsigned long long)base",
            "(unsigned long long)size",
            "i"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "addrs",
            "1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&addrs[3]",
            "2"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&addrs[1]",
            "2"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_parse_of_flags",
          "args": [
            "of_read_number(addrs, 1)",
            "0"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "pci_parse_of_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "75-107",
          "snippet": "unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [
            "#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL",
            "#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)",
            "#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)",
            "#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)",
            "#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)",
            "#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)",
            "#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL\n#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)\n#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)\n#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)\n#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)\n\nunsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "addrs",
            "1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    parse addresses (%d bytes) @ %p\\n\"",
            "proplen",
            "addrs"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"reg\"",
            "&proplen"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"assigned-addresses\"",
            "&proplen"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\n{\n\tu64 base, size;\n\tunsigned int flags;\n\tstruct pci_bus_region region;\n\tstruct resource *res;\n\tconst __be32 *addrs;\n\tu32 i;\n\tint proplen;\n\tbool mark_unset = false;\n\n\taddrs = of_get_property(node, \"assigned-addresses\", &proplen);\n\tif (!addrs || !proplen) {\n\t\taddrs = of_get_property(node, \"reg\", &proplen);\n\t\tif (!addrs || !proplen)\n\t\t\treturn;\n\t\tmark_unset = true;\n\t}\n\n\tpr_debug(\"    parse addresses (%d bytes) @ %p\\n\", proplen, addrs);\n\tfor (; proplen >= 20; proplen -= 20, addrs += 5) {\n\t\tflags = pci_parse_of_flags(of_read_number(addrs, 1), 0);\n\t\tif (!flags)\n\t\t\tcontinue;\n\t\tbase = of_read_number(&addrs[1], 2);\n\t\tsize = of_read_number(&addrs[3], 2);\n\t\tif (!size)\n\t\t\tcontinue;\n\t\ti = of_read_number(addrs, 1) & 0xff;\n\t\tpr_debug(\"  base: %llx, size: %llx, i: %x\\n\",\n\t\t\t (unsigned long long)base,\n\t\t\t (unsigned long long)size, i);\n\n\t\tif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\n\t\t\tres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\n\t\t} else if (i == dev->rom_base_reg) {\n\t\t\tres = &dev->resource[PCI_ROM_RESOURCE];\n\t\t\tflags |= IORESOURCE_READONLY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"PCI: bad cfg reg num 0x%x\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tres->flags = flags;\n\t\tif (mark_unset)\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\tres->name = pci_name(dev);\n\t\tregion.start = base;\n\t\tregion.end = base + size - 1;\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t}\n}"
  },
  {
    "function_name": "pci_parse_of_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "75-107",
    "snippet": "unsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [
      "#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL",
      "#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)",
      "#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)",
      "#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)",
      "#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)",
      "#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)",
      "#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#define OF_PCI_ADDR0_BARREG\t\t0x000000FFUL\n#define OF_PCI_ADDR0_ALIAS\t\t(1UL<<29)\n#define OF_PCI_ADDR0_PREFETCH\t\t(1UL<<30)\n#define OF_PCI_ADDR0_SPACE_MASK\t\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO64\tOF_PCI_ADDR0_SPACE(3)\n#define OF_PCI_ADDR0_SPACE_MMIO32\tOF_PCI_ADDR0_SPACE(2)\n#define OF_PCI_ADDR0_SPACE_IO\t\tOF_PCI_ADDR0_SPACE(1)\n\nunsigned int pci_parse_of_flags(u32 addr0, int bridge)\n{\n\tunsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;\n\n\tif (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {\n\t\tflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\n\n\t\tif (as == OF_PCI_ADDR0_SPACE_MMIO64)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;\n\n\t\tif (addr0 & OF_PCI_ADDR0_ALIAS)\n\t\t\tflags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;\n\n\t\tif (addr0 & OF_PCI_ADDR0_PREFETCH)\n\t\t\tflags |= IORESOURCE_PREFETCH |\n\t\t\t\t PCI_BASE_ADDRESS_MEM_PREFETCH;\n\n\t\t/* Note: We don't know whether the ROM has been left enabled\n\t\t * by the firmware or not. We mark it as disabled (ie, we do\n\t\t * not set the IORESOURCE_ROM_ENABLE flag) for now rather than\n\t\t * do a config space read, it will be force-enabled if needed\n\t\t */\n\t\tif (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)\n\t\t\tflags |= IORESOURCE_READONLY;\n\n\t} else if (as == OF_PCI_ADDR0_SPACE_IO)\n\t\tflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\n\n\tif (flags)\n\t\tflags |= IORESOURCE_SIZEALIGN;\n\n\treturn flags;\n}"
  },
  {
    "function_name": "get_int_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
    "lines": "22-31",
    "snippet": "static u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}",
    "includes": [
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop",
            "1"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "name",
            "&len"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic u32 get_int_prop(struct device_node *np, const char *name, u32 def)\n{\n\tconst __be32 *prop;\n\tint len;\n\n\tprop = of_get_property(np, name, &len);\n\tif (prop && len >= 4)\n\t\treturn of_read_number(prop, 1);\n\treturn def;\n}"
  }
]