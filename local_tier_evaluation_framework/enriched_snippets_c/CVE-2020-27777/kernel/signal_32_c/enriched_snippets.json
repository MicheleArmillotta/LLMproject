[
  {
    "function_name": "handle_signal32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1213-1298",
    "snippet": "int handle_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\tstruct task_struct *tsk)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "tsk->comm",
            "tsk->pid",
            "frame",
            "regs->nip",
            "regs->link"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(u32 __user *)newsp"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_user_regs",
          "args": [
            "regs",
            "&frame->mctx",
            "tm_mctx",
            "sigret",
            "1"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "save_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "238-333",
          "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_tm_user_regs",
          "args": [
            "regs",
            "&frame->mctx",
            "&frame->mctx_transact",
            "sigret",
            "msr"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "save_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "345-474",
          "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ksig->sig",
            "&sc->signal"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(&frame->mctx)",
            "&sc->regs"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "&frame->mctx"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "oldset->sig[1]",
            "&sc->_unused[3]"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(oldset->sig[0] >> 32)",
            "&sc->_unused[3]"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "oldset->sig[0]",
            "&sc->oldmask"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(ksig->ka.sa.sa_handler)",
            "&sc->handler"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "ksig->ka.sa.sa_handler"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "frame == NULL"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(tsk)",
            "sizeof(*frame)",
            "1"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "177-192",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "tsk"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "338-385",
          "snippet": "unsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nint handle_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\tstruct task_struct *tsk)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "do_setcontext_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "878-903",
    "snippet": "static int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_tm_user_regs",
          "args": [
            "regs",
            "mcp",
            "tm_mcp"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "585-738",
          "snippet": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tif (tm_suspend_disabled)\n\t\treturn 1;\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.ckvr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.vr_state,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.ckvr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.ckvrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_ckfpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &tm_sr->mc_vsregs) ||\n\t\t    copy_ckvsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/*\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t *\n\t * Pull in the MSR TM bits from the user context\n\t */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&current->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\tpreempt_enable();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tif (tm_suspend_disabled)\n\t\treturn 1;\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.ckvr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.vr_state,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.ckvr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.ckvrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_ckfpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &tm_sr->mc_vsregs) ||\n\t\t    copy_ckvsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/*\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t *\n\t * Pull in the MSR TM bits from the user context\n\t */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&current->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\tpreempt_enable();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tm_cmcp",
            "&tm_ucp->uc_regs"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&ucp->uc_regs"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigset_t",
          "args": [
            "&set",
            "&ucp->uc_sigmask"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "146-149",
          "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_setcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "848-875",
    "snippet": "static int do_setcontext(struct ucontext __user *ucp, struct pt_regs *regs, int sig)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n#ifdef CONFIG_PPC64\n\t{\n\t\tu32 cmcp;\n\n\t\tif (__get_user(cmcp, &ucp->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\t}\n#else\n\tif (__get_user(mcp, &ucp->uc_regs))\n\t\treturn -EFAULT;\n\tif (!access_ok(mcp, sizeof(*mcp)))\n\t\treturn -EFAULT;\n#endif\n\tset_current_blocked(&set);\n\tif (restore_user_regs(regs, mcp, sig))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_user_regs",
          "args": [
            "regs",
            "mcp",
            "sig"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "restore_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "481-577",
          "snippet": "static long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tset_trap_norestart(regs);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tset_trap_norestart(regs);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "mcp",
            "sizeof(*mcp)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "mcp",
            "&ucp->uc_regs"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&ucp->uc_regs"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigset_t",
          "args": [
            "&set",
            "&ucp->uc_sigmask"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "146-149",
          "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext(struct ucontext __user *ucp, struct pt_regs *regs, int sig)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n#ifdef CONFIG_PPC64\n\t{\n\t\tu32 cmcp;\n\n\t\tif (__get_user(cmcp, &ucp->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\t}\n#else\n\tif (__get_user(mcp, &ucp->uc_regs))\n\t\treturn -EFAULT;\n\tif (!access_ok(mcp, sizeof(*mcp)))\n\t\treturn -EFAULT;\n#endif\n\tset_current_blocked(&set);\n\tif (restore_user_regs(regs, mcp, sig))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_rt_signal32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "751-846",
    "snippet": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define copy_siginfo_to_user\tcopy_siginfo_to_user32",
      "#define tramp\tmc_pad",
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define __save_altstack __compat_save_altstack",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "tsk->comm",
            "tsk->pid",
            "addr",
            "regs->nip",
            "regs->link"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(u32 __user *)newsp"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_user_regs",
          "args": [
            "regs",
            "frame",
            "tm_frame",
            "sigret",
            "1"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "save_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "238-333",
          "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&rt_sf->uc.uc_link"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_tm_user_regs",
          "args": [
            "regs",
            "frame",
            "tm_frame",
            "sigret",
            "msr"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "save_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "345-474",
          "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)tm_frame",
            "&rt_sf->uc_transact.uc_regs"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)&rt_sf->uc_transact",
            "&rt_sf->uc.uc_link"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_sigset_t",
          "args": [
            "&rt_sf->uc.uc_sigmask",
            "oldset"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "put_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "141-144",
          "snippet": "static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(&rt_sf->uc.uc_mcontext)",
            "&rt_sf->uc.uc_regs"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "&rt_sf->uc.uc_mcontext"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_altstack",
          "args": [
            "&rt_sf->uc.uc_stack",
            "regs->gpr[1]"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&rt_sf->uc.uc_flags"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "&rt_sf->info",
            "&ksig->info"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rt_sf == NULL"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(tsk)",
            "sizeof(*rt_sf)",
            "1"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "177-192",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "tsk"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "338-385",
          "snippet": "unsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define copy_siginfo_to_user\tcopy_siginfo_to_user32\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define __save_altstack __compat_save_altstack\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nint handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "restore_tm_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "585-738",
    "snippet": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tif (tm_suspend_disabled)\n\t\treturn 1;\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.ckvr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.vr_state,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.ckvr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.ckvrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_ckfpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &tm_sr->mc_vsregs) ||\n\t\t    copy_ckvsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/*\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t *\n\t * Pull in the MSR TM bits from the user context\n\t */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&current->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\tpreempt_enable();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_vr_state",
          "args": [
            "&current->thread.vr_state"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_fp_state",
          "args": [
            "&current->thread.fp_state"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msr_check_and_set",
          "args": [
            "msr & (MSR_FP | MSR_VEC)"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "msr_check_and_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "120-134",
          "snippet": "unsigned long notrace msr_check_and_set(unsigned long bits)\n{\n\tunsigned long oldmsr = mfmsr();\n\tunsigned long newmsr;\n\n\tnewmsr = oldmsr | bits;\n\n\tif (cpu_has_feature(CPU_FTR_VSX) && (bits & MSR_FP))\n\t\tnewmsr |= MSR_VSX;\n\n\tif (oldmsr != newmsr)\n\t\tmtmsr_isync(newmsr);\n\n\treturn newmsr;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long notrace msr_check_and_set(unsigned long bits)\n{\n\tunsigned long oldmsr = mfmsr();\n\tunsigned long newmsr;\n\n\tnewmsr = oldmsr | bits;\n\n\tif (cpu_has_feature(CPU_FTR_VSX) && (bits & MSR_FP))\n\t\tnewmsr |= MSR_VSX;\n\n\tif (oldmsr != newmsr)\n\t\tmtmsr_isync(newmsr);\n\n\treturn newmsr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1033-1069",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavailable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!tm_enabled(new))\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d (new->msr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr);\n\n\ttm_recheckpoint(&new->thread);\n\n\t/*\n\t * The checkpointed state has been restored but the live state has\n\t * not, ensure all the math functionality is turned off to trigger\n\t * restore_math() to reload.\n\t */\n\tnew->thread.regs->msr &= ~(MSR_FP | MSR_VEC | MSR_VSX);\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_RESV",
          "args": [
            "msr_hi"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr_hi",
            "&tm_sr->mc_gregs[PT_MSR]"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->thread.evr",
            "0",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "current->thread.evr",
            "&sr->mc_vregs",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_ckvsx_from_user",
          "args": [
            "current",
            "&sr->mc_vsregs"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckvsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "123-134",
          "snippet": "unsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "&tm_sr->mc_vsregs"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "69-80",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_ckfpr_from_user",
          "args": [
            "current",
            "&tm_sr->mc_fregs"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckfpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "159-164",
          "snippet": "inline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sr->mc_fregs"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "144-149",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.ckvrsave"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&tm_sr->mc_vregs[32]"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.ckvrsave",
            "(u32 __user *)&sr->mc_vregs[32]"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "&tm_sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.ckvr_state",
            "&sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sr->mc_gregs[PT_MSR]"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.tm_tfhar",
            "&sr->mc_gregs[PT_NIP]"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_general_regs",
          "args": [
            "&current->thread.ckpt_regs",
            "sr"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "restore_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "161-173",
          "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\tif (tm_suspend_disabled)\n\t\treturn 1;\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.ckvr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.vr_state,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.ckvr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.ckvrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_ckfpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &tm_sr->mc_vsregs) ||\n\t\t    copy_ckvsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\n\t/*\n\t * Disabling preemption, since it is unsafe to be preempted\n\t * with MSR[TS] set without recheckpointing.\n\t */\n\tpreempt_disable();\n\n\t/*\n\t * CAUTION:\n\t * After regs->MSR[TS] being updated, make sure that get_user(),\n\t * put_user() or similar functions are *not* called. These\n\t * functions can generate page faults which will cause the process\n\t * to be de-scheduled with MSR[TS] set but without calling\n\t * tm_recheckpoint(). This can cause a bug.\n\t *\n\t * Pull in the MSR TM bits from the user context\n\t */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tmsr_check_and_set(msr & (MSR_FP | MSR_VEC));\n\tif (msr & MSR_FP) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tload_vr_state(&current->thread.vr_state);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\tpreempt_enable();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "481-577",
    "snippet": "static long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tset_trap_norestart(regs);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&sr->mc_vregs + ELF_NEVRREG"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->thread.evr",
            "0",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "current->thread.evr",
            "&sr->mc_vregs",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "&sr->mc_vsregs"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "69-80",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sr->mc_fregs"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "144-149",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.vrsave"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&sr->mc_vregs[32]"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "&sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sr->mc_gregs[PT_MSR]"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trap_norestart",
          "args": [
            "regs"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_general_regs",
          "args": [
            "regs",
            "sr"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "restore_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "161-173",
          "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tset_trap_norestart(regs);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vr = true;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_vsr = true;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\tcurrent->thread.used_spe = true;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_tm_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "345-474",
    "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &frame->tramp[0]",
            "(unsigned long) &frame->tramp[2]"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_SC",
            "&frame->tramp[1]"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_ADDI + sigret",
            "&frame->tramp[0]"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&frame->mc_gregs[PT_MSR]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&frame->mc_vregs + ELF_NEVRREG"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "current->thread.evr",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "393-404",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_ckvsx_to_user",
          "args": [
            "&tm_frame->mc_vsregs",
            "current"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckvsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "111-121",
          "snippet": "unsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "&tm_frame->mc_vsregs",
            "current"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "57-67",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_ckfpr_to_user",
          "args": [
            "&tm_frame->mc_fregs",
            "current"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "copy_ckfpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "152-157",
          "snippet": "inline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&tm_frame->mc_fregs",
            "current"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "137-142",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.ckvrsave",
            "(u32 __user *)&tm_frame->mc_vregs[32]"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&tm_frame->mc_vregs[32]"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.ckvrsave",
            "(u32 __user *)&frame->mc_vregs[32]"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_frame->mc_vregs",
            "&current->thread.ckvr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_frame->mc_vregs",
            "&current->thread.vr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "&current->thread.ckvr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(msr >> 32)",
            "&tm_frame->mc_gregs[PT_MSR]"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_general_regs",
          "args": [
            "regs",
            "tm_frame"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "save_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "154-159",
          "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tm_suspend_disabled"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret,\n\t\t\t     unsigned long msr)\n{\n\tWARN_ON(tm_suspend_disabled);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.ckvr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.ckvrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.ckvrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.ckvrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_ckfpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_ckfpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\tif (copy_ckvsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_ckvsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "238-333",
    "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &frame->tramp[0]",
            "(unsigned long) &frame->tramp[2]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_SC",
            "&frame->tramp[1]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "PPC_INST_ADDI + sigret",
            "&frame->tramp[0]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tm_frame->mc_gregs[PT_MSR]"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&frame->mc_gregs[PT_MSR]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&frame->mc_vregs + ELF_NEVRREG"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "current->thread.evr",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "393-404",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "&frame->mc_vsregs",
            "current"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "57-67",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "current"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&frame->mc_fregs",
            "current"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "137-142",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&frame->mc_vregs[32]"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "&current->thread.vr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_general_regs",
          "args": [
            "regs",
            "frame"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "save_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "154-159",
          "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\tflush_vsx_to_thread(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li 0,sigret; sc */\n\t\tif (__put_user(PPC_INST_ADDI + sigret, &frame->tramp[0])\n\t\t    || __put_user(PPC_INST_SC, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "161-173",
    "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&regs->orig_gpr3",
            "&sr->mc_gregs[PT_ORIG_R3]",
            "GP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs",
            "&sr->mc_gregs",
            "PT_MSR * sizeof(elf_greg_t)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "save_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "154-159",
    "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_gregs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
  },
  {
    "function_name": "get_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "146-149",
    "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "set",
            "uset",
            "sizeof(*uset)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
  },
  {
    "function_name": "put_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "141-144",
    "snippet": "static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uset",
            "set",
            "sizeof(*uset)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}"
  },
  {
    "function_name": "restore_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "122-135",
    "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tfor (i = 0; i <= PT_RESULT; i++) {\n\t\tif ((i == PT_MSR) || (i == PT_SOFTE))\n\t\t\tcontinue;\n\t\tif (__get_user(gregs[i], &sr->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "gregs[i]",
            "&sr->mc_gregs[i]"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tfor (i = 0; i <= PT_RESULT; i++) {\n\t\tif ((i == PT_MSR) || (i == PT_SOFTE))\n\t\t\tcontinue;\n\t\tif (__get_user(gregs[i], &sr->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "save_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "101-120",
    "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint val, i;\n\n\tWARN_ON(!FULL_REGS(regs));\n\n\tfor (i = 0; i <= PT_RESULT; i ++) {\n\t\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\t\tif (i == PT_SOFTE)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = gregs[i];\n\n\t\tif (__put_user(val, &frame->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "val",
            "&frame->mc_gregs[i]"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint val, i;\n\n\tWARN_ON(!FULL_REGS(regs));\n\n\tfor (i = 0; i <= PT_RESULT; i ++) {\n\t\t/* Force usr to alway see softe as 1 (interrupts enabled) */\n\t\tif (i == PT_SOFTE)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = gregs[i];\n\n\t\tif (__put_user(val, &frame->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "92-96",
    "snippet": "static inline int get_sigset_t(sigset_t *set,\n\t\t\t       const compat_sigset_t __user *uset)\n{\n\treturn get_compat_sigset(set, uset);\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_compat_sigset",
          "args": [
            "set",
            "uset"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set,\n\t\t\t       const compat_sigset_t __user *uset)\n{\n\treturn get_compat_sigset(set, uset);\n}"
  },
  {
    "function_name": "put_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "87-90",
    "snippet": "static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)\n{\n\treturn put_compat_sigset(uset, set, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_compat_sigset",
          "args": [
            "uset",
            "set",
            "sizeof(*uset)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)\n{\n\treturn put_compat_sigset(uset, set, sizeof(*uset));\n}"
  },
  {
    "function_name": "swapcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "907-998",
    "snippet": "SYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, int, ctx_size)\n#else\nSYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, long, ctx_size)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nSYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, int, ctx_size)\n#else\nSYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, long, ctx_size)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}"
  },
  {
    "function_name": "swapcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "910-998",
    "snippet": "SYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, long, ctx_size)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nSYSCALL_DEFINE3(swapcontext, struct ucontext __user *, old_ctx,\n\t\t       struct ucontext __user *, new_ctx, long, ctx_size)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(new_ctx, ctx_size) ||\n\t    fault_in_pages_readable((u8 __user *)new_ctx, ctx_size))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1001-1104",
    "snippet": "SYSCALL_DEFINE0(rt_sigreturn)\n#else\nSYSCALL_DEFINE0(rt_sigreturn)\n#endif\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct pt_regs *regs = current_pt_regs();\n\tint tm_restore = 0;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* Trying to start TM on non TM system */\n\t\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\t\tgoto bad;\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore) {\n\t\t/*\n\t\t * Unset regs->msr because ucontext MSR TS is not\n\t\t * set, and recheckpoint was not called. This avoid\n\t\t * hitting a TM Bad thing at RFID\n\t\t */\n\t\tregs->msr &= ~MSR_TS_MASK;\n\t}\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (!tm_restore)\n\t\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nSYSCALL_DEFINE0(rt_sigreturn)\n#else\nSYSCALL_DEFINE0(rt_sigreturn)\n#endif\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct pt_regs *regs = current_pt_regs();\n\tint tm_restore = 0;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* Trying to start TM on non TM system */\n\t\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\t\tgoto bad;\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore) {\n\t\t/*\n\t\t * Unset regs->msr because ucontext MSR TS is not\n\t\t * set, and recheckpoint was not called. This avoid\n\t\t * hitting a TM Bad thing at RFID\n\t\t */\n\t\tregs->msr &= ~MSR_TS_MASK;\n\t}\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (!tm_restore)\n\t\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1003-1104",
    "snippet": "SYSCALL_DEFINE0(rt_sigreturn)\n#endif\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct pt_regs *regs = current_pt_regs();\n\tint tm_restore = 0;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* Trying to start TM on non TM system */\n\t\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\t\tgoto bad;\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore) {\n\t\t/*\n\t\t * Unset regs->msr because ucontext MSR TS is not\n\t\t * set, and recheckpoint was not called. This avoid\n\t\t * hitting a TM Bad thing at RFID\n\t\t */\n\t\tregs->msr &= ~MSR_TS_MASK;\n\t}\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (!tm_restore)\n\t\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nSYSCALL_DEFINE0(rt_sigreturn)\n#endif\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct pt_regs *regs = current_pt_regs();\n\tint tm_restore = 0;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/*\n\t * If there is a transactional state then throw it away.\n\t * The purpose of a sigreturn is to destroy all traces of the\n\t * signal frame, this includes any transactional state created\n\t * within in. We only check for suspended as we can never be\n\t * active in the kernel, we are active, there is nothing better to\n\t * do than go ahead and Bad Thing later.\n\t * The cause is not important as there will never be a\n\t * recheckpoint so it's not user visible.\n\t */\n\tif (MSR_TM_SUSPENDED(mfmsr()))\n\t\ttm_reclaim_current(0);\n\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* Trying to start TM on non TM system */\n\t\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\t\tgoto bad;\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore) {\n\t\t/*\n\t\t * Unset regs->msr because ucontext MSR TS is not\n\t\t * set, and recheckpoint was not called. This avoid\n\t\t * hitting a TM Bad thing at RFID\n\t\t */\n\t\tregs->msr &= ~MSR_TS_MASK;\n\t}\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (!tm_restore)\n\t\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}"
  },
  {
    "function_name": "debug_setcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1107-1207",
    "snippet": "SYSCALL_DEFINE3(debug_setcontext, struct ucontext __user *, ctx,\n\t\t\t int, ndbg, struct sig_dbg_op __user *, dbg)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sig_dbg_op op;\n\tint i;\n\tunsigned long new_msr = regs->msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tunsigned long new_dbcr0 = current->thread.debug.dbcr0;\n#endif\n\n\tfor (i=0; i<ndbg; i++) {\n\t\tif (copy_from_user(&op, dbg + i, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tswitch (op.dbg_type) {\n\t\tcase SIG_DBG_SINGLE_STEPPING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tif (op.dbg_value) {\n\t\t\t\tnew_msr |= MSR_DE;\n\t\t\t\tnew_dbcr0 |= (DBCR0_IDM | DBCR0_IC);\n\t\t\t} else {\n\t\t\t\tnew_dbcr0 &= ~DBCR0_IC;\n\t\t\t\tif (!DBCR_ACTIVE_EVENTS(new_dbcr0,\n\t\t\t\t\t\tcurrent->thread.debug.dbcr1)) {\n\t\t\t\t\tnew_msr &= ~MSR_DE;\n\t\t\t\t\tnew_dbcr0 &= ~DBCR0_IDM;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_SE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_SE;\n#endif\n\t\t\tbreak;\n\t\tcase SIG_DBG_BRANCH_TRACING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\treturn -EINVAL;\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_BE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_BE;\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* We wait until here to actually install the values in the\n\t   registers so if we fail in the above loop, it will not\n\t   affect the contents of these registers.  After this point,\n\t   failure is a problem, anyway, and it's very unlikely unless\n\t   the user is really doing something wrong. */\n\tregs->msr = new_msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tcurrent->thread.debug.dbcr0 = new_dbcr0;\n#endif\n\n\tif (!access_ok(ctx, sizeof(*ctx)) ||\n\t    fault_in_pages_readable((u8 __user *)ctx, sizeof(*ctx)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(ctx, regs, 1)) {\n\t\tif (show_unhandled_signals)\n\t\t\tprintk_ratelimited(KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\",\n\t\t\t\t\t   current->comm, current->pid,\n\t\t\t\t\t   ctx, regs->nip, regs->link);\n\n\t\tforce_sig(SIGSEGV);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n\trestore_altstack(&ctx->uc_stack);\n\n\tset_thread_flag(TIF_RESTOREALL);\n out:\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n\nSYSCALL_DEFINE3(debug_setcontext, struct ucontext __user *, ctx,\n\t\t\t int, ndbg, struct sig_dbg_op __user *, dbg)\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sig_dbg_op op;\n\tint i;\n\tunsigned long new_msr = regs->msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tunsigned long new_dbcr0 = current->thread.debug.dbcr0;\n#endif\n\n\tfor (i=0; i<ndbg; i++) {\n\t\tif (copy_from_user(&op, dbg + i, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tswitch (op.dbg_type) {\n\t\tcase SIG_DBG_SINGLE_STEPPING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tif (op.dbg_value) {\n\t\t\t\tnew_msr |= MSR_DE;\n\t\t\t\tnew_dbcr0 |= (DBCR0_IDM | DBCR0_IC);\n\t\t\t} else {\n\t\t\t\tnew_dbcr0 &= ~DBCR0_IC;\n\t\t\t\tif (!DBCR_ACTIVE_EVENTS(new_dbcr0,\n\t\t\t\t\t\tcurrent->thread.debug.dbcr1)) {\n\t\t\t\t\tnew_msr &= ~MSR_DE;\n\t\t\t\t\tnew_dbcr0 &= ~DBCR0_IDM;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_SE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_SE;\n#endif\n\t\t\tbreak;\n\t\tcase SIG_DBG_BRANCH_TRACING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\treturn -EINVAL;\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_BE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_BE;\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* We wait until here to actually install the values in the\n\t   registers so if we fail in the above loop, it will not\n\t   affect the contents of these registers.  After this point,\n\t   failure is a problem, anyway, and it's very unlikely unless\n\t   the user is really doing something wrong. */\n\tregs->msr = new_msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tcurrent->thread.debug.dbcr0 = new_dbcr0;\n#endif\n\n\tif (!access_ok(ctx, sizeof(*ctx)) ||\n\t    fault_in_pages_readable((u8 __user *)ctx, sizeof(*ctx)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(ctx, regs, 1)) {\n\t\tif (show_unhandled_signals)\n\t\t\tprintk_ratelimited(KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\",\n\t\t\t\t\t   current->comm, current->pid,\n\t\t\t\t\t   ctx, regs->nip, regs->link);\n\n\t\tforce_sig(SIGSEGV);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n\trestore_altstack(&ctx->uc_stack);\n\n\tset_thread_flag(TIF_RESTOREALL);\n out:\n\treturn 0;\n}"
  },
  {
    "function_name": "sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1304-1375",
    "snippet": "SYSCALL_DEFINE0(sigreturn)\n#else\nSYSCALL_DEFINE0(sigreturn)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nSYSCALL_DEFINE0(sigreturn)\n#else\nSYSCALL_DEFINE0(sigreturn)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}"
  },
  {
    "function_name": "sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1306-1375",
    "snippet": "SYSCALL_DEFINE0(sigreturn)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nSYSCALL_DEFINE0(sigreturn)\n#endif\n{\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV);\n\treturn 0;\n}"
  }
]