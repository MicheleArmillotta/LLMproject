[
  {
    "function_name": "arch_reserved_kernel_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1706-1709",
    "snippet": "unsigned long __init arch_reserved_kernel_pages(void)\n{\n\treturn memblock_reserved_size() / PAGE_SIZE;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserved_size",
          "args": [],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nunsigned long __init arch_reserved_kernel_pages(void)\n{\n\treturn memblock_reserved_size() / PAGE_SIZE;\n}"
  },
  {
    "function_name": "fadump_reserve_crash_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1683-1704",
    "snippet": "static void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "mstart",
            "msize"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Reserving %lluMB of memory at %#016llx for preserving crash data\"",
            "(msize >> 20)",
            "mstart"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}"
  },
  {
    "function_name": "fadump_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1666-1679",
    "snippet": "int __init fadump_reserve_mem(void)\n{\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory to preserve crash data.\n\t\t */\n\t\tpr_info(\"Preserving crash data for processing in next boot.\\n\");\n\t\tfadump_reserve_crash_area(fw_dump.boot_mem_top);\n\t} else\n\t\tpr_debug(\"FADump-aware kernel..\\n\");\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"FADump-aware kernel..\\n\""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_reserve_crash_area",
          "args": [
            "fw_dump.boot_mem_top"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_reserve_crash_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1683-1704",
          "snippet": "static void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Preserving crash data for processing in next boot.\\n\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint __init fadump_reserve_mem(void)\n{\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory to preserve crash data.\n\t\t */\n\t\tpr_info(\"Preserving crash data for processing in next boot.\\n\");\n\t\tfadump_reserve_crash_area(fw_dump.boot_mem_top);\n\t} else\n\t\tpr_debug(\"FADump-aware kernel..\\n\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "early_init_dt_scan_fw_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1651-1659",
    "snippet": "int __init early_init_dt_scan_fw_dump(unsigned long node, const char *uname,\n\t\t\t\t      int depth, void *data)\n{\n\tif ((depth != 1) || (strcmp(uname, \"ibm,opal\") != 0))\n\t\treturn 0;\n\n\topal_fadump_dt_scan(&fw_dump, node);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "opal_fadump_dt_scan",
          "args": [
            "&fw_dump",
            "node"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"ibm,opal\""
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint __init early_init_dt_scan_fw_dump(unsigned long node, const char *uname,\n\t\t\t\t      int depth, void *data)\n{\n\tif ((depth != 1) || (strcmp(uname, \"ibm,opal\") != 0))\n\t\treturn 0;\n\n\topal_fadump_dt_scan(&fw_dump, node);\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1618-1646",
    "snippet": "int __init setup_fadump(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn 0;\n\n\tfadump_init_files();\n\tfadump_show_config();\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 1;\n\n\t/*\n\t * If dump data is available then see if it is valid and prepare for\n\t * saving it to the disk.\n\t */\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * if dump process fails then invalidate the registration\n\t\t * and release memory before proceeding for re-registration.\n\t\t */\n\t\tif (fw_dump.ops->fadump_process(&fw_dump) < 0)\n\t\t\tfadump_invalidate_release_mem();\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\telse if (fw_dump.reserve_dump_area_size)\n\t\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_init_mem_struct",
          "args": [
            "&fw_dump"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_invalidate_release_mem",
          "args": [],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_invalidate_release_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1399-1421",
          "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_process",
          "args": [
            "&fw_dump"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_show_config",
          "args": [],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_show_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "254-278",
          "snippet": "static void fadump_show_config(void)\n{\n\tint i;\n\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"    Boot memory size   : %lx\\n\", fw_dump.boot_memory_size);\n\tpr_debug(\"    Boot memory top    : %llx\\n\", fw_dump.boot_mem_top);\n\tpr_debug(\"Boot memory regions cnt: %llx\\n\", fw_dump.boot_mem_regs_cnt);\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tpr_debug(\"[%03d] base = %llx, size = %llx\\n\", i,\n\t\t\t fw_dump.boot_mem_addr[i], fw_dump.boot_mem_sz[i]);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void fadump_show_config(void)\n{\n\tint i;\n\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"    Boot memory size   : %lx\\n\", fw_dump.boot_memory_size);\n\tpr_debug(\"    Boot memory top    : %llx\\n\", fw_dump.boot_mem_top);\n\tpr_debug(\"Boot memory regions cnt: %llx\\n\", fw_dump.boot_mem_regs_cnt);\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tpr_debug(\"[%03d] base = %llx, size = %llx\\n\", i,\n\t\t\t fw_dump.boot_mem_addr[i], fw_dump.boot_mem_sz[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_init_files",
          "args": [],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_init_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1551-1613",
          "snippet": "static void fadump_init_files(void)\n{\n\tint rc = 0;\n\n\tfadump_kobj = kobject_create_and_add(\"fadump\", kernel_kobj);\n\tif (!fadump_kobj) {\n\t\tpr_err(\"failed to create fadump kobject\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"fadump_region\", 0444, powerpc_debugfs_root, NULL,\n\t\t\t    &fadump_region_fops);\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(fadump_kobj, &release_attr.attr);\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create release_mem sysfs file (%d)\\n\",\n\t\t\t       rc);\n\t}\n\n\trc = sysfs_create_groups(fadump_kobj, fadump_groups);\n\tif (rc) {\n\t\tpr_err(\"sysfs group creation failed (%d), unregistering FADump\",\n\t\t       rc);\n\t\tunregister_fadump();\n\t\treturn;\n\t}\n\n\t/*\n\t * The FADump sysfs are moved from kernel_kobj to fadump_kobj need to\n\t * create symlink at old location to maintain backward compatibility.\n\t *\n\t *      - fadump_enabled -> fadump/enabled\n\t *      - fadump_registered -> fadump/registered\n\t *      - fadump_release_mem -> fadump/release_mem\n\t */\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"enabled\", \"fadump_enabled\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_enabled symlink (%d)\", rc);\n\t\treturn;\n\t}\n\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"registered\",\n\t\t\t\t\t\t  \"fadump_registered\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_registered symlink (%d)\", rc);\n\t\tsysfs_remove_link(kernel_kobj, \"fadump_enabled\");\n\t\treturn;\n\t}\n\n\tif (fw_dump.dump_active) {\n\t\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj,\n\t\t\t\t\t\t\t  fadump_kobj,\n\t\t\t\t\t\t\t  \"release_mem\",\n\t\t\t\t\t\t\t  \"fadump_release_mem\");\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create fadump_release_mem symlink (%d)\",\n\t\t\t       rc);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "struct kobject *fadump_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstruct kobject *fadump_kobj;\n\nstatic void fadump_init_files(void)\n{\n\tint rc = 0;\n\n\tfadump_kobj = kobject_create_and_add(\"fadump\", kernel_kobj);\n\tif (!fadump_kobj) {\n\t\tpr_err(\"failed to create fadump kobject\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"fadump_region\", 0444, powerpc_debugfs_root, NULL,\n\t\t\t    &fadump_region_fops);\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(fadump_kobj, &release_attr.attr);\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create release_mem sysfs file (%d)\\n\",\n\t\t\t       rc);\n\t}\n\n\trc = sysfs_create_groups(fadump_kobj, fadump_groups);\n\tif (rc) {\n\t\tpr_err(\"sysfs group creation failed (%d), unregistering FADump\",\n\t\t       rc);\n\t\tunregister_fadump();\n\t\treturn;\n\t}\n\n\t/*\n\t * The FADump sysfs are moved from kernel_kobj to fadump_kobj need to\n\t * create symlink at old location to maintain backward compatibility.\n\t *\n\t *      - fadump_enabled -> fadump/enabled\n\t *      - fadump_registered -> fadump/registered\n\t *      - fadump_release_mem -> fadump/release_mem\n\t */\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"enabled\", \"fadump_enabled\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_enabled symlink (%d)\", rc);\n\t\treturn;\n\t}\n\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"registered\",\n\t\t\t\t\t\t  \"fadump_registered\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_registered symlink (%d)\", rc);\n\t\tsysfs_remove_link(kernel_kobj, \"fadump_enabled\");\n\t\treturn;\n\t}\n\n\tif (fw_dump.dump_active) {\n\t\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj,\n\t\t\t\t\t\t\t  fadump_kobj,\n\t\t\t\t\t\t\t  \"release_mem\",\n\t\t\t\t\t\t\t  \"fadump_release_mem\");\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create fadump_release_mem symlink (%d)\",\n\t\t\t       rc);\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint __init setup_fadump(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn 0;\n\n\tfadump_init_files();\n\tfadump_show_config();\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 1;\n\n\t/*\n\t * If dump data is available then see if it is valid and prepare for\n\t * saving it to the disk.\n\t */\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * if dump process fails then invalidate the registration\n\t\t * and release memory before proceeding for re-registration.\n\t\t */\n\t\tif (fw_dump.ops->fadump_process(&fw_dump) < 0)\n\t\t\tfadump_invalidate_release_mem();\n\t}\n\t/* Initialize the kernel dump memory structure for FAD registration. */\n\telse if (fw_dump.reserve_dump_area_size)\n\t\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fadump_init_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1551-1613",
    "snippet": "static void fadump_init_files(void)\n{\n\tint rc = 0;\n\n\tfadump_kobj = kobject_create_and_add(\"fadump\", kernel_kobj);\n\tif (!fadump_kobj) {\n\t\tpr_err(\"failed to create fadump kobject\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"fadump_region\", 0444, powerpc_debugfs_root, NULL,\n\t\t\t    &fadump_region_fops);\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(fadump_kobj, &release_attr.attr);\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create release_mem sysfs file (%d)\\n\",\n\t\t\t       rc);\n\t}\n\n\trc = sysfs_create_groups(fadump_kobj, fadump_groups);\n\tif (rc) {\n\t\tpr_err(\"sysfs group creation failed (%d), unregistering FADump\",\n\t\t       rc);\n\t\tunregister_fadump();\n\t\treturn;\n\t}\n\n\t/*\n\t * The FADump sysfs are moved from kernel_kobj to fadump_kobj need to\n\t * create symlink at old location to maintain backward compatibility.\n\t *\n\t *      - fadump_enabled -> fadump/enabled\n\t *      - fadump_registered -> fadump/registered\n\t *      - fadump_release_mem -> fadump/release_mem\n\t */\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"enabled\", \"fadump_enabled\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_enabled symlink (%d)\", rc);\n\t\treturn;\n\t}\n\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"registered\",\n\t\t\t\t\t\t  \"fadump_registered\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_registered symlink (%d)\", rc);\n\t\tsysfs_remove_link(kernel_kobj, \"fadump_enabled\");\n\t\treturn;\n\t}\n\n\tif (fw_dump.dump_active) {\n\t\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj,\n\t\t\t\t\t\t\t  fadump_kobj,\n\t\t\t\t\t\t\t  \"release_mem\",\n\t\t\t\t\t\t\t  \"fadump_release_mem\");\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create fadump_release_mem symlink (%d)\",\n\t\t\t       rc);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "struct kobject *fadump_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to create fadump_release_mem symlink (%d)\"",
            "rc"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_only_sysfs_link_entry_to_kobj",
          "args": [
            "kernel_kobj",
            "fadump_kobj",
            "\"release_mem\"",
            "\"fadump_release_mem\""
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_link",
          "args": [
            "kernel_kobj",
            "\"fadump_enabled\""
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to create fadump_registered symlink (%d)\"",
            "rc"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_only_sysfs_link_entry_to_kobj",
          "args": [
            "kernel_kobj",
            "fadump_kobj",
            "\"registered\"",
            "\"fadump_registered\""
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to create fadump_enabled symlink (%d)\"",
            "rc"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_only_sysfs_link_entry_to_kobj",
          "args": [
            "kernel_kobj",
            "fadump_kobj",
            "\"enabled\"",
            "\"fadump_enabled\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_fadump",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1451-1458",
          "snippet": "static void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "struct kobject *fadump_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstruct kobject *fadump_kobj;\n\nstatic void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sysfs group creation failed (%d), unregistering FADump\"",
            "rc"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_groups",
          "args": [
            "fadump_kobj",
            "fadump_groups"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to create release_mem sysfs file (%d)\\n\"",
            "rc"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_file",
          "args": [
            "fadump_kobj",
            "&release_attr.attr"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"fadump_region\"",
            "0444",
            "powerpc_debugfs_root",
            "NULL",
            "&fadump_region_fops"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create fadump kobject\\n\""
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"fadump\"",
            "kernel_kobj"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstruct kobject *fadump_kobj;\n\nstatic void fadump_init_files(void)\n{\n\tint rc = 0;\n\n\tfadump_kobj = kobject_create_and_add(\"fadump\", kernel_kobj);\n\tif (!fadump_kobj) {\n\t\tpr_err(\"failed to create fadump kobject\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"fadump_region\", 0444, powerpc_debugfs_root, NULL,\n\t\t\t    &fadump_region_fops);\n\n\tif (fw_dump.dump_active) {\n\t\trc = sysfs_create_file(fadump_kobj, &release_attr.attr);\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create release_mem sysfs file (%d)\\n\",\n\t\t\t       rc);\n\t}\n\n\trc = sysfs_create_groups(fadump_kobj, fadump_groups);\n\tif (rc) {\n\t\tpr_err(\"sysfs group creation failed (%d), unregistering FADump\",\n\t\t       rc);\n\t\tunregister_fadump();\n\t\treturn;\n\t}\n\n\t/*\n\t * The FADump sysfs are moved from kernel_kobj to fadump_kobj need to\n\t * create symlink at old location to maintain backward compatibility.\n\t *\n\t *      - fadump_enabled -> fadump/enabled\n\t *      - fadump_registered -> fadump/registered\n\t *      - fadump_release_mem -> fadump/release_mem\n\t */\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"enabled\", \"fadump_enabled\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_enabled symlink (%d)\", rc);\n\t\treturn;\n\t}\n\n\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj, fadump_kobj,\n\t\t\t\t\t\t  \"registered\",\n\t\t\t\t\t\t  \"fadump_registered\");\n\tif (rc) {\n\t\tpr_err(\"unable to create fadump_registered symlink (%d)\", rc);\n\t\tsysfs_remove_link(kernel_kobj, \"fadump_enabled\");\n\t\treturn;\n\t}\n\n\tif (fw_dump.dump_active) {\n\t\trc = compat_only_sysfs_link_entry_to_kobj(kernel_kobj,\n\t\t\t\t\t\t\t  fadump_kobj,\n\t\t\t\t\t\t\t  \"release_mem\",\n\t\t\t\t\t\t\t  \"fadump_release_mem\");\n\t\tif (rc)\n\t\t\tpr_err(\"unable to create fadump_release_mem symlink (%d)\",\n\t\t\t       rc);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fadump_region_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1524-1533",
    "snippet": "static int fadump_region_show(struct seq_file *m, void *private)\n{\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tmutex_lock(&fadump_mutex);\n\tfw_dump.ops->fadump_region_show(&fw_dump, m);\n\tmutex_unlock(&fadump_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_region_show",
          "args": [
            "&fw_dump",
            "m"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_region_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1524-1533",
          "snippet": "static int fadump_region_show(struct seq_file *m, void *private)\n{\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tmutex_lock(&fadump_mutex);\n\tfw_dump.ops->fadump_region_show(&fw_dump, m);\n\tmutex_unlock(&fadump_mutex);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int fadump_region_show(struct seq_file *m, void *private)\n{\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tmutex_lock(&fadump_mutex);\n\tfw_dump.ops->fadump_region_show(&fw_dump, m);\n\tmutex_unlock(&fadump_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "registered_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1481-1522",
    "snippet": "static ssize_t registered_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret = 0;\n\tint input = -1;\n\n\tif (!fw_dump.fadump_enabled || fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (kstrtoint(buf, 0, &input))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fadump_mutex);\n\n\tswitch (input) {\n\tcase 0:\n\t\tif (fw_dump.dump_registered == 0) {\n\t\t\tgoto unlock_out;\n\t\t}\n\n\t\t/* Un-register Firmware-assisted dump */\n\t\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tbreak;\n\tcase 1:\n\t\tif (fw_dump.dump_registered == 1) {\n\t\t\t/* Un-register Firmware-assisted dump */\n\t\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\t}\n\t\t/* Register Firmware-assisted dump */\n\t\tret = register_fadump();\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock_out:\n\tmutex_unlock(&fadump_mutex);\n\treturn ret < 0 ? ret : count;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_fadump",
          "args": [],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_fadump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1451-1458",
          "snippet": "static void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "struct kobject *fadump_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstruct kobject *fadump_kobj;\n\nstatic void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_unregister",
          "args": [
            "&fw_dump"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_unregister",
          "args": [
            "&fw_dump"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Un-register firmware-assisted dump\\n\""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&input"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t registered_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint ret = 0;\n\tint input = -1;\n\n\tif (!fw_dump.fadump_enabled || fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (kstrtoint(buf, 0, &input))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&fadump_mutex);\n\n\tswitch (input) {\n\tcase 0:\n\t\tif (fw_dump.dump_registered == 0) {\n\t\t\tgoto unlock_out;\n\t\t}\n\n\t\t/* Un-register Firmware-assisted dump */\n\t\tpr_debug(\"Un-register firmware-assisted dump\\n\");\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tbreak;\n\tcase 1:\n\t\tif (fw_dump.dump_registered == 1) {\n\t\t\t/* Un-register Firmware-assisted dump */\n\t\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\t}\n\t\t/* Register Firmware-assisted dump */\n\t\tret = register_fadump();\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock_out:\n\tmutex_unlock(&fadump_mutex);\n\treturn ret < 0 ? ret : count;\n}"
  },
  {
    "function_name": "registered_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1474-1479",
    "snippet": "static ssize_t registered_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.dump_registered);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fw_dump.dump_registered"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t registered_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.dump_registered);\n}"
  },
  {
    "function_name": "mem_reserved_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1467-1472",
    "snippet": "static ssize_t mem_reserved_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", fw_dump.reserve_dump_area_size);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\\n\"",
            "fw_dump.reserve_dump_area_size"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t mem_reserved_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%ld\\n\", fw_dump.reserve_dump_area_size);\n}"
  },
  {
    "function_name": "enabled_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1460-1465",
    "snippet": "static ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.fadump_enabled);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fw_dump.fadump_enabled"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fw_dump.fadump_enabled);\n}"
  },
  {
    "function_name": "unregister_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1451-1458",
    "snippet": "static void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "struct kobject *fadump_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "fadump_kobj"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_release_memory",
          "args": [
            "fw_dump.reserve_dump_area_start",
            "fw_dump.reserve_dump_area_size"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_release_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1357-1397",
          "snippet": "static void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_cleanup",
          "args": [],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1200-1217",
          "snippet": "void fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstruct kobject *fadump_kobj;\n\nstatic void unregister_fadump(void)\n{\n\tfadump_cleanup();\n\tfadump_release_memory(fw_dump.reserve_dump_area_start,\n\t\t\t      fw_dump.reserve_dump_area_size);\n\tfw_dump.fadump_enabled = 0;\n\tkobject_put(fadump_kobj);\n}"
  },
  {
    "function_name": "release_mem_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1423-1448",
    "snippet": "static ssize_t release_mem_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint input = -1;\n\n\tif (!fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (kstrtoint(buf, 0, &input))\n\t\treturn -EINVAL;\n\n\tif (input == 1) {\n\t\t/*\n\t\t * Take away the '/proc/vmcore'. We are releasing the dump\n\t\t * memory, hence it will not be valid anymore.\n\t\t */\n#ifdef CONFIG_PROC_VMCORE\n\t\tvmcore_cleanup();\n#endif\n\t\tfadump_invalidate_release_mem();\n\n\t} else\n\t\treturn -EINVAL;\n\treturn count;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_invalidate_release_mem",
          "args": [],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_invalidate_release_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1399-1421",
          "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcore_cleanup",
          "args": [],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "buf",
            "0",
            "&input"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic ssize_t release_mem_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint input = -1;\n\n\tif (!fw_dump.dump_active)\n\t\treturn -EPERM;\n\n\tif (kstrtoint(buf, 0, &input))\n\t\treturn -EINVAL;\n\n\tif (input == 1) {\n\t\t/*\n\t\t * Take away the '/proc/vmcore'. We are releasing the dump\n\t\t * memory, hence it will not be valid anymore.\n\t\t */\n#ifdef CONFIG_PROC_VMCORE\n\t\tvmcore_cleanup();\n#endif\n\t\tfadump_invalidate_release_mem();\n\n\t} else\n\t\treturn -EINVAL;\n\treturn count;\n}"
  },
  {
    "function_name": "fadump_invalidate_release_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1399-1421",
    "snippet": "static void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_init_mem_struct",
          "args": [
            "&fw_dump"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to setup kernel metadata!\\n\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_setup_metadata",
          "args": [
            "&fw_dump"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_free_cpu_notes_buf",
          "args": [],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_free_cpu_notes_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "814-823",
          "snippet": "void fadump_free_cpu_notes_buf(void)\n{\n\tif (!fw_dump.cpu_notes_buf_vaddr)\n\t\treturn;\n\n\tfadump_free_buffer(fw_dump.cpu_notes_buf_vaddr,\n\t\t\t   fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_free_cpu_notes_buf(void)\n{\n\tif (!fw_dump.cpu_notes_buf_vaddr)\n\t\treturn;\n\n\tfadump_free_buffer(fw_dump.cpu_notes_buf_vaddr,\n\t\t\t   fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_release_memory",
          "args": [
            "fw_dump.boot_mem_top",
            "memblock_end_of_DRAM()"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_release_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1357-1397",
          "snippet": "static void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_cleanup",
          "args": [],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1200-1217",
          "snippet": "void fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fadump_mutex"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic void fadump_invalidate_release_mem(void)\n{\n\tmutex_lock(&fadump_mutex);\n\tif (!fw_dump.dump_active) {\n\t\tmutex_unlock(&fadump_mutex);\n\t\treturn;\n\t}\n\n\tfadump_cleanup();\n\tmutex_unlock(&fadump_mutex);\n\n\tfadump_release_memory(fw_dump.boot_mem_top, memblock_end_of_DRAM());\n\tfadump_free_cpu_notes_buf();\n\n\t/*\n\t * Setup kernel metadata and initialize the kernel dump\n\t * memory structure for FADump re-registration.\n\t */\n\tif (fw_dump.ops->fadump_setup_metadata &&\n\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\tpr_warn(\"Failed to setup kernel metadata!\\n\");\n\tfw_dump.ops->fadump_init_mem_struct(&fw_dump);\n}"
  },
  {
    "function_name": "fadump_release_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1357-1397",
    "snippet": "static void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_release_reserved_area",
          "args": [
            "tstart",
            "end"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_release_reserved_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1241-1260",
          "snippet": "static void fadump_release_reserved_area(u64 start, u64 end)\n{\n\tu64 tstart, tend, spfn, epfn;\n\tstruct memblock_region *reg;\n\n\tspfn = PHYS_PFN(start);\n\tepfn = PHYS_PFN(end);\n\tfor_each_memblock(memory, reg) {\n\t\ttstart = max_t(u64, spfn, memblock_region_memory_base_pfn(reg));\n\t\ttend   = min_t(u64, epfn, memblock_region_memory_end_pfn(reg));\n\t\tif (tstart < tend) {\n\t\t\tfadump_free_reserved_memory(tstart, tend);\n\n\t\t\tif (tend == epfn)\n\t\t\t\tbreak;\n\n\t\t\tspfn = tend;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_release_reserved_area(u64 start, u64 end)\n{\n\tu64 tstart, tend, spfn, epfn;\n\tstruct memblock_region *reg;\n\n\tspfn = PHYS_PFN(start);\n\tepfn = PHYS_PFN(end);\n\tfor_each_memblock(memory, reg) {\n\t\ttstart = max_t(u64, spfn, memblock_region_memory_base_pfn(reg));\n\t\ttend   = min_t(u64, epfn, memblock_region_memory_end_pfn(reg));\n\t\tif (tstart < tend) {\n\t\t\tfadump_free_reserved_memory(tstart, tend);\n\n\t\t\tif (tend == epfn)\n\t\t\t\tbreak;\n\n\t\t\tspfn = tend;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort_and_merge_mem_ranges",
          "args": [
            "&reserved_mrange_info"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "sort_and_merge_mem_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1266-1307",
          "snippet": "static void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_add_mem_range",
          "args": [
            "&reserved_mrange_info",
            "ra_start",
            "ra_end"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_mem_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "865-915",
          "snippet": "static inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void fadump_release_memory(u64 begin, u64 end)\n{\n\tu64 ra_start, ra_end, tstart;\n\tint i, ret;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\t/*\n\t * If reserved ranges array limit is hit, overwrite the last reserved\n\t * memory range with reserved dump area to ensure it is excluded from\n\t * the memory being released (reused for next FADump registration).\n\t */\n\tif (reserved_mrange_info.mem_range_cnt ==\n\t    reserved_mrange_info.max_mem_ranges)\n\t\treserved_mrange_info.mem_range_cnt--;\n\n\tret = fadump_add_mem_range(&reserved_mrange_info, ra_start, ra_end);\n\tif (ret != 0)\n\t\treturn;\n\n\t/* Get the reserved ranges list in order first. */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n\n\t/* Exclude reserved ranges and release remaining memory */\n\ttstart = begin;\n\tfor (i = 0; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tra_start = reserved_mrange_info.mem_ranges[i].base;\n\t\tra_end = ra_start + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (tstart >= ra_end)\n\t\t\tcontinue;\n\n\t\tif (tstart < ra_start)\n\t\t\tfadump_release_reserved_area(tstart, ra_start);\n\t\ttstart = ra_end;\n\t}\n\n\tif (tstart < end)\n\t\tfadump_release_reserved_area(tstart, end);\n}"
  },
  {
    "function_name": "early_init_dt_scan_reserved_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1313-1349",
    "snippet": "static void __init early_init_dt_scan_reserved_ranges(unsigned long node)\n{\n\tconst __be32 *prop;\n\tint len, ret = -1;\n\tunsigned long i;\n\n\t/* reserved-ranges already scanned */\n\tif (reserved_mrange_info.mem_range_cnt != 0)\n\t\treturn;\n\n\tprop = of_get_flat_dt_prop(node, \"reserved-ranges\", &len);\n\tif (!prop)\n\t\treturn;\n\n\t/*\n\t * Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range.\n\t */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tret = fadump_add_mem_range(&reserved_mrange_info,\n\t\t\t\t\t\t   base, base + size);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_warn(\"some reserved ranges are ignored!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compact reserved ranges */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort_and_merge_mem_ranges",
          "args": [
            "&reserved_mrange_info"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "sort_and_merge_mem_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1266-1307",
          "snippet": "static void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"some reserved ranges are ignored!\\n\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_add_mem_range",
          "args": [
            "&reserved_mrange_info",
            "base",
            "base + size"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_mem_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "865-915",
          "snippet": "static inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 2",
            "2"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 0",
            "2"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"reserved-ranges\"",
            "&len"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void __init early_init_dt_scan_reserved_ranges(unsigned long node)\n{\n\tconst __be32 *prop;\n\tint len, ret = -1;\n\tunsigned long i;\n\n\t/* reserved-ranges already scanned */\n\tif (reserved_mrange_info.mem_range_cnt != 0)\n\t\treturn;\n\n\tprop = of_get_flat_dt_prop(node, \"reserved-ranges\", &len);\n\tif (!prop)\n\t\treturn;\n\n\t/*\n\t * Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range.\n\t */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tret = fadump_add_mem_range(&reserved_mrange_info,\n\t\t\t\t\t\t   base, base + size);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_warn(\"some reserved ranges are ignored!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compact reserved ranges */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n}"
  },
  {
    "function_name": "sort_and_merge_mem_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1266-1307",
    "snippet": "static void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void sort_and_merge_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *mem_ranges;\n\tstruct fadump_memory_range tmp_range;\n\tu64 base, size;\n\tint i, j, idx;\n\n\tif (!reserved_mrange_info.mem_range_cnt)\n\t\treturn;\n\n\t/* Sort the memory ranges */\n\tmem_ranges = mrange_info->mem_ranges;\n\tfor (i = 0; i < mrange_info->mem_range_cnt; i++) {\n\t\tidx = i;\n\t\tfor (j = (i + 1); j < mrange_info->mem_range_cnt; j++) {\n\t\t\tif (mem_ranges[idx].base > mem_ranges[j].base)\n\t\t\t\tidx = j;\n\t\t}\n\t\tif (idx != i) {\n\t\t\ttmp_range = mem_ranges[idx];\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t\tmem_ranges[i] = tmp_range;\n\t\t}\n\t}\n\n\t/* Merge adjacent reserved ranges */\n\tidx = 0;\n\tfor (i = 1; i < mrange_info->mem_range_cnt; i++) {\n\t\tbase = mem_ranges[i-1].base;\n\t\tsize = mem_ranges[i-1].size;\n\t\tif (mem_ranges[i].base == (base + size))\n\t\t\tmem_ranges[idx].size += mem_ranges[i].size;\n\t\telse {\n\t\t\tidx++;\n\t\t\tif (i == idx)\n\t\t\t\tcontinue;\n\n\t\t\tmem_ranges[idx] = mem_ranges[i];\n\t\t}\n\t}\n\tmrange_info->mem_range_cnt = idx + 1;\n}"
  },
  {
    "function_name": "fadump_release_reserved_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1241-1260",
    "snippet": "static void fadump_release_reserved_area(u64 start, u64 end)\n{\n\tu64 tstart, tend, spfn, epfn;\n\tstruct memblock_region *reg;\n\n\tspfn = PHYS_PFN(start);\n\tepfn = PHYS_PFN(end);\n\tfor_each_memblock(memory, reg) {\n\t\ttstart = max_t(u64, spfn, memblock_region_memory_base_pfn(reg));\n\t\ttend   = min_t(u64, epfn, memblock_region_memory_end_pfn(reg));\n\t\tif (tstart < tend) {\n\t\t\tfadump_free_reserved_memory(tstart, tend);\n\n\t\t\tif (tend == epfn)\n\t\t\t\tbreak;\n\n\t\t\tspfn = tend;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_free_reserved_memory",
          "args": [
            "tstart",
            "tend"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_free_reserved_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1219-1236",
          "snippet": "static void fadump_free_reserved_memory(unsigned long start_pfn,\n\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tunsigned long time_limit = jiffies + HZ;\n\n\tpr_info(\"freeing reserved memory (0x%llx - 0x%llx)\\n\",\n\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tfree_reserved_page(pfn_to_page(pfn));\n\n\t\tif (time_after(jiffies, time_limit)) {\n\t\t\tcond_resched();\n\t\t\ttime_limit = jiffies + HZ;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_reserved_memory(unsigned long start_pfn,\n\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tunsigned long time_limit = jiffies + HZ;\n\n\tpr_info(\"freeing reserved memory (0x%llx - 0x%llx)\\n\",\n\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tfree_reserved_page(pfn_to_page(pfn));\n\n\t\tif (time_after(jiffies, time_limit)) {\n\t\t\tcond_resched();\n\t\t\ttime_limit = jiffies + HZ;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "epfn",
            "memblock_region_memory_end_pfn(reg)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "reg"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "spfn",
            "memblock_region_memory_base_pfn(reg)"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "reg"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "end"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "start"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_release_reserved_area(u64 start, u64 end)\n{\n\tu64 tstart, tend, spfn, epfn;\n\tstruct memblock_region *reg;\n\n\tspfn = PHYS_PFN(start);\n\tepfn = PHYS_PFN(end);\n\tfor_each_memblock(memory, reg) {\n\t\ttstart = max_t(u64, spfn, memblock_region_memory_base_pfn(reg));\n\t\ttend   = min_t(u64, epfn, memblock_region_memory_end_pfn(reg));\n\t\tif (tstart < tend) {\n\t\t\tfadump_free_reserved_memory(tstart, tend);\n\n\t\t\tif (tend == epfn)\n\t\t\t\tbreak;\n\n\t\t\tspfn = tend;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fadump_free_reserved_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1219-1236",
    "snippet": "static void fadump_free_reserved_memory(unsigned long start_pfn,\n\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tunsigned long time_limit = jiffies + HZ;\n\n\tpr_info(\"freeing reserved memory (0x%llx - 0x%llx)\\n\",\n\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tfree_reserved_page(pfn_to_page(pfn));\n\n\t\tif (time_after(jiffies, time_limit)) {\n\t\t\tcond_resched();\n\t\t\ttime_limit = jiffies + HZ;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "time_limit"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"freeing reserved memory (0x%llx - 0x%llx)\\n\"",
            "PFN_PHYS(start_pfn)",
            "PFN_PHYS(end_pfn)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "end_pfn"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "start_pfn"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_reserved_memory(unsigned long start_pfn,\n\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn;\n\tunsigned long time_limit = jiffies + HZ;\n\n\tpr_info(\"freeing reserved memory (0x%llx - 0x%llx)\\n\",\n\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tfree_reserved_page(pfn_to_page(pfn));\n\n\t\tif (time_after(jiffies, time_limit)) {\n\t\t\tcond_resched();\n\t\t\ttime_limit = jiffies + HZ;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fadump_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1200-1217",
    "snippet": "void fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_cleanup",
          "args": [
            "&fw_dump"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_free_mem_ranges",
          "args": [
            "&crash_mrange_info"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_free_mem_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "825-835",
          "snippet": "static void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_unregister",
          "args": [
            "&fw_dump"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_invalidate",
          "args": [
            "&fw_dump"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Invalidating firmware-assisted dump registration\\n\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_cleanup(void)\n{\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\t/* Invalidate the registration only if dump is active. */\n\tif (fw_dump.dump_active) {\n\t\tpr_debug(\"Invalidating firmware-assisted dump registration\\n\");\n\t\tfw_dump.ops->fadump_invalidate(&fw_dump);\n\t} else if (fw_dump.dump_registered) {\n\t\t/* Un-register Firmware-assisted dump if it was registered. */\n\t\tfw_dump.ops->fadump_unregister(&fw_dump);\n\t\tfadump_free_mem_ranges(&crash_mrange_info);\n\t}\n\n\tif (fw_dump.ops->fadump_cleanup)\n\t\tfw_dump.ops->fadump_cleanup(&fw_dump);\n}"
  },
  {
    "function_name": "register_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1169-1198",
    "snippet": "static int register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\tint ret;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn -ENODEV;\n\n\tret = fadump_setup_crash_memory_ranges();\n\tif (ret)\n\t\treturn ret;\n\n\taddr = fw_dump.fadumphdr_addr;\n\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\treturn fw_dump.ops->fadump_register(&fw_dump);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_register",
          "args": [
            "&fw_dump"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Registering for firmware-assisted kernel dump...\\n\""
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_create_elfcore_headers",
          "args": [
            "vaddr"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_create_elfcore_headers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1060-1148",
          "snippet": "static int fadump_create_elfcore_headers(char *bufp)\n{\n\tunsigned long long raddr, offset;\n\tstruct elf_phdr *phdr;\n\tstruct elfhdr *elf;\n\tint i, j;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= phdr->p_filesz = VMCOREINFO_NOTE_SIZE;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\tj = 0;\n\toffset = 0;\n\traddr = fw_dump.boot_mem_addr[0];\n\tfor (i = 0; i < crash_mrange_info.mem_range_cnt; i++) {\n\t\tu64 mbase, msize;\n\n\t\tmbase = crash_mrange_info.mem_ranges[i].base;\n\t\tmsize = crash_mrange_info.mem_ranges[i].size;\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == raddr) {\n\t\t\t/*\n\t\t\t * The entire real memory region will be moved by\n\t\t\t * firmware to the specified destination_address.\n\t\t\t * Hence set the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = fw_dump.boot_mem_dest_addr + offset;\n\t\t\tif (j < (fw_dump.boot_mem_regs_cnt - 1)) {\n\t\t\t\toffset += fw_dump.boot_mem_sz[j];\n\t\t\t\traddr = fw_dump.boot_mem_addr[++j];\n\t\t\t}\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int fadump_create_elfcore_headers(char *bufp)\n{\n\tunsigned long long raddr, offset;\n\tstruct elf_phdr *phdr;\n\tstruct elfhdr *elf;\n\tint i, j;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= phdr->p_filesz = VMCOREINFO_NOTE_SIZE;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\tj = 0;\n\toffset = 0;\n\traddr = fw_dump.boot_mem_addr[0];\n\tfor (i = 0; i < crash_mrange_info.mem_range_cnt; i++) {\n\t\tu64 mbase, msize;\n\n\t\tmbase = crash_mrange_info.mem_ranges[i].base;\n\t\tmsize = crash_mrange_info.mem_ranges[i].size;\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == raddr) {\n\t\t\t/*\n\t\t\t * The entire real memory region will be moved by\n\t\t\t * firmware to the specified destination_address.\n\t\t\t * Hence set the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = fw_dump.boot_mem_dest_addr + offset;\n\t\t\tif (j < (fw_dump.boot_mem_regs_cnt - 1)) {\n\t\t\t\toffset += fw_dump.boot_mem_sz[j];\n\t\t\t\traddr = fw_dump.boot_mem_addr[++j];\n\t\t\t}\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Creating ELF core headers at %#016lx\\n\"",
            "addr"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_fadump_header",
          "args": [
            "addr"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "init_fadump_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1150-1167",
          "snippet": "static unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = FADUMP_CPU_UNKNOWN;\n\n\treturn addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = FADUMP_CPU_UNKNOWN;\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_setup_crash_memory_ranges",
          "args": [],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_setup_crash_memory_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "984-1028",
          "snippet": "static int fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tu64 start, end;\n\tint i, ret;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mrange_info.mem_range_cnt = 0;\n\n\t/*\n\t * Boot memory region(s) registered with firmware are moved to\n\t * different location at the time of crash. Create separate program\n\t * header(s) for this memory chunk(s) with the correct offset.\n\t */\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tstart = fw_dump.boot_mem_addr[i];\n\t\tend = start + fw_dump.boot_mem_sz[i];\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (u64)reg->base;\n\t\tend = start + (u64)reg->size;\n\n\t\t/*\n\t\t * skip the memory chunk that is already added\n\t\t * (0 through boot_memory_top).\n\t\t */\n\t\tif (start < fw_dump.boot_mem_top) {\n\t\t\tif (end > fw_dump.boot_mem_top)\n\t\t\t\tstart = fw_dump.boot_mem_top;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tret = fadump_exclude_reserved_area(start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tu64 start, end;\n\tint i, ret;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mrange_info.mem_range_cnt = 0;\n\n\t/*\n\t * Boot memory region(s) registered with firmware are moved to\n\t * different location at the time of crash. Create separate program\n\t * header(s) for this memory chunk(s) with the correct offset.\n\t */\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tstart = fw_dump.boot_mem_addr[i];\n\t\tend = start + fw_dump.boot_mem_sz[i];\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (u64)reg->base;\n\t\tend = start + (u64)reg->size;\n\n\t\t/*\n\t\t * skip the memory chunk that is already added\n\t\t * (0 through boot_memory_top).\n\t\t */\n\t\tif (start < fw_dump.boot_mem_top) {\n\t\t\tif (end > fw_dump.boot_mem_top)\n\t\t\t\tstart = fw_dump.boot_mem_top;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tret = fadump_exclude_reserved_area(start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int register_fadump(void)\n{\n\tunsigned long addr;\n\tvoid *vaddr;\n\tint ret;\n\n\t/*\n\t * If no memory is reserved then we can not register for firmware-\n\t * assisted dump.\n\t */\n\tif (!fw_dump.reserve_dump_area_size)\n\t\treturn -ENODEV;\n\n\tret = fadump_setup_crash_memory_ranges();\n\tif (ret)\n\t\treturn ret;\n\n\taddr = fw_dump.fadumphdr_addr;\n\n\t/* Initialize fadump crash info header. */\n\taddr = init_fadump_header(addr);\n\tvaddr = __va(addr);\n\n\tpr_debug(\"Creating ELF core headers at %#016lx\\n\", addr);\n\tfadump_create_elfcore_headers(vaddr);\n\n\t/* register the future kernel dump with firmware. */\n\tpr_debug(\"Registering for firmware-assisted kernel dump...\\n\");\n\treturn fw_dump.ops->fadump_register(&fw_dump);\n}"
  },
  {
    "function_name": "init_fadump_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1150-1167",
    "snippet": "static unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = FADUMP_CPU_UNKNOWN;\n\n\treturn addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdh",
            "0",
            "sizeof(struct fadump_crash_info_header)"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "addr"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic unsigned long init_fadump_header(unsigned long addr)\n{\n\tstruct fadump_crash_info_header *fdh;\n\n\tif (!addr)\n\t\treturn 0;\n\n\tfdh = __va(addr);\n\taddr += sizeof(struct fadump_crash_info_header);\n\n\tmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\n\tfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\n\tfdh->elfcorehdr_addr = addr;\n\t/* We will set the crashing cpu id in crash_fadump() during crash. */\n\tfdh->crashing_cpu = FADUMP_CPU_UNKNOWN;\n\n\treturn addr;\n}"
  },
  {
    "function_name": "fadump_create_elfcore_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1060-1148",
    "snippet": "static int fadump_create_elfcore_headers(char *bufp)\n{\n\tunsigned long long raddr, offset;\n\tstruct elf_phdr *phdr;\n\tstruct elfhdr *elf;\n\tint i, j;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= phdr->p_filesz = VMCOREINFO_NOTE_SIZE;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\tj = 0;\n\toffset = 0;\n\traddr = fw_dump.boot_mem_addr[0];\n\tfor (i = 0; i < crash_mrange_info.mem_range_cnt; i++) {\n\t\tu64 mbase, msize;\n\n\t\tmbase = crash_mrange_info.mem_ranges[i].base;\n\t\tmsize = crash_mrange_info.mem_ranges[i].size;\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == raddr) {\n\t\t\t/*\n\t\t\t * The entire real memory region will be moved by\n\t\t\t * firmware to the specified destination_address.\n\t\t\t * Hence set the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = fw_dump.boot_mem_dest_addr + offset;\n\t\t\tif (j < (fw_dump.boot_mem_regs_cnt - 1)) {\n\t\t\t\toffset += fw_dump.boot_mem_sz[j];\n\t\t\t\traddr = fw_dump.boot_mem_addr[++j];\n\t\t\t}\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "mbase"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_relocate",
          "args": [
            "paddr_vmcoreinfo_note()"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1035-1058",
          "snippet": "static inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tunsigned long raddr, rstart, rend, rlast, hole_size;\n\tint i;\n\n\thole_size = 0;\n\trlast = 0;\n\traddr = paddr;\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\trstart = fw_dump.boot_mem_addr[i];\n\t\trend = rstart + fw_dump.boot_mem_sz[i];\n\t\thole_size += (rstart - rlast);\n\n\t\tif (paddr >= rstart && paddr < rend) {\n\t\t\traddr += fw_dump.boot_mem_dest_addr - hole_size;\n\t\t\tbreak;\n\t\t}\n\n\t\trlast = rend;\n\t}\n\n\tpr_debug(\"vmcoreinfo: paddr = 0x%lx, raddr = 0x%lx\\n\", paddr, raddr);\n\treturn raddr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tunsigned long raddr, rstart, rend, rlast, hole_size;\n\tint i;\n\n\thole_size = 0;\n\trlast = 0;\n\traddr = paddr;\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\trstart = fw_dump.boot_mem_addr[i];\n\t\trend = rstart + fw_dump.boot_mem_sz[i];\n\t\thole_size += (rstart - rlast);\n\n\t\tif (paddr >= rstart && paddr < rend) {\n\t\t\traddr += fw_dump.boot_mem_dest_addr - hole_size;\n\t\t\tbreak;\n\t\t}\n\n\t\trlast = rend;\n\t}\n\n\tpr_debug(\"vmcoreinfo: paddr = 0x%lx, raddr = 0x%lx\\n\", paddr, raddr);\n\treturn raddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddr_vmcoreinfo_note",
          "args": [],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_init_elfcore_header",
          "args": [
            "bufp"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_init_elfcore_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "947-978",
          "snippet": "static int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n#if defined(_CALL_ELF)\n\telf->e_flags = _CALL_ELF;\n#else\n\telf->e_flags = 0;\n#endif\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n#if defined(_CALL_ELF)\n\telf->e_flags = _CALL_ELF;\n#else\n\telf->e_flags = 0;\n#endif\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int fadump_create_elfcore_headers(char *bufp)\n{\n\tunsigned long long raddr, offset;\n\tstruct elf_phdr *phdr;\n\tstruct elfhdr *elf;\n\tint i, j;\n\n\tfadump_init_elfcore_header(bufp);\n\telf = (struct elfhdr *)bufp;\n\tbufp += sizeof(struct elfhdr);\n\n\t/*\n\t * setup ELF PT_NOTE, place holder for cpu notes info. The notes info\n\t * will be populated during second kernel boot after crash. Hence\n\t * this PT_NOTE will always be the first elf note.\n\t *\n\t * NOTE: Any new ELF note addition should be placed after this note.\n\t */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_flags = 0;\n\tphdr->p_vaddr = 0;\n\tphdr->p_align = 0;\n\n\tphdr->p_offset = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = 0;\n\tphdr->p_memsz = 0;\n\n\t(elf->e_phnum)++;\n\n\t/* setup ELF PT_NOTE for vmcoreinfo */\n\tphdr = (struct elf_phdr *)bufp;\n\tbufp += sizeof(struct elf_phdr);\n\tphdr->p_type\t= PT_NOTE;\n\tphdr->p_flags\t= 0;\n\tphdr->p_vaddr\t= 0;\n\tphdr->p_align\t= 0;\n\n\tphdr->p_paddr\t= fadump_relocate(paddr_vmcoreinfo_note());\n\tphdr->p_offset\t= phdr->p_paddr;\n\tphdr->p_memsz\t= phdr->p_filesz = VMCOREINFO_NOTE_SIZE;\n\n\t/* Increment number of program headers. */\n\t(elf->e_phnum)++;\n\n\t/* setup PT_LOAD sections. */\n\tj = 0;\n\toffset = 0;\n\traddr = fw_dump.boot_mem_addr[0];\n\tfor (i = 0; i < crash_mrange_info.mem_range_cnt; i++) {\n\t\tu64 mbase, msize;\n\n\t\tmbase = crash_mrange_info.mem_ranges[i].base;\n\t\tmsize = crash_mrange_info.mem_ranges[i].size;\n\t\tif (!msize)\n\t\t\tcontinue;\n\n\t\tphdr = (struct elf_phdr *)bufp;\n\t\tbufp += sizeof(struct elf_phdr);\n\t\tphdr->p_type\t= PT_LOAD;\n\t\tphdr->p_flags\t= PF_R|PF_W|PF_X;\n\t\tphdr->p_offset\t= mbase;\n\n\t\tif (mbase == raddr) {\n\t\t\t/*\n\t\t\t * The entire real memory region will be moved by\n\t\t\t * firmware to the specified destination_address.\n\t\t\t * Hence set the correct offset.\n\t\t\t */\n\t\t\tphdr->p_offset = fw_dump.boot_mem_dest_addr + offset;\n\t\t\tif (j < (fw_dump.boot_mem_regs_cnt - 1)) {\n\t\t\t\toffset += fw_dump.boot_mem_sz[j];\n\t\t\t\traddr = fw_dump.boot_mem_addr[++j];\n\t\t\t}\n\t\t}\n\n\t\tphdr->p_paddr = mbase;\n\t\tphdr->p_vaddr = (unsigned long)__va(mbase);\n\t\tphdr->p_filesz = msize;\n\t\tphdr->p_memsz = msize;\n\t\tphdr->p_align = 0;\n\n\t\t/* Increment number of program headers. */\n\t\t(elf->e_phnum)++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_relocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "1035-1058",
    "snippet": "static inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tunsigned long raddr, rstart, rend, rlast, hole_size;\n\tint i;\n\n\thole_size = 0;\n\trlast = 0;\n\traddr = paddr;\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\trstart = fw_dump.boot_mem_addr[i];\n\t\trend = rstart + fw_dump.boot_mem_sz[i];\n\t\thole_size += (rstart - rlast);\n\n\t\tif (paddr >= rstart && paddr < rend) {\n\t\t\traddr += fw_dump.boot_mem_dest_addr - hole_size;\n\t\t\tbreak;\n\t\t}\n\n\t\trlast = rend;\n\t}\n\n\tpr_debug(\"vmcoreinfo: paddr = 0x%lx, raddr = 0x%lx\\n\", paddr, raddr);\n\treturn raddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"vmcoreinfo: paddr = 0x%lx, raddr = 0x%lx\\n\"",
            "paddr",
            "raddr"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic inline unsigned long fadump_relocate(unsigned long paddr)\n{\n\tunsigned long raddr, rstart, rend, rlast, hole_size;\n\tint i;\n\n\thole_size = 0;\n\trlast = 0;\n\traddr = paddr;\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\trstart = fw_dump.boot_mem_addr[i];\n\t\trend = rstart + fw_dump.boot_mem_sz[i];\n\t\thole_size += (rstart - rlast);\n\n\t\tif (paddr >= rstart && paddr < rend) {\n\t\t\traddr += fw_dump.boot_mem_dest_addr - hole_size;\n\t\t\tbreak;\n\t\t}\n\n\t\trlast = rend;\n\t}\n\n\tpr_debug(\"vmcoreinfo: paddr = 0x%lx, raddr = 0x%lx\\n\", paddr, raddr);\n\treturn raddr;\n}"
  },
  {
    "function_name": "fadump_setup_crash_memory_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "984-1028",
    "snippet": "static int fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tu64 start, end;\n\tint i, ret;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mrange_info.mem_range_cnt = 0;\n\n\t/*\n\t * Boot memory region(s) registered with firmware are moved to\n\t * different location at the time of crash. Create separate program\n\t * header(s) for this memory chunk(s) with the correct offset.\n\t */\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tstart = fw_dump.boot_mem_addr[i];\n\t\tend = start + fw_dump.boot_mem_sz[i];\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (u64)reg->base;\n\t\tend = start + (u64)reg->size;\n\n\t\t/*\n\t\t * skip the memory chunk that is already added\n\t\t * (0 through boot_memory_top).\n\t\t */\n\t\tif (start < fw_dump.boot_mem_top) {\n\t\t\tif (end > fw_dump.boot_mem_top)\n\t\t\t\tstart = fw_dump.boot_mem_top;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tret = fadump_exclude_reserved_area(start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_exclude_reserved_area",
          "args": [
            "start",
            "end"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_exclude_reserved_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "917-945",
          "snippet": "static int fadump_exclude_reserved_area(u64 start, u64 end)\n{\n\tu64 ra_start, ra_end;\n\tint ret = 0;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t}\n\t} else\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int fadump_exclude_reserved_area(u64 start, u64 end)\n{\n\tu64 ra_start, ra_end;\n\tint ret = 0;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t}\n\t} else\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_add_mem_range",
          "args": [
            "&crash_mrange_info",
            "start",
            "end"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_mem_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "865-915",
          "snippet": "static inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Setup crash memory ranges.\\n\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int fadump_setup_crash_memory_ranges(void)\n{\n\tstruct memblock_region *reg;\n\tu64 start, end;\n\tint i, ret;\n\n\tpr_debug(\"Setup crash memory ranges.\\n\");\n\tcrash_mrange_info.mem_range_cnt = 0;\n\n\t/*\n\t * Boot memory region(s) registered with firmware are moved to\n\t * different location at the time of crash. Create separate program\n\t * header(s) for this memory chunk(s) with the correct offset.\n\t */\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tstart = fw_dump.boot_mem_addr[i];\n\t\tend = start + fw_dump.boot_mem_sz[i];\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = (u64)reg->base;\n\t\tend = start + (u64)reg->size;\n\n\t\t/*\n\t\t * skip the memory chunk that is already added\n\t\t * (0 through boot_memory_top).\n\t\t */\n\t\tif (start < fw_dump.boot_mem_top) {\n\t\t\tif (end > fw_dump.boot_mem_top)\n\t\t\t\tstart = fw_dump.boot_mem_top;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* add this range excluding the reserved dump area. */\n\t\tret = fadump_exclude_reserved_area(start, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_init_elfcore_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "947-978",
    "snippet": "static int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n#if defined(_CALL_ELF)\n\telf->e_flags = _CALL_ELF;\n#else\n\telf->e_flags = 0;\n#endif\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf->e_ident+EI_PAD",
            "0",
            "EI_NIDENT-EI_PAD"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_init_elfcore_header(char *bufp)\n{\n\tstruct elfhdr *elf;\n\n\telf = (struct elfhdr *) bufp;\n\tbufp += sizeof(struct elfhdr);\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\n\telf->e_type = ET_CORE;\n\telf->e_machine = ELF_ARCH;\n\telf->e_version = EV_CURRENT;\n\telf->e_entry = 0;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_shoff = 0;\n#if defined(_CALL_ELF)\n\telf->e_flags = _CALL_ELF;\n#else\n\telf->e_flags = 0;\n#endif\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = 0;\n\telf->e_shentsize = 0;\n\telf->e_shnum = 0;\n\telf->e_shstrndx = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_exclude_reserved_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "917-945",
    "snippet": "static int fadump_exclude_reserved_area(u64 start, u64 end)\n{\n\tu64 ra_start, ra_end;\n\tint ret = 0;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t}\n\t} else\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_add_mem_range",
          "args": [
            "&crash_mrange_info",
            "start",
            "end"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_add_mem_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "865-915",
          "snippet": "static inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int fadump_exclude_reserved_area(u64 start, u64 end)\n{\n\tu64 ra_start, ra_end;\n\tint ret = 0;\n\n\tra_start = fw_dump.reserve_dump_area_start;\n\tra_end = ra_start + fw_dump.reserve_dump_area_size;\n\n\tif ((ra_start < end) && (ra_end > start)) {\n\t\tif ((start < ra_start) && (end > ra_end)) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t} else if (start < ra_start) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   start, ra_start);\n\t\t} else if (ra_end < end) {\n\t\t\tret = fadump_add_mem_range(&crash_mrange_info,\n\t\t\t\t\t\t   ra_end, end);\n\t\t}\n\t} else\n\t\tret = fadump_add_mem_range(&crash_mrange_info, start, end);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fadump_add_mem_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "865-915",
    "snippet": "static inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\"",
            "mrange_info->name",
            "(mrange_info->mem_range_cnt - 1)",
            "start",
            "end - 1",
            "(end - start)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_alloc_mem_ranges",
          "args": [
            "mrange_info"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_alloc_mem_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "841-863",
          "snippet": "static int fadump_alloc_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *new_array;\n\tu64 new_size;\n\n\tnew_size = mrange_info->mem_ranges_sz + PAGE_SIZE;\n\tpr_debug(\"Allocating %llu bytes of memory for %s memory ranges\\n\",\n\t\t new_size, mrange_info->name);\n\n\tnew_array = krealloc(mrange_info->mem_ranges, new_size, GFP_KERNEL);\n\tif (new_array == NULL) {\n\t\tpr_err(\"Insufficient memory for setting up %s memory ranges\\n\",\n\t\t       mrange_info->name);\n\t\tfadump_free_mem_ranges(mrange_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tmrange_info->mem_ranges = new_array;\n\tmrange_info->mem_ranges_sz = new_size;\n\tmrange_info->max_mem_ranges = (new_size /\n\t\t\t\t       sizeof(struct fadump_memory_range));\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_alloc_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *new_array;\n\tu64 new_size;\n\n\tnew_size = mrange_info->mem_ranges_sz + PAGE_SIZE;\n\tpr_debug(\"Allocating %llu bytes of memory for %s memory ranges\\n\",\n\t\t new_size, mrange_info->name);\n\n\tnew_array = krealloc(mrange_info->mem_ranges, new_size, GFP_KERNEL);\n\tif (new_array == NULL) {\n\t\tpr_err(\"Insufficient memory for setting up %s memory ranges\\n\",\n\t\t       mrange_info->name);\n\t\tfadump_free_mem_ranges(mrange_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tmrange_info->mem_ranges = new_array;\n\tmrange_info->mem_ranges_sz = new_size;\n\tmrange_info->max_mem_ranges = (new_size /\n\t\t\t\t       sizeof(struct fadump_memory_range));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Reached array size limit for %s memory ranges\\n\"",
            "mrange_info->name"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline int fadump_add_mem_range(struct fadump_mrange_info *mrange_info,\n\t\t\t\t       u64 base, u64 end)\n{\n\tstruct fadump_memory_range *mem_ranges = mrange_info->mem_ranges;\n\tbool is_adjacent = false;\n\tu64 start, size;\n\n\tif (base == end)\n\t\treturn 0;\n\n\t/*\n\t * Fold adjacent memory ranges to bring down the memory ranges/\n\t * PT_LOAD segments count.\n\t */\n\tif (mrange_info->mem_range_cnt) {\n\t\tstart = mem_ranges[mrange_info->mem_range_cnt - 1].base;\n\t\tsize  = mem_ranges[mrange_info->mem_range_cnt - 1].size;\n\n\t\tif ((start + size) == base)\n\t\t\tis_adjacent = true;\n\t}\n\tif (!is_adjacent) {\n\t\t/* resize the array on reaching the limit */\n\t\tif (mrange_info->mem_range_cnt == mrange_info->max_mem_ranges) {\n\t\t\tint ret;\n\n\t\t\tif (mrange_info->is_static) {\n\t\t\t\tpr_err(\"Reached array size limit for %s memory ranges\\n\",\n\t\t\t\t       mrange_info->name);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tret = fadump_alloc_mem_ranges(mrange_info);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t/* Update to the new resized array */\n\t\t\tmem_ranges = mrange_info->mem_ranges;\n\t\t}\n\n\t\tstart = base;\n\t\tmem_ranges[mrange_info->mem_range_cnt].base = start;\n\t\tmrange_info->mem_range_cnt++;\n\t}\n\n\tmem_ranges[mrange_info->mem_range_cnt - 1].size = (end - start);\n\tpr_debug(\"%s_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\\n\",\n\t\t mrange_info->name, (mrange_info->mem_range_cnt - 1),\n\t\t start, end - 1, (end - start));\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_alloc_mem_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "841-863",
    "snippet": "static int fadump_alloc_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *new_array;\n\tu64 new_size;\n\n\tnew_size = mrange_info->mem_ranges_sz + PAGE_SIZE;\n\tpr_debug(\"Allocating %llu bytes of memory for %s memory ranges\\n\",\n\t\t new_size, mrange_info->name);\n\n\tnew_array = krealloc(mrange_info->mem_ranges, new_size, GFP_KERNEL);\n\tif (new_array == NULL) {\n\t\tpr_err(\"Insufficient memory for setting up %s memory ranges\\n\",\n\t\t       mrange_info->name);\n\t\tfadump_free_mem_ranges(mrange_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tmrange_info->mem_ranges = new_array;\n\tmrange_info->mem_ranges_sz = new_size;\n\tmrange_info->max_mem_ranges = (new_size /\n\t\t\t\t       sizeof(struct fadump_memory_range));\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_free_mem_ranges",
          "args": [
            "mrange_info"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_free_mem_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "825-835",
          "snippet": "static void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Insufficient memory for setting up %s memory ranges\\n\"",
            "mrange_info->name"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "mrange_info->mem_ranges",
            "new_size",
            "GFP_KERNEL"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Allocating %llu bytes of memory for %s memory ranges\\n\"",
            "new_size",
            "mrange_info->name"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int fadump_alloc_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tstruct fadump_memory_range *new_array;\n\tu64 new_size;\n\n\tnew_size = mrange_info->mem_ranges_sz + PAGE_SIZE;\n\tpr_debug(\"Allocating %llu bytes of memory for %s memory ranges\\n\",\n\t\t new_size, mrange_info->name);\n\n\tnew_array = krealloc(mrange_info->mem_ranges, new_size, GFP_KERNEL);\n\tif (new_array == NULL) {\n\t\tpr_err(\"Insufficient memory for setting up %s memory ranges\\n\",\n\t\t       mrange_info->name);\n\t\tfadump_free_mem_ranges(mrange_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tmrange_info->mem_ranges = new_array;\n\tmrange_info->mem_ranges_sz = new_size;\n\tmrange_info->max_mem_ranges = (new_size /\n\t\t\t\t       sizeof(struct fadump_memory_range));\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_free_mem_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "825-835",
    "snippet": "static void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)((u64)mrange_info + RNG_NAME_SZ)",
            "0",
            "(sizeof(struct fadump_mrange_info) - RNG_NAME_SZ)"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mrange_info->mem_ranges"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_mem_ranges(struct fadump_mrange_info *mrange_info)\n{\n\tif (mrange_info->is_static) {\n\t\tmrange_info->mem_range_cnt = 0;\n\t\treturn;\n\t}\n\n\tkfree(mrange_info->mem_ranges);\n\tmemset((void *)((u64)mrange_info + RNG_NAME_SZ), 0,\n\t       (sizeof(struct fadump_mrange_info) - RNG_NAME_SZ));\n}"
  },
  {
    "function_name": "fadump_free_cpu_notes_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "814-823",
    "snippet": "void fadump_free_cpu_notes_buf(void)\n{\n\tif (!fw_dump.cpu_notes_buf_vaddr)\n\t\treturn;\n\n\tfadump_free_buffer(fw_dump.cpu_notes_buf_vaddr,\n\t\t\t   fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_free_buffer",
          "args": [
            "fw_dump.cpu_notes_buf_vaddr",
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_free_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "790-793",
          "snippet": "static void fadump_free_buffer(unsigned long vaddr, unsigned long size)\n{\n\tfree_reserved_area((void *)vaddr, (void *)(vaddr + size), -1, NULL);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_buffer(unsigned long vaddr, unsigned long size)\n{\n\tfree_reserved_area((void *)vaddr, (void *)(vaddr + size), -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_free_cpu_notes_buf(void)\n{\n\tif (!fw_dump.cpu_notes_buf_vaddr)\n\t\treturn;\n\n\tfadump_free_buffer(fw_dump.cpu_notes_buf_vaddr,\n\t\t\t   fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr = 0;\n\tfw_dump.cpu_notes_buf_size = 0;\n}"
  },
  {
    "function_name": "fadump_setup_cpu_notes_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "795-812",
    "snippet": "s32 fadump_setup_cpu_notes_buf(u32 num_cpus)\n{\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr =\n\t\t(unsigned long)fadump_alloc_buffer(fw_dump.cpu_notes_buf_size);\n\tif (!fw_dump.cpu_notes_buf_vaddr) {\n\t\tpr_err(\"Failed to allocate %ld bytes for CPU notes buffer\\n\",\n\t\t       fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at 0x%lx\\n\",\n\t\t fw_dump.cpu_notes_buf_size,\n\t\t fw_dump.cpu_notes_buf_vaddr);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Allocated buffer for cpu notes of size %ld at 0x%lx\\n\"",
            "fw_dump.cpu_notes_buf_size",
            "fw_dump.cpu_notes_buf_vaddr"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to allocate %ld bytes for CPU notes buffer\\n\"",
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_alloc_buffer",
          "args": [
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_alloc_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "773-788",
          "snippet": "static void *fadump_alloc_buffer(unsigned long size)\n{\n\tunsigned long count, i;\n\tstruct page *page;\n\tvoid *vaddr;\n\n\tvaddr = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = PAGE_ALIGN(size) / PAGE_SIZE;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tmark_page_reserved(page + i);\n\treturn vaddr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void *fadump_alloc_buffer(unsigned long size)\n{\n\tunsigned long count, i;\n\tstruct page *page;\n\tvoid *vaddr;\n\n\tvaddr = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = PAGE_ALIGN(size) / PAGE_SIZE;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tmark_page_reserved(page + i);\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "fw_dump.cpu_notes_buf_size"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\ns32 fadump_setup_cpu_notes_buf(u32 num_cpus)\n{\n\t/* Allocate buffer to hold cpu crash notes. */\n\tfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\n\tfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\n\tfw_dump.cpu_notes_buf_vaddr =\n\t\t(unsigned long)fadump_alloc_buffer(fw_dump.cpu_notes_buf_size);\n\tif (!fw_dump.cpu_notes_buf_vaddr) {\n\t\tpr_err(\"Failed to allocate %ld bytes for CPU notes buffer\\n\",\n\t\t       fw_dump.cpu_notes_buf_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"Allocated buffer for cpu notes of size %ld at 0x%lx\\n\",\n\t\t fw_dump.cpu_notes_buf_size,\n\t\t fw_dump.cpu_notes_buf_vaddr);\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_free_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "790-793",
    "snippet": "static void fadump_free_buffer(unsigned long vaddr, unsigned long size)\n{\n\tfree_reserved_area((void *)vaddr, (void *)(vaddr + size), -1, NULL);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_area",
          "args": [
            "(void *)vaddr",
            "(void *)(vaddr + size)",
            "-1",
            "NULL"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void fadump_free_buffer(unsigned long vaddr, unsigned long size)\n{\n\tfree_reserved_area((void *)vaddr, (void *)(vaddr + size), -1, NULL);\n}"
  },
  {
    "function_name": "fadump_alloc_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "773-788",
    "snippet": "static void *fadump_alloc_buffer(unsigned long size)\n{\n\tunsigned long count, i;\n\tstruct page *page;\n\tvoid *vaddr;\n\n\tvaddr = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = PAGE_ALIGN(size) / PAGE_SIZE;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tmark_page_reserved(page + i);\n\treturn vaddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_page_reserved",
          "args": [
            "page + i"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vaddr"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "size",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void *fadump_alloc_buffer(unsigned long size)\n{\n\tunsigned long count, i;\n\tstruct page *page;\n\tvoid *vaddr;\n\n\tvaddr = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tcount = PAGE_ALIGN(size) / PAGE_SIZE;\n\tpage = virt_to_page(vaddr);\n\tfor (i = 0; i < count; i++)\n\t\tmark_page_reserved(page + i);\n\treturn vaddr;\n}"
  },
  {
    "function_name": "fadump_update_elfcore_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "755-771",
    "snippet": "void fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elf_phdr *phdr;\n\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr\t= __pa(fw_dump.cpu_notes_buf_vaddr);\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "fw_dump.cpu_notes_buf_vaddr"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nvoid fadump_update_elfcore_header(char *bufp)\n{\n\tstruct elf_phdr *phdr;\n\n\tbufp += sizeof(struct elfhdr);\n\n\t/* First note is a place holder for cpu notes info. */\n\tphdr = (struct elf_phdr *)bufp;\n\n\tif (phdr->p_type == PT_NOTE) {\n\t\tphdr->p_paddr\t= __pa(fw_dump.cpu_notes_buf_vaddr);\n\t\tphdr->p_offset\t= phdr->p_paddr;\n\t\tphdr->p_filesz\t= fw_dump.cpu_notes_buf_size;\n\t\tphdr->p_memsz = fw_dump.cpu_notes_buf_size;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fadump_regs_to_elf_notes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "740-753",
    "snippet": "u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = append_elf_note(buf, CRASH_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t      &prstatus, sizeof(prstatus));\n\treturn buf;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "append_elf_note",
          "args": [
            "buf",
            "CRASH_CORE_NOTE_NAME",
            "NT_PRSTATUS",
            "&prstatus",
            "sizeof(prstatus)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_kernel_regs",
          "args": [
            "&prstatus.pr_reg",
            "regs"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&prstatus",
            "0",
            "sizeof(prstatus)"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nu32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\n{\n\tstruct elf_prstatus prstatus;\n\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\t/*\n\t * FIXME: How do i get PID? Do I really need it?\n\t * prstatus.pr_pid = ????\n\t */\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = append_elf_note(buf, CRASH_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t      &prstatus, sizeof(prstatus));\n\treturn buf;\n}"
  },
  {
    "function_name": "crash_fadump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "680-738",
    "snippet": "void crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [
      "#define CRASH_TIMEOUT\t\t500"
    ],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_trigger",
          "args": [
            "fdh",
            "str"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpus_in_fadump"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "&(fdh->regs)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_save_regs",
          "args": [
            "&fdh->regs"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_save_vmcoreinfo",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "fw_dump.fadumphdr_addr"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cpus_in_fadump"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&crashing_cpu",
            "-1",
            "this_cpu"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fadump_crash",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "should_fadump_crash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "176-181",
          "snippet": "int should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#define CRASH_TIMEOUT\t\t500\n\nstatic struct fw_dump fw_dump;\n\nvoid crash_fadump(struct pt_regs *regs, const char *str)\n{\n\tunsigned int msecs;\n\tstruct fadump_crash_info_header *fdh = NULL;\n\tint old_cpu, this_cpu;\n\t/* Do not include first CPU */\n\tunsigned int ncpus = num_online_cpus() - 1;\n\n\tif (!should_fadump_crash())\n\t\treturn;\n\n\t/*\n\t * old_cpu == -1 means this is the first CPU which has come here,\n\t * go ahead and trigger fadump.\n\t *\n\t * old_cpu != -1 means some other CPU has already on it's way\n\t * to trigger fadump, just keep looping here.\n\t */\n\tthis_cpu = smp_processor_id();\n\told_cpu = cmpxchg(&crashing_cpu, -1, this_cpu);\n\n\tif (old_cpu != -1) {\n\t\tatomic_inc(&cpus_in_fadump);\n\n\t\t/*\n\t\t * We can't loop here indefinitely. Wait as long as fadump\n\t\t * is in force. If we race with fadump un-registration this\n\t\t * loop will break and then we go down to normal panic path\n\t\t * and reboot. If fadump is in force the first crashing\n\t\t * cpu will definitely trigger fadump.\n\t\t */\n\t\twhile (fw_dump.dump_registered)\n\t\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\tfdh = __va(fw_dump.fadumphdr_addr);\n\tfdh->crashing_cpu = crashing_cpu;\n\tcrash_save_vmcoreinfo();\n\n\tif (regs)\n\t\tfdh->regs = *regs;\n\telse\n\t\tppc_save_regs(&fdh->regs);\n\n\tfdh->online_mask = *cpu_online_mask;\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(&(fdh->regs)) == 0x100) {\n\t\tmsecs = CRASH_TIMEOUT;\n\t\twhile ((atomic_read(&cpus_in_fadump) < ncpus) && (--msecs > 0))\n\t\t\tmdelay(1);\n\t}\n\n\tfw_dump.ops->fadump_trigger(fdh, str);\n}"
  },
  {
    "function_name": "early_fadump_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "672-677",
    "snippet": "static int __init early_fadump_reserve_mem(char *p)\n{\n\tif (p)\n\t\tfw_dump.reserve_bootvar = memparse(p, &p);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "prom_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "736-761",
          "snippet": "static unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init early_fadump_reserve_mem(char *p)\n{\n\tif (p)\n\t\tfw_dump.reserve_bootvar = memparse(p, &p);\n\treturn 0;\n}"
  },
  {
    "function_name": "early_fadump_param",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "649-664",
    "snippet": "static int __init early_fadump_param(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tif (strncmp(p, \"on\", 2) == 0)\n\t\tfw_dump.fadump_enabled = 1;\n\telse if (strncmp(p, \"off\", 3) == 0)\n\t\tfw_dump.fadump_enabled = 0;\n\telse if (strncmp(p, \"nocma\", 5) == 0) {\n\t\tfw_dump.fadump_enabled = 1;\n\t\tfw_dump.nocma = 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"nocma\"",
            "5"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init early_fadump_param(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tif (strncmp(p, \"on\", 2) == 0)\n\t\tfw_dump.fadump_enabled = 1;\n\telse if (strncmp(p, \"off\", 3) == 0)\n\t\tfw_dump.fadump_enabled = 0;\n\telse if (strncmp(p, \"nocma\", 5) == 0) {\n\t\tfw_dump.fadump_enabled = 1;\n\t\tfw_dump.nocma = 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "522-646",
    "snippet": "int __init fadump_reserve_mem(void)\n{\n\tu64 base, size, mem_boundary, bootmem_min;\n\tint ret = 1;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tpr_info(\"Firmware-Assisted Dump is not supported on this hardware\\n\");\n\t\tgoto error_out;\n\t}\n\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (!fw_dump.dump_active) {\n\t\tfw_dump.boot_memory_size =\n\t\t\tPAGE_ALIGN(fadump_calculate_reserve_size());\n#ifdef CONFIG_CMA\n\t\tif (!fw_dump.nocma) {\n\t\t\tfw_dump.boot_memory_size =\n\t\t\t\tALIGN(fw_dump.boot_memory_size,\n\t\t\t\t      FADUMP_CMA_ALIGNMENT);\n\t\t}\n#endif\n\n\t\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\t\tif (fw_dump.boot_memory_size < bootmem_min) {\n\t\t\tpr_err(\"Can't enable fadump with boot memory size (0x%lx) less than 0x%llx\\n\",\n\t\t\t       fw_dump.boot_memory_size, bootmem_min);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (!fadump_get_boot_mem_regions()) {\n\t\t\tpr_err(\"Too many holes in boot memory area to enable fadump\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmem_boundary = memory_limit;\n\telse\n\t\tmem_boundary = memblock_end_of_DRAM();\n\n\tbase = fw_dump.boot_mem_top;\n\tsize = get_fadump_area_size();\n\tfw_dump.reserve_dump_area_size = size;\n\tif (fw_dump.dump_active) {\n\t\tpr_info(\"Firmware-assisted dump is active.\\n\");\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\t/*\n\t\t * FADump capture kernel doesn't care much about hugepages.\n\t\t * In fact, handling hugepages in capture kernel is asking for\n\t\t * trouble. So, disable HugeTLB support when fadump is active.\n\t\t */\n\t\thugetlb_disabled = true;\n#endif\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * can be released for general use by invalidating fadump.\n\t\t */\n\t\tfadump_reserve_crash_area(base);\n\n\t\tpr_debug(\"fadumphdr_addr = %#016lx\\n\", fw_dump.fadumphdr_addr);\n\t\tpr_debug(\"Reserve dump area start address: 0x%lx\\n\",\n\t\t\t fw_dump.reserve_dump_area_start);\n\t} else {\n\t\t/*\n\t\t * Reserve memory at an offset closer to bottom of the RAM to\n\t\t * minimize the impact of memory hot-remove operation.\n\t\t */\n\t\tbase = fadump_locate_reserve_mem(base, size);\n\n\t\tif (!base || (base + size > mem_boundary)) {\n\t\t\tpr_err(\"Failed to find memory chunk for reservation!\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\t\tfw_dump.reserve_dump_area_start = base;\n\n\t\t/*\n\t\t * Calculate the kernel metadata address and register it with\n\t\t * f/w if the platform supports.\n\t\t */\n\t\tif (fw_dump.ops->fadump_setup_metadata &&\n\t\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\t\tgoto error_out;\n\n\t\tif (memblock_reserve(base, size)) {\n\t\t\tpr_err(\"Failed to reserve memory!\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tpr_info(\"Reserved %lldMB of memory at %#016llx (System RAM: %lldMB)\\n\",\n\t\t\t(size >> 20), base, (memblock_phys_mem_size() >> 20));\n\n\t\tret = fadump_cma_init();\n\t}\n\n\treturn ret;\nerror_out:\n\tfw_dump.fadump_enabled = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fadump_cma_init",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_cma_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "126-126",
          "snippet": "static int __init fadump_cma_init(void) { return 1; }",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int __init fadump_cma_init(void) { return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Reserved %lldMB of memory at %#016llx (System RAM: %lldMB)\\n\"",
            "(size >> 20)",
            "base",
            "(memblock_phys_mem_size() >> 20)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to reserve memory!\\n\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_setup_metadata",
          "args": [
            "&fw_dump"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to find memory chunk for reservation!\\n\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_locate_reserve_mem",
          "args": [
            "base",
            "size"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_locate_reserve_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "491-520",
          "snippet": "static u64 __init fadump_locate_reserve_mem(u64 base, u64 size)\n{\n\tstruct fadump_memory_range *mrngs;\n\tphys_addr_t mstart, mend;\n\tint idx = 0;\n\tu64 i, ret = 0;\n\n\tmrngs = reserved_mrange_info.mem_ranges;\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t&mstart, &mend, NULL) {\n\t\tpr_debug(\"%llu) mstart: %llx, mend: %llx, base: %llx\\n\",\n\t\t\t i, mstart, mend, base);\n\n\t\tif (mstart > base)\n\t\t\tbase = PAGE_ALIGN(mstart);\n\n\t\twhile ((mend > base) && ((mend - base) >= size)) {\n\t\t\tif (!overlaps_reserved_ranges(base, base+size, &idx)) {\n\t\t\t\tret = base;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbase = mrngs[idx].base + mrngs[idx].size;\n\t\t\tbase = PAGE_ALIGN(base);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic u64 __init fadump_locate_reserve_mem(u64 base, u64 size)\n{\n\tstruct fadump_memory_range *mrngs;\n\tphys_addr_t mstart, mend;\n\tint idx = 0;\n\tu64 i, ret = 0;\n\n\tmrngs = reserved_mrange_info.mem_ranges;\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t&mstart, &mend, NULL) {\n\t\tpr_debug(\"%llu) mstart: %llx, mend: %llx, base: %llx\\n\",\n\t\t\t i, mstart, mend, base);\n\n\t\tif (mstart > base)\n\t\t\tbase = PAGE_ALIGN(mstart);\n\n\t\twhile ((mend > base) && ((mend - base) >= size)) {\n\t\t\tif (!overlaps_reserved_ranges(base, base+size, &idx)) {\n\t\t\t\tret = base;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbase = mrngs[idx].base + mrngs[idx].size;\n\t\t\tbase = PAGE_ALIGN(base);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Reserve dump area start address: 0x%lx\\n\"",
            "fw_dump.reserve_dump_area_start"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"fadumphdr_addr = %#016lx\\n\"",
            "fw_dump.fadumphdr_addr"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_reserve_crash_area",
          "args": [
            "base"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_reserve_crash_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1683-1704",
          "snippet": "static void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void __init fadump_reserve_crash_area(u64 base)\n{\n\tstruct memblock_region *reg;\n\tu64 mstart, msize;\n\n\tfor_each_memblock(memory, reg) {\n\t\tmstart = reg->base;\n\t\tmsize  = reg->size;\n\n\t\tif ((mstart + msize) < base)\n\t\t\tcontinue;\n\n\t\tif (mstart < base) {\n\t\t\tmsize -= (base - mstart);\n\t\t\tmstart = base;\n\t\t}\n\n\t\tpr_info(\"Reserving %lluMB of memory at %#016llx for preserving crash data\",\n\t\t\t(msize >> 20), mstart);\n\t\tmemblock_reserve(mstart, msize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Firmware-assisted dump is active.\\n\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fadump_area_size",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "get_fadump_area_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "356-375",
          "snippet": "static unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\n\t/* This is to hold kernel metadata on platforms that support it */\n\tsize += (fw_dump.ops->fadump_get_metadata_size ?\n\t\t fw_dump.ops->fadump_get_metadata_size() : 0);\n\treturn size;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\n\t/* This is to hold kernel metadata on platforms that support it */\n\tsize += (fw_dump.ops->fadump_get_metadata_size ?\n\t\t fw_dump.ops->fadump_get_metadata_size() : 0);\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\"",
            "memory_limit"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_end_of_DRAM",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Too many holes in boot memory area to enable fadump\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_get_boot_mem_regions",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_get_boot_mem_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "423-457",
          "snippet": "static int __init fadump_get_boot_mem_regions(void)\n{\n\tunsigned long base, size, cur_size, hole_size, last_end;\n\tunsigned long mem_size = fw_dump.boot_memory_size;\n\tstruct memblock_region *reg;\n\tint ret = 1;\n\n\tfw_dump.boot_mem_regs_cnt = 0;\n\n\tlast_end = 0;\n\thole_size = 0;\n\tcur_size = 0;\n\tfor_each_memblock(memory, reg) {\n\t\tbase = reg->base;\n\t\tsize = reg->size;\n\t\thole_size += (base - last_end);\n\n\t\tif ((cur_size + size) >= mem_size) {\n\t\t\tsize = (mem_size - cur_size);\n\t\t\tret = add_boot_mem_regions(base, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tmem_size -= size;\n\t\tcur_size += size;\n\t\tret = add_boot_mem_regions(base, size);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tlast_end = base + size;\n\t}\n\tfw_dump.boot_mem_top = PAGE_ALIGN(fw_dump.boot_memory_size + hole_size);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int __init fadump_get_boot_mem_regions(void)\n{\n\tunsigned long base, size, cur_size, hole_size, last_end;\n\tunsigned long mem_size = fw_dump.boot_memory_size;\n\tstruct memblock_region *reg;\n\tint ret = 1;\n\n\tfw_dump.boot_mem_regs_cnt = 0;\n\n\tlast_end = 0;\n\thole_size = 0;\n\tcur_size = 0;\n\tfor_each_memblock(memory, reg) {\n\t\tbase = reg->base;\n\t\tsize = reg->size;\n\t\thole_size += (base - last_end);\n\n\t\tif ((cur_size + size) >= mem_size) {\n\t\t\tsize = (mem_size - cur_size);\n\t\t\tret = add_boot_mem_regions(base, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tmem_size -= size;\n\t\tcur_size += size;\n\t\tret = add_boot_mem_regions(base, size);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tlast_end = base + size;\n\t}\n\tfw_dump.boot_mem_top = PAGE_ALIGN(fw_dump.boot_memory_size + hole_size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't enable fadump with boot memory size (0x%lx) less than 0x%llx\\n\"",
            "fw_dump.boot_memory_size",
            "bootmem_min"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_get_bootmem_min",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "fw_dump.boot_memory_size",
            "FADUMP_CMA_ALIGNMENT"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "fadump_calculate_reserve_size()"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_calculate_reserve_size",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_calculate_reserve_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "295-350",
          "snippet": "static inline u64 fadump_calculate_reserve_size(void)\n{\n\tu64 base, size, bootmem_min;\n\tint ret;\n\n\tif (fw_dump.reserve_bootvar)\n\t\tpr_warn(\"'fadump_reserve_mem=' parameter is deprecated in favor of 'crashkernel=' parameter.\\n\");\n\n\t/*\n\t * Check if the size is specified through crashkernel= cmdline\n\t * option. If yes, then use that but ignore base as fadump reserves\n\t * memory at a predefined offset.\n\t */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t\t&size, &base);\n\tif (ret == 0 && size > 0) {\n\t\tunsigned long max_size;\n\n\t\tif (fw_dump.reserve_bootvar)\n\t\t\tpr_info(\"Using 'crashkernel=' parameter for memory reservation.\\n\");\n\n\t\tfw_dump.reserve_bootvar = (unsigned long)size;\n\n\t\t/*\n\t\t * Adjust if the boot memory size specified is above\n\t\t * the upper limit.\n\t\t */\n\t\tmax_size = memblock_phys_mem_size() / MAX_BOOT_MEM_RATIO;\n\t\tif (fw_dump.reserve_bootvar > max_size) {\n\t\t\tfw_dump.reserve_bootvar = max_size;\n\t\t\tpr_info(\"Adjusted boot memory size to %luMB\\n\",\n\t\t\t\t(fw_dump.reserve_bootvar >> 20));\n\t\t}\n\n\t\treturn fw_dump.reserve_bootvar;\n\t} else if (fw_dump.reserve_bootvar) {\n\t\t/*\n\t\t * 'fadump_reserve_mem=' is being used to reserve memory\n\t\t * for firmware-assisted dump.\n\t\t */\n\t\treturn fw_dump.reserve_bootvar;\n\t}\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_phys_mem_size() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\treturn (size > bootmem_min ? size : bootmem_min);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline u64 fadump_calculate_reserve_size(void)\n{\n\tu64 base, size, bootmem_min;\n\tint ret;\n\n\tif (fw_dump.reserve_bootvar)\n\t\tpr_warn(\"'fadump_reserve_mem=' parameter is deprecated in favor of 'crashkernel=' parameter.\\n\");\n\n\t/*\n\t * Check if the size is specified through crashkernel= cmdline\n\t * option. If yes, then use that but ignore base as fadump reserves\n\t * memory at a predefined offset.\n\t */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t\t&size, &base);\n\tif (ret == 0 && size > 0) {\n\t\tunsigned long max_size;\n\n\t\tif (fw_dump.reserve_bootvar)\n\t\t\tpr_info(\"Using 'crashkernel=' parameter for memory reservation.\\n\");\n\n\t\tfw_dump.reserve_bootvar = (unsigned long)size;\n\n\t\t/*\n\t\t * Adjust if the boot memory size specified is above\n\t\t * the upper limit.\n\t\t */\n\t\tmax_size = memblock_phys_mem_size() / MAX_BOOT_MEM_RATIO;\n\t\tif (fw_dump.reserve_bootvar > max_size) {\n\t\t\tfw_dump.reserve_bootvar = max_size;\n\t\t\tpr_info(\"Adjusted boot memory size to %luMB\\n\",\n\t\t\t\t(fw_dump.reserve_bootvar >> 20));\n\t\t}\n\n\t\treturn fw_dump.reserve_bootvar;\n\t} else if (fw_dump.reserve_bootvar) {\n\t\t/*\n\t\t * 'fadump_reserve_mem=' is being used to reserve memory\n\t\t * for firmware-assisted dump.\n\t\t */\n\t\treturn fw_dump.reserve_bootvar;\n\t}\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_phys_mem_size() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\treturn (size > bootmem_min ? size : bootmem_min);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Firmware-Assisted Dump is not supported on this hardware\\n\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nint __init fadump_reserve_mem(void)\n{\n\tu64 base, size, mem_boundary, bootmem_min;\n\tint ret = 1;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tpr_info(\"Firmware-Assisted Dump is not supported on this hardware\\n\");\n\t\tgoto error_out;\n\t}\n\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (!fw_dump.dump_active) {\n\t\tfw_dump.boot_memory_size =\n\t\t\tPAGE_ALIGN(fadump_calculate_reserve_size());\n#ifdef CONFIG_CMA\n\t\tif (!fw_dump.nocma) {\n\t\t\tfw_dump.boot_memory_size =\n\t\t\t\tALIGN(fw_dump.boot_memory_size,\n\t\t\t\t      FADUMP_CMA_ALIGNMENT);\n\t\t}\n#endif\n\n\t\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\t\tif (fw_dump.boot_memory_size < bootmem_min) {\n\t\t\tpr_err(\"Can't enable fadump with boot memory size (0x%lx) less than 0x%llx\\n\",\n\t\t\t       fw_dump.boot_memory_size, bootmem_min);\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (!fadump_get_boot_mem_regions()) {\n\t\t\tpr_err(\"Too many holes in boot memory area to enable fadump\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmem_boundary = memory_limit;\n\telse\n\t\tmem_boundary = memblock_end_of_DRAM();\n\n\tbase = fw_dump.boot_mem_top;\n\tsize = get_fadump_area_size();\n\tfw_dump.reserve_dump_area_size = size;\n\tif (fw_dump.dump_active) {\n\t\tpr_info(\"Firmware-assisted dump is active.\\n\");\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\t/*\n\t\t * FADump capture kernel doesn't care much about hugepages.\n\t\t * In fact, handling hugepages in capture kernel is asking for\n\t\t * trouble. So, disable HugeTLB support when fadump is active.\n\t\t */\n\t\thugetlb_disabled = true;\n#endif\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * can be released for general use by invalidating fadump.\n\t\t */\n\t\tfadump_reserve_crash_area(base);\n\n\t\tpr_debug(\"fadumphdr_addr = %#016lx\\n\", fw_dump.fadumphdr_addr);\n\t\tpr_debug(\"Reserve dump area start address: 0x%lx\\n\",\n\t\t\t fw_dump.reserve_dump_area_start);\n\t} else {\n\t\t/*\n\t\t * Reserve memory at an offset closer to bottom of the RAM to\n\t\t * minimize the impact of memory hot-remove operation.\n\t\t */\n\t\tbase = fadump_locate_reserve_mem(base, size);\n\n\t\tif (!base || (base + size > mem_boundary)) {\n\t\t\tpr_err(\"Failed to find memory chunk for reservation!\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\t\tfw_dump.reserve_dump_area_start = base;\n\n\t\t/*\n\t\t * Calculate the kernel metadata address and register it with\n\t\t * f/w if the platform supports.\n\t\t */\n\t\tif (fw_dump.ops->fadump_setup_metadata &&\n\t\t    (fw_dump.ops->fadump_setup_metadata(&fw_dump) < 0))\n\t\t\tgoto error_out;\n\n\t\tif (memblock_reserve(base, size)) {\n\t\t\tpr_err(\"Failed to reserve memory!\\n\");\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tpr_info(\"Reserved %lldMB of memory at %#016llx (System RAM: %lldMB)\\n\",\n\t\t\t(size >> 20), base, (memblock_phys_mem_size() >> 20));\n\n\t\tret = fadump_cma_init();\n\t}\n\n\treturn ret;\nerror_out:\n\tfw_dump.fadump_enabled = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_locate_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "491-520",
    "snippet": "static u64 __init fadump_locate_reserve_mem(u64 base, u64 size)\n{\n\tstruct fadump_memory_range *mrngs;\n\tphys_addr_t mstart, mend;\n\tint idx = 0;\n\tu64 i, ret = 0;\n\n\tmrngs = reserved_mrange_info.mem_ranges;\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t&mstart, &mend, NULL) {\n\t\tpr_debug(\"%llu) mstart: %llx, mend: %llx, base: %llx\\n\",\n\t\t\t i, mstart, mend, base);\n\n\t\tif (mstart > base)\n\t\t\tbase = PAGE_ALIGN(mstart);\n\n\t\twhile ((mend > base) && ((mend - base) >= size)) {\n\t\t\tif (!overlaps_reserved_ranges(base, base+size, &idx)) {\n\t\t\t\tret = base;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbase = mrngs[idx].base + mrngs[idx].size;\n\t\t\tbase = PAGE_ALIGN(base);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "base"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overlaps_reserved_ranges",
          "args": [
            "base",
            "base+size",
            "&idx"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps_reserved_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "465-485",
          "snippet": "static bool overlaps_reserved_ranges(u64 base, u64 end, int *idx)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = *idx; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tu64 rbase = reserved_mrange_info.mem_ranges[i].base;\n\t\tu64 rend = rbase + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (end <= rbase)\n\t\t\tbreak;\n\n\t\tif ((end > rbase) &&  (base < rend)) {\n\t\t\t*idx = i;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic bool overlaps_reserved_ranges(u64 base, u64 end, int *idx)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = *idx; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tu64 rbase = reserved_mrange_info.mem_ranges[i].base;\n\t\tu64 rend = rbase + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (end <= rbase)\n\t\t\tbreak;\n\n\t\tif ((end > rbase) &&  (base < rend)) {\n\t\t\t*idx = i;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mstart"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%llu) mstart: %llx, mend: %llx, base: %llx\\n\"",
            "i",
            "mstart",
            "mend",
            "base"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "NUMA_NO_NODE",
            "MEMBLOCK_NONE",
            "&mstart",
            "&mend",
            "NULL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic u64 __init fadump_locate_reserve_mem(u64 base, u64 size)\n{\n\tstruct fadump_memory_range *mrngs;\n\tphys_addr_t mstart, mend;\n\tint idx = 0;\n\tu64 i, ret = 0;\n\n\tmrngs = reserved_mrange_info.mem_ranges;\n\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t&mstart, &mend, NULL) {\n\t\tpr_debug(\"%llu) mstart: %llx, mend: %llx, base: %llx\\n\",\n\t\t\t i, mstart, mend, base);\n\n\t\tif (mstart > base)\n\t\t\tbase = PAGE_ALIGN(mstart);\n\n\t\twhile ((mend > base) && ((mend - base) >= size)) {\n\t\t\tif (!overlaps_reserved_ranges(base, base+size, &idx)) {\n\t\t\t\tret = base;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbase = mrngs[idx].base + mrngs[idx].size;\n\t\t\tbase = PAGE_ALIGN(base);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "overlaps_reserved_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "465-485",
    "snippet": "static bool overlaps_reserved_ranges(u64 base, u64 end, int *idx)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = *idx; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tu64 rbase = reserved_mrange_info.mem_ranges[i].base;\n\t\tu64 rend = rbase + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (end <= rbase)\n\t\t\tbreak;\n\n\t\tif ((end > rbase) &&  (base < rend)) {\n\t\t\t*idx = i;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic bool overlaps_reserved_ranges(u64 base, u64 end, int *idx)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = *idx; i < reserved_mrange_info.mem_range_cnt; i++) {\n\t\tu64 rbase = reserved_mrange_info.mem_ranges[i].base;\n\t\tu64 rend = rbase + reserved_mrange_info.mem_ranges[i].size;\n\n\t\tif (end <= rbase)\n\t\t\tbreak;\n\n\t\tif ((end > rbase) &&  (base < rend)) {\n\t\t\t*idx = i;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fadump_get_boot_mem_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "423-457",
    "snippet": "static int __init fadump_get_boot_mem_regions(void)\n{\n\tunsigned long base, size, cur_size, hole_size, last_end;\n\tunsigned long mem_size = fw_dump.boot_memory_size;\n\tstruct memblock_region *reg;\n\tint ret = 1;\n\n\tfw_dump.boot_mem_regs_cnt = 0;\n\n\tlast_end = 0;\n\thole_size = 0;\n\tcur_size = 0;\n\tfor_each_memblock(memory, reg) {\n\t\tbase = reg->base;\n\t\tsize = reg->size;\n\t\thole_size += (base - last_end);\n\n\t\tif ((cur_size + size) >= mem_size) {\n\t\t\tsize = (mem_size - cur_size);\n\t\t\tret = add_boot_mem_regions(base, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tmem_size -= size;\n\t\tcur_size += size;\n\t\tret = add_boot_mem_regions(base, size);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tlast_end = base + size;\n\t}\n\tfw_dump.boot_mem_top = PAGE_ALIGN(fw_dump.boot_memory_size + hole_size);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "fw_dump.boot_memory_size + hole_size"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_boot_mem_regions",
          "args": [
            "base",
            "size"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "add_boot_mem_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "398-421",
          "snippet": "static int __init add_boot_mem_regions(unsigned long mstart,\n\t\t\t\t       unsigned long msize)\n{\n\tunsigned long rstart, rsize, max_size;\n\tint ret = 1;\n\n\trstart = mstart;\n\tmax_size = fw_dump.max_copy_size ? fw_dump.max_copy_size : msize;\n\twhile (msize) {\n\t\tif (msize > max_size)\n\t\t\trsize = max_size;\n\t\telse\n\t\t\trsize = msize;\n\n\t\tret = add_boot_mem_region(rstart, rsize);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsize -= rsize;\n\t\trstart += rsize;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init add_boot_mem_regions(unsigned long mstart,\n\t\t\t\t       unsigned long msize)\n{\n\tunsigned long rstart, rsize, max_size;\n\tint ret = 1;\n\n\trstart = mstart;\n\tmax_size = fw_dump.max_copy_size ? fw_dump.max_copy_size : msize;\n\twhile (msize) {\n\t\tif (msize > max_size)\n\t\t\trsize = max_size;\n\t\telse\n\t\t\trsize = msize;\n\n\t\tret = add_boot_mem_region(rstart, rsize);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsize -= rsize;\n\t\trstart += rsize;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic int __init fadump_get_boot_mem_regions(void)\n{\n\tunsigned long base, size, cur_size, hole_size, last_end;\n\tunsigned long mem_size = fw_dump.boot_memory_size;\n\tstruct memblock_region *reg;\n\tint ret = 1;\n\n\tfw_dump.boot_mem_regs_cnt = 0;\n\n\tlast_end = 0;\n\thole_size = 0;\n\tcur_size = 0;\n\tfor_each_memblock(memory, reg) {\n\t\tbase = reg->base;\n\t\tsize = reg->size;\n\t\thole_size += (base - last_end);\n\n\t\tif ((cur_size + size) >= mem_size) {\n\t\t\tsize = (mem_size - cur_size);\n\t\t\tret = add_boot_mem_regions(base, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tmem_size -= size;\n\t\tcur_size += size;\n\t\tret = add_boot_mem_regions(base, size);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tlast_end = base + size;\n\t}\n\tfw_dump.boot_mem_top = PAGE_ALIGN(fw_dump.boot_memory_size + hole_size);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "add_boot_mem_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "398-421",
    "snippet": "static int __init add_boot_mem_regions(unsigned long mstart,\n\t\t\t\t       unsigned long msize)\n{\n\tunsigned long rstart, rsize, max_size;\n\tint ret = 1;\n\n\trstart = mstart;\n\tmax_size = fw_dump.max_copy_size ? fw_dump.max_copy_size : msize;\n\twhile (msize) {\n\t\tif (msize > max_size)\n\t\t\trsize = max_size;\n\t\telse\n\t\t\trsize = msize;\n\n\t\tret = add_boot_mem_region(rstart, rsize);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsize -= rsize;\n\t\trstart += rsize;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_boot_mem_region",
          "args": [
            "rstart",
            "rsize"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "add_boot_mem_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "398-421",
          "snippet": "static int __init add_boot_mem_regions(unsigned long mstart,\n\t\t\t\t       unsigned long msize)\n{\n\tunsigned long rstart, rsize, max_size;\n\tint ret = 1;\n\n\trstart = mstart;\n\tmax_size = fw_dump.max_copy_size ? fw_dump.max_copy_size : msize;\n\twhile (msize) {\n\t\tif (msize > max_size)\n\t\t\trsize = max_size;\n\t\telse\n\t\t\trsize = msize;\n\n\t\tret = add_boot_mem_region(rstart, rsize);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsize -= rsize;\n\t\trstart += rsize;\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init add_boot_mem_regions(unsigned long mstart,\n\t\t\t\t       unsigned long msize)\n{\n\tunsigned long rstart, rsize, max_size;\n\tint ret = 1;\n\n\trstart = mstart;\n\tmax_size = fw_dump.max_copy_size ? fw_dump.max_copy_size : msize;\n\twhile (msize) {\n\t\tif (msize > max_size)\n\t\t\trsize = max_size;\n\t\telse\n\t\t\trsize = msize;\n\n\t\tret = add_boot_mem_region(rstart, rsize);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tmsize -= rsize;\n\t\trstart += rsize;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "add_boot_mem_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "377-392",
    "snippet": "static int __init add_boot_mem_region(unsigned long rstart,\n\t\t\t\t      unsigned long rsize)\n{\n\tint i = fw_dump.boot_mem_regs_cnt++;\n\n\tif (fw_dump.boot_mem_regs_cnt > FADUMP_MAX_MEM_REGS) {\n\t\tfw_dump.boot_mem_regs_cnt = FADUMP_MAX_MEM_REGS;\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"Added boot memory range[%d] [%#016lx-%#016lx)\\n\",\n\t\t i, rstart, (rstart + rsize));\n\tfw_dump.boot_mem_addr[i] = rstart;\n\tfw_dump.boot_mem_sz[i] = rsize;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Added boot memory range[%d] [%#016lx-%#016lx)\\n\"",
            "i",
            "rstart",
            "(rstart + rsize)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic int __init add_boot_mem_region(unsigned long rstart,\n\t\t\t\t      unsigned long rsize)\n{\n\tint i = fw_dump.boot_mem_regs_cnt++;\n\n\tif (fw_dump.boot_mem_regs_cnt > FADUMP_MAX_MEM_REGS) {\n\t\tfw_dump.boot_mem_regs_cnt = FADUMP_MAX_MEM_REGS;\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"Added boot memory range[%d] [%#016lx-%#016lx)\\n\",\n\t\t i, rstart, (rstart + rsize));\n\tfw_dump.boot_mem_addr[i] = rstart;\n\tfw_dump.boot_mem_sz[i] = rsize;\n\treturn 1;\n}"
  },
  {
    "function_name": "get_fadump_area_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "356-375",
    "snippet": "static unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\n\t/* This is to hold kernel metadata on platforms that support it */\n\tsize += (fw_dump.ops->fadump_get_metadata_size ?\n\t\t fw_dump.ops->fadump_get_metadata_size() : 0);\n\treturn size;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_get_metadata_size",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_num_regions",
          "args": [
            "memory"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nstatic unsigned long get_fadump_area_size(void)\n{\n\tunsigned long size = 0;\n\n\tsize += fw_dump.cpu_state_data_size;\n\tsize += fw_dump.hpte_region_size;\n\tsize += fw_dump.boot_memory_size;\n\tsize += sizeof(struct fadump_crash_info_header);\n\tsize += sizeof(struct elfhdr); /* ELF core header.*/\n\tsize += sizeof(struct elf_phdr); /* place holder for cpu notes */\n\t/* Program headers for crash memory regions. */\n\tsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\n\n\tsize = PAGE_ALIGN(size);\n\n\t/* This is to hold kernel metadata on platforms that support it */\n\tsize += (fw_dump.ops->fadump_get_metadata_size ?\n\t\t fw_dump.ops->fadump_get_metadata_size() : 0);\n\treturn size;\n}"
  },
  {
    "function_name": "fadump_calculate_reserve_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "295-350",
    "snippet": "static inline u64 fadump_calculate_reserve_size(void)\n{\n\tu64 base, size, bootmem_min;\n\tint ret;\n\n\tif (fw_dump.reserve_bootvar)\n\t\tpr_warn(\"'fadump_reserve_mem=' parameter is deprecated in favor of 'crashkernel=' parameter.\\n\");\n\n\t/*\n\t * Check if the size is specified through crashkernel= cmdline\n\t * option. If yes, then use that but ignore base as fadump reserves\n\t * memory at a predefined offset.\n\t */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t\t&size, &base);\n\tif (ret == 0 && size > 0) {\n\t\tunsigned long max_size;\n\n\t\tif (fw_dump.reserve_bootvar)\n\t\t\tpr_info(\"Using 'crashkernel=' parameter for memory reservation.\\n\");\n\n\t\tfw_dump.reserve_bootvar = (unsigned long)size;\n\n\t\t/*\n\t\t * Adjust if the boot memory size specified is above\n\t\t * the upper limit.\n\t\t */\n\t\tmax_size = memblock_phys_mem_size() / MAX_BOOT_MEM_RATIO;\n\t\tif (fw_dump.reserve_bootvar > max_size) {\n\t\t\tfw_dump.reserve_bootvar = max_size;\n\t\t\tpr_info(\"Adjusted boot memory size to %luMB\\n\",\n\t\t\t\t(fw_dump.reserve_bootvar >> 20));\n\t\t}\n\n\t\treturn fw_dump.reserve_bootvar;\n\t} else if (fw_dump.reserve_bootvar) {\n\t\t/*\n\t\t * 'fadump_reserve_mem=' is being used to reserve memory\n\t\t * for firmware-assisted dump.\n\t\t */\n\t\treturn fw_dump.reserve_bootvar;\n\t}\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_phys_mem_size() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\treturn (size > bootmem_min ? size : bootmem_min);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fw_dump.ops->fadump_get_bootmem_min",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Adjusted boot memory size to %luMB\\n\"",
            "(fw_dump.reserve_bootvar >> 20)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Using 'crashkernel=' parameter for memory reservation.\\n\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_crashkernel",
          "args": [
            "boot_command_line",
            "memblock_phys_mem_size()",
            "&size",
            "&base"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"'fadump_reserve_mem=' parameter is deprecated in favor of 'crashkernel=' parameter.\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic inline u64 fadump_calculate_reserve_size(void)\n{\n\tu64 base, size, bootmem_min;\n\tint ret;\n\n\tif (fw_dump.reserve_bootvar)\n\t\tpr_warn(\"'fadump_reserve_mem=' parameter is deprecated in favor of 'crashkernel=' parameter.\\n\");\n\n\t/*\n\t * Check if the size is specified through crashkernel= cmdline\n\t * option. If yes, then use that but ignore base as fadump reserves\n\t * memory at a predefined offset.\n\t */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t\t&size, &base);\n\tif (ret == 0 && size > 0) {\n\t\tunsigned long max_size;\n\n\t\tif (fw_dump.reserve_bootvar)\n\t\t\tpr_info(\"Using 'crashkernel=' parameter for memory reservation.\\n\");\n\n\t\tfw_dump.reserve_bootvar = (unsigned long)size;\n\n\t\t/*\n\t\t * Adjust if the boot memory size specified is above\n\t\t * the upper limit.\n\t\t */\n\t\tmax_size = memblock_phys_mem_size() / MAX_BOOT_MEM_RATIO;\n\t\tif (fw_dump.reserve_bootvar > max_size) {\n\t\t\tfw_dump.reserve_bootvar = max_size;\n\t\t\tpr_info(\"Adjusted boot memory size to %luMB\\n\",\n\t\t\t\t(fw_dump.reserve_bootvar >> 20));\n\t\t}\n\n\t\treturn fw_dump.reserve_bootvar;\n\t} else if (fw_dump.reserve_bootvar) {\n\t\t/*\n\t\t * 'fadump_reserve_mem=' is being used to reserve memory\n\t\t * for firmware-assisted dump.\n\t\t */\n\t\treturn fw_dump.reserve_bootvar;\n\t}\n\n\t/* divide by 20 to get 5% of value */\n\tsize = memblock_phys_mem_size() / 20;\n\n\t/* round it down in multiples of 256 */\n\tsize = size & ~0x0FFFFFFFUL;\n\n\t/* Truncate to memory_limit. We don't want to over reserve the memory.*/\n\tif (memory_limit && size > memory_limit)\n\t\tsize = memory_limit;\n\n\tbootmem_min = fw_dump.ops->fadump_get_bootmem_min();\n\treturn (size > bootmem_min ? size : bootmem_min);\n}"
  },
  {
    "function_name": "fadump_show_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "254-278",
    "snippet": "static void fadump_show_config(void)\n{\n\tint i;\n\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"    Boot memory size   : %lx\\n\", fw_dump.boot_memory_size);\n\tpr_debug(\"    Boot memory top    : %llx\\n\", fw_dump.boot_mem_top);\n\tpr_debug(\"Boot memory regions cnt: %llx\\n\", fw_dump.boot_mem_regs_cnt);\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tpr_debug(\"[%03d] base = %llx, size = %llx\\n\", i,\n\t\t\t fw_dump.boot_mem_addr[i], fw_dump.boot_mem_sz[i]);\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"[%03d] base = %llx, size = %llx\\n\"",
            "i",
            "fw_dump.boot_mem_addr[i]",
            "fw_dump.boot_mem_sz[i]"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Boot memory regions cnt: %llx\\n\"",
            "fw_dump.boot_mem_regs_cnt"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    Boot memory top    : %llx\\n\"",
            "fw_dump.boot_mem_top"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    Boot memory size   : %lx\\n\"",
            "fw_dump.boot_memory_size"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    HPTE region size   : %lx\\n\"",
            "fw_dump.hpte_region_size"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    CPU state data size: %lx\\n\"",
            "fw_dump.cpu_state_data_size"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Dump section sizes:\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Dump Active       : %s\\n\"",
            "(fw_dump.dump_active ? \"yes\" : \"no\")"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Fadump enabled    : %s\\n\"",
            "(fw_dump.fadump_enabled ? \"yes\" : \"no\")"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Support for firmware-assisted dump (fadump): %s\\n\"",
            "(fw_dump.fadump_supported ? \"present\" : \"no support\")"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void fadump_show_config(void)\n{\n\tint i;\n\n\tpr_debug(\"Support for firmware-assisted dump (fadump): %s\\n\",\n\t\t\t(fw_dump.fadump_supported ? \"present\" : \"no support\"));\n\n\tif (!fw_dump.fadump_supported)\n\t\treturn;\n\n\tpr_debug(\"Fadump enabled    : %s\\n\",\n\t\t\t\t(fw_dump.fadump_enabled ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump Active       : %s\\n\",\n\t\t\t\t(fw_dump.dump_active ? \"yes\" : \"no\"));\n\tpr_debug(\"Dump section sizes:\\n\");\n\tpr_debug(\"    CPU state data size: %lx\\n\", fw_dump.cpu_state_data_size);\n\tpr_debug(\"    HPTE region size   : %lx\\n\", fw_dump.hpte_region_size);\n\tpr_debug(\"    Boot memory size   : %lx\\n\", fw_dump.boot_memory_size);\n\tpr_debug(\"    Boot memory top    : %llx\\n\", fw_dump.boot_mem_top);\n\tpr_debug(\"Boot memory regions cnt: %llx\\n\", fw_dump.boot_mem_regs_cnt);\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\tpr_debug(\"[%03d] base = %llx, size = %llx\\n\", i,\n\t\t\t fw_dump.boot_mem_addr[i], fw_dump.boot_mem_sz[i]);\n\t}\n}"
  },
  {
    "function_name": "is_fadump_reserved_mem_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "244-251",
    "snippet": "bool is_fadump_reserved_mem_contiguous(void)\n{\n\tu64 d_start, d_end;\n\n\td_start\t= fw_dump.reserve_dump_area_start;\n\td_end\t= d_start + fw_dump.reserve_dump_area_size;\n\treturn is_fadump_mem_area_contiguous(d_start, d_end);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_fadump_mem_area_contiguous",
          "args": [
            "d_start",
            "d_end"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "is_fadump_mem_area_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "192-216",
          "snippet": "static bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nbool is_fadump_reserved_mem_contiguous(void)\n{\n\tu64 d_start, d_end;\n\n\td_start\t= fw_dump.reserve_dump_area_start;\n\td_end\t= d_start + fw_dump.reserve_dump_area_size;\n\treturn is_fadump_mem_area_contiguous(d_start, d_end);\n}"
  },
  {
    "function_name": "is_fadump_boot_mem_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "222-238",
    "snippet": "bool is_fadump_boot_mem_contiguous(void)\n{\n\tunsigned long d_start, d_end;\n\tbool ret = false;\n\tint i;\n\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\td_start = fw_dump.boot_mem_addr[i];\n\t\td_end   = d_start + fw_dump.boot_mem_sz[i];\n\n\t\tret = is_fadump_mem_area_contiguous(d_start, d_end);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_fadump_mem_area_contiguous",
          "args": [
            "d_start",
            "d_end"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "is_fadump_mem_area_contiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "192-216",
          "snippet": "static bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nbool is_fadump_boot_mem_contiguous(void)\n{\n\tunsigned long d_start, d_end;\n\tbool ret = false;\n\tint i;\n\n\tfor (i = 0; i < fw_dump.boot_mem_regs_cnt; i++) {\n\t\td_start = fw_dump.boot_mem_addr[i];\n\t\td_end   = d_start + fw_dump.boot_mem_sz[i];\n\n\t\tret = is_fadump_mem_area_contiguous(d_start, d_end);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_fadump_mem_area_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "192-216",
    "snippet": "static bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "d_end",
            "(reg->base + reg->size)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "d_start",
            "reg->base"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "reg"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic bool is_fadump_mem_area_contiguous(u64 d_start, u64 d_end)\n{\n\tstruct memblock_region *reg;\n\tbool ret = false;\n\tu64 start, end;\n\n\tfor_each_memblock(memory, reg) {\n\t\tstart = max_t(u64, d_start, reg->base);\n\t\tend = min_t(u64, d_end, (reg->base + reg->size));\n\t\tif (d_start < end) {\n\t\t\t/* Memory hole from d_start to start */\n\t\t\tif (start > d_start)\n\t\t\t\tbreak;\n\n\t\t\tif (end == d_end) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_start = end + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_fadump_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "183-186",
    "snippet": "int is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}"
  },
  {
    "function_name": "should_fadump_crash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "176-181",
    "snippet": "int should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint should_fadump_crash(void)\n{\n\tif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "is_fadump_memory_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "158-174",
    "snippet": "int is_fadump_memory_area(u64 addr, unsigned long size)\n{\n\tu64 d_start, d_end;\n\n\tif (!fw_dump.dump_registered)\n\t\treturn 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\td_start = fw_dump.reserve_dump_area_start;\n\td_end = d_start + fw_dump.reserve_dump_area_size;\n\tif (((addr + size) > d_start) && (addr <= d_end))\n\t\treturn 1;\n\n\treturn (addr <= fw_dump.boot_mem_top);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint is_fadump_memory_area(u64 addr, unsigned long size)\n{\n\tu64 d_start, d_end;\n\n\tif (!fw_dump.dump_registered)\n\t\treturn 0;\n\n\tif (!size)\n\t\treturn 0;\n\n\td_start = fw_dump.reserve_dump_area_start;\n\td_end = d_start + fw_dump.reserve_dump_area_size;\n\tif (((addr + size) > d_start) && (addr <= d_end))\n\t\treturn 1;\n\n\treturn (addr <= fw_dump.boot_mem_top);\n}"
  },
  {
    "function_name": "early_init_dt_scan_fw_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "130-152",
    "snippet": "int __init early_init_dt_scan_fw_dump(unsigned long node, const char *uname,\n\t\t\t\t      int depth, void *data)\n{\n\tif (depth == 0) {\n\t\tearly_init_dt_scan_reserved_ranges(node);\n\t\treturn 0;\n\t}\n\n\tif (depth != 1)\n\t\treturn 0;\n\n\tif (strcmp(uname, \"rtas\") == 0) {\n\t\trtas_fadump_dt_scan(&fw_dump, node);\n\t\treturn 1;\n\t}\n\n\tif (strcmp(uname, \"ibm,opal\") == 0) {\n\t\topal_fadump_dt_scan(&fw_dump, node);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "opal_fadump_dt_scan",
          "args": [
            "&fw_dump",
            "node"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"ibm,opal\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_fadump_dt_scan",
          "args": [
            "&fw_dump",
            "node"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_dt_scan_reserved_ranges",
          "args": [
            "node"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_reserved_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1313-1349",
          "snippet": "static void __init early_init_dt_scan_reserved_ranges(unsigned long node)\n{\n\tconst __be32 *prop;\n\tint len, ret = -1;\n\tunsigned long i;\n\n\t/* reserved-ranges already scanned */\n\tif (reserved_mrange_info.mem_range_cnt != 0)\n\t\treturn;\n\n\tprop = of_get_flat_dt_prop(node, \"reserved-ranges\", &len);\n\tif (!prop)\n\t\treturn;\n\n\t/*\n\t * Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range.\n\t */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tret = fadump_add_mem_range(&reserved_mrange_info,\n\t\t\t\t\t\t   base, base + size);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_warn(\"some reserved ranges are ignored!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compact reserved ranges */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init fadump_reserve_crash_area(u64 base);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nstatic void __init early_init_dt_scan_reserved_ranges(unsigned long node)\n{\n\tconst __be32 *prop;\n\tint len, ret = -1;\n\tunsigned long i;\n\n\t/* reserved-ranges already scanned */\n\tif (reserved_mrange_info.mem_range_cnt != 0)\n\t\treturn;\n\n\tprop = of_get_flat_dt_prop(node, \"reserved-ranges\", &len);\n\tif (!prop)\n\t\treturn;\n\n\t/*\n\t * Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range.\n\t */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tret = fadump_add_mem_range(&reserved_mrange_info,\n\t\t\t\t\t\t   base, base + size);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_warn(\"some reserved ranges are ignored!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Compact reserved ranges */\n\tsort_and_merge_mem_ranges(&reserved_mrange_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint __init early_init_dt_scan_fw_dump(unsigned long node, const char *uname,\n\t\t\t\t      int depth, void *data)\n{\n\tif (depth == 0) {\n\t\tearly_init_dt_scan_reserved_ranges(node);\n\t\treturn 0;\n\t}\n\n\tif (depth != 1)\n\t\treturn 0;\n\n\tif (strcmp(uname, \"rtas\") == 0) {\n\t\trtas_fadump_dt_scan(&fw_dump, node);\n\t\treturn 1;\n\t}\n\n\tif (strcmp(uname, \"ibm,opal\") == 0) {\n\t\topal_fadump_dt_scan(&fw_dump, node);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fadump_cma_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "126-126",
    "snippet": "static int __init fadump_cma_init(void) { return 1; }",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic int __init fadump_cma_init(void) { return 1; }"
  },
  {
    "function_name": "fadump_cma_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
    "lines": "82-124",
    "snippet": "int __init fadump_cma_init(void)\n{\n\tunsigned long long base, size;\n\tint rc;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\t/*\n\t * Do not use CMA if user has provided fadump=nocma kernel parameter.\n\t * Return 1 to continue with fadump old behaviour.\n\t */\n\tif (fw_dump.nocma)\n\t\treturn 1;\n\n\tbase = fw_dump.reserve_dump_area_start;\n\tsize = fw_dump.boot_memory_size;\n\n\tif (!size)\n\t\treturn 0;\n\n\trc = cma_init_reserved_mem(base, size, 0, \"fadump_cma\", &fadump_cma);\n\tif (rc) {\n\t\tpr_err(\"Failed to init cma area for firmware-assisted dump,%d\\n\", rc);\n\t\t/*\n\t\t * Though the CMA init has failed we still have memory\n\t\t * reservation with us. The reserved memory will be\n\t\t * blocked from production system usage.  Hence return 1,\n\t\t * so that we can continue with fadump.\n\t\t */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * So we now have successfully initialized cma area for fadump.\n\t */\n\tpr_info(\"Initialized 0x%lx bytes cma area at %ldMB from 0x%lx \"\n\t\t\"bytes of memory reserved for firmware-assisted dump\\n\",\n\t\tcma_get_size(fadump_cma),\n\t\t(unsigned long)cma_get_base(fadump_cma) >> 20,\n\t\tfw_dump.reserve_dump_area_size);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/fadump-internal.h>",
      "#include <asm/fadump.h>",
      "#include <asm/prom.h>",
      "#include <asm/page.h>",
      "#include <asm/debugfs.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/cma.h>",
      "#include <linux/slab.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/kobject.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/delay.h>",
      "#include <linux/memblock.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fw_dump fw_dump;",
      "static void __init fadump_reserve_crash_area(u64 base);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Initialized 0x%lx bytes cma area at %ldMB from 0x%lx \"\n\t\t\"bytes of memory reserved for firmware-assisted dump\\n\"",
            "cma_get_size(fadump_cma)",
            "(unsigned long)cma_get_base(fadump_cma) >> 20",
            "fw_dump.reserve_dump_area_size"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_base",
          "args": [
            "fadump_cma"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_get_size",
          "args": [
            "fadump_cma"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to init cma area for firmware-assisted dump,%d\\n\"",
            "rc"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_init_reserved_mem",
          "args": [
            "base",
            "size",
            "0",
            "\"fadump_cma\"",
            "&fadump_cma"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic void __init fadump_reserve_crash_area(u64 base);\n\nint __init fadump_cma_init(void)\n{\n\tunsigned long long base, size;\n\tint rc;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\t/*\n\t * Do not use CMA if user has provided fadump=nocma kernel parameter.\n\t * Return 1 to continue with fadump old behaviour.\n\t */\n\tif (fw_dump.nocma)\n\t\treturn 1;\n\n\tbase = fw_dump.reserve_dump_area_start;\n\tsize = fw_dump.boot_memory_size;\n\n\tif (!size)\n\t\treturn 0;\n\n\trc = cma_init_reserved_mem(base, size, 0, \"fadump_cma\", &fadump_cma);\n\tif (rc) {\n\t\tpr_err(\"Failed to init cma area for firmware-assisted dump,%d\\n\", rc);\n\t\t/*\n\t\t * Though the CMA init has failed we still have memory\n\t\t * reservation with us. The reserved memory will be\n\t\t * blocked from production system usage.  Hence return 1,\n\t\t * so that we can continue with fadump.\n\t\t */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * So we now have successfully initialized cma area for fadump.\n\t */\n\tpr_info(\"Initialized 0x%lx bytes cma area at %ldMB from 0x%lx \"\n\t\t\"bytes of memory reserved for firmware-assisted dump\\n\",\n\t\tcma_get_size(fadump_cma),\n\t\t(unsigned long)cma_get_base(fadump_cma) >> 20,\n\t\tfw_dump.reserve_dump_area_size);\n\treturn 1;\n}"
  }
]