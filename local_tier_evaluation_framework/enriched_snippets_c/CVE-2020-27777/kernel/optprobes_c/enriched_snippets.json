[
  {
    "function_name": "arch_within_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "359-364",
    "snippet": "int arch_within_optimized_kprobe(struct optimized_kprobe *op,\n\t\t\t\t unsigned long addr)\n{\n\treturn ((unsigned long)op->kp.addr <= addr &&\n\t\t(unsigned long)op->kp.addr + RELATIVEJUMP_SIZE > addr);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nint arch_within_optimized_kprobe(struct optimized_kprobe *op,\n\t\t\t\t unsigned long addr)\n{\n\treturn ((unsigned long)op->kp.addr <= addr &&\n\t\t(unsigned long)op->kp.addr + RELATIVEJUMP_SIZE > addr);\n}"
  },
  {
    "function_name": "arch_unoptimize_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "347-357",
    "snippet": "void arch_unoptimize_kprobes(struct list_head *oplist,\n\t\t\t     struct list_head *done_list)\n{\n\tstruct optimized_kprobe *op;\n\tstruct optimized_kprobe *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, oplist, list) {\n\t\tarch_unoptimize_kprobe(op);\n\t\tlist_move(&op->list, done_list);\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&op->list",
            "done_list"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unoptimize_kprobe",
          "args": [
            "op"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unoptimize_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
          "lines": "342-345",
          "snippet": "void arch_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tarch_arm_kprobe(&op->kp);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/sstep.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid arch_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tarch_arm_kprobe(&op->kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "oplist",
            "list"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid arch_unoptimize_kprobes(struct list_head *oplist,\n\t\t\t     struct list_head *done_list)\n{\n\tstruct optimized_kprobe *op;\n\tstruct optimized_kprobe *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, oplist, list) {\n\t\tarch_unoptimize_kprobe(op);\n\t\tlist_move(&op->list, done_list);\n\t}\n}"
  },
  {
    "function_name": "arch_unoptimize_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "342-345",
    "snippet": "void arch_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tarch_arm_kprobe(&op->kp);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_arm_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "arch_arm_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "150-153",
          "snippet": "void arch_arm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(BREAKPOINT_INSTRUCTION));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid arch_arm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(BREAKPOINT_INSTRUCTION));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid arch_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tarch_arm_kprobe(&op->kp);\n}"
  },
  {
    "function_name": "arch_optimize_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "321-340",
    "snippet": "void arch_optimize_kprobes(struct list_head *oplist)\n{\n\tstruct ppc_inst instr;\n\tstruct optimized_kprobe *op;\n\tstruct optimized_kprobe *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, oplist, list) {\n\t\t/*\n\t\t * Backup instructions which will be replaced\n\t\t * by jump address\n\t\t */\n\t\tmemcpy(op->optinsn.copied_insn, op->kp.addr,\n\t\t\t\t\t       RELATIVEJUMP_SIZE);\n\t\tcreate_branch(&instr,\n\t\t\t      (struct ppc_inst *)op->kp.addr,\n\t\t\t      (unsigned long)op->optinsn.insn, 0);\n\t\tpatch_instruction((struct ppc_inst *)op->kp.addr, instr);\n\t\tlist_del_init(&op->list);\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)op->kp.addr",
            "instr"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&instr",
            "(struct ppc_inst *)op->kp.addr",
            "(unsigned long)op->optinsn.insn",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "op->optinsn.copied_insn",
            "op->kp.addr",
            "RELATIVEJUMP_SIZE"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "oplist",
            "list"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid arch_optimize_kprobes(struct list_head *oplist)\n{\n\tstruct ppc_inst instr;\n\tstruct optimized_kprobe *op;\n\tstruct optimized_kprobe *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, oplist, list) {\n\t\t/*\n\t\t * Backup instructions which will be replaced\n\t\t * by jump address\n\t\t */\n\t\tmemcpy(op->optinsn.copied_insn, op->kp.addr,\n\t\t\t\t\t       RELATIVEJUMP_SIZE);\n\t\tcreate_branch(&instr,\n\t\t\t      (struct ppc_inst *)op->kp.addr,\n\t\t\t      (unsigned long)op->optinsn.insn, 0);\n\t\tpatch_instruction((struct ppc_inst *)op->kp.addr, instr);\n\t\tlist_del_init(&op->list);\n\t}\n}"
  },
  {
    "function_name": "arch_check_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "316-319",
    "snippet": "int arch_check_optimized_kprobe(struct optimized_kprobe *op)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nint arch_check_optimized_kprobe(struct optimized_kprobe *op)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_prepared_optinsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "306-309",
    "snippet": "int arch_prepared_optinsn(struct arch_optimized_insn *optinsn)\n{\n\treturn optinsn->insn != NULL;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nint arch_prepared_optinsn(struct arch_optimized_insn *optinsn)\n{\n\treturn optinsn->insn != NULL;\n}"
  },
  {
    "function_name": "arch_prepare_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "199-304",
    "snippet": "int arch_prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tstruct ppc_inst branch_op_callback, branch_emulate_step, temp;\n\tkprobe_opcode_t *op_callback_addr, *emulate_step_addr, *buff;\n\tlong b_offset;\n\tunsigned long nip, size;\n\tint rc, i;\n\n\tkprobe_ppc_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n\n\tnip = can_optimize(p);\n\tif (!nip)\n\t\treturn -EILSEQ;\n\n\t/* Allocate instruction slot for detour buffer */\n\tbuff = get_ppc_optinsn_slot();\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * OPTPROBE uses 'b' instruction to branch to optinsn.insn.\n\t *\n\t * The target address has to be relatively nearby, to permit use\n\t * of branch instruction in powerpc, because the address is specified\n\t * in an immediate field in the instruction opcode itself, ie 24 bits\n\t * in the opcode specify the address. Therefore the address should\n\t * be within 32MB on either side of the current instruction.\n\t */\n\tb_offset = (unsigned long)buff - (unsigned long)p->addr;\n\tif (!is_offset_in_branch_range(b_offset))\n\t\tgoto error;\n\n\t/* Check if the return address is also within 32MB range */\n\tb_offset = (unsigned long)(buff + TMPL_RET_IDX) -\n\t\t\t(unsigned long)nip;\n\tif (!is_offset_in_branch_range(b_offset))\n\t\tgoto error;\n\n\t/* Setup template */\n\t/* We can optimize this via patch_instruction_window later */\n\tsize = (TMPL_END_IDX * sizeof(kprobe_opcode_t)) / sizeof(int);\n\tpr_devel(\"Copying template to %p, size %lu\\n\", buff, size);\n\tfor (i = 0; i < size; i++) {\n\t\trc = patch_instruction((struct ppc_inst *)(buff + i),\n\t\t\t\t       ppc_inst(*(optprobe_template_entry + i)));\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Fixup the template with instructions to:\n\t * 1. load the address of the actual probepoint\n\t */\n\tpatch_imm64_load_insns((unsigned long)op, 3, buff + TMPL_OP_IDX);\n\n\t/*\n\t * 2. branch to optimized_callback() and emulate_step()\n\t */\n\top_callback_addr = (kprobe_opcode_t *)ppc_kallsyms_lookup_name(\"optimized_callback\");\n\temulate_step_addr = (kprobe_opcode_t *)ppc_kallsyms_lookup_name(\"emulate_step\");\n\tif (!op_callback_addr || !emulate_step_addr) {\n\t\tWARN(1, \"Unable to lookup optimized_callback()/emulate_step()\\n\");\n\t\tgoto error;\n\t}\n\n\trc = create_branch(&branch_op_callback,\n\t\t\t   (struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),\n\t\t\t   (unsigned long)op_callback_addr,\n\t\t\t   BRANCH_SET_LINK);\n\n\trc |= create_branch(&branch_emulate_step,\n\t\t\t    (struct ppc_inst *)(buff + TMPL_EMULATE_IDX),\n\t\t\t    (unsigned long)emulate_step_addr,\n\t\t\t    BRANCH_SET_LINK);\n\n\tif (rc)\n\t\tgoto error;\n\n\tpatch_instruction((struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),\n\t\t\t  branch_op_callback);\n\tpatch_instruction((struct ppc_inst *)(buff + TMPL_EMULATE_IDX),\n\t\t\t  branch_emulate_step);\n\n\t/*\n\t * 3. load instruction to be emulated into relevant register, and\n\t */\n\ttemp = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\tpatch_imm64_load_insns(ppc_inst_as_u64(temp), 4, buff + TMPL_INSN_IDX);\n\n\t/*\n\t * 4. branch back from trampoline\n\t */\n\tpatch_branch((struct ppc_inst *)(buff + TMPL_RET_IDX), (unsigned long)nip, 0);\n\n\tflush_icache_range((unsigned long)buff,\n\t\t\t   (unsigned long)(&buff[TMPL_END_IDX]));\n\n\top->optinsn.insn = buff;\n\n\treturn 0;\n\nerror:\n\tfree_ppc_optinsn_slot(buff, 0);\n\treturn -ERANGE;\n\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define TMPL_END_IDX\t\t\\\n\t(optprobe_template_end - optprobe_template_entry)",
      "#define TMPL_INSN_IDX\t\t\\\n\t(optprobe_template_insn - optprobe_template_entry)",
      "#define TMPL_OP_IDX\t\t\\\n\t(optprobe_template_op_address - optprobe_template_entry)",
      "#define TMPL_RET_IDX\t\t\\\n\t(optprobe_template_ret - optprobe_template_entry)",
      "#define TMPL_EMULATE_IDX\t\\\n\t(optprobe_template_call_emulate - optprobe_template_entry)",
      "#define TMPL_CALL_HDLR_IDX\t\\\n\t(optprobe_template_call_handler - optprobe_template_entry)"
    ],
    "globals_used": [
      "struct kprobe_insn_cache kprobe_ppc_optinsn_slots = {\n\t.mutex = __MUTEX_INITIALIZER(kprobe_ppc_optinsn_slots.mutex),\n\t.pages = LIST_HEAD_INIT(kprobe_ppc_optinsn_slots.pages),\n\t/* insn_size initialized later */\n\t.alloc = __ppc_alloc_insn_page,\n\t.free = __ppc_free_insn_page,\n\t.nr_garbage = 0,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ppc_optinsn_slot",
          "args": [
            "buff",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long)buff",
            "(unsigned long)(&buff[TMPL_END_IDX])"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "(struct ppc_inst *)(buff + TMPL_RET_IDX)",
            "(unsigned long)nip",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_imm64_load_insns",
          "args": [
            "ppc_inst_as_u64(temp)",
            "4",
            "buff + TMPL_INSN_IDX"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "patch_imm64_load_insns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
          "lines": "167-197",
          "snippet": "void patch_imm64_load_insns(unsigned long val, int reg, kprobe_opcode_t *addr)\n{\n\t/* lis reg,(op)@highest */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@higher */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff)));\n\taddr++;\n\n\t/* rldicr reg,reg,32,31 */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)));\n\taddr++;\n\n\t/* oris reg,reg,(op)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff)));\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/sstep.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid patch_imm64_load_insns(unsigned long val, int reg, kprobe_opcode_t *addr)\n{\n\t/* lis reg,(op)@highest */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@higher */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff)));\n\taddr++;\n\n\t/* rldicr reg,reg,32,31 */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)));\n\taddr++;\n\n\t/* oris reg,reg,(op)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_u64",
          "args": [
            "temp"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)p->ainsn.insn"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)(buff + TMPL_EMULATE_IDX)",
            "branch_emulate_step"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX)",
            "branch_op_callback"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&branch_emulate_step",
            "(struct ppc_inst *)(buff + TMPL_EMULATE_IDX)",
            "(unsigned long)emulate_step_addr",
            "BRANCH_SET_LINK"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&branch_op_callback",
            "(struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX)",
            "(unsigned long)op_callback_addr",
            "BRANCH_SET_LINK"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Unable to lookup optimized_callback()/emulate_step()\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_kallsyms_lookup_name",
          "args": [
            "\"emulate_step\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_kallsyms_lookup_name",
          "args": [
            "\"optimized_callback\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)(buff + i)",
            "ppc_inst(*(optprobe_template_entry + i))"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "*(optprobe_template_entry + i)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"Copying template to %p, size %lu\\n\"",
            "buff",
            "size"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_offset_in_branch_range",
          "args": [
            "b_offset"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_offset_in_branch_range",
          "args": [
            "b_offset"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ppc_optinsn_slot",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_optimize",
          "args": [
            "p"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "can_optimize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
          "lines": "64-111",
          "snippet": "static unsigned long can_optimize(struct kprobe *p)\n{\n\tstruct pt_regs regs;\n\tstruct instruction_op op;\n\tunsigned long nip = 0;\n\n\t/*\n\t * kprobe placed for kretprobe during boot time\n\t * has a 'nop' instruction, which can be emulated.\n\t * So further checks can be skipped.\n\t */\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn (unsigned long)p->addr + sizeof(kprobe_opcode_t);\n\n\t/*\n\t * We only support optimizing kernel addresses, but not\n\t * module addresses.\n\t *\n\t * FIXME: Optimize kprobes placed in module addresses.\n\t */\n\tif (!is_kernel_addr((unsigned long)p->addr))\n\t\treturn 0;\n\n\tmemset(&regs, 0, sizeof(struct pt_regs));\n\tregs.nip = (unsigned long)p->addr;\n\tregs.trap = 0x0;\n\tregs.msr = MSR_KERNEL;\n\n\t/*\n\t * Kprobe placed in conditional branch instructions are\n\t * not optimized, as we can't predict the nip prior with\n\t * dummy pt_regs and can not ensure that the return branch\n\t * from detour buffer falls in the range of address (i.e 32MB).\n\t * A branch back from trampoline is set up in the detour buffer\n\t * to the nip returned by the analyse_instr() here.\n\t *\n\t * Ensure that the instruction is not a conditional branch,\n\t * and that can be emulated.\n\t */\n\tif (!is_conditional_branch(ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) &&\n\t    analyse_instr(&op, &regs,\n\t\t\t  ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) == 1) {\n\t\temulate_update_regs(&regs, &op);\n\t\tnip = regs.nip;\n\t}\n\n\treturn nip;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/sstep.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nstatic unsigned long can_optimize(struct kprobe *p)\n{\n\tstruct pt_regs regs;\n\tstruct instruction_op op;\n\tunsigned long nip = 0;\n\n\t/*\n\t * kprobe placed for kretprobe during boot time\n\t * has a 'nop' instruction, which can be emulated.\n\t * So further checks can be skipped.\n\t */\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn (unsigned long)p->addr + sizeof(kprobe_opcode_t);\n\n\t/*\n\t * We only support optimizing kernel addresses, but not\n\t * module addresses.\n\t *\n\t * FIXME: Optimize kprobes placed in module addresses.\n\t */\n\tif (!is_kernel_addr((unsigned long)p->addr))\n\t\treturn 0;\n\n\tmemset(&regs, 0, sizeof(struct pt_regs));\n\tregs.nip = (unsigned long)p->addr;\n\tregs.trap = 0x0;\n\tregs.msr = MSR_KERNEL;\n\n\t/*\n\t * Kprobe placed in conditional branch instructions are\n\t * not optimized, as we can't predict the nip prior with\n\t * dummy pt_regs and can not ensure that the return branch\n\t * from detour buffer falls in the range of address (i.e 32MB).\n\t * A branch back from trampoline is set up in the detour buffer\n\t * to the nip returned by the analyse_instr() here.\n\t *\n\t * Ensure that the instruction is not a conditional branch,\n\t * and that can be emulated.\n\t */\n\tif (!is_conditional_branch(ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) &&\n\t    analyse_instr(&op, &regs,\n\t\t\t  ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) == 1) {\n\t\temulate_update_regs(&regs, &op);\n\t\tnip = regs.nip;\n\t}\n\n\treturn nip;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\n#define TMPL_END_IDX\t\t\\\n\t(optprobe_template_end - optprobe_template_entry)\n#define TMPL_INSN_IDX\t\t\\\n\t(optprobe_template_insn - optprobe_template_entry)\n#define TMPL_OP_IDX\t\t\\\n\t(optprobe_template_op_address - optprobe_template_entry)\n#define TMPL_RET_IDX\t\t\\\n\t(optprobe_template_ret - optprobe_template_entry)\n#define TMPL_EMULATE_IDX\t\\\n\t(optprobe_template_call_emulate - optprobe_template_entry)\n#define TMPL_CALL_HDLR_IDX\t\\\n\t(optprobe_template_call_handler - optprobe_template_entry)\n\nstruct kprobe_insn_cache kprobe_ppc_optinsn_slots = {\n\t.mutex = __MUTEX_INITIALIZER(kprobe_ppc_optinsn_slots.mutex),\n\t.pages = LIST_HEAD_INIT(kprobe_ppc_optinsn_slots.pages),\n\t/* insn_size initialized later */\n\t.alloc = __ppc_alloc_insn_page,\n\t.free = __ppc_free_insn_page,\n\t.nr_garbage = 0,\n};\n\nint arch_prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tstruct ppc_inst branch_op_callback, branch_emulate_step, temp;\n\tkprobe_opcode_t *op_callback_addr, *emulate_step_addr, *buff;\n\tlong b_offset;\n\tunsigned long nip, size;\n\tint rc, i;\n\n\tkprobe_ppc_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n\n\tnip = can_optimize(p);\n\tif (!nip)\n\t\treturn -EILSEQ;\n\n\t/* Allocate instruction slot for detour buffer */\n\tbuff = get_ppc_optinsn_slot();\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * OPTPROBE uses 'b' instruction to branch to optinsn.insn.\n\t *\n\t * The target address has to be relatively nearby, to permit use\n\t * of branch instruction in powerpc, because the address is specified\n\t * in an immediate field in the instruction opcode itself, ie 24 bits\n\t * in the opcode specify the address. Therefore the address should\n\t * be within 32MB on either side of the current instruction.\n\t */\n\tb_offset = (unsigned long)buff - (unsigned long)p->addr;\n\tif (!is_offset_in_branch_range(b_offset))\n\t\tgoto error;\n\n\t/* Check if the return address is also within 32MB range */\n\tb_offset = (unsigned long)(buff + TMPL_RET_IDX) -\n\t\t\t(unsigned long)nip;\n\tif (!is_offset_in_branch_range(b_offset))\n\t\tgoto error;\n\n\t/* Setup template */\n\t/* We can optimize this via patch_instruction_window later */\n\tsize = (TMPL_END_IDX * sizeof(kprobe_opcode_t)) / sizeof(int);\n\tpr_devel(\"Copying template to %p, size %lu\\n\", buff, size);\n\tfor (i = 0; i < size; i++) {\n\t\trc = patch_instruction((struct ppc_inst *)(buff + i),\n\t\t\t\t       ppc_inst(*(optprobe_template_entry + i)));\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\t}\n\n\t/*\n\t * Fixup the template with instructions to:\n\t * 1. load the address of the actual probepoint\n\t */\n\tpatch_imm64_load_insns((unsigned long)op, 3, buff + TMPL_OP_IDX);\n\n\t/*\n\t * 2. branch to optimized_callback() and emulate_step()\n\t */\n\top_callback_addr = (kprobe_opcode_t *)ppc_kallsyms_lookup_name(\"optimized_callback\");\n\temulate_step_addr = (kprobe_opcode_t *)ppc_kallsyms_lookup_name(\"emulate_step\");\n\tif (!op_callback_addr || !emulate_step_addr) {\n\t\tWARN(1, \"Unable to lookup optimized_callback()/emulate_step()\\n\");\n\t\tgoto error;\n\t}\n\n\trc = create_branch(&branch_op_callback,\n\t\t\t   (struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),\n\t\t\t   (unsigned long)op_callback_addr,\n\t\t\t   BRANCH_SET_LINK);\n\n\trc |= create_branch(&branch_emulate_step,\n\t\t\t    (struct ppc_inst *)(buff + TMPL_EMULATE_IDX),\n\t\t\t    (unsigned long)emulate_step_addr,\n\t\t\t    BRANCH_SET_LINK);\n\n\tif (rc)\n\t\tgoto error;\n\n\tpatch_instruction((struct ppc_inst *)(buff + TMPL_CALL_HDLR_IDX),\n\t\t\t  branch_op_callback);\n\tpatch_instruction((struct ppc_inst *)(buff + TMPL_EMULATE_IDX),\n\t\t\t  branch_emulate_step);\n\n\t/*\n\t * 3. load instruction to be emulated into relevant register, and\n\t */\n\ttemp = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\tpatch_imm64_load_insns(ppc_inst_as_u64(temp), 4, buff + TMPL_INSN_IDX);\n\n\t/*\n\t * 4. branch back from trampoline\n\t */\n\tpatch_branch((struct ppc_inst *)(buff + TMPL_RET_IDX), (unsigned long)nip, 0);\n\n\tflush_icache_range((unsigned long)buff,\n\t\t\t   (unsigned long)(&buff[TMPL_END_IDX]));\n\n\top->optinsn.insn = buff;\n\n\treturn 0;\n\nerror:\n\tfree_ppc_optinsn_slot(buff, 0);\n\treturn -ERANGE;\n\n}"
  },
  {
    "function_name": "patch_imm64_load_insns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "167-197",
    "snippet": "void patch_imm64_load_insns(unsigned long val, int reg, kprobe_opcode_t *addr)\n{\n\t/* lis reg,(op)@highest */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@higher */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff)));\n\taddr++;\n\n\t/* rldicr reg,reg,32,31 */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)));\n\taddr++;\n\n\t/* oris reg,reg,(op)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff)));\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff))"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RS",
          "args": [
            "reg"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RA",
          "args": [
            "reg"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff))"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RS",
          "args": [
            "reg"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RA",
          "args": [
            "reg"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31))"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_ME64",
          "args": [
            "31"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_SH64",
          "args": [
            "32"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RS",
          "args": [
            "reg"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RA",
          "args": [
            "reg"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff))"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RS",
          "args": [
            "reg"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RA",
          "args": [
            "reg"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff))"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RT",
          "args": [
            "reg"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid patch_imm64_load_insns(unsigned long val, int reg, kprobe_opcode_t *addr)\n{\n\t/* lis reg,(op)@highest */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(reg) |\n\t\t\t\t   ((val >> 48) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@higher */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 32) & 0xffff)));\n\taddr++;\n\n\t/* rldicr reg,reg,32,31 */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_RLDICR | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | __PPC_SH64(32) | __PPC_ME64(31)));\n\taddr++;\n\n\t/* oris reg,reg,(op)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORIS | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori reg,reg,(op)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(reg) |\n\t\t\t\t   ___PPC_RS(reg) | (val & 0xffff)));\n}"
  },
  {
    "function_name": "patch_imm32_load_insns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "149-161",
    "snippet": "void patch_imm32_load_insns(unsigned int val, kprobe_opcode_t *addr)\n{\n\t/* addis r4,0,(insn)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(4) |\n\t\t\t\t   ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori r4,r4,(insn)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(4) |\n\t\t\t\t   ___PPC_RS(4) | (val & 0xffff)));\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ORI | ___PPC_RA(4) |\n\t\t\t\t   ___PPC_RS(4) | (val & 0xffff))"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ORI | ___PPC_RA(4) |\n\t\t\t\t   ___PPC_RS(4) | (val & 0xffff)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RS",
          "args": [
            "4"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RA",
          "args": [
            "4"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)addr",
            "ppc_inst(PPC_INST_ADDIS | ___PPC_RT(4) |\n\t\t\t\t   ((val >> 16) & 0xffff))"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_ADDIS | ___PPC_RT(4) |\n\t\t\t\t   ((val >> 16) & 0xffff)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___PPC_RT",
          "args": [
            "4"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid patch_imm32_load_insns(unsigned int val, kprobe_opcode_t *addr)\n{\n\t/* addis r4,0,(insn)@h */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ADDIS | ___PPC_RT(4) |\n\t\t\t\t   ((val >> 16) & 0xffff)));\n\taddr++;\n\n\t/* ori r4,r4,(insn)@l */\n\tpatch_instruction((struct ppc_inst *)addr,\n\t\t\t  ppc_inst(PPC_INST_ORI | ___PPC_RA(4) |\n\t\t\t\t   ___PPC_RS(4) | (val & 0xffff)));\n}"
  },
  {
    "function_name": "arch_remove_optimized_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "136-142",
    "snippet": "void arch_remove_optimized_kprobe(struct optimized_kprobe *op)\n{\n\tif (op->optinsn.insn) {\n\t\tfree_ppc_optinsn_slot(op->optinsn.insn, 1);\n\t\top->optinsn.insn = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ppc_optinsn_slot",
          "args": [
            "op->optinsn.insn",
            "1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nvoid arch_remove_optimized_kprobe(struct optimized_kprobe *op)\n{\n\tif (op->optinsn.insn) {\n\t\tfree_ppc_optinsn_slot(op->optinsn.insn, 1);\n\t\top->optinsn.insn = NULL;\n\t}\n}"
  },
  {
    "function_name": "optimized_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "113-133",
    "snippet": "static void optimized_callback(struct optimized_kprobe *op,\n\t\t\t       struct pt_regs *regs)\n{\n\t/* This is possible if op is under delayed unoptimizing */\n\tif (kprobe_disabled(&op->kp))\n\t\treturn;\n\n\tpreempt_disable();\n\n\tif (kprobe_running()) {\n\t\tkprobes_inc_nmissed_count(&op->kp);\n\t} else {\n\t\t__this_cpu_write(current_kprobe, &op->kp);\n\t\tregs->nip = (unsigned long)op->kp.addr;\n\t\tget_kprobe_ctlblk()->kprobe_status = KPROBE_HIT_ACTIVE;\n\t\topt_pre_handler(&op->kp, regs);\n\t\t__this_cpu_write(current_kprobe, NULL);\n\t}\n\n\tpreempt_enable_no_resched();\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opt_pre_handler",
          "args": [
            "&op->kp",
            "regs"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "&op->kp"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobes_inc_nmissed_count",
          "args": [
            "&op->kp"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "&op->kp"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nstatic void optimized_callback(struct optimized_kprobe *op,\n\t\t\t       struct pt_regs *regs)\n{\n\t/* This is possible if op is under delayed unoptimizing */\n\tif (kprobe_disabled(&op->kp))\n\t\treturn;\n\n\tpreempt_disable();\n\n\tif (kprobe_running()) {\n\t\tkprobes_inc_nmissed_count(&op->kp);\n\t} else {\n\t\t__this_cpu_write(current_kprobe, &op->kp);\n\t\tregs->nip = (unsigned long)op->kp.addr;\n\t\tget_kprobe_ctlblk()->kprobe_status = KPROBE_HIT_ACTIVE;\n\t\topt_pre_handler(&op->kp, regs);\n\t\t__this_cpu_write(current_kprobe, NULL);\n\t}\n\n\tpreempt_enable_no_resched();\n}"
  },
  {
    "function_name": "can_optimize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "64-111",
    "snippet": "static unsigned long can_optimize(struct kprobe *p)\n{\n\tstruct pt_regs regs;\n\tstruct instruction_op op;\n\tunsigned long nip = 0;\n\n\t/*\n\t * kprobe placed for kretprobe during boot time\n\t * has a 'nop' instruction, which can be emulated.\n\t * So further checks can be skipped.\n\t */\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn (unsigned long)p->addr + sizeof(kprobe_opcode_t);\n\n\t/*\n\t * We only support optimizing kernel addresses, but not\n\t * module addresses.\n\t *\n\t * FIXME: Optimize kprobes placed in module addresses.\n\t */\n\tif (!is_kernel_addr((unsigned long)p->addr))\n\t\treturn 0;\n\n\tmemset(&regs, 0, sizeof(struct pt_regs));\n\tregs.nip = (unsigned long)p->addr;\n\tregs.trap = 0x0;\n\tregs.msr = MSR_KERNEL;\n\n\t/*\n\t * Kprobe placed in conditional branch instructions are\n\t * not optimized, as we can't predict the nip prior with\n\t * dummy pt_regs and can not ensure that the return branch\n\t * from detour buffer falls in the range of address (i.e 32MB).\n\t * A branch back from trampoline is set up in the detour buffer\n\t * to the nip returned by the analyse_instr() here.\n\t *\n\t * Ensure that the instruction is not a conditional branch,\n\t * and that can be emulated.\n\t */\n\tif (!is_conditional_branch(ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) &&\n\t    analyse_instr(&op, &regs,\n\t\t\t  ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) == 1) {\n\t\temulate_update_regs(&regs, &op);\n\t\tnip = regs.nip;\n\t}\n\n\treturn nip;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulate_update_regs",
          "args": [
            "&regs",
            "&op"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "analyse_instr",
          "args": [
            "&op",
            "&regs",
            "ppc_inst_read((struct ppc_inst *)p->ainsn.insn)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)p->ainsn.insn"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_conditional_branch",
          "args": [
            "ppc_inst_read((struct ppc_inst *)p->ainsn.insn)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)p->ainsn.insn"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&regs",
            "0",
            "sizeof(struct pt_regs)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nstatic unsigned long can_optimize(struct kprobe *p)\n{\n\tstruct pt_regs regs;\n\tstruct instruction_op op;\n\tunsigned long nip = 0;\n\n\t/*\n\t * kprobe placed for kretprobe during boot time\n\t * has a 'nop' instruction, which can be emulated.\n\t * So further checks can be skipped.\n\t */\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn (unsigned long)p->addr + sizeof(kprobe_opcode_t);\n\n\t/*\n\t * We only support optimizing kernel addresses, but not\n\t * module addresses.\n\t *\n\t * FIXME: Optimize kprobes placed in module addresses.\n\t */\n\tif (!is_kernel_addr((unsigned long)p->addr))\n\t\treturn 0;\n\n\tmemset(&regs, 0, sizeof(struct pt_regs));\n\tregs.nip = (unsigned long)p->addr;\n\tregs.trap = 0x0;\n\tregs.msr = MSR_KERNEL;\n\n\t/*\n\t * Kprobe placed in conditional branch instructions are\n\t * not optimized, as we can't predict the nip prior with\n\t * dummy pt_regs and can not ensure that the return branch\n\t * from detour buffer falls in the range of address (i.e 32MB).\n\t * A branch back from trampoline is set up in the detour buffer\n\t * to the nip returned by the analyse_instr() here.\n\t *\n\t * Ensure that the instruction is not a conditional branch,\n\t * and that can be emulated.\n\t */\n\tif (!is_conditional_branch(ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) &&\n\t    analyse_instr(&op, &regs,\n\t\t\t  ppc_inst_read((struct ppc_inst *)p->ainsn.insn)) == 1) {\n\t\temulate_update_regs(&regs, &op);\n\t\tnip = regs.nip;\n\t}\n\n\treturn nip;\n}"
  },
  {
    "function_name": "__ppc_free_insn_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "46-49",
    "snippet": "static void __ppc_free_insn_page(void *page __maybe_unused)\n{\n\tinsn_page_in_use = false;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool insn_page_in_use;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nstatic bool insn_page_in_use;\n\nstatic void __ppc_free_insn_page(void *page __maybe_unused)\n{\n\tinsn_page_in_use = false;\n}"
  },
  {
    "function_name": "__ppc_alloc_insn_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/optprobes.c",
    "lines": "38-44",
    "snippet": "static void *__ppc_alloc_insn_page(void)\n{\n\tif (insn_page_in_use)\n\t\treturn NULL;\n\tinsn_page_in_use = true;\n\treturn &optinsn_slot;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/sstep.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool insn_page_in_use;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/ppc-opcode.h>\n#include <asm/sstep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/ptrace.h>\n#include <asm/kprobes.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/jump_label.h>\n#include <linux/kprobes.h>\n\nstatic bool insn_page_in_use;\n\nstatic void *__ppc_alloc_insn_page(void)\n{\n\tif (insn_page_in_use)\n\t\treturn NULL;\n\tinsn_page_in_use = true;\n\treturn &optinsn_slot;\n}"
  }
]