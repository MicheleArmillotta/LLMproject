[
  {
    "function_name": "eeh_remove_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "167-201",
    "snippet": "void eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
      "static LIST_HEAD(eeh_eventlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "event",
            "tmp",
            "&eeh_eventlist",
            "list"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic LIST_HEAD(eeh_eventlist);\n\nvoid eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}"
  },
  {
    "function_name": "eeh_send_failure_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "143-155",
    "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__eeh_send_failure_event",
          "args": [
            "pe"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_send_failure_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "102-141",
          "snippet": "int __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
            "static DECLARE_COMPLETION(eeh_eventlist_event);",
            "static LIST_HEAD(eeh_eventlist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic DECLARE_COMPLETION(eeh_eventlist_event);\nstatic LIST_HEAD(eeh_eventlist);\n\nint __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Event dropped due to no_recover setting\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\t/*\n\t * If we've manually supressed recovery events via debugfs\n\t * then just drop it on the floor.\n\t */\n\tif (eeh_debugfs_no_recover) {\n\t\tpr_err(\"EEH: Event dropped due to no_recover setting\\n\");\n\t\treturn 0;\n\t}\n\n\treturn __eeh_send_failure_event(pe);\n}"
  },
  {
    "function_name": "__eeh_send_failure_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "102-141",
    "snippet": "int __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
      "static DECLARE_COMPLETION(eeh_eventlist_event);",
      "static LIST_HEAD(eeh_eventlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&eeh_eventlist_event"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->list",
            "&eeh_eventlist"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "pe->stack_trace",
            "ARRAY_SIZE(pe->stack_trace)",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pe->stack_trace"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: out of memory, event not handled\\n\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*event)",
            "GFP_ATOMIC"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic DECLARE_COMPLETION(eeh_eventlist_event);\nstatic LIST_HEAD(eeh_eventlist);\n\nint __eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/*\n\t * Mark the PE as recovering before inserting it in the queue.\n\t * This prevents the PE from being free()ed by a hotplug driver\n\t * while the PE is sitting in the event queue.\n\t */\n\tif (pe) {\n#ifdef CONFIG_STACKTRACE\n\t\t/*\n\t\t * Save the current stack trace so we can dump it from the\n\t\t * event handler thread.\n\t\t */\n\t\tpe->trace_entries = stack_trace_save(pe->stack_trace,\n\t\t\t\t\t ARRAY_SIZE(pe->stack_trace), 0);\n#endif /* CONFIG_STACKTRACE */\n\n\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t}\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tcomplete(&eeh_eventlist_event);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "78-92",
    "snippet": "int eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed to start EEH daemon (%d)\\n\"",
            "__func__",
            "ret"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "eeh_event_handler",
            "NULL",
            "\"eehd\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nint eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_event_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "39-70",
    "snippet": "static int eeh_event_handler(void * dummy)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (wait_for_completion_interruptible(&eeh_eventlist_event))\n\t\t\tbreak;\n\n\t\t/* Fetch EEH event from the queue */\n\t\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\t\tevent = NULL;\n\t\tif (!list_empty(&eeh_eventlist)) {\n\t\t\tevent = list_entry(eeh_eventlist.next,\n\t\t\t\t\t   struct eeh_event, list);\n\t\t\tlist_del(&event->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\t/* We might have event without binding PE */\n\t\tif (event->pe)\n\t\t\teeh_handle_normal_event(event->pe);\n\t\telse\n\t\t\teeh_handle_special_event();\n\n\t\tkfree(event);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
      "static DECLARE_COMPLETION(eeh_eventlist_event);",
      "static LIST_HEAD(eeh_eventlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_handle_special_event",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_special_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "1120-1225",
          "snippet": "void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe, *tmp_pe;\n\tstruct eeh_dev *edev, *tmp_edev;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_mark_isolated(phb_pe);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc != EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_pe_mark_isolated(pe);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_handle_normal_event(pe);\n\t\t} else {\n\t\t\teeh_for_each_pe(pe, tmp_pe)\n\t\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp_edev)\n\t\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t\t\t/* Notify all devices to be down */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\t\teeh_pe_report(\n\t\t\t\t\"error_detected(permanent failure)\", pe,\n\t\t\t\teeh_report_failure, NULL);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\tif (!bus) {\n\t\t\t\t\tpr_err(\"%s: Cannot find PCI bus for \"\n\t\t\t\t\t       \"PHB#%x-PE#%x\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       pe->phb->global_number,\n\t\t\t\t\t       pe->addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpci_hp_remove_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nvoid eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe, *tmp_pe;\n\tstruct eeh_dev *edev, *tmp_edev;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_mark_isolated(phb_pe);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc != EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_pe_mark_isolated(pe);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_handle_normal_event(pe);\n\t\t} else {\n\t\t\teeh_for_each_pe(pe, tmp_pe)\n\t\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp_edev)\n\t\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t\t\t/* Notify all devices to be down */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\t\teeh_pe_report(\n\t\t\t\t\"error_detected(permanent failure)\", pe,\n\t\t\t\teeh_report_failure, NULL);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\tif (!bus) {\n\t\t\t\t\tpr_err(\"%s: Cannot find PCI bus for \"\n\t\t\t\t\t       \"PHB#%x-PE#%x\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       pe->phb->global_number,\n\t\t\t\t\t       pe->addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpci_hp_remove_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_handle_normal_event",
          "args": [
            "event->pe"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_normal_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "836-1111",
          "snippet": "void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define MAX_WAIT_FOR_RECOVERY 300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nvoid eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "eeh_eventlist.next",
            "structeeh_event",
            "list"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&eeh_eventlist"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&eeh_eventlist_event"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic DECLARE_COMPLETION(eeh_eventlist_event);\nstatic LIST_HEAD(eeh_eventlist);\n\nstatic int eeh_event_handler(void * dummy)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (wait_for_completion_interruptible(&eeh_eventlist_event))\n\t\t\tbreak;\n\n\t\t/* Fetch EEH event from the queue */\n\t\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\t\tevent = NULL;\n\t\tif (!list_empty(&eeh_eventlist)) {\n\t\t\tevent = list_entry(eeh_eventlist.next,\n\t\t\t\t\t   struct eeh_event, list);\n\t\t\tlist_del(&event->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\t/* We might have event without binding PE */\n\t\tif (event->pe)\n\t\t\teeh_handle_normal_event(event->pe);\n\t\telse\n\t\t\teeh_handle_special_event();\n\n\t\tkfree(event);\n\t}\n\n\treturn 0;\n}"
  }
]