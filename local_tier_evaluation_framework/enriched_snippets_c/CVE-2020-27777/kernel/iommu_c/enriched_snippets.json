[
  {
    "function_name": "iommu_del_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1125-1139",
    "snippet": "void iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!device_iommu_mapped(dev)) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_group_remove_device",
          "args": [
            "dev"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"iommu_tce: skipping device %s with no tbl\\n\"",
            "dev_name(dev)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_iommu_mapped",
          "args": [
            "dev"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_del_device(struct device *dev)\n{\n\t/*\n\t * Some devices might not have IOMMU table and group\n\t * and we needn't detach them from the associated\n\t * IOMMU groups\n\t */\n\tif (!device_iommu_mapped(dev)) {\n\t\tpr_debug(\"iommu_tce: skipping device %s with no tbl\\n\",\n\t\t\t dev_name(dev));\n\t\treturn;\n\t}\n\n\tiommu_group_remove_device(dev);\n}"
  },
  {
    "function_name": "iommu_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1101-1122",
    "snippet": "int iommu_add_device(struct iommu_table_group *table_group, struct device *dev)\n{\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (device_iommu_mapped(dev)) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),  iommu_group_id(table_group->group));\n\n\treturn iommu_group_add_device(table_group->group, dev);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_group_add_device",
          "args": [
            "table_group->group",
            "dev"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Adding %s to iommu group %d\\n\"",
            "__func__",
            "dev_name(dev)",
            "iommu_group_id(table_group->group)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_id",
          "args": [
            "table_group->group"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Skipping device %s with iommu group %d\\n\"",
            "__func__",
            "dev_name(dev)",
            "iommu_group_id(dev->iommu_group)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_id",
          "args": [
            "dev->iommu_group"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_iommu_mapped",
          "args": [
            "dev"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_is_registered",
          "args": [
            "dev"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_add_device(struct iommu_table_group *table_group, struct device *dev)\n{\n\t/*\n\t * The sysfs entries should be populated before\n\t * binding IOMMU group. If sysfs entries isn't\n\t * ready, we simply bail.\n\t */\n\tif (!device_is_registered(dev))\n\t\treturn -ENOENT;\n\n\tif (device_iommu_mapped(dev)) {\n\t\tpr_debug(\"%s: Skipping device %s with iommu group %d\\n\",\n\t\t\t __func__, dev_name(dev),\n\t\t\t iommu_group_id(dev->iommu_group));\n\t\treturn -EBUSY;\n\t}\n\n\tpr_debug(\"%s: Adding %s to iommu group %d\\n\",\n\t\t __func__, dev_name(dev),  iommu_group_id(table_group->group));\n\n\treturn iommu_group_add_device(table_group->group, dev);\n}"
  },
  {
    "function_name": "iommu_release_ownership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1082-1098",
    "snippet": "void iommu_release_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tmemset(tbl->it_map, 0, sz);\n\n\tiommu_table_reserve_pages(tbl, tbl->it_reserved_start,\n\t\t\ttbl->it_reserved_end);\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_table_reserve_pages",
          "args": [
            "tbl",
            "tbl->it_reserved_start",
            "tbl->it_reserved_end"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_reserve_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "636-661",
          "snippet": "static void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0",
            "sz"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_release_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tmemset(tbl->it_map, 0, sz);\n\n\tiommu_table_reserve_pages(tbl, tbl->it_reserved_start,\n\t\t\ttbl->it_reserved_end);\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n}"
  },
  {
    "function_name": "iommu_take_ownership",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1043-1079",
    "snippet": "int iommu_take_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\tint ret = 0;\n\n\t/*\n\t * VFIO does not control TCE entries allocation and the guest\n\t * can write new TCEs on top of existing ones so iommu_tce_build()\n\t * must be able to release old pages. This functionality\n\t * requires exchange() callback defined so if it is not\n\t * implemented, we disallow taking ownership over the table.\n\t */\n\tif (!tbl->it_ops->xchg_no_kill)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tiommu_table_release_pages(tbl);\n\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size)) {\n\t\tpr_err(\"iommu_tce: it_map is not empty\");\n\t\tret = -EBUSY;\n\t\t/* Undo iommu_table_release_pages, i.e. restore bit#0, etc */\n\t\tiommu_table_reserve_pages(tbl, tbl->it_reserved_start,\n\t\t\t\ttbl->it_reserved_end);\n\t} else {\n\t\tmemset(tbl->it_map, 0xff, sz);\n\t}\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0xff",
            "sz"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_table_reserve_pages",
          "args": [
            "tbl",
            "tbl->it_reserved_start",
            "tbl->it_reserved_end"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_reserve_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "636-661",
          "snippet": "static void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"iommu_tce: it_map is not empty\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "tbl->it_map",
            "tbl->it_size"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_table_release_pages",
          "args": [
            "tbl"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "663-676",
          "snippet": "static void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->pools[i].lock"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tbl->large_pool.lock",
            "flags"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_take_ownership(struct iommu_table *tbl)\n{\n\tunsigned long flags, i, sz = (tbl->it_size + 7) >> 3;\n\tint ret = 0;\n\n\t/*\n\t * VFIO does not control TCE entries allocation and the guest\n\t * can write new TCEs on top of existing ones so iommu_tce_build()\n\t * must be able to release old pages. This functionality\n\t * requires exchange() callback defined so if it is not\n\t * implemented, we disallow taking ownership over the table.\n\t */\n\tif (!tbl->it_ops->xchg_no_kill)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&tbl->large_pool.lock, flags);\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_lock(&tbl->pools[i].lock);\n\n\tiommu_table_release_pages(tbl);\n\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size)) {\n\t\tpr_err(\"iommu_tce: it_map is not empty\");\n\t\tret = -EBUSY;\n\t\t/* Undo iommu_table_release_pages, i.e. restore bit#0, etc */\n\t\tiommu_table_reserve_pages(tbl, tbl->it_reserved_start,\n\t\t\t\ttbl->it_reserved_end);\n\t} else {\n\t\tmemset(tbl->it_map, 0xff, sz);\n\t}\n\n\tfor (i = 0; i < tbl->nr_pools; i++)\n\t\tspin_unlock(&tbl->pools[i].lock);\n\tspin_unlock_irqrestore(&tbl->large_pool.lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_tce_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1035-1040",
    "snippet": "void iommu_tce_kill(struct iommu_table *tbl,\n\t\tunsigned long entry, unsigned long pages)\n{\n\tif (tbl->it_ops->tce_kill)\n\t\ttbl->it_ops->tce_kill(tbl, entry, pages, false);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tbl->it_ops->tce_kill",
          "args": [
            "tbl",
            "entry",
            "pages",
            "false"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_tce_kill(struct iommu_table *tbl,\n\t\tunsigned long entry, unsigned long pages)\n{\n\tif (tbl->it_ops->tce_kill)\n\t\ttbl->it_ops->tce_kill(tbl, entry, pages, false);\n}"
  },
  {
    "function_name": "iommu_tce_xchg_no_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1016-1032",
    "snippet": "extern long iommu_tce_xchg_no_kill(struct mm_struct *mm,\n\t\tstruct iommu_table *tbl,\n\t\tunsigned long entry, unsigned long *hpa,\n\t\tenum dma_data_direction *direction)\n{\n\tlong ret;\n\tunsigned long size = 0;\n\n\tret = tbl->it_ops->xchg_no_kill(tbl, entry, hpa, direction, false);\n\tif (!ret && ((*direction == DMA_FROM_DEVICE) ||\n\t\t\t(*direction == DMA_BIDIRECTIONAL)) &&\n\t\t\t!mm_iommu_is_devmem(mm, *hpa, tbl->it_page_shift,\n\t\t\t\t\t&size))\n\t\tSetPageDirty(pfn_to_page(*hpa >> PAGE_SHIFT));\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "pfn_to_page(*hpa >> PAGE_SHIFT)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "*hpa >> PAGE_SHIFT"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_iommu_is_devmem",
          "args": [
            "mm",
            "*hpa",
            "tbl->it_page_shift",
            "&size"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->xchg_no_kill",
          "args": [
            "tbl",
            "entry",
            "hpa",
            "direction",
            "false"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nextern long iommu_tce_xchg_no_kill(struct mm_struct *mm,\n\t\tstruct iommu_table *tbl,\n\t\tunsigned long entry, unsigned long *hpa,\n\t\tenum dma_data_direction *direction)\n{\n\tlong ret;\n\tunsigned long size = 0;\n\n\tret = tbl->it_ops->xchg_no_kill(tbl, entry, hpa, direction, false);\n\tif (!ret && ((*direction == DMA_FROM_DEVICE) ||\n\t\t\t(*direction == DMA_BIDIRECTIONAL)) &&\n\t\t\t!mm_iommu_is_devmem(mm, *hpa, tbl->it_page_shift,\n\t\t\t\t\t&size))\n\t\tSetPageDirty(pfn_to_page(*hpa >> PAGE_SHIFT));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_tce_check_gpa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "1005-1013",
    "snippet": "int iommu_tce_check_gpa(unsigned long page_shift, unsigned long gpa)\n{\n\tunsigned long mask = (1UL << page_shift) - 1;\n\n\tif (gpa & mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_tce_check_gpa(unsigned long page_shift, unsigned long gpa)\n{\n\tunsigned long mask = (1UL << page_shift) - 1;\n\n\tif (gpa & mask)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_tce_check_ioba",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "985-1002",
    "snippet": "int iommu_tce_check_ioba(unsigned long page_shift,\n\t\tunsigned long offset, unsigned long size,\n\t\tunsigned long ioba, unsigned long npages)\n{\n\tunsigned long mask = (1UL << page_shift) - 1;\n\n\tif (ioba & mask)\n\t\treturn -EINVAL;\n\n\tioba >>= page_shift;\n\tif (ioba < offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + 1) > (offset + size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_tce_check_ioba(unsigned long page_shift,\n\t\tunsigned long offset, unsigned long size,\n\t\tunsigned long ioba, unsigned long npages)\n{\n\tunsigned long mask = (1UL << page_shift) - 1;\n\n\tif (ioba & mask)\n\t\treturn -EINVAL;\n\n\tioba >>= page_shift;\n\tif (ioba < offset)\n\t\treturn -EINVAL;\n\n\tif ((ioba + 1) > (offset + size))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_flush_tce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "974-982",
    "snippet": "void iommu_flush_tce(struct iommu_table *tbl)\n{\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_flush_tce(struct iommu_table *tbl)\n{\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n}"
  },
  {
    "function_name": "iommu_tce_direction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "961-971",
    "snippet": "enum dma_data_direction iommu_tce_direction(unsigned long tce)\n{\n\tif ((tce & TCE_PCI_READ) && (tce & TCE_PCI_WRITE))\n\t\treturn DMA_BIDIRECTIONAL;\n\telse if (tce & TCE_PCI_READ)\n\t\treturn DMA_TO_DEVICE;\n\telse if (tce & TCE_PCI_WRITE)\n\t\treturn DMA_FROM_DEVICE;\n\telse\n\t\treturn DMA_NONE;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nenum dma_data_direction iommu_tce_direction(unsigned long tce)\n{\n\tif ((tce & TCE_PCI_READ) && (tce & TCE_PCI_WRITE))\n\t\treturn DMA_BIDIRECTIONAL;\n\telse if (tce & TCE_PCI_READ)\n\t\treturn DMA_TO_DEVICE;\n\telse if (tce & TCE_PCI_WRITE)\n\t\treturn DMA_FROM_DEVICE;\n\telse\n\t\treturn DMA_NONE;\n}"
  },
  {
    "function_name": "iommu_register_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "939-959",
    "snippet": "void iommu_register_group(struct iommu_table_group *table_group,\n\t\tint pci_domain_number, unsigned long pe_num)\n{\n\tstruct iommu_group *grp;\n\tchar *name;\n\n\tgrp = iommu_group_alloc();\n\tif (IS_ERR(grp)) {\n\t\tpr_warn(\"powerpc iommu api: cannot create new group, err=%ld\\n\",\n\t\t\t\tPTR_ERR(grp));\n\t\treturn;\n\t}\n\ttable_group->group = grp;\n\tiommu_group_set_iommudata(grp, table_group, group_release);\n\tname = kasprintf(GFP_KERNEL, \"domain%d-pe%lx\",\n\t\t\tpci_domain_number, pe_num);\n\tif (!name)\n\t\treturn;\n\tiommu_group_set_name(grp, name);\n\tkfree(name);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_set_name",
          "args": [
            "grp",
            "name"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"domain%d-pe%lx\"",
            "pci_domain_number",
            "pe_num"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_set_iommudata",
          "args": [
            "grp",
            "table_group",
            "group_release"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"powerpc iommu api: cannot create new group, err=%ld\\n\"",
            "PTR_ERR(grp)"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "grp"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "grp"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_group_alloc",
          "args": [],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid iommu_register_group(struct iommu_table_group *table_group,\n\t\tint pci_domain_number, unsigned long pe_num)\n{\n\tstruct iommu_group *grp;\n\tchar *name;\n\n\tgrp = iommu_group_alloc();\n\tif (IS_ERR(grp)) {\n\t\tpr_warn(\"powerpc iommu api: cannot create new group, err=%ld\\n\",\n\t\t\t\tPTR_ERR(grp));\n\t\treturn;\n\t}\n\ttable_group->group = grp;\n\tiommu_group_set_iommudata(grp, table_group, group_release);\n\tname = kasprintf(GFP_KERNEL, \"domain%d-pe%lx\",\n\t\t\tpci_domain_number, pe_num);\n\tif (!name)\n\t\treturn;\n\tiommu_group_set_name(grp, name);\n\tkfree(name);\n}"
  },
  {
    "function_name": "group_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "932-937",
    "snippet": "static void group_release(void *iommu_data)\n{\n\tstruct iommu_table_group *table_group = iommu_data;\n\n\ttable_group->group = NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void group_release(void *iommu_data)\n{\n\tstruct iommu_table_group *table_group = iommu_data;\n\n\ttable_group->group = NULL;\n}"
  },
  {
    "function_name": "iommu_direction_to_tce_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "913-925",
    "snippet": "unsigned long iommu_direction_to_tce_perm(enum dma_data_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn TCE_PCI_READ | TCE_PCI_WRITE;\n\tcase DMA_FROM_DEVICE:\n\t\treturn TCE_PCI_WRITE;\n\tcase DMA_TO_DEVICE:\n\t\treturn TCE_PCI_READ;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nunsigned long iommu_direction_to_tce_perm(enum dma_data_direction dir)\n{\n\tswitch (dir) {\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn TCE_PCI_READ | TCE_PCI_WRITE;\n\tcase DMA_FROM_DEVICE:\n\t\treturn TCE_PCI_WRITE;\n\tcase DMA_TO_DEVICE:\n\t\treturn TCE_PCI_READ;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "iommu_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "899-911",
    "snippet": "void iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vaddr",
            "get_order(size)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "nio_pages"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "405-416",
          "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}"
  },
  {
    "function_name": "iommu_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "852-897",
    "snippet": "void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, 0);\n\tif (mapping == DMA_MAPPING_ERROR) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)ret",
            "order"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_alloc",
          "args": [
            "dev",
            "tbl",
            "ret",
            "nio_pages",
            "DMA_BIDIRECTIONAL",
            "mask >> tbl->it_page_shift",
            "io_order",
            "0"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "293-334",
          "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_order",
          "args": [
            "size",
            "tbl"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ret",
            "0",
            "size"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "flag",
            "order"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc_consistent size too large: 0x%lx\\n\"",
            "size"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, 0);\n\tif (mapping == DMA_MAPPING_ERROR) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "833-846",
    "snippet": "void iommu_unmap_page(struct iommu_table *tbl, dma_addr_t dma_handle,\n\t\t      size_t size, enum dma_data_direction direction,\n\t\t      unsigned long attrs)\n{\n\tunsigned int npages;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(dma_handle, size,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\tiommu_free(tbl, dma_handle, npages);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "npages"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "405-416",
          "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "dma_handle",
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_unmap_page(struct iommu_table *tbl, dma_addr_t dma_handle,\n\t\t      size_t size, enum dma_data_direction direction,\n\t\t      unsigned long attrs)\n{\n\tunsigned int npages;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(dma_handle, size,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\tiommu_free(tbl, dma_handle, npages);\n\t}\n}"
  },
  {
    "function_name": "iommu_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "794-831",
    "snippet": "dma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  unsigned long attrs)\n{\n\tdma_addr_t dma_handle = DMA_MAPPING_ERROR;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_MAPPING_ERROR) {\n\t\t\tif (!(attrs & DMA_ATTR_NO_WARN) &&\n\t\t\t    printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\"",
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_alloc",
          "args": [
            "dev",
            "tbl",
            "vaddr",
            "npages",
            "direction",
            "mask >> tbl->it_page_shift",
            "align",
            "attrs"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "293-334",
          "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "uaddr",
            "size",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\ndma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  unsigned long attrs)\n{\n\tdma_addr_t dma_handle = DMA_MAPPING_ERROR;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\n\tif (tbl) {\n\t\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_MAPPING_ERROR) {\n\t\t\tif (!(attrs & DMA_ATTR_NO_WARN) &&\n\t\t\t    printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}"
  },
  {
    "function_name": "iommu_tce_table_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "780-786",
    "snippet": "int iommu_tce_table_put(struct iommu_table *tbl)\n{\n\tif (WARN_ON(!tbl))\n\t\treturn 0;\n\n\treturn kref_put(&tbl->it_kref, iommu_table_free);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&tbl->it_kref",
            "iommu_table_free"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tbl"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint iommu_tce_table_put(struct iommu_table *tbl)\n{\n\tif (WARN_ON(!tbl))\n\t\treturn 0;\n\n\treturn kref_put(&tbl->it_kref, iommu_table_free);\n}"
  },
  {
    "function_name": "iommu_tce_table_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "771-777",
    "snippet": "struct iommu_table *iommu_tce_table_get(struct iommu_table *tbl)\n{\n\tif (kref_get_unless_zero(&tbl->it_kref))\n\t\treturn tbl;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get_unless_zero",
          "args": [
            "&tbl->it_kref"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstruct iommu_table *iommu_tce_table_get(struct iommu_table *tbl)\n{\n\tif (kref_get_unless_zero(&tbl->it_kref))\n\t\treturn tbl;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "iommu_table_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "738-769",
    "snippet": "static void iommu_table_free(struct kref *kref)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\tstruct iommu_table *tbl;\n\n\ttbl = container_of(kref, struct iommu_table, it_kref);\n\n\tif (tbl->it_ops->free)\n\t\ttbl->it_ops->free(tbl);\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\tiommu_table_release_pages(tbl);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs\\n\", __func__);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long) tbl->it_map",
            "order"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "bitmap_sz"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "tbl->it_size"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unexpected TCEs\\n\"",
            "__func__"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "tbl->it_map",
            "tbl->it_size"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_table_release_pages",
          "args": [
            "tbl"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "663-676",
          "snippet": "static void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbl"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->free",
          "args": [
            "tbl"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structiommu_table",
            "it_kref"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_free(struct kref *kref)\n{\n\tunsigned long bitmap_sz;\n\tunsigned int order;\n\tstruct iommu_table *tbl;\n\n\ttbl = container_of(kref, struct iommu_table, it_kref);\n\n\tif (tbl->it_ops->free)\n\t\ttbl->it_ops->free(tbl);\n\n\tif (!tbl->it_map) {\n\t\tkfree(tbl);\n\t\treturn;\n\t}\n\n\tiommu_table_release_pages(tbl);\n\n\t/* verify that table contains no entries */\n\tif (!bitmap_empty(tbl->it_map, tbl->it_size))\n\t\tpr_warn(\"%s: Unexpected TCEs\\n\", __func__);\n\n\t/* calculate bitmap size in bytes */\n\tbitmap_sz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\t/* free bitmap */\n\torder = get_order(bitmap_sz);\n\tfree_pages((unsigned long) tbl->it_map, order);\n\n\t/* free table */\n\tkfree(tbl);\n}"
  },
  {
    "function_name": "iommu_init_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "682-736",
    "snippet": "struct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\tiommu_table_reserve_pages(tbl, res_start, res_end);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\"",
            "novmerge ? \"disabled\" : \"enabled\""
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_table_clear",
          "args": [
            "tbl"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "595-634",
          "snippet": "static void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&(p->lock)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&(p->lock)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_table_reserve_pages",
          "args": [
            "tbl",
            "res_start",
            "res_end"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_table_reserve_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "636-661",
          "snippet": "static void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tbl->it_map",
            "0",
            "sz"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"iommu_init_table: Can't allocate %ld bytes\\n\"",
            "sz"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_smp_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "147-199",
          "snippet": "static void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static cpumask_t wd_smp_cpus_pending;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "nid",
            "GFP_KERNEL",
            "get_order(sz)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "sz"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "tbl->it_size"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tbl->it_ops"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\n\nstruct iommu_table *iommu_init_table(struct iommu_table *tbl, int nid,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tunsigned long sz;\n\tstatic int welcomed = 0;\n\tstruct page *page;\n\tunsigned int i;\n\tstruct iommu_pool *p;\n\n\tBUG_ON(!tbl->it_ops);\n\n\t/* number of bytes needed for the bitmap */\n\tsz = BITS_TO_LONGS(tbl->it_size) * sizeof(unsigned long);\n\n\tpage = alloc_pages_node(nid, GFP_KERNEL, get_order(sz));\n\tif (!page)\n\t\tpanic(\"iommu_init_table: Can't allocate %ld bytes\\n\", sz);\n\ttbl->it_map = page_address(page);\n\tmemset(tbl->it_map, 0, sz);\n\n\tiommu_table_reserve_pages(tbl, res_start, res_end);\n\n\t/* We only split the IOMMU table if we have 1GB or more of space */\n\tif ((tbl->it_size << tbl->it_page_shift) >= (1UL * 1024 * 1024 * 1024))\n\t\ttbl->nr_pools = IOMMU_NR_POOLS;\n\telse\n\t\ttbl->nr_pools = 1;\n\n\t/* We reserve the top 1/4 of the table for large allocations */\n\ttbl->poolsize = (tbl->it_size * 3 / 4) / tbl->nr_pools;\n\n\tfor (i = 0; i < tbl->nr_pools; i++) {\n\t\tp = &tbl->pools[i];\n\t\tspin_lock_init(&(p->lock));\n\t\tp->start = tbl->poolsize * i;\n\t\tp->hint = p->start;\n\t\tp->end = p->start + tbl->poolsize;\n\t}\n\n\tp = &tbl->large_pool;\n\tspin_lock_init(&(p->lock));\n\tp->start = tbl->poolsize * i;\n\tp->hint = p->start;\n\tp->end = tbl->it_size;\n\n\tiommu_table_clear(tbl);\n\n\tif (!welcomed) {\n\t\tprintk(KERN_INFO \"IOMMU table initialized, virtual merging %s\\n\",\n\t\t       novmerge ? \"disabled\" : \"enabled\");\n\t\twelcomed = 1;\n\t}\n\n\treturn tbl;\n}"
  },
  {
    "function_name": "iommu_table_release_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "663-676",
    "snippet": "static void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "i - tbl->it_offset",
            "tbl->it_map"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_release_pages(struct iommu_table *tbl)\n{\n\tint i;\n\n\t/*\n\t * In case we have reserved the first bit, we should not emit\n\t * the warning below.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tclear_bit(0, tbl->it_map);\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tclear_bit(i - tbl->it_offset, tbl->it_map);\n}"
  },
  {
    "function_name": "iommu_table_reserve_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "636-661",
    "snippet": "static void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "i - tbl->it_offset",
            "tbl->it_map"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "tbl->it_map"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "res_end < res_start"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_reserve_pages(struct iommu_table *tbl,\n\t\tunsigned long res_start, unsigned long res_end)\n{\n\tint i;\n\n\tWARN_ON_ONCE(res_end < res_start);\n\t/*\n\t * Reserve page 0 so it will not be used for any mappings.\n\t * This avoids buggy drivers that consider page 0 to be invalid\n\t * to crash the machine or even lose data.\n\t */\n\tif (tbl->it_offset == 0)\n\t\tset_bit(0, tbl->it_map);\n\n\ttbl->it_reserved_start = res_start;\n\ttbl->it_reserved_end = res_end;\n\n\t/* Check if res_start..res_end isn't empty and overlaps the table */\n\tif (res_start && res_end &&\n\t\t\t(tbl->it_offset + tbl->it_size < res_start ||\n\t\t\t res_end < tbl->it_offset))\n\t\treturn;\n\n\tfor (i = tbl->it_reserved_start; i < tbl->it_reserved_end; ++i)\n\t\tset_bit(i - tbl->it_offset, tbl->it_map);\n}"
  },
  {
    "function_name": "iommu_table_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "595-634",
    "snippet": "static void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "index",
            "tbl->it_map"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%d entries for the kdump boot\\n\"",
            "KDUMP_MIN_TCE_ENTRIES"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"TCE table is full; freeing \""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "index",
            "tbl->it_map"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->get",
          "args": [
            "tbl",
            "index + tbl->it_offset"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->clear",
          "args": [
            "tbl",
            "tbl->it_offset",
            "tbl->it_size"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fadump_active",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "is_fadump_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "183-186",
          "snippet": "int is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint is_fadump_active(void)\n{\n\treturn fw_dump.dump_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kdump_kernel",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void iommu_table_clear(struct iommu_table *tbl)\n{\n\t/*\n\t * In case of firmware assisted dump system goes through clean\n\t * reboot process at the time of system crash. Hence it's safe to\n\t * clear the TCE entries if firmware assisted dump is active.\n\t */\n\tif (!is_kdump_kernel() || is_fadump_active()) {\n\t\t/* Clear the table in case firmware left allocations in it */\n\t\ttbl->it_ops->clear(tbl, tbl->it_offset, tbl->it_size);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_CRASH_DUMP\n\tif (tbl->it_ops->get) {\n\t\tunsigned long index, tceval, tcecount = 0;\n\n\t\t/* Reserve the existing mappings left by the first kernel. */\n\t\tfor (index = 0; index < tbl->it_size; index++) {\n\t\t\ttceval = tbl->it_ops->get(tbl, index + tbl->it_offset);\n\t\t\t/*\n\t\t\t * Freed TCE entry contains 0x7fffffffffffffff on JS20\n\t\t\t */\n\t\t\tif (tceval && (tceval != 0x7fffffffffffffffUL)) {\n\t\t\t\t__set_bit(index, tbl->it_map);\n\t\t\t\ttcecount++;\n\t\t\t}\n\t\t}\n\n\t\tif ((tbl->it_size - tcecount) < KDUMP_MIN_TCE_ENTRIES) {\n\t\t\tprintk(KERN_WARNING \"TCE table is full; freeing \");\n\t\t\tprintk(KERN_WARNING \"%d entries for the kdump boot\\n\",\n\t\t\t\tKDUMP_MIN_TCE_ENTRIES);\n\t\t\tfor (index = tbl->it_size - KDUMP_MIN_TCE_ENTRIES;\n\t\t\t\tindex < tbl->it_size; index++)\n\t\t\t\t__clear_bit(index, tbl->it_map);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "ppc_iommu_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "563-593",
    "snippet": "void ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tunsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "sg"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "dma_handle",
            "npages"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "383-403",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "dma_handle",
            "sg->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tunsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
  },
  {
    "function_name": "ppc_iommu_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "418-560",
    "snippet": "int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     unsigned long attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_MAPPING_ERROR)) {\n\t\t\tif (!(attrs & DMA_ATTR_NO_WARN) &&\n\t\t\t    printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_MAPPING_ERROR;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_MAPPING_ERROR;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;",
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "383-403",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "s->dma_address",
            "s->dma_length",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "outs"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"mapped %d elements:\\n\"",
            "outcount"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - dma next is: %lx\\n\"",
            "dma_next"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - filling new segment.\\n\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"    merged, new len: %ux\\n\"",
            "outs->dma_length"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"    can't merge, new segment.\\n\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_next",
          "args": [
            "outs"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - trying merge...\\n\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "build_fail"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->set",
          "args": [
            "tbl",
            "entry",
            "npages",
            "vaddr & IOMMU_PAGE_MASK(tbl)",
            "direction",
            "attrs"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\"",
            "npages",
            "entry",
            "dma_addr"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\"",
            "tbl",
            "vaddr",
            "npages"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry == DMA_MAPPING_ERROR"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"  - vaddr: %lx, size: %lx\\n\"",
            "vaddr",
            "slen"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_range_alloc",
          "args": [
            "dev",
            "tbl",
            "npages",
            "&handle",
            "mask >> tbl->it_page_shift",
            "align"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "163-291",
          "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iommu_num_pages",
          "args": [
            "vaddr",
            "slen",
            "IOMMU_PAGE_SIZE(tbl)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_SIZE",
          "args": [
            "tbl"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_virt",
          "args": [
            "s"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_sg",
          "args": [
            "sglist",
            "s",
            "nelems",
            "i"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_max_seg_size",
          "args": [
            "dev"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"sg mapping %d elements:\\n\"",
            "nelems"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "direction == DMA_NONE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nint ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     unsigned long attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_MAPPING_ERROR)) {\n\t\t\tif (!(attrs & DMA_ATTR_NO_WARN) &&\n\t\t\t    printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_MAPPING_ERROR;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_MAPPING_ERROR;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "iommu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "405-416",
    "snippet": "static void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "dma_addr",
            "npages"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "383-403",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\tunsigned int npages)\n{\n\t__iommu_free(tbl, dma_addr, npages);\n\n\t/* Make sure TLB cache is flushed if the HW needs it. We do\n\t * not do an mb() here on purpose, it is not needed on any of\n\t * the current platforms.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
  },
  {
    "function_name": "__iommu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "383-403",
    "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_clear",
          "args": [
            "tbl->it_map",
            "free_entry",
            "npages"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->clear",
          "args": [
            "tbl",
            "entry",
            "npages"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_free_check",
          "args": [
            "tbl",
            "dma_addr",
            "npages"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "336-362",
          "snippet": "static bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pool",
          "args": [
            "tbl",
            "free_entry"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "get_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "364-381",
          "snippet": "static struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
  },
  {
    "function_name": "get_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "364-381",
    "snippet": "static struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pool_nr > tbl->nr_pools"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct iommu_pool *get_pool(struct iommu_table *tbl,\n\t\t\t\t   unsigned long entry)\n{\n\tstruct iommu_pool *p;\n\tunsigned long largepool_start = tbl->large_pool.start;\n\n\t/* The large pool is the last pool at the top of the table */\n\tif (entry >= largepool_start) {\n\t\tp = &tbl->large_pool;\n\t} else {\n\t\tunsigned int pool_nr = entry / tbl->poolsize;\n\n\t\tBUG_ON(pool_nr > tbl->nr_pools);\n\t\tp = &tbl->pools[pool_nr];\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "iommu_free_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "336-362",
    "snippet": "static bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"\\tindex     = 0x%llx\\n\"",
            "(u64)tbl->it_index"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"iommu_free: invalid entry\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic bool iommu_free_check(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t     unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tif (((free_entry + npages) > tbl->it_size) ||\n\t    (entry < tbl->it_offset)) {\n\t\tif (printk_ratelimit()) {\n\t\t\tprintk(KERN_INFO \"iommu_free: invalid entry\\n\");\n\t\t\tprintk(KERN_INFO \"\\tentry     = 0x%lx\\n\", entry); \n\t\t\tprintk(KERN_INFO \"\\tdma_addr  = 0x%llx\\n\", (u64)dma_addr);\n\t\t\tprintk(KERN_INFO \"\\tTable     = 0x%llx\\n\", (u64)tbl);\n\t\t\tprintk(KERN_INFO \"\\tbus#      = 0x%llx\\n\", (u64)tbl->it_busno);\n\t\t\tprintk(KERN_INFO \"\\tsize      = 0x%llx\\n\", (u64)tbl->it_size);\n\t\t\tprintk(KERN_INFO \"\\tstartOff  = 0x%llx\\n\", (u64)tbl->it_offset);\n\t\t\tprintk(KERN_INFO \"\\tindex     = 0x%llx\\n\", (u64)tbl->it_index);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "iommu_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "293-334",
    "snippet": "static dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->flush",
          "args": [
            "tbl"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iommu_free",
          "args": [
            "tbl",
            "ret",
            "npages"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__iommu_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "383-403",
          "snippet": "static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\n\t\t\t unsigned int npages)\n{\n\tunsigned long entry, free_entry;\n\tunsigned long flags;\n\tstruct iommu_pool *pool;\n\n\tentry = dma_addr >> tbl->it_page_shift;\n\tfree_entry = entry - tbl->it_offset;\n\n\tpool = get_pool(tbl, free_entry);\n\n\tif (!iommu_free_check(tbl, dma_addr, npages))\n\t\treturn;\n\n\ttbl->it_ops->clear(tbl, entry, npages);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\tbitmap_clear(tbl->it_map, free_entry, npages);\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "build_fail"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tbl->it_ops->set",
          "args": [
            "tbl",
            "entry",
            "npages",
            "(unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl)",
            "direction",
            "attrs"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOMMU_PAGE_MASK",
          "args": [
            "tbl"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry == DMA_MAPPING_ERROR"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_range_alloc",
          "args": [
            "dev",
            "tbl",
            "npages",
            "NULL",
            "mask",
            "align_order"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_range_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "163-291",
          "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\n\t\t\t      void *page, unsigned int npages,\n\t\t\t      enum dma_data_direction direction,\n\t\t\t      unsigned long mask, unsigned int align_order,\n\t\t\t      unsigned long attrs)\n{\n\tunsigned long entry;\n\tdma_addr_t ret = DMA_MAPPING_ERROR;\n\tint build_fail;\n\n\tentry = iommu_range_alloc(dev, tbl, npages, NULL, mask, align_order);\n\n\tif (unlikely(entry == DMA_MAPPING_ERROR))\n\t\treturn DMA_MAPPING_ERROR;\n\n\tentry += tbl->it_offset;\t/* Offset into real TCE table */\n\tret = entry << tbl->it_page_shift;\t/* Set the return dma address */\n\n\t/* Put the TCEs in the HW table */\n\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t      (unsigned long)page &\n\t\t\t\t      IOMMU_PAGE_MASK(tbl), direction, attrs);\n\n\t/* tbl->it_ops->set() only returns non-zero for transient errors.\n\t * Clean up the table bitmap in this case and return\n\t * DMA_MAPPING_ERROR. For all other errors the functionality is\n\t * not altered.\n\t */\n\tif (unlikely(build_fail)) {\n\t\t__iommu_free(tbl, ret, npages);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iommu_range_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "163-291",
    "snippet": "static unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pass == 0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iommu_area_alloc",
          "args": [
            "tbl->it_map",
            "limit",
            "start",
            "npages",
            "tbl->it_offset",
            "boundary_size >> tbl->it_page_shift",
            "align_mask"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "1UL << 32",
            "1 << tbl->it_page_shift"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "dma_get_seg_boundary(dev) + 1",
            "1 << tbl->it_page_shift"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_get_seg_boundary",
          "args": [
            "dev"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&(pool->lock)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&(pool->lock)",
            "flags"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_read",
          "args": [
            "iommu_pool_hash"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_iommu",
          "args": [
            "dev"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_iommu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
          "lines": "157-160",
          "snippet": "static inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "npages == 0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic unsigned long iommu_range_alloc(struct device *dev,\n\t\t\t\t       struct iommu_table *tbl,\n                                       unsigned long npages,\n                                       unsigned long *handle,\n                                       unsigned long mask,\n                                       unsigned int align_order)\n{ \n\tunsigned long n, end, start;\n\tunsigned long limit;\n\tint largealloc = npages > 15;\n\tint pass = 0;\n\tunsigned long align_mask;\n\tunsigned long boundary_size;\n\tunsigned long flags;\n\tunsigned int pool_nr;\n\tstruct iommu_pool *pool;\n\n\talign_mask = (1ull << align_order) - 1;\n\n\t/* This allocator was derived from x86_64's bit string search */\n\n\t/* Sanity check */\n\tif (unlikely(npages == 0)) {\n\t\tif (printk_ratelimit())\n\t\t\tWARN_ON(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (should_fail_iommu(dev))\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/*\n\t * We don't need to disable preemption here because any CPU can\n\t * safely use any IOMMU pool.\n\t */\n\tpool_nr = raw_cpu_read(iommu_pool_hash) & (tbl->nr_pools - 1);\n\n\tif (largealloc)\n\t\tpool = &(tbl->large_pool);\n\telse\n\t\tpool = &(tbl->pools[pool_nr]);\n\n\tspin_lock_irqsave(&(pool->lock), flags);\n\nagain:\n\tif ((pass == 0) && handle && *handle &&\n\t    (*handle >= pool->start) && (*handle < pool->end))\n\t\tstart = *handle;\n\telse\n\t\tstart = pool->hint;\n\n\tlimit = pool->end;\n\n\t/* The case below can happen if we have a small segment appended\n\t * to a large, or when the previous alloc was at the very end of\n\t * the available space. If so, go back to the initial start.\n\t */\n\tif (start >= limit)\n\t\tstart = pool->start;\n\n\tif (limit + tbl->it_offset > mask) {\n\t\tlimit = mask - tbl->it_offset + 1;\n\t\t/* If we're constrained on address range, first try\n\t\t * at the masked hint to avoid O(n) search complexity,\n\t\t * but on second pass, start at 0 in pool 0.\n\t\t */\n\t\tif ((start & mask) >= limit || pass > 0) {\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool = &(tbl->pools[0]);\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tstart = pool->start;\n\t\t} else {\n\t\t\tstart &= mask;\n\t\t}\n\t}\n\n\tif (dev)\n\t\tboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\n\t\t\t\t      1 << tbl->it_page_shift);\n\telse\n\t\tboundary_size = ALIGN(1UL << 32, 1 << tbl->it_page_shift);\n\t/* 4GB boundary for iseries_hv_alloc and iseries_hv_map */\n\n\tn = iommu_area_alloc(tbl->it_map, limit, start, npages, tbl->it_offset,\n\t\t\t     boundary_size >> tbl->it_page_shift, align_mask);\n\tif (n == -1) {\n\t\tif (likely(pass == 0)) {\n\t\t\t/* First try the pool from the start */\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else if (pass <= tbl->nr_pools) {\n\t\t\t/* Now try scanning all the other pools */\n\t\t\tspin_unlock(&(pool->lock));\n\t\t\tpool_nr = (pool_nr + 1) & (tbl->nr_pools - 1);\n\t\t\tpool = &tbl->pools[pool_nr];\n\t\t\tspin_lock(&(pool->lock));\n\t\t\tpool->hint = pool->start;\n\t\t\tpass++;\n\t\t\tgoto again;\n\n\t\t} else {\n\t\t\t/* Give up */\n\t\t\tspin_unlock_irqrestore(&(pool->lock), flags);\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\t}\n\t}\n\n\tend = n + npages;\n\n\t/* Bump the hint to a new block for small allocs. */\n\tif (largealloc) {\n\t\t/* Don't bump to new block to avoid fragmentation */\n\t\tpool->hint = end;\n\t} else {\n\t\t/* Overflow will be taken care of at the next allocation */\n\t\tpool->hint = (end + tbl->it_blocksize - 1) &\n\t\t                ~(tbl->it_blocksize - 1);\n\t}\n\n\t/* Update handle for SG allocations */\n\tif (handle)\n\t\t*handle = end;\n\n\tspin_unlock_irqrestore(&(pool->lock), flags);\n\n\treturn n;\n}"
  },
  {
    "function_name": "should_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "157-160",
    "snippet": "static inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic inline bool should_fail_iommu(struct device *dev)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "fail_iommu_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "140-150",
    "snippet": "static int __init fail_iommu_setup(void)\n{\n#ifdef CONFIG_PCI\n\tbus_register_notifier(&pci_bus_type, &fail_iommu_bus_notifier);\n#endif\n#ifdef CONFIG_IBMVIO\n\tbus_register_notifier(&vio_bus_type, &fail_iommu_bus_notifier);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&vio_bus_type",
            "&fail_iommu_bus_notifier"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&fail_iommu_bus_notifier"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init fail_iommu_setup(void)\n{\n#ifdef CONFIG_PCI\n\tbus_register_notifier(&pci_bus_type, &fail_iommu_bus_notifier);\n#endif\n#ifdef CONFIG_IBMVIO\n\tbus_register_notifier(&vio_bus_type, &fail_iommu_bus_notifier);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fail_iommu_bus_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "120-134",
    "snippet": "static int fail_iommu_bus_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tif (action == BUS_NOTIFY_ADD_DEVICE) {\n\t\tif (device_create_file(dev, &dev_attr_fail_iommu))\n\t\t\tpr_warn(\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\");\n\t} else if (action == BUS_NOTIFY_DEL_DEVICE) {\n\t\tdevice_remove_file(dev, &dev_attr_fail_iommu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_remove_file",
          "args": [
            "dev",
            "&dev_attr_fail_iommu"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_fail_iommu"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int fail_iommu_bus_notify(struct notifier_block *nb,\n\t\t\t\t unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tif (action == BUS_NOTIFY_ADD_DEVICE) {\n\t\tif (device_create_file(dev, &dev_attr_fail_iommu))\n\t\t\tpr_warn(\"Unable to create IOMMU fault injection sysfs \"\n\t\t\t\t\"entries\\n\");\n\t} else if (action == BUS_NOTIFY_DEL_DEVICE) {\n\t\tdevice_remove_file(dev, &dev_attr_fail_iommu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fail_iommu_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "106-116",
    "snippet": "static ssize_t fail_iommu_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint i;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &i) > 0)\n\t\tdev->archdata.fail_iommu = (i == 0) ? 0 : 1;\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&i"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic ssize_t fail_iommu_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tint i;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &i) > 0)\n\t\tdev->archdata.fail_iommu = (i == 0) ? 0 : 1;\n\n\treturn count;\n}"
  },
  {
    "function_name": "fail_iommu_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "100-104",
    "snippet": "static ssize_t fail_iommu_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->archdata.fail_iommu);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "dev->archdata.fail_iommu"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic ssize_t fail_iommu_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->archdata.fail_iommu);\n}"
  },
  {
    "function_name": "fail_iommu_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "91-97",
    "snippet": "static int __init fail_iommu_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_iommu\",\n\t\t\t\t\t\t       NULL, &fail_iommu);\n\n\treturn PTR_ERR_OR_ZERO(dir);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "dir"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_iommu\"",
            "NULL",
            "&fail_iommu"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init fail_iommu_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_iommu\",\n\t\t\t\t\t\t       NULL, &fail_iommu);\n\n\treturn PTR_ERR_OR_ZERO(dir);\n}"
  },
  {
    "function_name": "should_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "86-89",
    "snippet": "static bool should_fail_iommu(struct device *dev)\n{\n\treturn dev->archdata.fail_iommu && should_fail(&fail_iommu, 1);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fail_iommu",
            "1"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic bool should_fail_iommu(struct device *dev)\n{\n\treturn dev->archdata.fail_iommu && should_fail(&fail_iommu, 1);\n}"
  },
  {
    "function_name": "setup_fail_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "80-83",
    "snippet": "static int __init setup_fail_iommu(char *str)\n{\n\treturn setup_fault_attr(&fail_iommu, str);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_fault_attr",
          "args": [
            "&fail_iommu",
            "str"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int __init setup_fail_iommu(char *str)\n{\n\treturn setup_fault_attr(&fail_iommu, str);\n}"
  },
  {
    "function_name": "setup_iommu_pool_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "65-73",
    "snippet": "static int __init setup_iommu_pool_hash(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tper_cpu(iommu_pool_hash, i) = hash_32(i, IOMMU_POOL_HASHBITS);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned int, iommu_pool_hash);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "i",
            "IOMMU_POOL_HASHBITS"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_PER_CPU(unsigned int, iommu_pool_hash);\n\nstatic int __init setup_iommu_pool_hash(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tper_cpu(iommu_pool_hash, i) = hash_32(i, IOMMU_POOL_HASHBITS);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_iommu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/iommu.c",
    "lines": "45-52",
    "snippet": "static int __init setup_iommu(char *str)\n{\n\tif (!strcmp(str, \"novmerge\"))\n\t\tnovmerge = 1;\n\telse if (!strcmp(str, \"vmerge\"))\n\t\tnovmerge = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/tce.h>",
      "#include <asm/vio.h>",
      "#include <asm/fadump.h>",
      "#include <asm/kdump.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/iommu.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/sched.h>",
      "#include <linux/iommu.h>",
      "#include <linux/pci.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/hash.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/iommu-helper.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/dma-mapping.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int novmerge;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"vmerge\""
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\n\nstatic int __init setup_iommu(char *str)\n{\n\tif (!strcmp(str, \"novmerge\"))\n\t\tnovmerge = 1;\n\telse if (!strcmp(str, \"vmerge\"))\n\t\tnovmerge = 0;\n\treturn 1;\n}"
  }
]