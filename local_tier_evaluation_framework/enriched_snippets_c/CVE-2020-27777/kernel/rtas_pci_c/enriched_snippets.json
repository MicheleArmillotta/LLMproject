[
  {
    "function_name": "rtas_setup_phb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "227-241",
    "snippet": "int rtas_setup_phb(struct pci_controller *phb)\n{\n\tstruct device_node *dev = phb->dn;\n\n\tif (is_python(dev))\n\t\tpython_countermeasures(dev);\n\n\tif (phb_set_bus_ranges(dev, phb))\n\t\treturn 1;\n\n\tphb->ops = &rtas_pci_ops;\n\tphb->buid = get_phb_buid(dev);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_ops rtas_pci_ops = {\n\t.read = rtas_pci_read_config,\n\t.write = rtas_pci_write_config,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_phb_buid",
          "args": [
            "dev"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "get_phb_buid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "199-208",
          "snippet": "unsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ibm_read_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int ibm_read_pci_config;\n\nunsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb_set_bus_ranges",
          "args": [
            "dev",
            "phb"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "phb_set_bus_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "210-225",
          "snippet": "static int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "python_countermeasures",
          "args": [
            "dev"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "python_countermeasures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "154-189",
          "snippet": "static void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PRG_CL_RESET_VALID 0x00010000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PRG_CL_RESET_VALID 0x00010000\n\nstatic void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_python",
          "args": [
            "dev"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "is_python",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "144-152",
          "snippet": "static int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pci_ops rtas_pci_ops = {\n\t.read = rtas_pci_read_config,\n\t.write = rtas_pci_write_config,\n};\n\nint rtas_setup_phb(struct pci_controller *phb)\n{\n\tstruct device_node *dev = phb->dn;\n\n\tif (is_python(dev))\n\t\tpython_countermeasures(dev);\n\n\tif (phb_set_bus_ranges(dev, phb))\n\t\treturn 1;\n\n\tphb->ops = &rtas_pci_ops;\n\tphb->buid = get_phb_buid(dev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "phb_set_bus_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "210-225",
    "snippet": "static int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bus_range[1]"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "bus_range[0]"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dev",
            "\"bus-range\"",
            "&len"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int phb_set_bus_ranges(struct device_node *dev,\n\t\t\t      struct pci_controller *phb)\n{\n\tconst __be32 *bus_range;\n\tunsigned int len;\n\n\tbus_range = of_get_property(dev, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\treturn 1;\n \t}\n\n\tphb->first_busno = be32_to_cpu(bus_range[0]);\n\tphb->last_busno  = be32_to_cpu(bus_range[1]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_phb_buid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "199-208",
    "snippet": "unsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ibm_read_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_address_to_resource",
          "args": [
            "phb",
            "0",
            "&r"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int ibm_read_pci_config;\n\nunsigned long get_phb_buid(struct device_node *phb)\n{\n\tstruct resource r;\n\n\tif (ibm_read_pci_config == -1)\n\t\treturn 0;\n\tif (of_address_to_resource(phb, 0, &r))\n\t\treturn 0;\n\treturn r.start;\n}"
  },
  {
    "function_name": "init_pci_config_tokens",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "191-197",
    "snippet": "void __init init_pci_config_tokens(void)\n{\n\tread_pci_config = rtas_token(\"read-pci-config\");\n\twrite_pci_config = rtas_token(\"write-pci-config\");\n\tibm_read_pci_config = rtas_token(\"ibm,read-pci-config\");\n\tibm_write_pci_config = rtas_token(\"ibm,write-pci-config\");\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_pci_config;",
      "static int write_pci_config;",
      "static int ibm_read_pci_config;",
      "static int ibm_write_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,write-pci-config\""
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int write_pci_config;\nstatic int ibm_read_pci_config;\nstatic int ibm_write_pci_config;\n\nvoid __init init_pci_config_tokens(void)\n{\n\tread_pci_config = rtas_token(\"read-pci-config\");\n\twrite_pci_config = rtas_token(\"write-pci-config\");\n\tibm_read_pci_config = rtas_token(\"ibm,read-pci-config\");\n\tibm_write_pci_config = rtas_token(\"ibm,write-pci-config\");\n}"
  },
  {
    "function_name": "python_countermeasures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "154-189",
    "snippet": "static void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRG_CL_RESET_VALID 0x00010000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "chip_regs"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"reg0: %x\\n\"",
            "val"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_be32",
          "args": [
            "chip_regs + 0xf6030"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_be32",
          "args": [
            "chip_regs + 0xf6030",
            "val"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Python workaround: \""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_be32",
          "args": [
            "chip_regs + 0xf6030"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "registers.start & ~(0xfffffUL)",
            "0x100000"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't get address for Python workarounds !\\n\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_address_to_resource",
          "args": [
            "dev",
            "0",
            "&registers"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PRG_CL_RESET_VALID 0x00010000\n\nstatic void python_countermeasures(struct device_node *dev)\n{\n\tstruct resource registers;\n\tvoid __iomem *chip_regs;\n\tvolatile u32 val;\n\n\tif (of_address_to_resource(dev, 0, &registers)) {\n\t\tprintk(KERN_ERR \"Can't get address for Python workarounds !\\n\");\n\t\treturn;\n\t}\n\n\t/* Python's register file is 1 MB in size. */\n\tchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\n\n\t/*\n\t * Firmware doesn't always clear this bit which is critical\n\t * for good performance - Anton\n\t */\n\n#define PRG_CL_RESET_VALID 0x00010000\n\n\tval = in_be32(chip_regs + 0xf6030);\n\tif (val & PRG_CL_RESET_VALID) {\n\t\tprintk(KERN_INFO \"Python workaround: \");\n\t\tval &= ~PRG_CL_RESET_VALID;\n\t\tout_be32(chip_regs + 0xf6030, val);\n\t\t/*\n\t\t * We must read it back for changes to\n\t\t * take effect\n\t\t */\n\t\tval = in_be32(chip_regs + 0xf6030);\n\t\tprintk(\"reg0: %x\\n\", val);\n\t}\n\n\tiounmap(chip_regs);\n}"
  },
  {
    "function_name": "is_python",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "144-152",
    "snippet": "static int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "model",
            "\"Python\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "290-305",
          "snippet": "static char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dev",
            "\"model\"",
            "NULL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int is_python(struct device_node *dev)\n{\n\tconst char *model = of_get_property(dev, \"model\", NULL);\n\n\tif (model && strstr(model, \"Python\"))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_pci_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "127-137",
    "snippet": "static int rtas_pci_write_config(struct pci_bus *bus,\n\t\t\t\t unsigned int devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct pci_dn *pdn;\n\n\tpdn = pci_get_pdn_by_devfn(bus, devfn);\n\n\t/* Validity of pdn is checked in here. */\n\treturn rtas_write_config(pdn, where, size, val);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_write_config",
          "args": [
            "pdn",
            "where",
            "size",
            "val"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_write_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "97-125",
          "snippet": "int rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_pci_config;",
            "static int ibm_write_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int write_pci_config;\nstatic int ibm_write_pci_config;\n\nint rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_pdn_by_devfn",
          "args": [
            "bus",
            "devfn"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "58-93",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int rtas_pci_write_config(struct pci_bus *bus,\n\t\t\t\t unsigned int devfn,\n\t\t\t\t int where, int size, u32 val)\n{\n\tstruct pci_dn *pdn;\n\n\tpdn = pci_get_pdn_by_devfn(bus, devfn);\n\n\t/* Validity of pdn is checked in here. */\n\treturn rtas_write_config(pdn, where, size, val);\n}"
  },
  {
    "function_name": "rtas_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "97-125",
    "snippet": "int rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_pci_config;",
      "static int ibm_write_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "write_pci_config",
            "3",
            "1",
            "NULL",
            "addr",
            "size",
            "(ulong)val"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUID_LO",
          "args": [
            "buid"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUID_HI",
          "args": [
            "buid"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_config_addr",
          "args": [
            "pdn->busno",
            "pdn->devfn",
            "where"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_access_valid",
          "args": [
            "pdn",
            "where"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "config_access_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "35-43",
          "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int write_pci_config;\nstatic int ibm_write_pci_config;\n\nint rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\n{\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\n\t\t\tBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\n\t} else {\n\t\tret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\n\t}\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
  },
  {
    "function_name": "rtas_pci_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "77-95",
    "snippet": "static int rtas_pci_read_config(struct pci_bus *bus,\n\t\t\t\tunsigned int devfn,\n\t\t\t\tint where, int size, u32 *val)\n{\n\tstruct pci_dn *pdn;\n\tint ret;\n\n\t*val = 0xFFFFFFFF;\n\n\tpdn = pci_get_pdn_by_devfn(bus, devfn);\n\n\t/* Validity of pdn is checked in here */\n\tret = rtas_read_config(pdn, where, size, val);\n\tif (*val == EEH_IO_ERROR_VALUE(size) &&\n\t    eeh_dev_check_failure(pdn_to_eeh_dev(pdn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_check_failure",
          "args": [
            "pdn_to_eeh_dev(pdn)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_check_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "440-585",
          "snippet": "int eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_MAX_FAILS\t2100000"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static struct eeh_stats eeh_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define EEH_MAX_FAILS\t2100000\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic struct eeh_stats eeh_stats;\n\nint eeh_dev_check_failure(struct eeh_dev *edev)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct device_node *dn;\n\tstruct pci_dev *dev;\n\tstruct eeh_pe *pe, *parent_pe;\n\tint rc = 0;\n\tconst char *location = NULL;\n\n\teeh_stats.total_mmio_ffs++;\n\n\tif (!eeh_enabled())\n\t\treturn 0;\n\n\tif (!edev) {\n\t\teeh_stats.no_dn++;\n\t\treturn 0;\n\t}\n\tdev = eeh_dev_to_pci_dev(edev);\n\tpe = eeh_dev_to_pe(edev);\n\n\t/* Access to IO BARs might get this far and still not want checking. */\n\tif (!pe) {\n\t\teeh_stats.ignored_check++;\n\t\teeh_edev_dbg(edev, \"Ignored check\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pe->addr && !pe->config_addr) {\n\t\teeh_stats.no_cfg_addr++;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * On PowerNV platform, we might already have fenced PHB\n\t * there and we need take care of that firstly.\n\t */\n\tret = eeh_phb_check_failure(pe);\n\tif (ret > 0)\n\t\treturn ret;\n\n\t/*\n\t * If the PE isn't owned by us, we shouldn't check the\n\t * state. Instead, let the owner handle it if the PE has\n\t * been frozen.\n\t */\n\tif (eeh_pe_passed(pe))\n\t\treturn 0;\n\n\t/* If we already have a pending isolation event for this\n\t * slot, we know it's bad already, we don't need to check.\n\t * Do this checking under a lock; as multiple PCI devices\n\t * in one slot might report errors simultaneously, and we\n\t * only want one error recovery routine running.\n\t */\n\teeh_serialize_lock(&flags);\n\trc = 1;\n\tif (pe->state & EEH_PE_ISOLATED) {\n\t\tpe->check_count++;\n\t\tif (pe->check_count == EEH_MAX_FAILS) {\n\t\t\tdn = pci_device_to_OF_node(dev);\n\t\t\tif (dn)\n\t\t\t\tlocation = of_get_property(dn, \"ibm,loc-code\",\n\t\t\t\t\t\tNULL);\n\t\t\teeh_edev_err(edev, \"%d reads ignored for recovering device at location=%s driver=%s\\n\",\n\t\t\t\tpe->check_count,\n\t\t\t\tlocation ? location : \"unknown\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\teeh_edev_err(edev, \"Might be infinite loop in %s driver\\n\",\n\t\t\t\teeh_driver_name(dev));\n\t\t\tdump_stack();\n\t\t}\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * Now test for an EEH failure.  This is VERY expensive.\n\t * Note that the eeh_config_addr may be a parent device\n\t * in the case of a device behind a bridge, or it may be\n\t * function zero of a multi-function device.\n\t * In any case they must share a common PHB.\n\t */\n\tret = eeh_ops->get_state(pe, NULL);\n\n\t/* Note that config-io to empty slots may fail;\n\t * they are empty when they don't have children.\n\t * We will punt with the following conditions: Failure to get\n\t * PE's state, EEH not support and Permanently unavailable\n\t * state, PE is in good state.\n\t */\n\tif ((ret < 0) ||\n\t    (ret == EEH_STATE_NOT_SUPPORT) || eeh_state_active(ret)) {\n\t\teeh_stats.false_positives++;\n\t\tpe->false_positives++;\n\t\trc = 0;\n\t\tgoto dn_unlock;\n\t}\n\n\t/*\n\t * It should be corner case that the parent PE has been\n\t * put into frozen state as well. We should take care\n\t * that at first.\n\t */\n\tparent_pe = pe->parent;\n\twhile (parent_pe) {\n\t\t/* Hit the ceiling ? */\n\t\tif (parent_pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/* Frozen parent PE ? */\n\t\tret = eeh_ops->get_state(parent_pe, NULL);\n\t\tif (ret > 0 && !eeh_state_active(ret)) {\n\t\t\tpe = parent_pe;\n\t\t\tpr_err(\"EEH: Failure of PHB#%x-PE#%x will be handled at parent PHB#%x-PE#%x.\\n\",\n\t\t\t       pe->phb->global_number, pe->addr,\n\t\t\t       pe->phb->global_number, parent_pe->addr);\n\t\t}\n\n\t\t/* Next parent level */\n\t\tparent_pe = parent_pe->parent;\n\t}\n\n\teeh_stats.slot_resets++;\n\n\t/* Avoid repeated reports of this failure, including problems\n\t * with other functions on this device, and functions under\n\t * bridges.\n\t */\n\teeh_pe_mark_isolated(pe);\n\teeh_serialize_unlock(flags);\n\n\t/* Most EEH events are due to device driver bugs.  Having\n\t * a stack trace will help the device-driver authors figure\n\t * out what happened.  So print that out.\n\t */\n\tpr_debug(\"EEH: %s: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t__func__, pe->phb->global_number, pe->addr);\n\teeh_send_failure_event(pe);\n\n\treturn 1;\n\ndn_unlock:\n\teeh_serialize_unlock(flags);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EEH_IO_ERROR_VALUE",
          "args": [
            "size"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_read_config",
          "args": [
            "pdn",
            "where",
            "size",
            "val"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_read_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "45-75",
          "snippet": "int rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_pci_config;",
            "static int ibm_read_pci_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int ibm_read_pci_config;\n\nint rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_pdn_by_devfn",
          "args": [
            "bus",
            "devfn"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "58-93",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int rtas_pci_read_config(struct pci_bus *bus,\n\t\t\t\tunsigned int devfn,\n\t\t\t\tint where, int size, u32 *val)\n{\n\tstruct pci_dn *pdn;\n\tint ret;\n\n\t*val = 0xFFFFFFFF;\n\n\tpdn = pci_get_pdn_by_devfn(bus, devfn);\n\n\t/* Validity of pdn is checked in here */\n\tret = rtas_read_config(pdn, where, size, val);\n\tif (*val == EEH_IO_ERROR_VALUE(size) &&\n\t    eeh_dev_check_failure(pdn_to_eeh_dev(pdn)))\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "45-75",
    "snippet": "int rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_pci_config;",
      "static int ibm_read_pci_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "read_pci_config",
            "2",
            "2",
            "&returnval",
            "addr",
            "size"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUID_LO",
          "args": [
            "buid"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUID_HI",
          "args": [
            "buid"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_config_addr",
          "args": [
            "pdn->busno",
            "pdn->devfn",
            "where"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_access_valid",
          "args": [
            "pdn",
            "where"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "config_access_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
          "lines": "35-43",
          "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/mpic.h>",
            "#include <asm/rtas.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int read_pci_config;\nstatic int ibm_read_pci_config;\n\nint rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\n{\n\tint returnval = -1;\n\tunsigned long buid, addr;\n\tint ret;\n\n\tif (!pdn)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\tif (!config_access_valid(pdn, where))\n\t\treturn PCIBIOS_BAD_REGISTER_NUMBER;\n#ifdef CONFIG_EEH\n\tif (pdn->edev && pdn->edev->pe &&\n\t    (pdn->edev->pe->state & EEH_PE_CFG_BLOCKED))\n\t\treturn PCIBIOS_SET_FAILED;\n#endif\n\n\taddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\n\tbuid = pdn->phb->buid;\n\tif (buid) {\n\t\tret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\n\t\t\t\taddr, BUID_HI(buid), BUID_LO(buid), size);\n\t} else {\n\t\tret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\n\t}\n\t*val = returnval;\n\n\tif (ret)\n\t\treturn PCIBIOS_DEVICE_NOT_FOUND;\n\n\treturn PCIBIOS_SUCCESSFUL;\n}"
  },
  {
    "function_name": "config_access_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas_pci.c",
    "lines": "35-43",
    "snippet": "static inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/mpic.h>",
      "#include <asm/rtas.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/mpic.h>\n#include <asm/rtas.h>\n#include <asm/iommu.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/pgtable.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic inline int config_access_valid(struct pci_dn *dn, int where)\n{\n\tif (where < 256)\n\t\treturn 1;\n\tif (where < 4096 && dn->pci_ext_config_space)\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]