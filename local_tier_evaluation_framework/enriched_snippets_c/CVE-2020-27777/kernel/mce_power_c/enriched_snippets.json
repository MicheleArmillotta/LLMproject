[
  {
    "function_name": "__machine_check_early_realmode_p10",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "740-743",
    "snippet": "long __machine_check_early_realmode_p10(struct pt_regs *regs)\n{\n\treturn mce_handle_error(regs, mce_p10_derror_table, mce_p10_ierror_table);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mce_ierror_table mce_p10_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH_FOREIGN, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008080000, true,\n  MCE_ERROR_TYPE_USER,MCE_USER_ERROR_SCV, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x00000000080c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008100000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008140000, false,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x00000000081c0000, true, MCE_ECLASS_HARDWARE,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH_FOREIGN,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };",
      "static const struct mce_derror_table mce_p10_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, false,\n  MCE_ERROR_TYPE_USER, MCE_USER_ERROR_TLBIE, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000020, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000010, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE_FOREIGN,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000008, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD_STORE_FOREIGN, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_error",
          "args": [
            "regs",
            "mce_p10_derror_table",
            "mce_p10_ierror_table"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "685-707",
          "snippet": "static long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic const struct mce_ierror_table mce_p10_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH_FOREIGN, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008080000, true,\n  MCE_ERROR_TYPE_USER,MCE_USER_ERROR_SCV, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x00000000080c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008100000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008140000, false,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x00000000081c0000, true, MCE_ECLASS_HARDWARE,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH_FOREIGN,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };\nstatic const struct mce_derror_table mce_p10_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, false,\n  MCE_ERROR_TYPE_USER, MCE_USER_ERROR_TLBIE, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000020, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000010, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE_FOREIGN,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000008, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD_STORE_FOREIGN, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };\n\nlong __machine_check_early_realmode_p10(struct pt_regs *regs)\n{\n\treturn mce_handle_error(regs, mce_p10_derror_table, mce_p10_ierror_table);\n}"
  },
  {
    "function_name": "__machine_check_early_realmode_p9",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "722-738",
    "snippet": "long __machine_check_early_realmode_p9(struct pt_regs *regs)\n{\n\t/*\n\t * On POWER9 DD2.1 and below, it's possible to get a machine check\n\t * caused by a paste instruction where only DSISR bit 25 is set. This\n\t * will result in the MCE handler seeing an unknown event and the kernel\n\t * crashing. An MCE that occurs like this is spurious, so we don't need\n\t * to do anything in terms of servicing it. If there is something that\n\t * needs to be serviced, the CPU will raise the MCE again with the\n\t * correct DSISR so that it can be serviced properly. So detect this\n\t * case and mark it as handled.\n\t */\n\tif (SRR1_MC_LOADSTORE(regs->msr) && regs->dsisr == 0x02000000)\n\t\treturn 1;\n\n\treturn mce_handle_error(regs, mce_p9_derror_table, mce_p9_ierror_table);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mce_ierror_table mce_p9_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH_FOREIGN, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008000000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_IFETCH_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008040000, true,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_PAGE_TABLE_WALK_IFETCH_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000080c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008100000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008140000, false,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x0000000008180000, false,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_STORE_TIMEOUT,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x00000000081c0000, true, MCE_ECLASS_HARDWARE,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH_FOREIGN,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };",
      "static const struct mce_derror_table mce_p9_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00002000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_LOAD_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00001000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_PAGE_TABLE_WALK_LOAD_STORE_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, false,\n  MCE_ERROR_TYPE_USER, MCE_USER_ERROR_TLBIE, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000020, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000010, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE_FOREIGN,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000008, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD_STORE_FOREIGN, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_error",
          "args": [
            "regs",
            "mce_p9_derror_table",
            "mce_p9_ierror_table"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "685-707",
          "snippet": "static long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRR1_MC_LOADSTORE",
          "args": [
            "regs->msr"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic const struct mce_ierror_table mce_p9_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH_FOREIGN, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008000000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_IFETCH_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008040000, true,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_PAGE_TABLE_WALK_IFETCH_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000080c0000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008100000, true,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008140000, false,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x0000000008180000, false,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_STORE_TIMEOUT,\n  MCE_INITIATOR_CPU,  MCE_SEV_FATAL, false }, /* ASYNC is fatal */\n{ 0x00000000081c0000, 0x00000000081c0000, true, MCE_ECLASS_HARDWARE,\n  MCE_ERROR_TYPE_RA,  MCE_RA_ERROR_PAGE_TABLE_WALK_IFETCH_FOREIGN,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };\nstatic const struct mce_derror_table mce_p9_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00002000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_LOAD_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00001000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_PAGE_TABLE_WALK_LOAD_STORE_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, false,\n  MCE_ERROR_TYPE_USER, MCE_USER_ERROR_TLBIE, MCE_ECLASS_SOFTWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000020, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000010, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_PAGE_TABLE_WALK_LOAD_STORE_FOREIGN,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000008, false,\n  MCE_ERROR_TYPE_RA,   MCE_RA_ERROR_LOAD_STORE_FOREIGN, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };\n\nlong __machine_check_early_realmode_p9(struct pt_regs *regs)\n{\n\t/*\n\t * On POWER9 DD2.1 and below, it's possible to get a machine check\n\t * caused by a paste instruction where only DSISR bit 25 is set. This\n\t * will result in the MCE handler seeing an unknown event and the kernel\n\t * crashing. An MCE that occurs like this is spurious, so we don't need\n\t * to do anything in terms of servicing it. If there is something that\n\t * needs to be serviced, the CPU will raise the MCE again with the\n\t * correct DSISR so that it can be serviced properly. So detect this\n\t * case and mark it as handled.\n\t */\n\tif (SRR1_MC_LOADSTORE(regs->msr) && regs->dsisr == 0x02000000)\n\t\treturn 1;\n\n\treturn mce_handle_error(regs, mce_p9_derror_table, mce_p9_ierror_table);\n}"
  },
  {
    "function_name": "__machine_check_early_realmode_p8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "717-720",
    "snippet": "long __machine_check_early_realmode_p8(struct pt_regs *regs)\n{\n\treturn mce_handle_error(regs, mce_p8_derror_table, mce_p8_ierror_table);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mce_ierror_table mce_p8_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008000000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_IFETCH_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008040000, true,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_PAGE_TABLE_WALK_IFETCH_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };",
      "static const struct mce_derror_table mce_p8_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00002000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_LOAD_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00001000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_PAGE_TABLE_WALK_LOAD_STORE_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, /* SECONDARY ERAT */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_error",
          "args": [
            "regs",
            "mce_p8_derror_table",
            "mce_p8_ierror_table"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "685-707",
          "snippet": "static long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic const struct mce_ierror_table mce_p8_ierror_table[] = {\n{ 0x00000000081c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000081c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008000000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_IFETCH_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000081c0000, 0x0000000008040000, true,\n  MCE_ERROR_TYPE_LINK,MCE_LINK_ERROR_PAGE_TABLE_WALK_IFETCH_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };\nstatic const struct mce_derror_table mce_p8_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00002000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_LOAD_TIMEOUT, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00001000, true,\n  MCE_ERROR_TYPE_LINK, MCE_LINK_ERROR_PAGE_TABLE_WALK_LOAD_STORE_TIMEOUT,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000200, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, /* SECONDARY ERAT */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT,\t/* Before PARITY */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0, false, 0, 0, 0, 0, 0 } };\n\nlong __machine_check_early_realmode_p8(struct pt_regs *regs)\n{\n\treturn mce_handle_error(regs, mce_p8_derror_table, mce_p8_ierror_table);\n}"
  },
  {
    "function_name": "__machine_check_early_realmode_p7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "709-715",
    "snippet": "long __machine_check_early_realmode_p7(struct pt_regs *regs)\n{\n\t/* P7 DD1 leaves top bits of DSISR undefined */\n\tregs->dsisr &= 0x0000ffff;\n\n\treturn mce_handle_error(regs, mce_p7_derror_table, mce_p7_ierror_table);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct mce_ierror_table mce_p7_ierror_table[] = {\n{ 0x00000000001c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_INDETERMINATE, /* BOTH */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };",
      "static const struct mce_derror_table mce_p7_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_INDETERMINATE, /* BOTH */\n  MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0, false, 0, 0, 0, 0, 0 } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_handle_error",
          "args": [
            "regs",
            "mce_p7_derror_table",
            "mce_p7_ierror_table"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "685-707",
          "snippet": "static long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic const struct mce_ierror_table mce_p7_ierror_table[] = {\n{ 0x00000000001c0000, 0x0000000000040000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x0000000000080000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x00000000000c0000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000100000, true,\n  MCE_ERROR_TYPE_SLB, MCE_SLB_ERROR_INDETERMINATE, /* BOTH */\n  MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000140000, true,\n  MCE_ERROR_TYPE_TLB, MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,  MCE_SEV_WARNING, true },\n{ 0x00000000001c0000, 0x0000000000180000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_PAGE_TABLE_WALK_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0x00000000001c0000, 0x00000000001c0000, true,\n  MCE_ERROR_TYPE_UE,  MCE_UE_ERROR_IFETCH, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,  MCE_SEV_SEVERE, true },\n{ 0, 0, 0, 0, 0, 0, 0 } };\nstatic const struct mce_derror_table mce_p7_derror_table[] = {\n{ 0x00008000, false,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_LOAD_STORE, MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00004000, true,\n  MCE_ERROR_TYPE_UE,   MCE_UE_ERROR_PAGE_TABLE_WALK_LOAD_STORE,\n  MCE_ECLASS_HARDWARE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000800, true,\n  MCE_ERROR_TYPE_ERAT, MCE_ERAT_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000400, true,\n  MCE_ERROR_TYPE_TLB,  MCE_TLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000080, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_MULTIHIT, MCE_ECLASS_SOFT_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0x00000100, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_PARITY, MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_SEVERE, true },\n{ 0x00000040, true,\n  MCE_ERROR_TYPE_SLB,  MCE_SLB_ERROR_INDETERMINATE, /* BOTH */\n  MCE_ECLASS_HARD_INDETERMINATE,\n  MCE_INITIATOR_CPU,   MCE_SEV_WARNING, true },\n{ 0, false, 0, 0, 0, 0, 0 } };\n\nlong __machine_check_early_realmode_p7(struct pt_regs *regs)\n{\n\t/* P7 DD1 leaves top bits of DSISR undefined */\n\tregs->dsisr &= 0x0000ffff;\n\n\treturn mce_handle_error(regs, mce_p7_derror_table, mce_p7_ierror_table);\n}"
  },
  {
    "function_name": "mce_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "685-707",
    "snippet": "static long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_mce_event",
          "args": [
            "regs",
            "handled",
            "&mce_err",
            "regs->nip",
            "addr",
            "phys_addr"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "save_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "102-173",
          "snippet": "void save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr, uint64_t phys_addr)\n{\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\tmce->cpu = get_paca()->paca_index;\n\n\t/* Mark it recovered if we have handled it and MSR(RI=1). */\n\tif (handled && (regs->msr & MSR_RI))\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\n\tmce->initiator = mce_err->initiator;\n\tmce->severity = mce_err->severity;\n\tmce->sync_error = mce_err->sync_error;\n\tmce->error_class = mce_err->error_class;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_USER) {\n\t\tmce->u.user_error.effective_address_provided = true;\n\t\tmce->u.user_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_RA) {\n\t\tmce->u.ra_error.effective_address_provided = true;\n\t\tmce->u.ra_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_LINK) {\n\t\tmce->u.link_error.effective_address_provided = true;\n\t\tmce->u.link_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t\tif (phys_addr != ULONG_MAX) {\n\t\t\tmce->u.ue_error.physical_address_provided = true;\n\t\t\tmce->u.ue_error.physical_address = phys_addr;\n\t\t\tmce->u.ue_error.ignore_event = mce_err->ignore_event;\n\t\t\tmachine_check_ue_event(mce);\n\t\t}\n\t}\n\treturn;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nvoid save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr, uint64_t phys_addr)\n{\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\tmce->cpu = get_paca()->paca_index;\n\n\t/* Mark it recovered if we have handled it and MSR(RI=1). */\n\tif (handled && (regs->msr & MSR_RI))\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\n\tmce->initiator = mce_err->initiator;\n\tmce->severity = mce_err->severity;\n\tmce->sync_error = mce_err->sync_error;\n\tmce->error_class = mce_err->error_class;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_USER) {\n\t\tmce->u.user_error.effective_address_provided = true;\n\t\tmce->u.user_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_RA) {\n\t\tmce->u.ra_error.effective_address_provided = true;\n\t\tmce->u.ra_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_LINK) {\n\t\tmce->u.link_error.effective_address_provided = true;\n\t\tmce->u.link_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t\tif (phys_addr != ULONG_MAX) {\n\t\t\tmce->u.ue_error.physical_address_provided = true;\n\t\t\tmce->u.ue_error.physical_address = phys_addr;\n\t\t\tmce->u.ue_error.ignore_event = mce_err->ignore_event;\n\t\t\tmachine_check_ue_event(mce);\n\t\t}\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ue_error",
          "args": [
            "regs",
            "&mce_err"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ue_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "662-683",
          "snippet": "static long mce_handle_ue_error(struct pt_regs *regs,\n\t\t\t\tstruct mce_error_info *mce_err)\n{\n\tlong handled = 0;\n\n\tmce_common_process_ue(regs, mce_err);\n\tif (mce_err->ignore_event)\n\t\treturn 1;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ue_error(struct pt_regs *regs,\n\t\t\t\tstruct mce_error_info *mce_err)\n{\n\tlong handled = 0;\n\n\tmce_common_process_ue(regs, mce_err);\n\tif (mce_err->ignore_event)\n\t\treturn 1;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_ierror",
          "args": [
            "regs",
            "itable",
            "&mce_err",
            "&addr",
            "&phys_addr"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_ierror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "478-562",
          "snippet": "static int mce_handle_ierror(struct pt_regs *regs,\n\t\tconst struct mce_ierror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t srr1 = regs->msr;\n\tint handled = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].srr1_mask; i++) {\n\t\tif ((srr1 & table[i].srr1_mask) != table[i].srr1_value)\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\thandled = mce_flush(MCE_FLUSH_SLB);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\thandled = mce_flush(MCE_FLUSH_ERAT);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\thandled = mce_flush(MCE_FLUSH_TLB);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].nip_valid) {\n\t\t\t*addr = regs->nip;\n\t\t\tif (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH) {\n\t\t\t\t\tpfn = addr_to_pfn(regs, regs->nip);\n\t\t\t\t\tif (pfn != ULONG_MAX) {\n\t\t\t\t\t\t*phys_addr =\n\t\t\t\t\t\t\t(pfn << PAGE_SHIFT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handled;\n\t}\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MCE_FLUSH_ERAT 3",
            "#define MCE_FLUSH_TLB 2",
            "#define MCE_FLUSH_SLB 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_handle_ierror(struct pt_regs *regs,\n\t\tconst struct mce_ierror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t srr1 = regs->msr;\n\tint handled = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].srr1_mask; i++) {\n\t\tif ((srr1 & table[i].srr1_mask) != table[i].srr1_value)\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\thandled = mce_flush(MCE_FLUSH_SLB);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\thandled = mce_flush(MCE_FLUSH_ERAT);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\thandled = mce_flush(MCE_FLUSH_TLB);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].nip_valid) {\n\t\t\t*addr = regs->nip;\n\t\t\tif (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH) {\n\t\t\t\t\tpfn = addr_to_pfn(regs, regs->nip);\n\t\t\t\t\tif (pfn != ULONG_MAX) {\n\t\t\t\t\t\t*phys_addr =\n\t\t\t\t\t\t\t(pfn << PAGE_SHIFT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handled;\n\t}\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_handle_derror",
          "args": [
            "regs",
            "dtable",
            "&mce_err",
            "&addr",
            "&phys_addr"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "mce_handle_derror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "564-660",
          "snippet": "static int mce_handle_derror(struct pt_regs *regs,\n\t\tconst struct mce_derror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t dsisr = regs->dsisr;\n\tint handled = 0;\n\tint found = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].dsisr_value; i++) {\n\t\tif (!(dsisr & table[i].dsisr_value))\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\tif (mce_flush(MCE_FLUSH_SLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tif (mce_flush(MCE_FLUSH_ERAT))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tif (mce_flush(MCE_FLUSH_TLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Attempt to handle multiple conditions, but only return\n\t\t * one. Ensure uncorrectable errors are first in the table\n\t\t * to match.\n\t\t */\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].dar_valid)\n\t\t\t*addr = regs->dar;\n\t\telse if (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t/*\n\t\t\t * We do a maximum of 4 nested MCE calls, see\n\t\t\t * kernel/exception-64s.h\n\t\t\t */\n\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH)\n\t\t\t\tmce_find_instr_ea_and_phys(regs, addr,\n\t\t\t\t\t\t\t   phys_addr);\n\t\t}\n\t\tfound = 1;\n\t}\n\n\tif (found)\n\t\treturn handled;\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MCE_FLUSH_ERAT 3",
            "#define MCE_FLUSH_TLB 2",
            "#define MCE_FLUSH_SLB 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_handle_derror(struct pt_regs *regs,\n\t\tconst struct mce_derror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t dsisr = regs->dsisr;\n\tint handled = 0;\n\tint found = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].dsisr_value; i++) {\n\t\tif (!(dsisr & table[i].dsisr_value))\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\tif (mce_flush(MCE_FLUSH_SLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tif (mce_flush(MCE_FLUSH_ERAT))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tif (mce_flush(MCE_FLUSH_TLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Attempt to handle multiple conditions, but only return\n\t\t * one. Ensure uncorrectable errors are first in the table\n\t\t * to match.\n\t\t */\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].dar_valid)\n\t\t\t*addr = regs->dar;\n\t\telse if (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t/*\n\t\t\t * We do a maximum of 4 nested MCE calls, see\n\t\t\t * kernel/exception-64s.h\n\t\t\t */\n\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH)\n\t\t\t\tmce_find_instr_ea_and_phys(regs, addr,\n\t\t\t\t\t\t\t   phys_addr);\n\t\t}\n\t\tfound = 1;\n\t}\n\n\tif (found)\n\t\treturn handled;\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRR1_MC_LOADSTORE",
          "args": [
            "srr1"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_error(struct pt_regs *regs,\n\t\tconst struct mce_derror_table dtable[],\n\t\tconst struct mce_ierror_table itable[])\n{\n\tstruct mce_error_info mce_err = { 0 };\n\tuint64_t addr, phys_addr = ULONG_MAX;\n\tuint64_t srr1 = regs->msr;\n\tlong handled;\n\n\tif (SRR1_MC_LOADSTORE(srr1))\n\t\thandled = mce_handle_derror(regs, dtable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\telse\n\t\thandled = mce_handle_ierror(regs, itable, &mce_err, &addr,\n\t\t\t\t&phys_addr);\n\n\tif (!handled && mce_err.error_type == MCE_ERROR_TYPE_UE)\n\t\thandled = mce_handle_ue_error(regs, &mce_err);\n\n\tsave_mce_event(regs, handled, &mce_err, regs->nip, addr, phys_addr);\n\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_ue_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "662-683",
    "snippet": "static long mce_handle_ue_error(struct pt_regs *regs,\n\t\t\t\tstruct mce_error_info *mce_err)\n{\n\tlong handled = 0;\n\n\tmce_common_process_ue(regs, mce_err);\n\tif (mce_err->ignore_event)\n\t\treturn 1;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.mce_check_early_recovery",
          "args": [
            "regs"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_common_process_ue",
          "args": [
            "regs",
            "mce_err"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "mce_common_process_ue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "271-281",
          "snippet": "void mce_common_process_ue(struct pt_regs *regs,\n\t\t\t   struct mce_error_info *mce_err)\n{\n\tconst struct exception_table_entry *entry;\n\n\tentry = search_kernel_exception_table(regs->nip);\n\tif (entry) {\n\t\tmce_err->ignore_event = true;\n\t\tregs->nip = extable_fixup(entry);\n\t}\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nvoid mce_common_process_ue(struct pt_regs *regs,\n\t\t\t   struct mce_error_info *mce_err)\n{\n\tconst struct exception_table_entry *entry;\n\n\tentry = search_kernel_exception_table(regs->nip);\n\tif (entry) {\n\t\tmce_err->ignore_event = true;\n\t\tregs->nip = extable_fixup(entry);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic long mce_handle_ue_error(struct pt_regs *regs,\n\t\t\t\tstruct mce_error_info *mce_err)\n{\n\tlong handled = 0;\n\n\tmce_common_process_ue(regs, mce_err);\n\tif (mce_err->ignore_event)\n\t\treturn 1;\n\n\t/*\n\t * On specific SCOM read via MMIO we may get a machine check\n\t * exception with SRR0 pointing inside opal. If that is the\n\t * case OPAL may have recovery address to re-read SCOM data in\n\t * different way and hence we can recover from this MC.\n\t */\n\n\tif (ppc_md.mce_check_early_recovery) {\n\t\tif (ppc_md.mce_check_early_recovery(regs))\n\t\t\thandled = 1;\n\t}\n\treturn handled;\n}"
  },
  {
    "function_name": "mce_handle_derror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "564-660",
    "snippet": "static int mce_handle_derror(struct pt_regs *regs,\n\t\tconst struct mce_derror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t dsisr = regs->dsisr;\n\tint handled = 0;\n\tint found = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].dsisr_value; i++) {\n\t\tif (!(dsisr & table[i].dsisr_value))\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\tif (mce_flush(MCE_FLUSH_SLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tif (mce_flush(MCE_FLUSH_ERAT))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tif (mce_flush(MCE_FLUSH_TLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Attempt to handle multiple conditions, but only return\n\t\t * one. Ensure uncorrectable errors are first in the table\n\t\t * to match.\n\t\t */\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].dar_valid)\n\t\t\t*addr = regs->dar;\n\t\telse if (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t/*\n\t\t\t * We do a maximum of 4 nested MCE calls, see\n\t\t\t * kernel/exception-64s.h\n\t\t\t */\n\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH)\n\t\t\t\tmce_find_instr_ea_and_phys(regs, addr,\n\t\t\t\t\t\t\t   phys_addr);\n\t\t}\n\t\tfound = 1;\n\t}\n\n\tif (found)\n\t\treturn handled;\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MCE_FLUSH_ERAT 3",
      "#define MCE_FLUSH_TLB 2",
      "#define MCE_FLUSH_SLB 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_find_instr_ea_and_phys",
          "args": [
            "regs",
            "addr",
            "phys_addr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "mce_find_instr_ea_and_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "443-476",
          "snippet": "static int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,\n\t\t\t\t\tuint64_t *phys_addr)\n{\n\t/*\n\t * Carefully look at the NIP to determine\n\t * the instruction to analyse. Reading the NIP\n\t * in real-mode is tricky and can lead to recursive\n\t * faults\n\t */\n\tstruct ppc_inst instr;\n\tunsigned long pfn, instr_addr;\n\tstruct instruction_op op;\n\tstruct pt_regs tmp = *regs;\n\n\tpfn = addr_to_pfn(regs, regs->nip);\n\tif (pfn != ULONG_MAX) {\n\t\tinstr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);\n\t\tinstr = ppc_inst_read((struct ppc_inst *)instr_addr);\n\t\tif (!analyse_instr(&op, &tmp, instr)) {\n\t\t\tpfn = addr_to_pfn(regs, op.ea);\n\t\t\t*addr = op.ea;\n\t\t\t*phys_addr = (pfn << PAGE_SHIFT);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * analyse_instr() might fail if the instruction\n\t\t * is not a load/store, although this is unexpected\n\t\t * for load/store errors or if we got the NIP\n\t\t * wrong\n\t\t */\n\t}\n\t*addr = 0;\n\treturn -1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,\n\t\t\t\t\tuint64_t *phys_addr)\n{\n\t/*\n\t * Carefully look at the NIP to determine\n\t * the instruction to analyse. Reading the NIP\n\t * in real-mode is tricky and can lead to recursive\n\t * faults\n\t */\n\tstruct ppc_inst instr;\n\tunsigned long pfn, instr_addr;\n\tstruct instruction_op op;\n\tstruct pt_regs tmp = *regs;\n\n\tpfn = addr_to_pfn(regs, regs->nip);\n\tif (pfn != ULONG_MAX) {\n\t\tinstr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);\n\t\tinstr = ppc_inst_read((struct ppc_inst *)instr_addr);\n\t\tif (!analyse_instr(&op, &tmp, instr)) {\n\t\t\tpfn = addr_to_pfn(regs, op.ea);\n\t\t\t*addr = op.ea;\n\t\t\t*phys_addr = (pfn << PAGE_SHIFT);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * analyse_instr() might fail if the instruction\n\t\t * is not a load/store, although this is unexpected\n\t\t * for load/store errors or if we got the NIP\n\t\t * wrong\n\t\t */\n\t}\n\t*addr = 0;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_flush",
          "args": [
            "MCE_FLUSH_TLB"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "mce_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "109-127",
          "snippet": "static int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MCE_FLUSH_ERAT 3",
            "#define MCE_FLUSH_TLB 2",
            "#define MCE_FLUSH_SLB 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slb_save_contents",
          "args": [
            "local_paca->mce_faulty_slbs"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_handle_derror(struct pt_regs *regs,\n\t\tconst struct mce_derror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t dsisr = regs->dsisr;\n\tint handled = 0;\n\tint found = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].dsisr_value; i++) {\n\t\tif (!(dsisr & table[i].dsisr_value))\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\tif (mce_flush(MCE_FLUSH_SLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tif (mce_flush(MCE_FLUSH_ERAT))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tif (mce_flush(MCE_FLUSH_TLB))\n\t\t\t\thandled = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Attempt to handle multiple conditions, but only return\n\t\t * one. Ensure uncorrectable errors are first in the table\n\t\t * to match.\n\t\t */\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].dar_valid)\n\t\t\t*addr = regs->dar;\n\t\telse if (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t/*\n\t\t\t * We do a maximum of 4 nested MCE calls, see\n\t\t\t * kernel/exception-64s.h\n\t\t\t */\n\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH)\n\t\t\t\tmce_find_instr_ea_and_phys(regs, addr,\n\t\t\t\t\t\t\t   phys_addr);\n\t\t}\n\t\tfound = 1;\n\t}\n\n\tif (found)\n\t\treturn handled;\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mce_handle_ierror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "478-562",
    "snippet": "static int mce_handle_ierror(struct pt_regs *regs,\n\t\tconst struct mce_ierror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t srr1 = regs->msr;\n\tint handled = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].srr1_mask; i++) {\n\t\tif ((srr1 & table[i].srr1_mask) != table[i].srr1_value)\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\thandled = mce_flush(MCE_FLUSH_SLB);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\thandled = mce_flush(MCE_FLUSH_ERAT);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\thandled = mce_flush(MCE_FLUSH_TLB);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].nip_valid) {\n\t\t\t*addr = regs->nip;\n\t\t\tif (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH) {\n\t\t\t\t\tpfn = addr_to_pfn(regs, regs->nip);\n\t\t\t\t\tif (pfn != ULONG_MAX) {\n\t\t\t\t\t\t*phys_addr =\n\t\t\t\t\t\t\t(pfn << PAGE_SHIFT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handled;\n\t}\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MCE_FLUSH_ERAT 3",
      "#define MCE_FLUSH_TLB 2",
      "#define MCE_FLUSH_SLB 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_to_pfn",
          "args": [
            "regs",
            "regs->nip"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "29-63",
          "snippet": "unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nunsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mce_flush",
          "args": [
            "MCE_FLUSH_TLB"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "mce_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "109-127",
          "snippet": "static int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MCE_FLUSH_ERAT 3",
            "#define MCE_FLUSH_TLB 2",
            "#define MCE_FLUSH_SLB 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slb_save_contents",
          "args": [
            "local_paca->mce_faulty_slbs"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_handle_ierror(struct pt_regs *regs,\n\t\tconst struct mce_ierror_table table[],\n\t\tstruct mce_error_info *mce_err, uint64_t *addr,\n\t\tuint64_t *phys_addr)\n{\n\tuint64_t srr1 = regs->msr;\n\tint handled = 0;\n\tint i;\n\n\t*addr = 0;\n\n\tfor (i = 0; table[i].srr1_mask; i++) {\n\t\tif ((srr1 & table[i].srr1_mask) != table[i].srr1_value)\n\t\t\tcontinue;\n\n\t\t/* attempt to correct the error */\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tif (local_paca->in_mce == 1)\n\t\t\t\tslb_save_contents(local_paca->mce_faulty_slbs);\n\t\t\thandled = mce_flush(MCE_FLUSH_SLB);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\thandled = mce_flush(MCE_FLUSH_ERAT);\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\thandled = mce_flush(MCE_FLUSH_TLB);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* now fill in mce_error_info */\n\t\tmce_err->error_type = table[i].error_type;\n\t\tmce_err->error_class = table[i].error_class;\n\t\tswitch (table[i].error_type) {\n\t\tcase MCE_ERROR_TYPE_UE:\n\t\t\tmce_err->u.ue_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_SLB:\n\t\t\tmce_err->u.slb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_ERAT:\n\t\t\tmce_err->u.erat_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_TLB:\n\t\t\tmce_err->u.tlb_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_USER:\n\t\t\tmce_err->u.user_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_RA:\n\t\t\tmce_err->u.ra_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\tcase MCE_ERROR_TYPE_LINK:\n\t\t\tmce_err->u.link_error_type = table[i].error_subtype;\n\t\t\tbreak;\n\t\t}\n\t\tmce_err->sync_error = table[i].sync_error;\n\t\tmce_err->severity = table[i].severity;\n\t\tmce_err->initiator = table[i].initiator;\n\t\tif (table[i].nip_valid) {\n\t\t\t*addr = regs->nip;\n\t\t\tif (mce_err->sync_error &&\n\t\t\t\ttable[i].error_type == MCE_ERROR_TYPE_UE) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tif (get_paca()->in_mce < MAX_MCE_DEPTH) {\n\t\t\t\t\tpfn = addr_to_pfn(regs, regs->nip);\n\t\t\t\t\tif (pfn != ULONG_MAX) {\n\t\t\t\t\t\t*phys_addr =\n\t\t\t\t\t\t\t(pfn << PAGE_SHIFT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handled;\n\t}\n\n\tmce_err->error_type = MCE_ERROR_TYPE_UNKNOWN;\n\tmce_err->error_class = MCE_ECLASS_UNKNOWN;\n\tmce_err->severity = MCE_SEV_SEVERE;\n\tmce_err->initiator = MCE_INITIATOR_CPU;\n\tmce_err->sync_error = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mce_find_instr_ea_and_phys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "443-476",
    "snippet": "static int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,\n\t\t\t\t\tuint64_t *phys_addr)\n{\n\t/*\n\t * Carefully look at the NIP to determine\n\t * the instruction to analyse. Reading the NIP\n\t * in real-mode is tricky and can lead to recursive\n\t * faults\n\t */\n\tstruct ppc_inst instr;\n\tunsigned long pfn, instr_addr;\n\tstruct instruction_op op;\n\tstruct pt_regs tmp = *regs;\n\n\tpfn = addr_to_pfn(regs, regs->nip);\n\tif (pfn != ULONG_MAX) {\n\t\tinstr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);\n\t\tinstr = ppc_inst_read((struct ppc_inst *)instr_addr);\n\t\tif (!analyse_instr(&op, &tmp, instr)) {\n\t\t\tpfn = addr_to_pfn(regs, op.ea);\n\t\t\t*addr = op.ea;\n\t\t\t*phys_addr = (pfn << PAGE_SHIFT);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * analyse_instr() might fail if the instruction\n\t\t * is not a load/store, although this is unexpected\n\t\t * for load/store errors or if we got the NIP\n\t\t * wrong\n\t\t */\n\t}\n\t*addr = 0;\n\treturn -1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_to_pfn",
          "args": [
            "regs",
            "op.ea"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "29-63",
          "snippet": "unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nunsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "analyse_instr",
          "args": [
            "&op",
            "&tmp",
            "instr"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)instr_addr"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic int mce_find_instr_ea_and_phys(struct pt_regs *regs, uint64_t *addr,\n\t\t\t\t\tuint64_t *phys_addr)\n{\n\t/*\n\t * Carefully look at the NIP to determine\n\t * the instruction to analyse. Reading the NIP\n\t * in real-mode is tricky and can lead to recursive\n\t * faults\n\t */\n\tstruct ppc_inst instr;\n\tunsigned long pfn, instr_addr;\n\tstruct instruction_op op;\n\tstruct pt_regs tmp = *regs;\n\n\tpfn = addr_to_pfn(regs, regs->nip);\n\tif (pfn != ULONG_MAX) {\n\t\tinstr_addr = (pfn << PAGE_SHIFT) + (regs->nip & ~PAGE_MASK);\n\t\tinstr = ppc_inst_read((struct ppc_inst *)instr_addr);\n\t\tif (!analyse_instr(&op, &tmp, instr)) {\n\t\t\tpfn = addr_to_pfn(regs, op.ea);\n\t\t\t*addr = op.ea;\n\t\t\t*phys_addr = (pfn << PAGE_SHIFT);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * analyse_instr() might fail if the instruction\n\t\t * is not a load/store, although this is unexpected\n\t\t * for load/store errors or if we got the NIP\n\t\t * wrong\n\t\t */\n\t}\n\t*addr = 0;\n\treturn -1;\n}"
  },
  {
    "function_name": "mce_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "109-127",
    "snippet": "static int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MCE_FLUSH_ERAT 3",
      "#define MCE_FLUSH_TLB 2",
      "#define MCE_FLUSH_SLB 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlbiel_all",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_erat",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "flush_erat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "94-103",
          "snippet": "static void flush_erat(void)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (!early_cpu_has_feature(CPU_FTR_ARCH_300)) {\n\t\tflush_and_reload_slb();\n\t\treturn;\n\t}\n#endif\n\tasm volatile(PPC_ISA_3_0_INVALIDATE_ERAT : : :\"memory\");\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_erat(void)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (!early_cpu_has_feature(CPU_FTR_ARCH_300)) {\n\t\tflush_and_reload_slb();\n\t\treturn;\n\t}\n#endif\n\tasm volatile(PPC_ISA_3_0_INVALIDATE_ERAT : : :\"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "67-91",
          "snippet": "void flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\n#define MCE_FLUSH_ERAT 3\n#define MCE_FLUSH_TLB 2\n#define MCE_FLUSH_SLB 1\n\nstatic int mce_flush(int what)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (what == MCE_FLUSH_SLB) {\n\t\tflush_and_reload_slb();\n\t\treturn 1;\n\t}\n#endif\n\tif (what == MCE_FLUSH_ERAT) {\n\t\tflush_erat();\n\t\treturn 1;\n\t}\n\tif (what == MCE_FLUSH_TLB) {\n\t\ttlbiel_all();\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_erat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "94-103",
    "snippet": "static void flush_erat(void)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (!early_cpu_has_feature(CPU_FTR_ARCH_300)) {\n\t\tflush_and_reload_slb();\n\t\treturn;\n\t}\n#endif\n\tasm volatile(PPC_ISA_3_0_INVALIDATE_ERAT : : :\"memory\");\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_and_reload_slb",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "flush_and_reload_slb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
          "lines": "67-91",
          "snippet": "void flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/extable.h>",
            "#include <asm/exception-64s.h>",
            "#include <asm/sstep.h>",
            "#include <asm/pte-walk.h>",
            "#include <asm/machdep.h>",
            "#include <asm/mce.h>",
            "#include <asm/mmu.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/extable.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_300"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic void flush_erat(void)\n{\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (!early_cpu_has_feature(CPU_FTR_ARCH_300)) {\n\t\tflush_and_reload_slb();\n\t\treturn;\n\t}\n#endif\n\tasm volatile(PPC_ISA_3_0_INVALIDATE_ERAT : : :\"memory\");\n}"
  },
  {
    "function_name": "flush_and_reload_slb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "67-91",
    "snippet": "void flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slb_restore_bolted_realmode",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_slb_shadow",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_radix_enabled",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slb_flush_all_realmode",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid flush_and_reload_slb(void)\n{\n\t/* Invalidate all SLBs */\n\tslb_flush_all_realmode();\n\n#ifdef CONFIG_KVM_BOOK3S_HANDLER\n\t/*\n\t * If machine check is hit when in guest or in transition, we will\n\t * only flush the SLBs and continue.\n\t */\n\tif (get_paca()->kvm_hstate.in_guest)\n\t\treturn;\n#endif\n\tif (early_radix_enabled())\n\t\treturn;\n\n\t/*\n\t * This probably shouldn't happen, but it may be possible it's\n\t * called in early boot before SLB shadows are allocated.\n\t */\n\tif (!get_slb_shadow())\n\t\treturn;\n\n\tslb_restore_bolted_realmode();\n}"
  },
  {
    "function_name": "addr_to_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce_power.c",
    "lines": "29-63",
    "snippet": "unsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/extable.h>",
      "#include <asm/exception-64s.h>",
      "#include <asm/sstep.h>",
      "#include <asm/pte-walk.h>",
      "#include <asm/machdep.h>",
      "#include <asm/mce.h>",
      "#include <asm/mmu.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/extable.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "__pte(pte_val(pte) | (addr & rpnmask))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pte",
          "args": [
            "pte_val(pte) | (addr & rpnmask)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_val",
          "args": [
            "pte"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_special",
          "args": [
            "pte"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ptep"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_linux_pte",
          "args": [
            "mm->pgd",
            "addr",
            "NULL",
            "&shift"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/extable.h>\n#include <asm/exception-64s.h>\n#include <asm/sstep.h>\n#include <asm/pte-walk.h>\n#include <asm/machdep.h>\n#include <asm/mce.h>\n#include <asm/mmu.h>\n#include <linux/pgtable.h>\n#include <linux/extable.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nunsigned long addr_to_pfn(struct pt_regs *regs, unsigned long addr)\n{\n\tpte_t *ptep, pte;\n\tunsigned int shift;\n\tunsigned long pfn, flags;\n\tstruct mm_struct *mm;\n\n\tif (user_mode(regs))\n\t\tmm = current->mm;\n\telse\n\t\tmm = &init_mm;\n\n\tlocal_irq_save(flags);\n\tptep = __find_linux_pte(mm->pgd, addr, NULL, &shift);\n\tif (!ptep) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\tpte = READ_ONCE(*ptep);\n\n\tif (!pte_present(pte) || pte_special(pte)) {\n\t\tpfn = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\tif (shift <= PAGE_SHIFT)\n\t\tpfn = pte_pfn(pte);\n\telse {\n\t\tunsigned long rpnmask = (1ul << shift) - PAGE_SIZE;\n\t\tpfn = pte_pfn(__pte(pte_val(pte) | (addr & rpnmask)));\n\t}\nout:\n\tlocal_irq_restore(flags);\n\treturn pfn;\n}"
  }
]