[
  {
    "function_name": "check_legacy_serial_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "575-653",
    "snippet": "static int __init check_legacy_serial_console(void)\n{\n\tstruct device_node *prom_stdout = NULL;\n\tint i, speed = 0, offset = 0;\n\tconst char *name;\n\tconst __be32 *spd;\n\n\tDBG(\" -> check_legacy_serial_console()\\n\");\n\n\t/* The user has requested a console so this is already set up. */\n\tif (strstr(boot_command_line, \"console=\")) {\n\t\tDBG(\" console was specified !\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!of_chosen) {\n\t\tDBG(\" of_chosen is NULL !\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (legacy_serial_console < 0) {\n\t\tDBG(\" legacy_serial_console not found !\\n\");\n\t\treturn -ENODEV;\n\t}\n\t/* We are getting a weird phandle from OF ... */\n\t/* ... So use the full path instead */\n\tname = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (name == NULL)\n\t\tname = of_get_property(of_chosen, \"stdout-path\", NULL);\n\tif (name == NULL) {\n\t\tDBG(\" no stdout-path !\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprom_stdout = of_find_node_by_path(name);\n\tif (!prom_stdout) {\n\t\tDBG(\" can't find stdout package %s !\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\tDBG(\"stdout is %pOF\\n\", prom_stdout);\n\n\tname = of_get_property(prom_stdout, \"name\", NULL);\n\tif (!name) {\n\t\tDBG(\" stdout package has no name !\\n\");\n\t\tgoto not_found;\n\t}\n\tspd = of_get_property(prom_stdout, \"current-speed\", NULL);\n\tif (spd)\n\t\tspeed = be32_to_cpup(spd);\n\n\tif (strcmp(name, \"serial\") != 0)\n\t\tgoto not_found;\n\n\t/* Look for it in probed array */\n\tfor (i = 0; i < legacy_serial_count; i++) {\n\t\tif (prom_stdout != legacy_serial_infos[i].np)\n\t\t\tcontinue;\n\t\toffset = i;\n\t\tspeed = legacy_serial_infos[i].speed;\n\t\tbreak;\n\t}\n\tif (i >= legacy_serial_count)\n\t\tgoto not_found;\n\n\tof_node_put(prom_stdout);\n\n\tDBG(\"Found serial console at ttyS%d\\n\", offset);\n\n\tif (speed) {\n\t\tstatic char __initdata opt[16];\n\t\tsprintf(opt, \"%d\", speed);\n\t\treturn add_preferred_console(\"ttyS\", offset, opt);\n\t} else\n\t\treturn add_preferred_console(\"ttyS\", offset, NULL);\n\n not_found:\n\tDBG(\"No preferred console found !\\n\");\n\tof_node_put(prom_stdout);\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
      "static unsigned int legacy_serial_count;",
      "static int legacy_serial_console = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "prom_stdout"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"No preferred console found !\\n\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_preferred_console",
          "args": [
            "\"ttyS\"",
            "offset",
            "NULL"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_preferred_console",
          "args": [
            "\"ttyS\"",
            "offset",
            "opt"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "opt",
            "\"%d\"",
            "speed"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Found serial console at ttyS%d\\n\"",
            "offset"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "prom_stdout"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"serial\""
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "spd"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "prom_stdout",
            "\"current-speed\"",
            "NULL"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" stdout package has no name !\\n\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "prom_stdout",
            "\"name\"",
            "NULL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"stdout is %pOF\\n\"",
            "prom_stdout"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" can't find stdout package %s !\\n\"",
            "name"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "name"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" no stdout-path !\\n\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_chosen",
            "\"stdout-path\"",
            "NULL"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_chosen",
            "\"linux,stdout-path\"",
            "NULL"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" legacy_serial_console not found !\\n\""
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" of_chosen is NULL !\\n\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" console was specified !\\n\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "boot_command_line",
            "\"console=\""
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "290-305",
          "snippet": "static char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> check_legacy_serial_console()\\n\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\nstatic int legacy_serial_console = -1;\n\nstatic int __init check_legacy_serial_console(void)\n{\n\tstruct device_node *prom_stdout = NULL;\n\tint i, speed = 0, offset = 0;\n\tconst char *name;\n\tconst __be32 *spd;\n\n\tDBG(\" -> check_legacy_serial_console()\\n\");\n\n\t/* The user has requested a console so this is already set up. */\n\tif (strstr(boot_command_line, \"console=\")) {\n\t\tDBG(\" console was specified !\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!of_chosen) {\n\t\tDBG(\" of_chosen is NULL !\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (legacy_serial_console < 0) {\n\t\tDBG(\" legacy_serial_console not found !\\n\");\n\t\treturn -ENODEV;\n\t}\n\t/* We are getting a weird phandle from OF ... */\n\t/* ... So use the full path instead */\n\tname = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (name == NULL)\n\t\tname = of_get_property(of_chosen, \"stdout-path\", NULL);\n\tif (name == NULL) {\n\t\tDBG(\" no stdout-path !\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprom_stdout = of_find_node_by_path(name);\n\tif (!prom_stdout) {\n\t\tDBG(\" can't find stdout package %s !\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\tDBG(\"stdout is %pOF\\n\", prom_stdout);\n\n\tname = of_get_property(prom_stdout, \"name\", NULL);\n\tif (!name) {\n\t\tDBG(\" stdout package has no name !\\n\");\n\t\tgoto not_found;\n\t}\n\tspd = of_get_property(prom_stdout, \"current-speed\", NULL);\n\tif (spd)\n\t\tspeed = be32_to_cpup(spd);\n\n\tif (strcmp(name, \"serial\") != 0)\n\t\tgoto not_found;\n\n\t/* Look for it in probed array */\n\tfor (i = 0; i < legacy_serial_count; i++) {\n\t\tif (prom_stdout != legacy_serial_infos[i].np)\n\t\t\tcontinue;\n\t\toffset = i;\n\t\tspeed = legacy_serial_infos[i].speed;\n\t\tbreak;\n\t}\n\tif (i >= legacy_serial_count)\n\t\tgoto not_found;\n\n\tof_node_put(prom_stdout);\n\n\tDBG(\"Found serial console at ttyS%d\\n\", offset);\n\n\tif (speed) {\n\t\tstatic char __initdata opt[16];\n\t\tsprintf(opt, \"%d\", speed);\n\t\treturn add_preferred_console(\"ttyS\", offset, opt);\n\t} else\n\t\treturn add_preferred_console(\"ttyS\", offset, NULL);\n\n not_found:\n\tDBG(\"No preferred console found !\\n\");\n\tof_node_put(prom_stdout);\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "serial_dev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "535-563",
    "snippet": "static int __init serial_dev_init(void)\n{\n\tint i;\n\n\tif (legacy_serial_count == 0)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Before we register the platform serial devices, we need\n\t * to fixup their interrupts and their IO ports.\n\t */\n\tDBG(\"Fixing serial ports interrupts and IO ports ...\\n\");\n\n\tfor (i = 0; i < legacy_serial_count; i++) {\n\t\tstruct plat_serial8250_port *port = &legacy_serial_ports[i];\n\t\tstruct device_node *np = legacy_serial_infos[i].np;\n\n\t\tif (!port->irq)\n\t\t\tfixup_port_irq(i, np, port);\n\t\tif (port->iotype == UPIO_PORT)\n\t\t\tfixup_port_pio(i, np, port);\n\t\tif ((port->iotype == UPIO_MEM) || (port->iotype == UPIO_TSI))\n\t\t\tfixup_port_mmio(i, np, port);\n\t}\n\n\tDBG(\"Registering platform serial ports\\n\");\n\n\treturn platform_device_register(&serial_device);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
      "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
      "static unsigned int legacy_serial_count;",
      "static struct platform_device serial_device = {\n\t.name\t= \"serial8250\",\n\t.id\t= PLAT8250_DEV_PLATFORM,\n\t.dev\t= {\n\t\t.platform_data = legacy_serial_ports,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "platform_device_register",
          "args": [
            "&serial_device"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Registering platform serial ports\\n\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_port_mmio",
          "args": [
            "i",
            "np",
            "port"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_port_mmio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "513-520",
          "snippet": "static void __init fixup_port_mmio(int index,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct plat_serial8250_port *port)\n{\n\tDBG(\"fixup_port_mmio(%d)\\n\", index);\n\n\tport->membase = ioremap(port->mapbase, 0x100);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic void __init fixup_port_mmio(int index,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct plat_serial8250_port *port)\n{\n\tDBG(\"fixup_port_mmio(%d)\\n\", index);\n\n\tport->membase = ioremap(port->mapbase, 0x100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_port_pio",
          "args": [
            "i",
            "np",
            "port"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_port_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "489-511",
          "snippet": "static void __init fixup_port_pio(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n#ifdef CONFIG_PCI\n\tstruct pci_controller *hose;\n\n\tDBG(\"fixup_port_pio(%d)\\n\", index);\n\n\those = pci_find_hose_for_OF_device(np);\n\tif (hose) {\n\t\tunsigned long offset = (unsigned long)hose->io_base_virt -\n#ifdef CONFIG_PPC64\n\t\t\tpci_io_base;\n#else\n\t\t\tisa_io_base;\n#endif\n\t\tDBG(\"port %d, IO %lx -> %lx\\n\",\n\t\t    index, port->iobase, port->iobase + offset);\n\t\tport->iobase += offset;\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic void __init fixup_port_pio(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n#ifdef CONFIG_PCI\n\tstruct pci_controller *hose;\n\n\tDBG(\"fixup_port_pio(%d)\\n\", index);\n\n\those = pci_find_hose_for_OF_device(np);\n\tif (hose) {\n\t\tunsigned long offset = (unsigned long)hose->io_base_virt -\n#ifdef CONFIG_PPC64\n\t\t\tpci_io_base;\n#else\n\t\t\tisa_io_base;\n#endif\n\t\tDBG(\"port %d, IO %lx -> %lx\\n\",\n\t\t    index, port->iobase, port->iobase + offset);\n\t\tport->iobase += offset;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_port_irq",
          "args": [
            "i",
            "np",
            "port"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_port_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "460-487",
          "snippet": "static void __init fixup_port_irq(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n\tunsigned int virq;\n\n\tDBG(\"fixup_port_irq(%d)\\n\", index);\n\n\tvirq = irq_of_parse_and_map(np, 0);\n\tif (!virq && legacy_serial_infos[index].irq_check_parent) {\n\t\tnp = of_get_parent(np);\n\t\tif (np == NULL)\n\t\t\treturn;\n\t\tvirq = irq_of_parse_and_map(np, 0);\n\t\tof_node_put(np);\n\t}\n\tif (!virq)\n\t\treturn;\n\n\tport->irq = virq;\n\n#ifdef CONFIG_SERIAL_8250_FSL\n\tif (of_device_is_compatible(np, \"fsl,ns16550\")) {\n\t\tport->handle_irq = fsl8250_handle_irq;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\n\nstatic void __init fixup_port_irq(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n\tunsigned int virq;\n\n\tDBG(\"fixup_port_irq(%d)\\n\", index);\n\n\tvirq = irq_of_parse_and_map(np, 0);\n\tif (!virq && legacy_serial_infos[index].irq_check_parent) {\n\t\tnp = of_get_parent(np);\n\t\tif (np == NULL)\n\t\t\treturn;\n\t\tvirq = irq_of_parse_and_map(np, 0);\n\t\tof_node_put(np);\n\t}\n\tif (!virq)\n\t\treturn;\n\n\tport->irq = virq;\n\n#ifdef CONFIG_SERIAL_8250_FSL\n\tif (of_device_is_compatible(np, \"fsl,ns16550\")) {\n\t\tport->handle_irq = fsl8250_handle_irq;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Fixing serial ports interrupts and IO ports ...\\n\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\nstatic struct platform_device serial_device = {\n\t.name\t= \"serial8250\",\n\t.id\t= PLAT8250_DEV_PLATFORM,\n\t.dev\t= {\n\t\t.platform_data = legacy_serial_ports,\n\t},\n};\n\nstatic int __init serial_dev_init(void)\n{\n\tint i;\n\n\tif (legacy_serial_count == 0)\n\t\treturn -ENODEV;\n\n\t/*\n\t * Before we register the platform serial devices, we need\n\t * to fixup their interrupts and their IO ports.\n\t */\n\tDBG(\"Fixing serial ports interrupts and IO ports ...\\n\");\n\n\tfor (i = 0; i < legacy_serial_count; i++) {\n\t\tstruct plat_serial8250_port *port = &legacy_serial_ports[i];\n\t\tstruct device_node *np = legacy_serial_infos[i].np;\n\n\t\tif (!port->irq)\n\t\t\tfixup_port_irq(i, np, port);\n\t\tif (port->iotype == UPIO_PORT)\n\t\t\tfixup_port_pio(i, np, port);\n\t\tif ((port->iotype == UPIO_MEM) || (port->iotype == UPIO_TSI))\n\t\t\tfixup_port_mmio(i, np, port);\n\t}\n\n\tDBG(\"Registering platform serial ports\\n\");\n\n\treturn platform_device_register(&serial_device);\n}"
  },
  {
    "function_name": "fixup_port_mmio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "513-520",
    "snippet": "static void __init fixup_port_mmio(int index,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct plat_serial8250_port *port)\n{\n\tDBG(\"fixup_port_mmio(%d)\\n\", index);\n\n\tport->membase = ioremap(port->mapbase, 0x100);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "port->mapbase",
            "0x100"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"fixup_port_mmio(%d)\\n\"",
            "index"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic void __init fixup_port_mmio(int index,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct plat_serial8250_port *port)\n{\n\tDBG(\"fixup_port_mmio(%d)\\n\", index);\n\n\tport->membase = ioremap(port->mapbase, 0x100);\n}"
  },
  {
    "function_name": "fixup_port_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "489-511",
    "snippet": "static void __init fixup_port_pio(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n#ifdef CONFIG_PCI\n\tstruct pci_controller *hose;\n\n\tDBG(\"fixup_port_pio(%d)\\n\", index);\n\n\those = pci_find_hose_for_OF_device(np);\n\tif (hose) {\n\t\tunsigned long offset = (unsigned long)hose->io_base_virt -\n#ifdef CONFIG_PPC64\n\t\t\tpci_io_base;\n#else\n\t\t\tisa_io_base;\n#endif\n\t\tDBG(\"port %d, IO %lx -> %lx\\n\",\n\t\t    index, port->iobase, port->iobase + offset);\n\t\tport->iobase += offset;\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"port %d, IO %lx -> %lx\\n\"",
            "index",
            "port->iobase",
            "port->iobase + offset"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_hose_for_OF_device",
          "args": [
            "np"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "pci_find_hose_for_OF_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "333-343",
          "snippet": "struct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"fixup_port_pio(%d)\\n\"",
            "index"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic void __init fixup_port_pio(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n#ifdef CONFIG_PCI\n\tstruct pci_controller *hose;\n\n\tDBG(\"fixup_port_pio(%d)\\n\", index);\n\n\those = pci_find_hose_for_OF_device(np);\n\tif (hose) {\n\t\tunsigned long offset = (unsigned long)hose->io_base_virt -\n#ifdef CONFIG_PPC64\n\t\t\tpci_io_base;\n#else\n\t\t\tisa_io_base;\n#endif\n\t\tDBG(\"port %d, IO %lx -> %lx\\n\",\n\t\t    index, port->iobase, port->iobase + offset);\n\t\tport->iobase += offset;\n\t}\n#endif\n}"
  },
  {
    "function_name": "fixup_port_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "460-487",
    "snippet": "static void __init fixup_port_irq(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n\tunsigned int virq;\n\n\tDBG(\"fixup_port_irq(%d)\\n\", index);\n\n\tvirq = irq_of_parse_and_map(np, 0);\n\tif (!virq && legacy_serial_infos[index].irq_check_parent) {\n\t\tnp = of_get_parent(np);\n\t\tif (np == NULL)\n\t\t\treturn;\n\t\tvirq = irq_of_parse_and_map(np, 0);\n\t\tof_node_put(np);\n\t}\n\tif (!virq)\n\t\treturn;\n\n\tport->irq = virq;\n\n#ifdef CONFIG_SERIAL_8250_FSL\n\tif (of_device_is_compatible(np, \"fsl,ns16550\")) {\n\t\tport->handle_irq = fsl8250_handle_irq;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SERIAL_8250_CONSOLE"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "np",
            "\"fsl,ns16550\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "np"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_of_parse_and_map",
          "args": [
            "np",
            "0"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_of_parse_and_map",
          "args": [
            "np",
            "0"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"fixup_port_irq(%d)\\n\"",
            "index"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\n\nstatic void __init fixup_port_irq(int index,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct plat_serial8250_port *port)\n{\n\tunsigned int virq;\n\n\tDBG(\"fixup_port_irq(%d)\\n\", index);\n\n\tvirq = irq_of_parse_and_map(np, 0);\n\tif (!virq && legacy_serial_infos[index].irq_check_parent) {\n\t\tnp = of_get_parent(np);\n\t\tif (np == NULL)\n\t\t\treturn;\n\t\tvirq = irq_of_parse_and_map(np, 0);\n\t\tof_node_put(np);\n\t}\n\tif (!virq)\n\t\treturn;\n\n\tport->irq = virq;\n\n#ifdef CONFIG_SERIAL_8250_FSL\n\tif (of_device_is_compatible(np, \"fsl,ns16550\")) {\n\t\tport->handle_irq = fsl8250_handle_irq;\n\t\tport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);\n\t}\n#endif\n}"
  },
  {
    "function_name": "find_legacy_serial_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "365-450",
    "snippet": "void __init find_legacy_serial_ports(void)\n{\n\tstruct device_node *np, *stdout = NULL;\n\tconst char *path;\n\tint index;\n\n\tDBG(\" -> find_legacy_serial_port()\\n\");\n\n\t/* Now find out if one of these is out firmware console */\n\tpath = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (path == NULL)\n\t\tpath = of_get_property(of_chosen, \"stdout-path\", NULL);\n\tif (path != NULL) {\n\t\tstdout = of_find_node_by_path(path);\n\t\tif (stdout)\n\t\t\tDBG(\"stdout is %pOF\\n\", stdout);\n\t} else {\n\t\tDBG(\" no linux,stdout-path !\\n\");\n\t}\n\n\t/* Iterate over all the 16550 ports, looking for known parents */\n\tfor_each_compatible_node(np, \"serial\", \"ns16550\") {\n\t\tstruct device_node *parent = of_get_parent(np);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (of_match_node(legacy_serial_parents, parent) != NULL) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_soc_port(np, np);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(parent);\n\t}\n\n\t/* Next, fill our array with ISA ports */\n\tfor_each_node_by_type(np, \"serial\") {\n\t\tstruct device_node *isa = of_get_parent(np);\n\t\tif (of_node_name_eq(isa, \"isa\") || of_node_name_eq(isa, \"lpc\")) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_isa_port(np, isa);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(isa);\n\t}\n\n#ifdef CONFIG_PCI\n\t/* Next, try to locate PCI ports */\n\tfor (np = NULL; (np = of_find_all_nodes(np));) {\n\t\tstruct device_node *pci, *parent = of_get_parent(np);\n\t\tif (of_node_name_eq(parent, \"isa\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!of_node_name_eq(np, \"serial\") &&\n\t\t    !of_node_is_type(np, \"serial\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check for known pciclass, and also check whether we have\n\t\t * a device with child nodes for ports or not\n\t\t */\n\t\tif (of_device_is_compatible(np, \"pciclass,0700\") ||\n\t\t    of_device_is_compatible(np, \"pciclass,070002\"))\n\t\t\tpci = np;\n\t\telse if (of_device_is_compatible(parent, \"pciclass,0700\") ||\n\t\t\t of_device_is_compatible(parent, \"pciclass,070002\"))\n\t\t\tpci = parent;\n\t\telse {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tindex = add_legacy_pci_port(np, pci);\n\t\tif (index >= 0 && np == stdout)\n\t\t\tlegacy_serial_console = index;\n\t\tof_node_put(parent);\n\t}\n#endif\n\n\tDBG(\"legacy_serial_console = %d\\n\", legacy_serial_console);\n\tif (legacy_serial_console >= 0)\n\t\tsetup_legacy_serial_console(legacy_serial_console);\n\tDBG(\" <- find_legacy_serial_port()\\n\");\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct of_device_id legacy_serial_parents[] __initconst = {\n\t{.type = \"soc\",},\n\t{.type = \"tsi-bridge\",},\n\t{.type = \"opb\", },\n\t{.compatible = \"ibm,opb\",},\n\t{.compatible = \"simple-bus\",},\n\t{.compatible = \"wrs,epld-localbus\",},\n\t{},\n};",
      "static int legacy_serial_console = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" <- find_legacy_serial_port()\\n\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_legacy_serial_console",
          "args": [
            "legacy_serial_console"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "setup_legacy_serial_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "324-354",
          "snippet": "static void __init setup_legacy_serial_console(int console)\n{\n\tstruct legacy_serial_info *info = &legacy_serial_infos[console];\n\tstruct plat_serial8250_port *port = &legacy_serial_ports[console];\n\tvoid __iomem *addr;\n\tunsigned int stride;\n\n\tstride = 1 << port->regshift;\n\n\t/* Check if a translated MMIO address has been found */\n\tif (info->taddr) {\n\t\taddr = ioremap(info->taddr, 0x1000);\n\t\tif (addr == NULL)\n\t\t\treturn;\n\t\tudbg_uart_init_mmio(addr, stride);\n\t} else {\n\t\t/* Check if it's PIO and we support untranslated PIO */\n\t\tif (port->iotype == UPIO_PORT && isa_io_special)\n\t\t\tudbg_uart_init_pio(port->iobase, stride);\n\t\telse\n\t\t\treturn;\n\t}\n\n\t/* Try to query the current speed */\n\tif (info->speed == 0)\n\t\tinfo->speed = udbg_probe_uart_speed(info->clock);\n\n\t/* Set it up */\n\tDBG(\"default console speed = %d\\n\", info->speed);\n\tudbg_uart_setup(info->speed, info->clock);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
            "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\n\nstatic void __init setup_legacy_serial_console(int console)\n{\n\tstruct legacy_serial_info *info = &legacy_serial_infos[console];\n\tstruct plat_serial8250_port *port = &legacy_serial_ports[console];\n\tvoid __iomem *addr;\n\tunsigned int stride;\n\n\tstride = 1 << port->regshift;\n\n\t/* Check if a translated MMIO address has been found */\n\tif (info->taddr) {\n\t\taddr = ioremap(info->taddr, 0x1000);\n\t\tif (addr == NULL)\n\t\t\treturn;\n\t\tudbg_uart_init_mmio(addr, stride);\n\t} else {\n\t\t/* Check if it's PIO and we support untranslated PIO */\n\t\tif (port->iotype == UPIO_PORT && isa_io_special)\n\t\t\tudbg_uart_init_pio(port->iobase, stride);\n\t\telse\n\t\t\treturn;\n\t}\n\n\t/* Try to query the current speed */\n\tif (info->speed == 0)\n\t\tinfo->speed = udbg_probe_uart_speed(info->clock);\n\n\t/* Set it up */\n\tDBG(\"default console speed = %d\\n\", info->speed);\n\tudbg_uart_setup(info->speed, info->clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"legacy_serial_console = %d\\n\"",
            "legacy_serial_console"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_legacy_pci_port",
          "args": [
            "np",
            "pci"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_pci_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "252-321",
          "snippet": "static int __init add_legacy_pci_port(struct device_node *np,\n\t\t\t\t      struct device_node *pci_dev)\n{\n\tu64 addr, base;\n\tconst __be32 *addrp;\n\tunsigned int flags;\n\tint iotype, index = -1, lindex = 0;\n\n\tDBG(\" -> add_legacy_pci_port(%pOF)\\n\", np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree (that is have an fcode). Anything\n\t * else can't be used that early and will be normally probed by\n\t * the generic 8250_pci driver later on. The reason is that 8250\n\t * compatible UARTs on PCI need all sort of quirks (port offsets\n\t * etc...) that this code doesn't know about\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* Get the PCI address. Assume BAR 0 */\n\taddrp = of_get_pci_address(pci_dev, 0, NULL, &flags);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\t/* We only support BAR 0 for now */\n\tiotype = (flags & IORESOURCE_MEM) ? UPIO_MEM : UPIO_PORT;\n\taddr = of_translate_address(pci_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Set the IO base to the same as the translated address for MMIO,\n\t * or to the domain local IO base for PIO (it will be fixed up later)\n\t */\n\tif (iotype == UPIO_MEM)\n\t\tbase = addr;\n\telse\n\t\tbase = of_read_number(&addrp[2], 1);\n\n\t/* Try to guess an index... If we have subdevices of the pci dev,\n\t * we get to their \"reg\" property\n\t */\n\tif (np != pci_dev) {\n\t\tconst __be32 *reg = of_get_property(np, \"reg\", NULL);\n\t\tif (reg && (be32_to_cpup(reg) < 4))\n\t\t\tindex = lindex = be32_to_cpup(reg);\n\t}\n\n\t/* Local index means it's the Nth port in the PCI chip. Unfortunately\n\t * the offset to add here is device specific. We know about those\n\t * EXAR ports and we default to the most common case. If your UART\n\t * doesn't work for these settings, you'll have to add your own special\n\t * cases here\n\t */\n\tif (of_device_is_compatible(pci_dev, \"pci13a8,152\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,154\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,158\")) {\n\t\taddr += 0x200 * lindex;\n\t\tbase += 0x200 * lindex;\n\t} else {\n\t\taddr += 8 * lindex;\n\t\tbase += 8 * lindex;\n\t}\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\treturn add_legacy_port(np, index, iotype, base, addr, 0,\n\t\t\t       legacy_port_flags, np != pci_dev);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_pci_port(struct device_node *np,\n\t\t\t\t      struct device_node *pci_dev)\n{\n\tu64 addr, base;\n\tconst __be32 *addrp;\n\tunsigned int flags;\n\tint iotype, index = -1, lindex = 0;\n\n\tDBG(\" -> add_legacy_pci_port(%pOF)\\n\", np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree (that is have an fcode). Anything\n\t * else can't be used that early and will be normally probed by\n\t * the generic 8250_pci driver later on. The reason is that 8250\n\t * compatible UARTs on PCI need all sort of quirks (port offsets\n\t * etc...) that this code doesn't know about\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* Get the PCI address. Assume BAR 0 */\n\taddrp = of_get_pci_address(pci_dev, 0, NULL, &flags);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\t/* We only support BAR 0 for now */\n\tiotype = (flags & IORESOURCE_MEM) ? UPIO_MEM : UPIO_PORT;\n\taddr = of_translate_address(pci_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Set the IO base to the same as the translated address for MMIO,\n\t * or to the domain local IO base for PIO (it will be fixed up later)\n\t */\n\tif (iotype == UPIO_MEM)\n\t\tbase = addr;\n\telse\n\t\tbase = of_read_number(&addrp[2], 1);\n\n\t/* Try to guess an index... If we have subdevices of the pci dev,\n\t * we get to their \"reg\" property\n\t */\n\tif (np != pci_dev) {\n\t\tconst __be32 *reg = of_get_property(np, \"reg\", NULL);\n\t\tif (reg && (be32_to_cpup(reg) < 4))\n\t\t\tindex = lindex = be32_to_cpup(reg);\n\t}\n\n\t/* Local index means it's the Nth port in the PCI chip. Unfortunately\n\t * the offset to add here is device specific. We know about those\n\t * EXAR ports and we default to the most common case. If your UART\n\t * doesn't work for these settings, you'll have to add your own special\n\t * cases here\n\t */\n\tif (of_device_is_compatible(pci_dev, \"pci13a8,152\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,154\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,158\")) {\n\t\taddr += 0x200 * lindex;\n\t\tbase += 0x200 * lindex;\n\t} else {\n\t\taddr += 8 * lindex;\n\t\tbase += 8 * lindex;\n\t}\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\treturn add_legacy_port(np, index, iotype, base, addr, 0,\n\t\t\t       legacy_port_flags, np != pci_dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "parent",
            "\"pciclass,070002\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "parent",
            "\"pciclass,0700\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "np",
            "\"pciclass,070002\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "np",
            "\"pciclass,0700\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "np",
            "\"serial\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_name_eq",
          "args": [
            "np",
            "\"serial\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_name_eq",
          "args": [
            "parent",
            "\"isa\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_all_nodes",
          "args": [
            "np"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "isa"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_legacy_isa_port",
          "args": [
            "np",
            "isa"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_isa_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "203-249",
          "snippet": "static int __init add_legacy_isa_port(struct device_node *np,\n\t\t\t\t      struct device_node *isa_brg)\n{\n\tconst __be32 *reg;\n\tconst char *typep;\n\tint index = -1;\n\tu64 taddr;\n\n\tDBG(\" -> add_legacy_isa_port(%pOF)\\n\", np);\n\n\t/* Get the ISA port number */\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (reg == NULL)\n\t\treturn -1;\n\n\t/* Verify it's an IO port, we don't support anything else */\n\tif (!(be32_to_cpu(reg[0]) & 0x00000001))\n\t\treturn -1;\n\n\t/* Now look for an \"ibm,aix-loc\" property that gives us ordering\n\t * if any...\n\t */\n\ttypep = of_get_property(np, \"ibm,aix-loc\", NULL);\n\n\t/* If we have a location index, then use it */\n\tif (typep && *typep == 'S')\n\t\tindex = simple_strtol(typep+1, NULL, 0) - 1;\n\n\t/* Translate ISA address. If it fails, we still register the port\n\t * with no translated address so that it can be picked up as an IO\n\t * port later by the serial driver\n\t *\n\t * Note: Don't even try on P8 lpc, we know it's not directly mapped\n\t */\n\tif (!of_device_is_compatible(isa_brg, \"ibm,power8-lpc\") ||\n\t    of_get_property(isa_brg, \"ranges\", NULL)) {\n\t\ttaddr = of_translate_address(np, reg);\n\t\tif (taddr == OF_BAD_ADDR)\n\t\t\ttaddr = 0;\n\t} else\n\t\ttaddr = 0;\n\n\t/* Add port, irq will be dealt with later */\n\treturn add_legacy_port(np, index, UPIO_PORT, be32_to_cpu(reg[1]),\n\t\t\t       taddr, 0, legacy_port_flags, 0);\n\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_isa_port(struct device_node *np,\n\t\t\t\t      struct device_node *isa_brg)\n{\n\tconst __be32 *reg;\n\tconst char *typep;\n\tint index = -1;\n\tu64 taddr;\n\n\tDBG(\" -> add_legacy_isa_port(%pOF)\\n\", np);\n\n\t/* Get the ISA port number */\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (reg == NULL)\n\t\treturn -1;\n\n\t/* Verify it's an IO port, we don't support anything else */\n\tif (!(be32_to_cpu(reg[0]) & 0x00000001))\n\t\treturn -1;\n\n\t/* Now look for an \"ibm,aix-loc\" property that gives us ordering\n\t * if any...\n\t */\n\ttypep = of_get_property(np, \"ibm,aix-loc\", NULL);\n\n\t/* If we have a location index, then use it */\n\tif (typep && *typep == 'S')\n\t\tindex = simple_strtol(typep+1, NULL, 0) - 1;\n\n\t/* Translate ISA address. If it fails, we still register the port\n\t * with no translated address so that it can be picked up as an IO\n\t * port later by the serial driver\n\t *\n\t * Note: Don't even try on P8 lpc, we know it's not directly mapped\n\t */\n\tif (!of_device_is_compatible(isa_brg, \"ibm,power8-lpc\") ||\n\t    of_get_property(isa_brg, \"ranges\", NULL)) {\n\t\ttaddr = of_translate_address(np, reg);\n\t\tif (taddr == OF_BAD_ADDR)\n\t\t\ttaddr = 0;\n\t} else\n\t\ttaddr = 0;\n\n\t/* Add port, irq will be dealt with later */\n\treturn add_legacy_port(np, index, UPIO_PORT, be32_to_cpu(reg[1]),\n\t\t\t       taddr, 0, legacy_port_flags, 0);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "np"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_name_eq",
          "args": [
            "isa",
            "\"lpc\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_name_eq",
          "args": [
            "isa",
            "\"isa\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_by_type",
          "args": [
            "np",
            "\"serial\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_legacy_soc_port",
          "args": [
            "np",
            "np"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_soc_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "162-201",
          "snippet": "static int __init add_legacy_soc_port(struct device_node *np,\n\t\t\t\t      struct device_node *soc_dev)\n{\n\tu64 addr;\n\tconst __be32 *addrp;\n\tstruct device_node *tsi = of_get_parent(np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree.\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* if reg-offset don't try to use it */\n\tif ((of_get_property(np, \"reg-offset\", NULL) != NULL))\n\t\treturn -1;\n\n\t/* if rtas uses this device, don't try to use it as well */\n\tif (of_get_property(np, \"used-by-rtas\", NULL) != NULL)\n\t\treturn -1;\n\n\t/* Get the address */\n\taddrp = of_get_address(soc_dev, 0, NULL, NULL);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\taddr = of_translate_address(soc_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\tif (of_node_is_type(tsi, \"tsi-bridge\"))\n\t\treturn add_legacy_port(np, -1, UPIO_TSI, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n\telse\n\t\treturn add_legacy_port(np, -1, UPIO_MEM, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_soc_port(struct device_node *np,\n\t\t\t\t      struct device_node *soc_dev)\n{\n\tu64 addr;\n\tconst __be32 *addrp;\n\tstruct device_node *tsi = of_get_parent(np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree.\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* if reg-offset don't try to use it */\n\tif ((of_get_property(np, \"reg-offset\", NULL) != NULL))\n\t\treturn -1;\n\n\t/* if rtas uses this device, don't try to use it as well */\n\tif (of_get_property(np, \"used-by-rtas\", NULL) != NULL)\n\t\treturn -1;\n\n\t/* Get the address */\n\taddrp = of_get_address(soc_dev, 0, NULL, NULL);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\taddr = of_translate_address(soc_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\tif (of_node_is_type(tsi, \"tsi-bridge\"))\n\t\treturn add_legacy_port(np, -1, UPIO_TSI, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n\telse\n\t\treturn add_legacy_port(np, -1, UPIO_MEM, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_device_is_available",
          "args": [
            "np"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_match_node",
          "args": [
            "legacy_serial_parents",
            "parent"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_compatible_node",
          "args": [
            "np",
            "\"serial\"",
            "\"ns16550\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" no linux,stdout-path !\\n\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"stdout is %pOF\\n\"",
            "stdout"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "path"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_chosen",
            "\"stdout-path\"",
            "NULL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "of_chosen",
            "\"linux,stdout-path\"",
            "NULL"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> find_legacy_serial_port()\\n\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const struct of_device_id legacy_serial_parents[] __initconst = {\n\t{.type = \"soc\",},\n\t{.type = \"tsi-bridge\",},\n\t{.type = \"opb\", },\n\t{.compatible = \"ibm,opb\",},\n\t{.compatible = \"simple-bus\",},\n\t{.compatible = \"wrs,epld-localbus\",},\n\t{},\n};\nstatic int legacy_serial_console = -1;\n\nvoid __init find_legacy_serial_ports(void)\n{\n\tstruct device_node *np, *stdout = NULL;\n\tconst char *path;\n\tint index;\n\n\tDBG(\" -> find_legacy_serial_port()\\n\");\n\n\t/* Now find out if one of these is out firmware console */\n\tpath = of_get_property(of_chosen, \"linux,stdout-path\", NULL);\n\tif (path == NULL)\n\t\tpath = of_get_property(of_chosen, \"stdout-path\", NULL);\n\tif (path != NULL) {\n\t\tstdout = of_find_node_by_path(path);\n\t\tif (stdout)\n\t\t\tDBG(\"stdout is %pOF\\n\", stdout);\n\t} else {\n\t\tDBG(\" no linux,stdout-path !\\n\");\n\t}\n\n\t/* Iterate over all the 16550 ports, looking for known parents */\n\tfor_each_compatible_node(np, \"serial\", \"ns16550\") {\n\t\tstruct device_node *parent = of_get_parent(np);\n\t\tif (!parent)\n\t\t\tcontinue;\n\t\tif (of_match_node(legacy_serial_parents, parent) != NULL) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_soc_port(np, np);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(parent);\n\t}\n\n\t/* Next, fill our array with ISA ports */\n\tfor_each_node_by_type(np, \"serial\") {\n\t\tstruct device_node *isa = of_get_parent(np);\n\t\tif (of_node_name_eq(isa, \"isa\") || of_node_name_eq(isa, \"lpc\")) {\n\t\t\tif (of_device_is_available(np)) {\n\t\t\t\tindex = add_legacy_isa_port(np, isa);\n\t\t\t\tif (index >= 0 && np == stdout)\n\t\t\t\t\tlegacy_serial_console = index;\n\t\t\t}\n\t\t}\n\t\tof_node_put(isa);\n\t}\n\n#ifdef CONFIG_PCI\n\t/* Next, try to locate PCI ports */\n\tfor (np = NULL; (np = of_find_all_nodes(np));) {\n\t\tstruct device_node *pci, *parent = of_get_parent(np);\n\t\tif (of_node_name_eq(parent, \"isa\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!of_node_name_eq(np, \"serial\") &&\n\t\t    !of_node_is_type(np, \"serial\")) {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check for known pciclass, and also check whether we have\n\t\t * a device with child nodes for ports or not\n\t\t */\n\t\tif (of_device_is_compatible(np, \"pciclass,0700\") ||\n\t\t    of_device_is_compatible(np, \"pciclass,070002\"))\n\t\t\tpci = np;\n\t\telse if (of_device_is_compatible(parent, \"pciclass,0700\") ||\n\t\t\t of_device_is_compatible(parent, \"pciclass,070002\"))\n\t\t\tpci = parent;\n\t\telse {\n\t\t\tof_node_put(parent);\n\t\t\tcontinue;\n\t\t}\n\t\tindex = add_legacy_pci_port(np, pci);\n\t\tif (index >= 0 && np == stdout)\n\t\t\tlegacy_serial_console = index;\n\t\tof_node_put(parent);\n\t}\n#endif\n\n\tDBG(\"legacy_serial_console = %d\\n\", legacy_serial_console);\n\tif (legacy_serial_console >= 0)\n\t\tsetup_legacy_serial_console(legacy_serial_console);\n\tDBG(\" <- find_legacy_serial_port()\\n\");\n}"
  },
  {
    "function_name": "setup_legacy_serial_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "324-354",
    "snippet": "static void __init setup_legacy_serial_console(int console)\n{\n\tstruct legacy_serial_info *info = &legacy_serial_infos[console];\n\tstruct plat_serial8250_port *port = &legacy_serial_ports[console];\n\tvoid __iomem *addr;\n\tunsigned int stride;\n\n\tstride = 1 << port->regshift;\n\n\t/* Check if a translated MMIO address has been found */\n\tif (info->taddr) {\n\t\taddr = ioremap(info->taddr, 0x1000);\n\t\tif (addr == NULL)\n\t\t\treturn;\n\t\tudbg_uart_init_mmio(addr, stride);\n\t} else {\n\t\t/* Check if it's PIO and we support untranslated PIO */\n\t\tif (port->iotype == UPIO_PORT && isa_io_special)\n\t\t\tudbg_uart_init_pio(port->iobase, stride);\n\t\telse\n\t\t\treturn;\n\t}\n\n\t/* Try to query the current speed */\n\tif (info->speed == 0)\n\t\tinfo->speed = udbg_probe_uart_speed(info->clock);\n\n\t/* Set it up */\n\tDBG(\"default console speed = %d\\n\", info->speed);\n\tudbg_uart_setup(info->speed, info->clock);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
      "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udbg_uart_setup",
          "args": [
            "info->speed",
            "info->clock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_uart_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/udbg_16550.c",
          "lines": "95-122",
          "snippet": "void udbg_uart_setup(unsigned int speed, unsigned int clock)\n{\n\tunsigned int dll, base_bauds;\n\n\tif (!udbg_uart_out)\n\t\treturn;\n\n\tif (clock == 0)\n\t\tclock = 1843200;\n\tif (speed == 0)\n\t\tspeed = 9600;\n\n\tbase_bauds = clock / 16;\n\tdll = base_bauds / speed;\n\n\tudbg_uart_out(UART_LCR, 0x00);\n\tudbg_uart_out(UART_IER, 0xff);\n\tudbg_uart_out(UART_IER, 0x00);\n\tudbg_uart_out(UART_LCR, LCR_DLAB);\n\tudbg_uart_out(UART_DLL, dll & 0xff);\n\tudbg_uart_out(UART_DLM, dll >> 8);\n\t/* 8 data, 1 stop, no parity */\n\tudbg_uart_out(UART_LCR, 0x3);\n\t/* RTS/DTR */\n\tudbg_uart_out(UART_MCR, 0x3);\n\t/* Clear & enable FIFOs */\n\tudbg_uart_out(UART_FCR, 0x7);\n}",
          "includes": [
            "#include <platforms/44x/44x.h>",
            "#include <asm/reg_a2.h>",
            "#include <asm/io.h>",
            "#include <asm/udbg.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LCR_DLAB 0x80",
            "#define UART_DLM\tUART_IER",
            "#define UART_DLL\tUART_RBR",
            "#define UART_MCR\t4",
            "#define UART_LCR\t3",
            "#define UART_FCR\t2",
            "#define UART_IER\t1"
          ],
          "globals_used": [
            "static void (*udbg_uart_out)(unsigned int reg, u8 data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <platforms/44x/44x.h>\n#include <asm/reg_a2.h>\n#include <asm/io.h>\n#include <asm/udbg.h>\n#include <linux/types.h>\n\n#define LCR_DLAB 0x80\n#define UART_DLM\tUART_IER\n#define UART_DLL\tUART_RBR\n#define UART_MCR\t4\n#define UART_LCR\t3\n#define UART_FCR\t2\n#define UART_IER\t1\n\nstatic void (*udbg_uart_out)(unsigned int reg, u8 data);\n\nvoid udbg_uart_setup(unsigned int speed, unsigned int clock)\n{\n\tunsigned int dll, base_bauds;\n\n\tif (!udbg_uart_out)\n\t\treturn;\n\n\tif (clock == 0)\n\t\tclock = 1843200;\n\tif (speed == 0)\n\t\tspeed = 9600;\n\n\tbase_bauds = clock / 16;\n\tdll = base_bauds / speed;\n\n\tudbg_uart_out(UART_LCR, 0x00);\n\tudbg_uart_out(UART_IER, 0xff);\n\tudbg_uart_out(UART_IER, 0x00);\n\tudbg_uart_out(UART_LCR, LCR_DLAB);\n\tudbg_uart_out(UART_DLL, dll & 0xff);\n\tudbg_uart_out(UART_DLM, dll >> 8);\n\t/* 8 data, 1 stop, no parity */\n\tudbg_uart_out(UART_LCR, 0x3);\n\t/* RTS/DTR */\n\tudbg_uart_out(UART_MCR, 0x3);\n\t/* Clear & enable FIFOs */\n\tudbg_uart_out(UART_FCR, 0x7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"default console speed = %d\\n\"",
            "info->speed"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udbg_probe_uart_speed",
          "args": [
            "info->clock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_probe_uart_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/udbg_16550.c",
          "lines": "124-156",
          "snippet": "unsigned int udbg_probe_uart_speed(unsigned int clock)\n{\n\tunsigned int dll, dlm, divisor, prescaler, speed;\n\tu8 old_lcr;\n\n\told_lcr = udbg_uart_in(UART_LCR);\n\n\t/* select divisor latch registers.  */\n\tudbg_uart_out(UART_LCR, old_lcr | LCR_DLAB);\n\n\t/* now, read the divisor */\n\tdll = udbg_uart_in(UART_DLL);\n\tdlm = udbg_uart_in(UART_DLM);\n\tdivisor = dlm << 8 | dll;\n\n\t/* check prescaling */\n\tif (udbg_uart_in(UART_MCR) & 0x80)\n\t\tprescaler = 4;\n\telse\n\t\tprescaler = 1;\n\n\t/* restore the LCR */\n\tudbg_uart_out(UART_LCR, old_lcr);\n\n\t/* calculate speed */\n\tspeed = (clock / prescaler) / (divisor * 16);\n\n\t/* sanity check */\n\tif (speed > (clock / 16))\n\t\tspeed = 9600;\n\n\treturn speed;\n}",
          "includes": [
            "#include <platforms/44x/44x.h>",
            "#include <asm/reg_a2.h>",
            "#include <asm/io.h>",
            "#include <asm/udbg.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define LCR_DLAB 0x80",
            "#define UART_DLM\tUART_IER",
            "#define UART_DLL\tUART_RBR",
            "#define UART_MCR\t4",
            "#define UART_LCR\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <platforms/44x/44x.h>\n#include <asm/reg_a2.h>\n#include <asm/io.h>\n#include <asm/udbg.h>\n#include <linux/types.h>\n\n#define LCR_DLAB 0x80\n#define UART_DLM\tUART_IER\n#define UART_DLL\tUART_RBR\n#define UART_MCR\t4\n#define UART_LCR\t3\n\nunsigned int udbg_probe_uart_speed(unsigned int clock)\n{\n\tunsigned int dll, dlm, divisor, prescaler, speed;\n\tu8 old_lcr;\n\n\told_lcr = udbg_uart_in(UART_LCR);\n\n\t/* select divisor latch registers.  */\n\tudbg_uart_out(UART_LCR, old_lcr | LCR_DLAB);\n\n\t/* now, read the divisor */\n\tdll = udbg_uart_in(UART_DLL);\n\tdlm = udbg_uart_in(UART_DLM);\n\tdivisor = dlm << 8 | dll;\n\n\t/* check prescaling */\n\tif (udbg_uart_in(UART_MCR) & 0x80)\n\t\tprescaler = 4;\n\telse\n\t\tprescaler = 1;\n\n\t/* restore the LCR */\n\tudbg_uart_out(UART_LCR, old_lcr);\n\n\t/* calculate speed */\n\tspeed = (clock / prescaler) / (divisor * 16);\n\n\t/* sanity check */\n\tif (speed > (clock / 16))\n\t\tspeed = 9600;\n\n\treturn speed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udbg_uart_init_pio",
          "args": [
            "port->iobase",
            "stride"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_uart_init_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/udbg_16550.c",
          "lines": "175-184",
          "snippet": "void udbg_uart_init_pio(unsigned long port, unsigned int stride)\n{\n\tif (!port)\n\t\treturn;\n\tudbg_uart.pio_base = port;\n\tudbg_uart_stride = stride;\n\tudbg_uart_in = udbg_uart_in_pio;\n\tudbg_uart_out = udbg_uart_out_pio;\n\tudbg_use_uart();\n}",
          "includes": [
            "#include <platforms/44x/44x.h>",
            "#include <asm/reg_a2.h>",
            "#include <asm/io.h>",
            "#include <asm/udbg.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static union {\n\tunsigned char __iomem *mmio_base;\n\tunsigned long pio_base;\n} udbg_uart;",
            "static unsigned int udbg_uart_stride = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <platforms/44x/44x.h>\n#include <asm/reg_a2.h>\n#include <asm/io.h>\n#include <asm/udbg.h>\n#include <linux/types.h>\n\nstatic union {\n\tunsigned char __iomem *mmio_base;\n\tunsigned long pio_base;\n} udbg_uart;\nstatic unsigned int udbg_uart_stride = 1;\n\nvoid udbg_uart_init_pio(unsigned long port, unsigned int stride)\n{\n\tif (!port)\n\t\treturn;\n\tudbg_uart.pio_base = port;\n\tudbg_uart_stride = stride;\n\tudbg_uart_in = udbg_uart_in_pio;\n\tudbg_uart_out = udbg_uart_out_pio;\n\tudbg_use_uart();\n}"
        }
      },
      {
        "call_info": {
          "callee": "udbg_uart_init_mmio",
          "args": [
            "addr",
            "stride"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_uart_init_mmio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/udbg_16550.c",
          "lines": "197-206",
          "snippet": "void udbg_uart_init_mmio(void __iomem *addr, unsigned int stride)\n{\n\tif (!addr)\n\t\treturn;\n\tudbg_uart.mmio_base = addr;\n\tudbg_uart_stride = stride;\n\tudbg_uart_in = udbg_uart_in_mmio;\n\tudbg_uart_out = udbg_uart_out_mmio;\n\tudbg_use_uart();\n}",
          "includes": [
            "#include <platforms/44x/44x.h>",
            "#include <asm/reg_a2.h>",
            "#include <asm/io.h>",
            "#include <asm/udbg.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern u8 real_readb(volatile u8 __iomem  *addr);",
            "extern void real_writeb(u8 data, volatile u8 __iomem *addr);",
            "extern u8 real_205_readb(volatile u8 __iomem  *addr);",
            "extern void real_205_writeb(u8 data, volatile u8 __iomem *addr);",
            "static union {\n\tunsigned char __iomem *mmio_base;\n\tunsigned long pio_base;\n} udbg_uart;",
            "static unsigned int udbg_uart_stride = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <platforms/44x/44x.h>\n#include <asm/reg_a2.h>\n#include <asm/io.h>\n#include <asm/udbg.h>\n#include <linux/types.h>\n\nextern u8 real_readb(volatile u8 __iomem  *addr);\nextern void real_writeb(u8 data, volatile u8 __iomem *addr);\nextern u8 real_205_readb(volatile u8 __iomem  *addr);\nextern void real_205_writeb(u8 data, volatile u8 __iomem *addr);\nstatic union {\n\tunsigned char __iomem *mmio_base;\n\tunsigned long pio_base;\n} udbg_uart;\nstatic unsigned int udbg_uart_stride = 1;\n\nvoid udbg_uart_init_mmio(void __iomem *addr, unsigned int stride)\n{\n\tif (!addr)\n\t\treturn;\n\tudbg_uart.mmio_base = addr;\n\tudbg_uart_stride = stride;\n\tudbg_uart_in = udbg_uart_in_mmio;\n\tudbg_uart_out = udbg_uart_out_mmio;\n\tudbg_use_uart();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "info->taddr",
            "0x1000"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\n\nstatic void __init setup_legacy_serial_console(int console)\n{\n\tstruct legacy_serial_info *info = &legacy_serial_infos[console];\n\tstruct plat_serial8250_port *port = &legacy_serial_ports[console];\n\tvoid __iomem *addr;\n\tunsigned int stride;\n\n\tstride = 1 << port->regshift;\n\n\t/* Check if a translated MMIO address has been found */\n\tif (info->taddr) {\n\t\taddr = ioremap(info->taddr, 0x1000);\n\t\tif (addr == NULL)\n\t\t\treturn;\n\t\tudbg_uart_init_mmio(addr, stride);\n\t} else {\n\t\t/* Check if it's PIO and we support untranslated PIO */\n\t\tif (port->iotype == UPIO_PORT && isa_io_special)\n\t\t\tudbg_uart_init_pio(port->iobase, stride);\n\t\telse\n\t\t\treturn;\n\t}\n\n\t/* Try to query the current speed */\n\tif (info->speed == 0)\n\t\tinfo->speed = udbg_probe_uart_speed(info->clock);\n\n\t/* Set it up */\n\tDBG(\"default console speed = %d\\n\", info->speed);\n\tudbg_uart_setup(info->speed, info->clock);\n}"
  },
  {
    "function_name": "add_legacy_pci_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "252-321",
    "snippet": "static int __init add_legacy_pci_port(struct device_node *np,\n\t\t\t\t      struct device_node *pci_dev)\n{\n\tu64 addr, base;\n\tconst __be32 *addrp;\n\tunsigned int flags;\n\tint iotype, index = -1, lindex = 0;\n\n\tDBG(\" -> add_legacy_pci_port(%pOF)\\n\", np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree (that is have an fcode). Anything\n\t * else can't be used that early and will be normally probed by\n\t * the generic 8250_pci driver later on. The reason is that 8250\n\t * compatible UARTs on PCI need all sort of quirks (port offsets\n\t * etc...) that this code doesn't know about\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* Get the PCI address. Assume BAR 0 */\n\taddrp = of_get_pci_address(pci_dev, 0, NULL, &flags);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\t/* We only support BAR 0 for now */\n\tiotype = (flags & IORESOURCE_MEM) ? UPIO_MEM : UPIO_PORT;\n\taddr = of_translate_address(pci_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Set the IO base to the same as the translated address for MMIO,\n\t * or to the domain local IO base for PIO (it will be fixed up later)\n\t */\n\tif (iotype == UPIO_MEM)\n\t\tbase = addr;\n\telse\n\t\tbase = of_read_number(&addrp[2], 1);\n\n\t/* Try to guess an index... If we have subdevices of the pci dev,\n\t * we get to their \"reg\" property\n\t */\n\tif (np != pci_dev) {\n\t\tconst __be32 *reg = of_get_property(np, \"reg\", NULL);\n\t\tif (reg && (be32_to_cpup(reg) < 4))\n\t\t\tindex = lindex = be32_to_cpup(reg);\n\t}\n\n\t/* Local index means it's the Nth port in the PCI chip. Unfortunately\n\t * the offset to add here is device specific. We know about those\n\t * EXAR ports and we default to the most common case. If your UART\n\t * doesn't work for these settings, you'll have to add your own special\n\t * cases here\n\t */\n\tif (of_device_is_compatible(pci_dev, \"pci13a8,152\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,154\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,158\")) {\n\t\taddr += 0x200 * lindex;\n\t\tbase += 0x200 * lindex;\n\t} else {\n\t\taddr += 8 * lindex;\n\t\tbase += 8 * lindex;\n\t}\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\treturn add_legacy_port(np, index, iotype, base, addr, 0,\n\t\t\t       legacy_port_flags, np != pci_dev);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_legacy_port",
          "args": [
            "np",
            "index",
            "iotype",
            "base",
            "addr",
            "0",
            "legacy_port_flags",
            "np != pci_dev"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "73-160",
          "snippet": "static int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_LEGACY_SERIAL_PORTS\t8"
          ],
          "globals_used": [
            "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
            "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
            "static unsigned int legacy_serial_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\n#define MAX_LEGACY_SERIAL_PORTS\t8\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\n\nstatic int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "pci_dev",
            "\"pci13a8,158\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "pci_dev",
            "\"pci13a8,154\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "pci_dev",
            "\"pci13a8,152\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reg"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reg"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"reg\"",
            "NULL"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&addrp[2]",
            "1"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_translate_address",
          "args": [
            "pci_dev",
            "addrp"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_pci_address",
          "args": [
            "pci_dev",
            "0",
            "NULL",
            "&flags"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"clock-frequency\"",
            "NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> add_legacy_pci_port(%pOF)\\n\"",
            "np"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_pci_port(struct device_node *np,\n\t\t\t\t      struct device_node *pci_dev)\n{\n\tu64 addr, base;\n\tconst __be32 *addrp;\n\tunsigned int flags;\n\tint iotype, index = -1, lindex = 0;\n\n\tDBG(\" -> add_legacy_pci_port(%pOF)\\n\", np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree (that is have an fcode). Anything\n\t * else can't be used that early and will be normally probed by\n\t * the generic 8250_pci driver later on. The reason is that 8250\n\t * compatible UARTs on PCI need all sort of quirks (port offsets\n\t * etc...) that this code doesn't know about\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* Get the PCI address. Assume BAR 0 */\n\taddrp = of_get_pci_address(pci_dev, 0, NULL, &flags);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\t/* We only support BAR 0 for now */\n\tiotype = (flags & IORESOURCE_MEM) ? UPIO_MEM : UPIO_PORT;\n\taddr = of_translate_address(pci_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Set the IO base to the same as the translated address for MMIO,\n\t * or to the domain local IO base for PIO (it will be fixed up later)\n\t */\n\tif (iotype == UPIO_MEM)\n\t\tbase = addr;\n\telse\n\t\tbase = of_read_number(&addrp[2], 1);\n\n\t/* Try to guess an index... If we have subdevices of the pci dev,\n\t * we get to their \"reg\" property\n\t */\n\tif (np != pci_dev) {\n\t\tconst __be32 *reg = of_get_property(np, \"reg\", NULL);\n\t\tif (reg && (be32_to_cpup(reg) < 4))\n\t\t\tindex = lindex = be32_to_cpup(reg);\n\t}\n\n\t/* Local index means it's the Nth port in the PCI chip. Unfortunately\n\t * the offset to add here is device specific. We know about those\n\t * EXAR ports and we default to the most common case. If your UART\n\t * doesn't work for these settings, you'll have to add your own special\n\t * cases here\n\t */\n\tif (of_device_is_compatible(pci_dev, \"pci13a8,152\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,154\") ||\n\t    of_device_is_compatible(pci_dev, \"pci13a8,158\")) {\n\t\taddr += 0x200 * lindex;\n\t\tbase += 0x200 * lindex;\n\t} else {\n\t\taddr += 8 * lindex;\n\t\tbase += 8 * lindex;\n\t}\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\treturn add_legacy_port(np, index, iotype, base, addr, 0,\n\t\t\t       legacy_port_flags, np != pci_dev);\n}"
  },
  {
    "function_name": "add_legacy_isa_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "203-249",
    "snippet": "static int __init add_legacy_isa_port(struct device_node *np,\n\t\t\t\t      struct device_node *isa_brg)\n{\n\tconst __be32 *reg;\n\tconst char *typep;\n\tint index = -1;\n\tu64 taddr;\n\n\tDBG(\" -> add_legacy_isa_port(%pOF)\\n\", np);\n\n\t/* Get the ISA port number */\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (reg == NULL)\n\t\treturn -1;\n\n\t/* Verify it's an IO port, we don't support anything else */\n\tif (!(be32_to_cpu(reg[0]) & 0x00000001))\n\t\treturn -1;\n\n\t/* Now look for an \"ibm,aix-loc\" property that gives us ordering\n\t * if any...\n\t */\n\ttypep = of_get_property(np, \"ibm,aix-loc\", NULL);\n\n\t/* If we have a location index, then use it */\n\tif (typep && *typep == 'S')\n\t\tindex = simple_strtol(typep+1, NULL, 0) - 1;\n\n\t/* Translate ISA address. If it fails, we still register the port\n\t * with no translated address so that it can be picked up as an IO\n\t * port later by the serial driver\n\t *\n\t * Note: Don't even try on P8 lpc, we know it's not directly mapped\n\t */\n\tif (!of_device_is_compatible(isa_brg, \"ibm,power8-lpc\") ||\n\t    of_get_property(isa_brg, \"ranges\", NULL)) {\n\t\ttaddr = of_translate_address(np, reg);\n\t\tif (taddr == OF_BAD_ADDR)\n\t\t\ttaddr = 0;\n\t} else\n\t\ttaddr = 0;\n\n\t/* Add port, irq will be dealt with later */\n\treturn add_legacy_port(np, index, UPIO_PORT, be32_to_cpu(reg[1]),\n\t\t\t       taddr, 0, legacy_port_flags, 0);\n\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_legacy_port",
          "args": [
            "np",
            "index",
            "UPIO_PORT",
            "be32_to_cpu(reg[1])",
            "taddr",
            "0",
            "legacy_port_flags",
            "0"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "73-160",
          "snippet": "static int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_LEGACY_SERIAL_PORTS\t8"
          ],
          "globals_used": [
            "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
            "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
            "static unsigned int legacy_serial_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\n#define MAX_LEGACY_SERIAL_PORTS\t8\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\n\nstatic int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "reg[1]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_translate_address",
          "args": [
            "np",
            "reg"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "isa_brg",
            "\"ranges\"",
            "NULL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_device_is_compatible",
          "args": [
            "isa_brg",
            "\"ibm,power8-lpc\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "typep+1",
            "NULL",
            "0"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"ibm,aix-loc\"",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "reg[0]"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"reg\"",
            "NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> add_legacy_isa_port(%pOF)\\n\"",
            "np"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_isa_port(struct device_node *np,\n\t\t\t\t      struct device_node *isa_brg)\n{\n\tconst __be32 *reg;\n\tconst char *typep;\n\tint index = -1;\n\tu64 taddr;\n\n\tDBG(\" -> add_legacy_isa_port(%pOF)\\n\", np);\n\n\t/* Get the ISA port number */\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (reg == NULL)\n\t\treturn -1;\n\n\t/* Verify it's an IO port, we don't support anything else */\n\tif (!(be32_to_cpu(reg[0]) & 0x00000001))\n\t\treturn -1;\n\n\t/* Now look for an \"ibm,aix-loc\" property that gives us ordering\n\t * if any...\n\t */\n\ttypep = of_get_property(np, \"ibm,aix-loc\", NULL);\n\n\t/* If we have a location index, then use it */\n\tif (typep && *typep == 'S')\n\t\tindex = simple_strtol(typep+1, NULL, 0) - 1;\n\n\t/* Translate ISA address. If it fails, we still register the port\n\t * with no translated address so that it can be picked up as an IO\n\t * port later by the serial driver\n\t *\n\t * Note: Don't even try on P8 lpc, we know it's not directly mapped\n\t */\n\tif (!of_device_is_compatible(isa_brg, \"ibm,power8-lpc\") ||\n\t    of_get_property(isa_brg, \"ranges\", NULL)) {\n\t\ttaddr = of_translate_address(np, reg);\n\t\tif (taddr == OF_BAD_ADDR)\n\t\t\ttaddr = 0;\n\t} else\n\t\ttaddr = 0;\n\n\t/* Add port, irq will be dealt with later */\n\treturn add_legacy_port(np, index, UPIO_PORT, be32_to_cpu(reg[1]),\n\t\t\t       taddr, 0, legacy_port_flags, 0);\n\n}"
  },
  {
    "function_name": "add_legacy_soc_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "162-201",
    "snippet": "static int __init add_legacy_soc_port(struct device_node *np,\n\t\t\t\t      struct device_node *soc_dev)\n{\n\tu64 addr;\n\tconst __be32 *addrp;\n\tstruct device_node *tsi = of_get_parent(np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree.\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* if reg-offset don't try to use it */\n\tif ((of_get_property(np, \"reg-offset\", NULL) != NULL))\n\t\treturn -1;\n\n\t/* if rtas uses this device, don't try to use it as well */\n\tif (of_get_property(np, \"used-by-rtas\", NULL) != NULL)\n\t\treturn -1;\n\n\t/* Get the address */\n\taddrp = of_get_address(soc_dev, 0, NULL, NULL);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\taddr = of_translate_address(soc_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\tif (of_node_is_type(tsi, \"tsi-bridge\"))\n\t\treturn add_legacy_port(np, -1, UPIO_TSI, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n\telse\n\t\treturn add_legacy_port(np, -1, UPIO_MEM, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_legacy_port",
          "args": [
            "np",
            "-1",
            "UPIO_MEM",
            "addr",
            "addr",
            "0",
            "legacy_port_flags",
            "0"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "add_legacy_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
          "lines": "73-160",
          "snippet": "static int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/udbg.h>",
            "#include <asm/serial.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/io.h>",
            "#include <linux/serial_reg.h>",
            "#include <linux/of_device.h>",
            "#include <linux/of_address.h>",
            "#include <linux/pci.h>",
            "#include <linux/console.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_LEGACY_SERIAL_PORTS\t8"
          ],
          "globals_used": [
            "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
            "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
            "static unsigned int legacy_serial_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\n#define MAX_LEGACY_SERIAL_PORTS\t8\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\n\nstatic int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "tsi",
            "\"tsi-bridge\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_translate_address",
          "args": [
            "soc_dev",
            "addrp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_address",
          "args": [
            "soc_dev",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"used-by-rtas\"",
            "NULL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"reg-offset\"",
            "NULL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"clock-frequency\"",
            "NULL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |\n\tUPF_SHARE_IRQ | UPF_FIXED_PORT;\n\nstatic int __init add_legacy_soc_port(struct device_node *np,\n\t\t\t\t      struct device_node *soc_dev)\n{\n\tu64 addr;\n\tconst __be32 *addrp;\n\tstruct device_node *tsi = of_get_parent(np);\n\n\t/* We only support ports that have a clock frequency properly\n\t * encoded in the device-tree.\n\t */\n\tif (of_get_property(np, \"clock-frequency\", NULL) == NULL)\n\t\treturn -1;\n\n\t/* if reg-offset don't try to use it */\n\tif ((of_get_property(np, \"reg-offset\", NULL) != NULL))\n\t\treturn -1;\n\n\t/* if rtas uses this device, don't try to use it as well */\n\tif (of_get_property(np, \"used-by-rtas\", NULL) != NULL)\n\t\treturn -1;\n\n\t/* Get the address */\n\taddrp = of_get_address(soc_dev, 0, NULL, NULL);\n\tif (addrp == NULL)\n\t\treturn -1;\n\n\taddr = of_translate_address(soc_dev, addrp);\n\tif (addr == OF_BAD_ADDR)\n\t\treturn -1;\n\n\t/* Add port, irq will be dealt with later. We passed a translated\n\t * IO port value. It will be fixed up later along with the irq\n\t */\n\tif (of_node_is_type(tsi, \"tsi-bridge\"))\n\t\treturn add_legacy_port(np, -1, UPIO_TSI, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n\telse\n\t\treturn add_legacy_port(np, -1, UPIO_MEM, addr, addr,\n\t\t\t\t       0, legacy_port_flags, 0);\n}"
  },
  {
    "function_name": "add_legacy_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "73-160",
    "snippet": "static int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_LEGACY_SERIAL_PORTS\t8"
    ],
    "globals_used": [
      "static struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];",
      "static struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];",
      "static unsigned int legacy_serial_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\"",
            "(iotype == UPIO_PORT) ? \"port\" : \"mem\"",
            "(unsigned long long)base",
            "(unsigned long long)taddr",
            "irq",
            "legacy_serial_ports[index].uartclk",
            "legacy_serial_infos[index].speed"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\"",
            "index",
            "np"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "spd"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "np"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&legacy_serial_ports[index]",
            "0",
            "sizeof(struct plat_serial8250_port)"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Replacing legacy port %d\\n\"",
            "index"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Moved legacy port %d -> %d\\n\"",
            "index",
            "legacy_serial_count"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "rs"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"reg-shift\"",
            "NULL"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"current-speed\"",
            "NULL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "clk"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"clock-frequency\"",
            "NULL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\n#define MAX_LEGACY_SERIAL_PORTS\t8\n\nstatic struct plat_serial8250_port\nlegacy_serial_ports[MAX_LEGACY_SERIAL_PORTS+1];\nstatic struct legacy_serial_info {\n\tstruct device_node\t\t*np;\n\tunsigned int\t\t\tspeed;\n\tunsigned int\t\t\tclock;\n\tint\t\t\t\tirq_check_parent;\n\tphys_addr_t\t\t\ttaddr;\n} legacy_serial_infos[MAX_LEGACY_SERIAL_PORTS];\nstatic unsigned int legacy_serial_count;\n\nstatic int __init add_legacy_port(struct device_node *np, int want_index,\n\t\t\t\t  int iotype, phys_addr_t base,\n\t\t\t\t  phys_addr_t taddr, unsigned long irq,\n\t\t\t\t  upf_t flags, int irq_check_parent)\n{\n\tconst __be32 *clk, *spd, *rs;\n\tu32 clock = BASE_BAUD * 16;\n\tu32 shift = 0;\n\tint index;\n\n\t/* get clock freq. if present */\n\tclk = of_get_property(np, \"clock-frequency\", NULL);\n\tif (clk && *clk)\n\t\tclock = be32_to_cpup(clk);\n\n\t/* get default speed if present */\n\tspd = of_get_property(np, \"current-speed\", NULL);\n\n\t/* get register shift if present */\n\trs = of_get_property(np, \"reg-shift\", NULL);\n\tif (rs && *rs)\n\t\tshift = be32_to_cpup(rs);\n\n\t/* If we have a location index, then try to use it */\n\tif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\n\t\tindex = want_index;\n\telse\n\t\tindex = legacy_serial_count;\n\n\t/* if our index is still out of range, that mean that\n\t * array is full, we could scan for a free slot but that\n\t * make little sense to bother, just skip the port\n\t */\n\tif (index >= MAX_LEGACY_SERIAL_PORTS)\n\t\treturn -1;\n\tif (index >= legacy_serial_count)\n\t\tlegacy_serial_count = index + 1;\n\n\t/* Check if there is a port who already claimed our slot */\n\tif (legacy_serial_infos[index].np != NULL) {\n\t\t/* if we still have some room, move it, else override */\n\t\tif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\n\t\t\tprintk(KERN_DEBUG \"Moved legacy port %d -> %d\\n\",\n\t\t\t       index, legacy_serial_count);\n\t\t\tlegacy_serial_ports[legacy_serial_count] =\n\t\t\t\tlegacy_serial_ports[index];\n\t\t\tlegacy_serial_infos[legacy_serial_count] =\n\t\t\t\tlegacy_serial_infos[index];\n\t\t\tlegacy_serial_count++;\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Replacing legacy port %d\\n\", index);\n\t\t}\n\t}\n\n\t/* Now fill the entry */\n\tmemset(&legacy_serial_ports[index], 0,\n\t       sizeof(struct plat_serial8250_port));\n\tif (iotype == UPIO_PORT)\n\t\tlegacy_serial_ports[index].iobase = base;\n\telse\n\t\tlegacy_serial_ports[index].mapbase = base;\n\n\tlegacy_serial_ports[index].iotype = iotype;\n\tlegacy_serial_ports[index].uartclk = clock;\n\tlegacy_serial_ports[index].irq = irq;\n\tlegacy_serial_ports[index].flags = flags;\n\tlegacy_serial_ports[index].regshift = shift;\n\tlegacy_serial_infos[index].taddr = taddr;\n\tlegacy_serial_infos[index].np = of_node_get(np);\n\tlegacy_serial_infos[index].clock = clock;\n\tlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\n\tlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\n\n\tif (iotype == UPIO_TSI) {\n\t\tlegacy_serial_ports[index].serial_in = tsi_serial_in;\n\t\tlegacy_serial_ports[index].serial_out = tsi_serial_out;\n\t}\n\n\tprintk(KERN_DEBUG \"Found legacy serial port %d for %pOF\\n\",\n\t       index, np);\n\tprintk(KERN_DEBUG \"  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\\n\",\n\t       (iotype == UPIO_PORT) ? \"port\" : \"mem\",\n\t       (unsigned long long)base, (unsigned long long)taddr, irq,\n\t       legacy_serial_ports[index].uartclk,\n\t       legacy_serial_infos[index].speed);\n\n\treturn index;\n}"
  },
  {
    "function_name": "tsi_serial_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "66-71",
    "snippet": "static void tsi_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\tif (!((offset == UART_IER) && (value & UART_IER_UUE)))\n\t\twriteb(value, p->membase + offset);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeb",
          "args": [
            "value",
            "p->membase + offset"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic void tsi_serial_out(struct uart_port *p, int offset, int value)\n{\n\toffset = offset << p->regshift;\n\tif (!((offset == UART_IER) && (value & UART_IER_UUE)))\n\t\twriteb(value, p->membase + offset);\n}"
  },
  {
    "function_name": "tsi_serial_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/legacy_serial.c",
    "lines": "55-64",
    "snippet": "static unsigned int tsi_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int tmp;\n\toffset = offset << p->regshift;\n\tif (offset == UART_IIR) {\n\t\ttmp = readl(p->membase + (UART_IIR & ~3));\n\t\treturn (tmp >> 16) & 0xff; /* UART_IIR % 4 == 2 */\n\t} else\n\t\treturn readb(p->membase + offset);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/udbg.h>",
      "#include <asm/serial.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/io.h>",
      "#include <linux/serial_reg.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of_address.h>",
      "#include <linux/pci.h>",
      "#include <linux/console.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/serial_8250.h>",
      "#include <linux/serial.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readb",
          "args": [
            "p->membase + offset"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readl",
          "args": [
            "p->membase + (UART_IIR & ~3)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/udbg.h>\n#include <asm/serial.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/io.h>\n#include <linux/serial_reg.h>\n#include <linux/of_device.h>\n#include <linux/of_address.h>\n#include <linux/pci.h>\n#include <linux/console.h>\n#include <linux/serial_core.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/kernel.h>\n\nstatic unsigned int tsi_serial_in(struct uart_port *p, int offset)\n{\n\tunsigned int tmp;\n\toffset = offset << p->regshift;\n\tif (offset == UART_IIR) {\n\t\ttmp = readl(p->membase + (UART_IIR & ~3));\n\t\treturn (tmp >> 16) & 0xff; /* UART_IIR % 4 == 2 */\n\t} else\n\t\treturn readb(p->membase + offset);\n}"
  }
]