[
  {
    "function_name": "ppc_del_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "475-492",
    "snippet": "long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "child->thread.debug.dbcr0",
            "child->thread.debug.dbcr1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_dac",
          "args": [
            "child",
            "(int)data - 4"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "del_dac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "344-382",
          "snippet": "static int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_instruction_bp",
          "args": [
            "child",
            "(int)data"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "del_instruction_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "228-281",
          "snippet": "static int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_del_hwdebug(struct task_struct *child, long data)\n{\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ppc_set_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "439-473",
    "snippet": "long ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif (bp_info->trigger_type == 0 ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif (bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE ||\n\t\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dac_range",
          "args": [
            "child",
            "bp_info"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "set_dac_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "385-436",
          "snippet": "static int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_instruction_bp",
          "args": [
            "child",
            "bp_info"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "set_instruction_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "139-226",
          "snippet": "static long set_instruction_bp(struct task_struct *child,\n\t\t\t       struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif (!slot1_in_use && !slot2_in_use) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || slot3_in_use == slot4_in_use) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t       struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif (!slot1_in_use && !slot2_in_use) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || slot3_in_use == slot4_in_use) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif (bp_info->trigger_type == 0 ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif (bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE ||\n\t\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n}"
  },
  {
    "function_name": "set_dac_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "385-436",
    "snippet": "static int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}"
  },
  {
    "function_name": "del_dac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "344-382",
    "snippet": "static int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_dac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "283-342",
    "snippet": "static int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && condition_mode == 0)\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else {\n\t\treturn -ENOSPC;\n\t}\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && condition_mode == 0)\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else {\n\t\treturn -ENOSPC;\n\t}\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}"
  },
  {
    "function_name": "del_instruction_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "228-281",
    "snippet": "static int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_instruction_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "139-226",
    "snippet": "static long set_instruction_bp(struct task_struct *child,\n\t\t\t       struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif (!slot1_in_use && !slot2_in_use) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || slot3_in_use == slot4_in_use) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t       struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif (!slot1_in_use && !slot2_in_use) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || slot3_in_use == slot4_in_use) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else {\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}"
  },
  {
    "function_name": "ptrace_set_debugreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "83-137",
    "snippet": "int ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0 register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0 accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "task->thread.debug.dbcr0",
            "task->thread.debug.dbcr1"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0 register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0 accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n\treturn 0;\n}"
  },
  {
    "function_name": "ptrace_get_debugreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "74-81",
    "snippet": "int ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\treturn put_user(child->thread.debug.dac1, datalp);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "child->thread.debug.dac1",
            "datalp"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\treturn put_user(child->thread.debug.dac1, datalp);\n}"
  },
  {
    "function_name": "ppc_gethwdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "59-72",
    "snippet": "void ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\tdbginfo->num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\tdbginfo->num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\tdbginfo->data_bp_alignment = 4;\n\tdbginfo->sizeof_condition = 4;\n\tdbginfo->features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t    PPC_DEBUG_FEATURE_INSN_BP_MASK;\n\tif (IS_ENABLED(CONFIG_PPC_ADV_DEBUG_DAC_RANGE))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t     PPC_DEBUG_FEATURE_DATA_BP_MASK;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_ADV_DEBUG_DAC_RANGE"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\tdbginfo->num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\tdbginfo->num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\tdbginfo->data_bp_alignment = 4;\n\tdbginfo->sizeof_condition = 4;\n\tdbginfo->features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t    PPC_DEBUG_FEATURE_INSN_BP_MASK;\n\tif (IS_ENABLED(CONFIG_PPC_ADV_DEBUG_DAC_RANGE))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t     PPC_DEBUG_FEATURE_DATA_BP_MASK;\n}"
  },
  {
    "function_name": "user_disable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "32-57",
    "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC | DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "task->thread.debug.dbcr0",
            "task->thread.debug.dbcr1"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC | DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_block_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "20-30",
    "snippet": "void user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
    "lines": "8-18",
    "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  }
]