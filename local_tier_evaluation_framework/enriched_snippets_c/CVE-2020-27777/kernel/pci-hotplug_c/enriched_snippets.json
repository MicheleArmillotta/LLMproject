[
  {
    "function_name": "pci_hp_add_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "106-147",
    "snippet": "void pci_hp_add_devices(struct pci_bus *bus)\n{\n\tint slotno, mode, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL &&\n\t\t   dn->child && PCI_DN(dn->child)) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tmax = bus->busn_res.start;\n\t\t/*\n\t\t * Scan bridges that are already configured. We don't touch\n\t\t * them unless they are misconfigured (which will be done in\n\t\t * the second scan below).\n\t\t */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 0);\n\n\t\t/* Scan bridges that need to be reconfigured */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 1);\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_finish_adding_to_bus",
          "args": [
            "bus"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_finish_adding_to_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1498-1515",
          "snippet": "void pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tif (bus->self)\n\t\t\tpci_assign_unassigned_bridge_resources(bus->self);\n\t\telse\n\t\t\tpci_assign_unassigned_bus_resources(bus);\n\t}\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tif (bus->self)\n\t\t\tpci_assign_unassigned_bridge_resources(bus->self);\n\t\telse\n\t\t\tpci_assign_unassigned_bus_resources(bus);\n\t}\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_scan_bridge",
          "args": [
            "bus",
            "dev",
            "max",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pci_bridge",
          "args": [
            "dev",
            "bus"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_scan_bridge",
          "args": [
            "bus",
            "dev",
            "max",
            "0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pci_bridge",
          "args": [
            "dev",
            "bus"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_scan_slot",
          "args": [
            "bus",
            "PCI_DEVFN(slotno, 0)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DEVFN",
          "args": [
            "slotno",
            "0"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "PCI_DN(dn->child)->devfn"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn->child"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn->child"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_rescan_bus",
          "args": [
            "dn",
            "bus"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "of_rescan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "442-445",
          "snippet": "void of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_rescan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_add_devices(struct pci_bus *bus)\n{\n\tint slotno, mode, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL &&\n\t\t   dn->child && PCI_DN(dn->child)) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tmax = bus->busn_res.start;\n\t\t/*\n\t\t * Scan bridges that are already configured. We don't touch\n\t\t * them unless they are misconfigured (which will be done in\n\t\t * the second scan below).\n\t\t */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 0);\n\n\t\t/* Scan bridges that need to be reconfigured */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 1);\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}"
  },
  {
    "function_name": "pci_hp_remove_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "77-92",
    "snippet": "void pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_stop_and_remove_bus_device",
          "args": [
            "dev"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"   Removing %s...\\n\"",
            "pci_name(dev)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "dev",
            "tmp",
            "&bus->devices",
            "bus_list"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Removing devices on bus %04x:%02x\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_hp_remove_devices",
          "args": [
            "child_bus"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "pci_hp_remove_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "77-92",
          "snippet": "void pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_bus",
            "&bus->children",
            "node"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
  },
  {
    "function_name": "pcibios_release_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "55-68",
    "snippet": "void pcibios_release_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\tstruct pci_dn *pdn = pci_get_pdn(dev);\n\n\tif (phb->controller_ops.release_device)\n\t\tphb->controller_ops.release_device(dev);\n\n\t/* free()ing the pci_dn has been deferred to us, do it now */\n\tif (pdn && (pdn->flags & PCI_DN_FLAG_DEAD)) {\n\t\tpci_dbg(dev, \"freeing dead pdn\\n\");\n\t\tkfree(pdn);\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdn"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dbg",
          "args": [
            "dev",
            "\"freeing dead pdn\\n\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.release_device",
          "args": [
            "dev"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "dev"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "95-125",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pcibios_release_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\tstruct pci_dn *pdn = pci_get_pdn(dev);\n\n\tif (phb->controller_ops.release_device)\n\t\tphb->controller_ops.release_device(dev);\n\n\t/* free()ing the pci_dn has been deferred to us, do it now */\n\tif (pdn && (pdn->flags & PCI_DN_FLAG_DEAD)) {\n\t\tpci_dbg(dev, \"freeing dead pdn\\n\");\n\t\tkfree(pdn);\n\t}\n}"
  },
  {
    "function_name": "pci_find_bus_by_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "38-46",
    "snippet": "struct pci_bus *pci_find_bus_by_node(struct device_node *dn)\n{\n\tstruct pci_dn *pdn = PCI_DN(dn);\n\n\tif (!pdn  || !pdn->phb || !pdn->phb->bus)\n\t\treturn NULL;\n\n\treturn find_bus_among_children(pdn->phb->bus, dn);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_bus_among_children",
          "args": [
            "pdn->phb->bus",
            "dn"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "find_bus_among_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "20-36",
          "snippet": "static struct pci_bus *find_bus_among_children(struct pci_bus *bus,\n\t\t\t\t\t       struct device_node *dn)\n{\n\tstruct pci_bus *child = NULL;\n\tstruct pci_bus *tmp;\n\n\tif (pci_bus_to_OF_node(bus) == dn)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = find_bus_among_children(tmp, dn);\n\t\tif (child)\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_bus *find_bus_among_children(struct pci_bus *bus,\n\t\t\t\t\t       struct device_node *dn)\n{\n\tstruct pci_bus *child = NULL;\n\tstruct pci_bus *tmp;\n\n\tif (pci_bus_to_OF_node(bus) == dn)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = find_bus_among_children(tmp, dn);\n\t\tif (child)\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstruct pci_bus *pci_find_bus_by_node(struct device_node *dn)\n{\n\tstruct pci_dn *pdn = PCI_DN(dn);\n\n\tif (!pdn  || !pdn->phb || !pdn->phb->bus)\n\t\treturn NULL;\n\n\treturn find_bus_among_children(pdn->phb->bus, dn);\n}"
  },
  {
    "function_name": "find_bus_among_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
    "lines": "20-36",
    "snippet": "static struct pci_bus *find_bus_among_children(struct pci_bus *bus,\n\t\t\t\t\t       struct device_node *dn)\n{\n\tstruct pci_bus *child = NULL;\n\tstruct pci_bus *tmp;\n\n\tif (pci_bus_to_OF_node(bus) == dn)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = find_bus_among_children(tmp, dn);\n\t\tif (child)\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/export.h>",
      "#include <linux/pci.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_bus_among_children",
          "args": [
            "tmp",
            "dn"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "find_bus_among_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "20-36",
          "snippet": "static struct pci_bus *find_bus_among_children(struct pci_bus *bus,\n\t\t\t\t\t       struct device_node *dn)\n{\n\tstruct pci_bus *child = NULL;\n\tstruct pci_bus *tmp;\n\n\tif (pci_bus_to_OF_node(bus) == dn)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = find_bus_among_children(tmp, dn);\n\t\tif (child)\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&bus->children",
            "node"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nstatic struct pci_bus *find_bus_among_children(struct pci_bus *bus,\n\t\t\t\t\t       struct device_node *dn)\n{\n\tstruct pci_bus *child = NULL;\n\tstruct pci_bus *tmp;\n\n\tif (pci_bus_to_OF_node(bus) == dn)\n\t\treturn bus;\n\n\tlist_for_each_entry(tmp, &bus->children, node) {\n\t\tchild = find_bus_among_children(tmp, dn);\n\t\tif (child)\n\t\t\tbreak;\n\t}\n\n\treturn child;\n}"
  }
]