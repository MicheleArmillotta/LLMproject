[
  {
    "function_name": "isa_bridge_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "362-366",
    "snippet": "static int __init isa_bridge_init(void)\n{\n\tbus_register_notifier(&pci_bus_type, &isa_bridge_notifier);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block isa_bridge_notifier = {\n\t.notifier_call = isa_bridge_notify\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_register_notifier",
          "args": [
            "&pci_bus_type",
            "&isa_bridge_notifier"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct notifier_block isa_bridge_notifier = {\n\t.notifier_call = isa_bridge_notify\n};\n\nstatic int __init isa_bridge_init(void)\n{\n\tbus_register_notifier(&pci_bus_type, &isa_bridge_notifier);\n\treturn 0;\n}"
  },
  {
    "function_name": "isa_bridge_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "320-352",
    "snippet": "static int isa_bridge_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct device_node *devnode = pci_device_to_OF_node(pdev);\n\n\tswitch(action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\t/* Check if we have an early ISA device, without PCI dev */\n\t\tif (isa_bridge_devnode && isa_bridge_devnode == devnode &&\n\t\t    !isa_bridge_pcidev) {\n\t\t\tpr_debug(\"ISA bridge PCI attached: %s\\n\",\n\t\t\t\t pci_name(pdev));\n\t\t\tisa_bridge_pcidev = pdev;\n\t\t}\n\n\t\t/* Check if we have no ISA device, and this happens to be one,\n\t\t * register it as such if it has an OF device\n\t\t */\n\t\tif (!isa_bridge_devnode && of_node_is_type(devnode, \"isa\"))\n\t\t\tisa_bridge_find_late(pdev, devnode);\n\n\t\treturn 0;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\t/* Check if this our existing ISA device */\n\t\tif (pdev == isa_bridge_pcidev ||\n\t\t    (devnode && devnode == isa_bridge_devnode))\n\t\t\tisa_bridge_remove();\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_bridge_remove",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "isa_bridge_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "297-315",
          "snippet": "static void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\tunmap_kernel_range(ISA_IO_BASE, 0x10000);\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long isa_io_base;",
            "static struct device_node *isa_bridge_devnode;",
            "struct pci_dev *isa_bridge_pcidev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\tunmap_kernel_range(ISA_IO_BASE, 0x10000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_bridge_find_late",
          "args": [
            "pdev",
            "devnode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "isa_bridge_find_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "275-292",
          "snippet": "static void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %pOF on %s\\n\",\n\t\t devnode, pci_name(pdev));\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long isa_io_base;",
            "static struct device_node *isa_bridge_devnode;",
            "struct pci_dev *isa_bridge_pcidev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %pOF on %s\\n\",\n\t\t devnode, pci_name(pdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_is_type",
          "args": [
            "devnode",
            "\"isa\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge PCI attached: %s\\n\"",
            "pci_name(pdev)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pci_dev",
          "args": [
            "dev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic int isa_bridge_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct device *dev = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct device_node *devnode = pci_device_to_OF_node(pdev);\n\n\tswitch(action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\t/* Check if we have an early ISA device, without PCI dev */\n\t\tif (isa_bridge_devnode && isa_bridge_devnode == devnode &&\n\t\t    !isa_bridge_pcidev) {\n\t\t\tpr_debug(\"ISA bridge PCI attached: %s\\n\",\n\t\t\t\t pci_name(pdev));\n\t\t\tisa_bridge_pcidev = pdev;\n\t\t}\n\n\t\t/* Check if we have no ISA device, and this happens to be one,\n\t\t * register it as such if it has an OF device\n\t\t */\n\t\tif (!isa_bridge_devnode && of_node_is_type(devnode, \"isa\"))\n\t\t\tisa_bridge_find_late(pdev, devnode);\n\n\t\treturn 0;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\t/* Check if this our existing ISA device */\n\t\tif (pdev == isa_bridge_pcidev ||\n\t\t    (devnode && devnode == isa_bridge_devnode))\n\t\t\tisa_bridge_remove();\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "isa_bridge_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "297-315",
    "snippet": "static void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\tunmap_kernel_range(ISA_IO_BASE, 0x10000);\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_kernel_range",
          "args": [
            "ISA_IO_BASE",
            "0x10000"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "isa_bridge_devnode"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge removed !\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_remove(void)\n{\n\tpr_debug(\"ISA bridge removed !\\n\");\n\n\t/* Clear the global ISA io base to indicate that we have no more\n\t * ISA bridge. Note that drivers don't quite handle that, though\n\t * we should probably do something about it. But do we ever really\n\t * have ISA bridges being removed on machines using legacy devices ?\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\n\t/* Clear references to the bridge */\n\tof_node_put(isa_bridge_devnode);\n\tisa_bridge_devnode = NULL;\n\tisa_bridge_pcidev = NULL;\n\n\t/* Unmap the ISA area */\n\tunmap_kernel_range(ISA_IO_BASE, 0x10000);\n}"
  },
  {
    "function_name": "isa_bridge_find_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "275-292",
    "snippet": "static void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %pOF on %s\\n\",\n\t\t devnode, pci_name(pdev));\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;",
      "struct pci_dev *isa_bridge_pcidev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge (late) is %pOF on %s\\n\"",
            "devnode",
            "pci_name(pdev)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_process_ISA_OF_ranges",
          "args": [
            "devnode",
            "hose->io_base_phys"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_ISA_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "58-132",
          "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define ISA_SPACE_IO 0x1",
            "#define ISA_SPACE_MASK 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "devnode"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\nstruct pci_dev *isa_bridge_pcidev;\n\nstatic void isa_bridge_find_late(struct pci_dev *pdev,\n\t\t\t\t struct device_node *devnode)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\n\t/* Store ISA device node and PCI device */\n\tisa_bridge_devnode = of_node_get(devnode);\n\tisa_bridge_pcidev = pdev;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(devnode, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (late) is %pOF on %s\\n\",\n\t\t devnode, pci_name(pdev));\n}"
  },
  {
    "function_name": "isa_bridge_init_non_pci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "187-269",
    "snippet": "void __init isa_bridge_init_non_pci(struct device_node *np)\n{\n\tconst __be32 *ranges, *pbasep = NULL;\n\tint rlen, i, rs;\n\tu32 na, ns, pna;\n\tu64 cbase, pbase, size = 0;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\tpna = of_n_addr_cells(np);\n\tif (of_property_read_u32(np, \"#address-cells\", &na) ||\n\t    of_property_read_u32(np, \"#size-cells\", &ns)) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF is missing address format\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Check it's a supported address format */\n\tif (na != 2 || ns != 1) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has unsupported address format\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\trs = na + ns + pna;\n\n\t/* Grab the ranges property */\n\tranges = of_get_property(np, \"ranges\", &rlen);\n\tif (ranges == NULL || rlen < rs) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has absent or invalid ranges\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Parse it. We are only looking for IO space */\n\tfor (i = 0; (i + rs - 1) < rlen; i += rs) {\n\t\tif (be32_to_cpup(ranges + i) != 1)\n\t\t\tcontinue;\n\t\tcbase = be32_to_cpup(ranges + i + 1);\n\t\tsize = of_read_number(ranges + i + na + pna, ns);\n\t\tpbasep = ranges + i + na;\n\t\tbreak;\n\t}\n\n\t/* Got something ? */\n\tif (!size || !pbasep) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has no usable IO range\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t/* Map pbase */\n\tpbase = of_translate_address(np, pbasep);\n\tif (pbase == OF_BAD_ADDR) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF failed to translate IO base\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* We need page alignment */\n\tif ((cbase & ~PAGE_MASK) || (pbase & ~PAGE_MASK)) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has non aligned IO range\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Got it */\n\tisa_bridge_devnode = np;\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge\n\t * and map it\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\tremap_isa_base(pbase, size);\n\n\tpr_debug(\"ISA: Non-PCI bridge is %pOF\\n\", np);\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA: Non-PCI bridge is %pOF\\n\"",
            "np"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remap_isa_base",
          "args": [
            "pbase",
            "size"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "remap_isa_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "42-56",
          "snippet": "static void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF has non aligned IO range\\n\"",
            "np"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF failed to translate IO base\\n\"",
            "np"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_translate_address",
          "args": [
            "np",
            "pbasep"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF has no usable IO range\\n\"",
            "np"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "ranges + i + na + pna",
            "ns"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "ranges + i + 1"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "ranges + i"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF has absent or invalid ranges\\n\"",
            "np"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "np",
            "\"ranges\"",
            "&rlen"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF has unsupported address format\\n\"",
            "np"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"ISA: Non-PCI bridge %pOF is missing address format\\n\"",
            "np"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "np",
            "\"#size-cells\"",
            "&ns"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "np",
            "\"#address-cells\"",
            "&na"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_n_addr_cells",
          "args": [
            "np"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\n\nvoid __init isa_bridge_init_non_pci(struct device_node *np)\n{\n\tconst __be32 *ranges, *pbasep = NULL;\n\tint rlen, i, rs;\n\tu32 na, ns, pna;\n\tu64 cbase, pbase, size = 0;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\tpna = of_n_addr_cells(np);\n\tif (of_property_read_u32(np, \"#address-cells\", &na) ||\n\t    of_property_read_u32(np, \"#size-cells\", &ns)) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF is missing address format\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Check it's a supported address format */\n\tif (na != 2 || ns != 1) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has unsupported address format\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\trs = na + ns + pna;\n\n\t/* Grab the ranges property */\n\tranges = of_get_property(np, \"ranges\", &rlen);\n\tif (ranges == NULL || rlen < rs) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has absent or invalid ranges\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Parse it. We are only looking for IO space */\n\tfor (i = 0; (i + rs - 1) < rlen; i += rs) {\n\t\tif (be32_to_cpup(ranges + i) != 1)\n\t\t\tcontinue;\n\t\tcbase = be32_to_cpup(ranges + i + 1);\n\t\tsize = of_read_number(ranges + i + na + pna, ns);\n\t\tpbasep = ranges + i + na;\n\t\tbreak;\n\t}\n\n\t/* Got something ? */\n\tif (!size || !pbasep) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has no usable IO range\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\t/* Map pbase */\n\tpbase = of_translate_address(np, pbasep);\n\tif (pbase == OF_BAD_ADDR) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF failed to translate IO base\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* We need page alignment */\n\tif ((cbase & ~PAGE_MASK) || (pbase & ~PAGE_MASK)) {\n\t\tpr_warn(\"ISA: Non-PCI bridge %pOF has non aligned IO range\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\t/* Got it */\n\tisa_bridge_devnode = np;\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge\n\t * and map it\n\t */\n\tisa_io_base = ISA_IO_BASE;\n\tremap_isa_base(pbase, size);\n\n\tpr_debug(\"ISA: Non-PCI bridge is %pOF\\n\", np);\n}"
  },
  {
    "function_name": "isa_bridge_find_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "141-179",
    "snippet": "void __init isa_bridge_find_early(struct pci_controller *hose)\n{\n\tstruct device_node *np, *parent = NULL, *tmp;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\t/* For each \"isa\" node in the system. Note : we do a search by\n\t * type and not by name. It might be better to do by name but that's\n\t * what the code used to do and I don't want to break too much at\n\t * once. We can look into changing that separately\n\t */\n\tfor_each_node_by_type(np, \"isa\") {\n\t\t/* Look for our hose being a parent */\n\t\tfor (parent = of_get_parent(np); parent;) {\n\t\t\tif (parent == hose->dn) {\n\t\t\t\tof_node_put(parent);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = parent;\n\t\t\tparent = of_get_parent(parent);\n\t\t\tof_node_put(tmp);\n\t\t}\n\t\tif (parent != NULL)\n\t\t\tbreak;\n\t}\n\tif (np == NULL)\n\t\treturn;\n\tisa_bridge_devnode = np;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(np, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (early) is %pOF\\n\", np);\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base;",
      "static struct device_node *isa_bridge_devnode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ISA bridge (early) is %pOF\\n\"",
            "np"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_process_ISA_OF_ranges",
          "args": [
            "np",
            "hose->io_base_phys"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_ISA_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "58-132",
          "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define ISA_SPACE_IO 0x1",
            "#define ISA_SPACE_MASK 0x1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "tmp"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "parent"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "np"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_by_type",
          "args": [
            "np",
            "\"isa\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base;\nstatic struct device_node *isa_bridge_devnode;\n\nvoid __init isa_bridge_find_early(struct pci_controller *hose)\n{\n\tstruct device_node *np, *parent = NULL, *tmp;\n\n\t/* If we already have an ISA bridge, bail off */\n\tif (isa_bridge_devnode != NULL)\n\t\treturn;\n\n\t/* For each \"isa\" node in the system. Note : we do a search by\n\t * type and not by name. It might be better to do by name but that's\n\t * what the code used to do and I don't want to break too much at\n\t * once. We can look into changing that separately\n\t */\n\tfor_each_node_by_type(np, \"isa\") {\n\t\t/* Look for our hose being a parent */\n\t\tfor (parent = of_get_parent(np); parent;) {\n\t\t\tif (parent == hose->dn) {\n\t\t\t\tof_node_put(parent);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp = parent;\n\t\t\tparent = of_get_parent(parent);\n\t\t\tof_node_put(tmp);\n\t\t}\n\t\tif (parent != NULL)\n\t\t\tbreak;\n\t}\n\tif (np == NULL)\n\t\treturn;\n\tisa_bridge_devnode = np;\n\n\t/* Now parse the \"ranges\" property and setup the ISA mapping */\n\tpci_process_ISA_OF_ranges(np, hose->io_base_phys);\n\n\t/* Set the global ISA io base to indicate we have an ISA bridge */\n\tisa_io_base = ISA_IO_BASE;\n\n\tpr_debug(\"ISA bridge (early) is %pOF\\n\", np);\n}"
  },
  {
    "function_name": "pci_process_ISA_OF_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "58-132",
    "snippet": "static void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define ISA_SPACE_IO 0x1",
      "#define ISA_SPACE_MASK 0x1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_isa_base",
          "args": [
            "phb_io_base_phys",
            "0x10000"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "remap_isa_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
          "lines": "42-56",
          "snippet": "static void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}",
          "includes": [
            "#include <asm/isa-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "range->size"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"unexpected isa to pci mapping: %s\\n\"",
            "__func__"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "isa_node",
            "\"ranges\"",
            "&rlen"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define ISA_SPACE_IO 0x1\n#define ISA_SPACE_MASK 0x1\n\nstatic void pci_process_ISA_OF_ranges(struct device_node *isa_node,\n\t\t\t\t      unsigned long phb_io_base_phys)\n{\n\t/* We should get some saner parsing here and remove these structs */\n\tstruct pci_address {\n\t\tu32 a_hi;\n\t\tu32 a_mid;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_address {\n\t\tu32 a_hi;\n\t\tu32 a_lo;\n\t};\n\n\tstruct isa_range {\n\t\tstruct isa_address isa_addr;\n\t\tstruct pci_address pci_addr;\n\t\tunsigned int size;\n\t};\n\n\tconst struct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = of_get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range)))\n\t\tgoto inval_range;\n\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:\n\t *   cells 0 - 1:\tan ISA address\n\t *   cells 2 - 4:\ta PCI address\n\t *\t\t\t(size depending on dev->n_addr_cells)\n\t *   cell 5:\t\tthe size of the range\n\t */\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO) {\n\t\trange++;\n\t\trlen -= sizeof(struct isa_range);\n\t\tif (rlen < sizeof(struct isa_range))\n\t\t\tgoto inval_range;\n\t}\n\tif ((range->isa_addr.a_hi & ISA_SPACE_MASK) != ISA_SPACE_IO)\n\t\tgoto inval_range;\n\n\tisa_addr = range->isa_addr.a_lo;\n\tpci_addr = (unsigned long) range->pci_addr.a_mid << 32 |\n\t\trange->pci_addr.a_lo;\n\n\t/* Assume these are both zero. Note: We could fix that and\n\t * do a proper parsing instead ... oh well, that will do for\n\t * now as nobody uses fancy mappings for ISA bridges\n\t */\n\tif ((pci_addr != 0) || (isa_addr != 0)) {\n\t\tprintk(KERN_ERR \"unexpected isa to pci mapping: %s\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Align size and make sure it's cropped to 64K */\n\tsize = PAGE_ALIGN(range->size);\n\tif (size > 0x10000)\n\t\tsize = 0x10000;\n\n\tremap_isa_base(phb_io_base_phys, size);\n\treturn;\n\ninval_range:\n\tprintk(KERN_ERR \"no ISA IO ranges or unexpected isa range, \"\n\t       \"mapping 64k\\n\");\n\tremap_isa_base(phb_io_base_phys, 0x10000);\n}"
  },
  {
    "function_name": "remap_isa_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/isa-bridge.c",
    "lines": "42-56",
    "snippet": "static void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}",
    "includes": [
      "#include <asm/isa-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/notifier.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_ioremap_range",
          "args": [
            "ISA_IO_BASE",
            "pa",
            "size",
            "pgprot_noncached(PAGE_KERNEL)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_kernel_range",
          "args": [
            "ISA_IO_BASE",
            "size"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap_page_range",
          "args": [
            "ISA_IO_BASE",
            "ISA_IO_BASE + size",
            "pa",
            "pgprot_noncached(PAGE_KERNEL)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "size & ~PAGE_MASK"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pa & ~PAGE_MASK"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ISA_IO_BASE & ~PAGE_MASK"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/isa-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void remap_isa_base(phys_addr_t pa, unsigned long size)\n{\n\tWARN_ON_ONCE(ISA_IO_BASE & ~PAGE_MASK);\n\tWARN_ON_ONCE(pa & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\tif (slab_is_available()) {\n\t\tif (ioremap_page_range(ISA_IO_BASE, ISA_IO_BASE + size, pa,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL)))\n\t\t\tunmap_kernel_range(ISA_IO_BASE, size);\n\t} else {\n\t\tearly_ioremap_range(ISA_IO_BASE, pa, size,\n\t\t\t\tpgprot_noncached(PAGE_KERNEL));\n\t}\n}"
  }
]