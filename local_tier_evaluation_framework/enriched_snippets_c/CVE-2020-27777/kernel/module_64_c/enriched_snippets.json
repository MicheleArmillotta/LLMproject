[
  {
    "function_name": "module_finalize_ftrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "781-800",
    "snippet": "int module_finalize_ftrace(struct module *mod, const Elf_Shdr *sechdrs)\n{\n\tmod->arch.tramp = stub_for_addr(sechdrs,\n\t\t\t\t\t(unsigned long)ftrace_caller,\n\t\t\t\t\tmod,\n\t\t\t\t\t\"ftrace_caller\");\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tmod->arch.tramp_regs = stub_for_addr(sechdrs,\n\t\t\t\t\t(unsigned long)ftrace_regs_caller,\n\t\t\t\t\tmod,\n\t\t\t\t\t\"ftrace_regs_caller\");\n\tif (!mod->arch.tramp_regs)\n\t\treturn -ENOENT;\n#endif\n\n\tif (!mod->arch.tramp)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stub_for_addr",
          "args": [
            "sechdrs",
            "(unsigned long)ftrace_regs_caller",
            "mod",
            "\"ftrace_regs_caller\""
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "stub_for_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "467-491",
          "snippet": "static unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint module_finalize_ftrace(struct module *mod, const Elf_Shdr *sechdrs)\n{\n\tmod->arch.tramp = stub_for_addr(sechdrs,\n\t\t\t\t\t(unsigned long)ftrace_caller,\n\t\t\t\t\tmod,\n\t\t\t\t\t\"ftrace_caller\");\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tmod->arch.tramp_regs = stub_for_addr(sechdrs,\n\t\t\t\t\t(unsigned long)ftrace_regs_caller,\n\t\t\t\t\tmod,\n\t\t\t\t\t\"ftrace_regs_caller\");\n\tif (!mod->arch.tramp_regs)\n\t\treturn -ENOENT;\n#endif\n\n\tif (!mod->arch.tramp)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "module_trampoline_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "745-779",
    "snippet": "int module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STUB_MAGIC 0x73747562 /* stub */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stub_func_addr",
          "args": [
            "funcdata"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "stub_func_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "77-80",
          "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: fault reading funcdata for stub %lx for %s\\n\"",
            "__func__",
            "addr",
            "mod->name"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&funcdata",
            "&stub->funcdata",
            "sizeof(funcdata)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad magic for stub %lx for %s\\n\"",
            "__func__",
            "addr",
            "mod->name"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: fault reading magic for stub %lx for %s\\n\"",
            "__func__",
            "addr",
            "mod->name"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&magic",
            "&stub->magic",
            "sizeof(magic)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: stub %lx not in module %s\\n\"",
            "__func__",
            "addr",
            "mod->name"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "addr",
            "mod"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nint module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_relocate_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "520-742",
    "snippet": "int apply_relocate_add(Elf64_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *me)\n{\n\tunsigned int i;\n\tElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf64_Sym *sym;\n\tunsigned long *location;\n\tunsigned long value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\n\t/* First time we're called, we can fix up .TOC. */\n\tif (!me->arch.toc_fixed) {\n\t\tsym = find_dot_toc(sechdrs, strtab, symindex);\n\t\t/* It's theoretically possible that a module doesn't want a\n\t\t * .TOC. so don't fail it just for that. */\n\t\tif (sym)\n\t\t\tsym->st_value = my_r2(sechdrs, me);\n\t\tme->arch.toc_fixed = true;\n\t}\n\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to */\n\t\tsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF64_R_SYM(rela[i].r_info);\n\n\t\tpr_debug(\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\",\n\t\t       location, (long)ELF64_R_TYPE(rela[i].r_info),\n\t\t       strtab + sym->st_name, (unsigned long)sym->st_value,\n\t\t       (long)rela[i].r_addend);\n\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC64_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ADDR64:\n\t\t\t/* Simply set it */\n\t\t\t*(unsigned long *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC:\n\t\t\t*(unsigned long *)location = my_r2(sechdrs, me);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif (value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16 relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0) {\n\t\t\t\tpr_err(\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_HA:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\t/* FIXME: Handle weak symbols here --RR */\n\t\t\tif (sym->st_shndx == SHN_UNDEF ||\n\t\t\t    sym->st_shndx == SHN_LIVEPATCH) {\n\t\t\t\t/* External: go via stub */\n\t\t\t\tvalue = stub_for_addr(sechdrs, value, me,\n\t\t\t\t\t\tstrtab + sym->st_name);\n\t\t\t\tif (!value)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\tif (!restore_r2(strtab + sym->st_name,\n\t\t\t\t\t\t\t(u32 *)location + 1, me))\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t} else\n\t\t\t\tvalue += local_entry_offset(sym);\n\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\n\t\t\t\tpr_err(\"%s: REL24 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| (value & 0x03fffffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL64:\n\t\t\t/* 64 bits relative (used by features fixups) */\n\t\t\t*location = value - (unsigned long)location;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL32:\n\t\t\t/* 32 bits relative (used by relative exception tables) */\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x80000000 > 0xffffffff) {\n\t\t\t\tpr_err(\"%s: REL32 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOCSAVE:\n\t\t\t/*\n\t\t\t * Marker reloc indicates we don't have to save r2.\n\t\t\t * That would only save us one instruction, so ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ENTRY:\n\t\t\t/*\n\t\t\t * Optimize ELFv2 large code model entry point if\n\t\t\t * the TOC is within 2GB range of current location.\n\t\t\t */\n\t\t\tvalue = my_r2(sechdrs, me) - (unsigned long)location;\n\t\t\tif (value + 0x80008000 > 0xffffffff)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Check for the large code model prolog sequence:\n\t\t         *\tld r2, ...(r12)\n\t\t\t *\tadd r2, r2, r12\n\t\t\t */\n\t\t\tif ((((uint32_t *)location)[0] & ~0xfffc) !=\n\t\t\t    (PPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R12)))\n\t\t\t\tbreak;\n\t\t\tif (((uint32_t *)location)[1] !=\n\t\t\t    (PPC_INST_ADD | __PPC_RT(R2) | __PPC_RA(R2) | __PPC_RB(R12)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If found, replace it with:\n\t\t\t *\taddis r2, r12, (.TOC.-func)@ha\n\t\t\t *\taddi  r2,  r2, (.TOC.-func)@l\n\t\t\t */\n\t\t\t((uint32_t *)location)[0] = PPC_INST_ADDIS | __PPC_RT(R2) |\n\t\t\t\t\t\t    __PPC_RA(R12) | PPC_HA(value);\n\t\t\t((uint32_t *)location)[1] = PPC_INST_ADDI | __PPC_RT(R2) |\n\t\t\t\t\t\t    __PPC_RA(R2) | PPC_LO(value);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_HA:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_LO:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown ADD relocation: %lu\\n\",\n\t\t\t       me->name,\n\t\t\t       (unsigned long)ELF64_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Unknown ADD relocation: %lu\\n\"",
            "me->name",
            "(unsigned long)ELF64_R_TYPE(rela[i].r_info)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_LO",
          "args": [
            "value"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RA",
          "args": [
            "R2"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R2"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_HA",
          "args": [
            "value"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RA",
          "args": [
            "R12"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R2"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RB",
          "args": [
            "R12"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RA",
          "args": [
            "R2"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R2"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RA",
          "args": [
            "R12"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R2"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_r2",
          "args": [
            "sechdrs",
            "me"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "my_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "429-432",
          "snippet": "static inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: REL32 %li out of range!\\n\"",
            "me->name",
            "(long int)value"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: REL24 %li out of range!\\n\"",
            "me->name",
            "(long int)value"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_entry_offset",
          "args": [
            "sym"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "local_entry_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "81-84",
          "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_r2",
          "args": [
            "strtab + sym->st_name",
            "(u32 *)location + 1",
            "me"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "restore_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "495-518",
          "snippet": "static int restore_r2(const char *name, u32 *instruction, struct module *me)\n{\n\tu32 *prev_insn = instruction - 1;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn 1;\n\n\t/*\n\t * Make sure the branch isn't a sibling call.  Sibling calls aren't\n\t * \"link\" branches and they don't return, so they don't need the r2\n\t * restore afterwards.\n\t */\n\tif (!instr_is_relative_link_branch(ppc_inst(*prev_insn)))\n\t\treturn 1;\n\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expected nop after call, got %08x at %pS\\n\",\n\t\t\tme->name, *instruction, instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = PPC_INST_LD_TOC;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic int restore_r2(const char *name, u32 *instruction, struct module *me)\n{\n\tu32 *prev_insn = instruction - 1;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn 1;\n\n\t/*\n\t * Make sure the branch isn't a sibling call.  Sibling calls aren't\n\t * \"link\" branches and they don't return, so they don't need the r2\n\t * restore afterwards.\n\t */\n\tif (!instr_is_relative_link_branch(ppc_inst(*prev_insn)))\n\t\treturn 1;\n\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expected nop after call, got %08x at %pS\\n\",\n\t\t\tme->name, *instruction, instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = PPC_INST_LD_TOC;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stub_for_addr",
          "args": [
            "sechdrs",
            "value",
            "me",
            "strtab + sym->st_name"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "stub_for_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "467-491",
          "snippet": "static unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16_DS relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16 relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\"",
            "location",
            "(long)ELF64_R_TYPE(rela[i].r_info)",
            "strtab + sym->st_name",
            "(unsigned long)sym->st_value",
            "(long)rela[i].r_addend"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_dot_toc",
          "args": [
            "sechdrs",
            "strtab",
            "symindex"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "find_dot_toc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "270-286",
          "snippet": "static Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_ABS\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_ABS\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Applying ADD relocate section %u to %u\\n\"",
            "relsec",
            "sechdrs[relsec].sh_info"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint apply_relocate_add(Elf64_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *me)\n{\n\tunsigned int i;\n\tElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf64_Sym *sym;\n\tunsigned long *location;\n\tunsigned long value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\n\t/* First time we're called, we can fix up .TOC. */\n\tif (!me->arch.toc_fixed) {\n\t\tsym = find_dot_toc(sechdrs, strtab, symindex);\n\t\t/* It's theoretically possible that a module doesn't want a\n\t\t * .TOC. so don't fail it just for that. */\n\t\tif (sym)\n\t\t\tsym->st_value = my_r2(sechdrs, me);\n\t\tme->arch.toc_fixed = true;\n\t}\n\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to */\n\t\tsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF64_R_SYM(rela[i].r_info);\n\n\t\tpr_debug(\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\",\n\t\t       location, (long)ELF64_R_TYPE(rela[i].r_info),\n\t\t       strtab + sym->st_name, (unsigned long)sym->st_value,\n\t\t       (long)rela[i].r_addend);\n\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC64_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ADDR64:\n\t\t\t/* Simply set it */\n\t\t\t*(unsigned long *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC:\n\t\t\t*(unsigned long *)location = my_r2(sechdrs, me);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif (value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16 relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0) {\n\t\t\t\tpr_err(\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_HA:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\t/* FIXME: Handle weak symbols here --RR */\n\t\t\tif (sym->st_shndx == SHN_UNDEF ||\n\t\t\t    sym->st_shndx == SHN_LIVEPATCH) {\n\t\t\t\t/* External: go via stub */\n\t\t\t\tvalue = stub_for_addr(sechdrs, value, me,\n\t\t\t\t\t\tstrtab + sym->st_name);\n\t\t\t\tif (!value)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\tif (!restore_r2(strtab + sym->st_name,\n\t\t\t\t\t\t\t(u32 *)location + 1, me))\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t} else\n\t\t\t\tvalue += local_entry_offset(sym);\n\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\n\t\t\t\tpr_err(\"%s: REL24 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| (value & 0x03fffffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL64:\n\t\t\t/* 64 bits relative (used by features fixups) */\n\t\t\t*location = value - (unsigned long)location;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL32:\n\t\t\t/* 32 bits relative (used by relative exception tables) */\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x80000000 > 0xffffffff) {\n\t\t\t\tpr_err(\"%s: REL32 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOCSAVE:\n\t\t\t/*\n\t\t\t * Marker reloc indicates we don't have to save r2.\n\t\t\t * That would only save us one instruction, so ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ENTRY:\n\t\t\t/*\n\t\t\t * Optimize ELFv2 large code model entry point if\n\t\t\t * the TOC is within 2GB range of current location.\n\t\t\t */\n\t\t\tvalue = my_r2(sechdrs, me) - (unsigned long)location;\n\t\t\tif (value + 0x80008000 > 0xffffffff)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Check for the large code model prolog sequence:\n\t\t         *\tld r2, ...(r12)\n\t\t\t *\tadd r2, r2, r12\n\t\t\t */\n\t\t\tif ((((uint32_t *)location)[0] & ~0xfffc) !=\n\t\t\t    (PPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R12)))\n\t\t\t\tbreak;\n\t\t\tif (((uint32_t *)location)[1] !=\n\t\t\t    (PPC_INST_ADD | __PPC_RT(R2) | __PPC_RA(R2) | __PPC_RB(R12)))\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If found, replace it with:\n\t\t\t *\taddis r2, r12, (.TOC.-func)@ha\n\t\t\t *\taddi  r2,  r2, (.TOC.-func)@l\n\t\t\t */\n\t\t\t((uint32_t *)location)[0] = PPC_INST_ADDIS | __PPC_RT(R2) |\n\t\t\t\t\t\t    __PPC_RA(R12) | PPC_HA(value);\n\t\t\t((uint32_t *)location)[1] = PPC_INST_ADDI | __PPC_RT(R2) |\n\t\t\t\t\t\t    __PPC_RA(R2) | PPC_LO(value);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_HA:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_LO:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown ADD relocation: %lu\\n\",\n\t\t\t       me->name,\n\t\t\t       (unsigned long)ELF64_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_r2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "495-518",
    "snippet": "static int restore_r2(const char *name, u32 *instruction, struct module *me)\n{\n\tu32 *prev_insn = instruction - 1;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn 1;\n\n\t/*\n\t * Make sure the branch isn't a sibling call.  Sibling calls aren't\n\t * \"link\" branches and they don't return, so they don't need the r2\n\t * restore afterwards.\n\t */\n\tif (!instr_is_relative_link_branch(ppc_inst(*prev_insn)))\n\t\treturn 1;\n\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expected nop after call, got %08x at %pS\\n\",\n\t\t\tme->name, *instruction, instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = PPC_INST_LD_TOC;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Expected nop after call, got %08x at %pS\\n\"",
            "me->name",
            "*instruction",
            "instruction"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instr_is_relative_link_branch",
          "args": [
            "ppc_inst(*prev_insn)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "*prev_insn"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mprofile_ftrace_call",
          "args": [
            "name"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "is_mprofile_ftrace_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "417-420",
          "snippet": "static bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic int restore_r2(const char *name, u32 *instruction, struct module *me)\n{\n\tu32 *prev_insn = instruction - 1;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn 1;\n\n\t/*\n\t * Make sure the branch isn't a sibling call.  Sibling calls aren't\n\t * \"link\" branches and they don't return, so they don't need the r2\n\t * restore afterwards.\n\t */\n\tif (!instr_is_relative_link_branch(ppc_inst(*prev_insn)))\n\t\treturn 1;\n\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expected nop after call, got %08x at %pS\\n\",\n\t\t\tme->name, *instruction, instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = PPC_INST_LD_TOC;\n\treturn 1;\n}"
  },
  {
    "function_name": "stub_for_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "467-491",
    "snippet": "static unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_stub",
          "args": [
            "sechdrs",
            "&stubs[i]",
            "addr",
            "me",
            "name"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "create_stub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "435-463",
          "snippet": "static inline int create_stub(const Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me,\n\t\t\t      const char *name)\n{\n\tlong reladdr;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn create_ftrace_stub(entry, addr, me);\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STUB_MAGIC 0x73747562 /* stub */"
          ],
          "globals_used": [
            "static u32 ppc64_stub_insns[] = {\n\tPPC_INST_ADDIS | __PPC_RT(R11) | __PPC_RA(R2),\n\tPPC_INST_ADDI | __PPC_RT(R11) | __PPC_RA(R11),\n\t/* Save current r2 value in magic place on the stack. */\n\tPPC_INST_STD | __PPC_RS(R2) | __PPC_RA(R1) | R2_STACK_OFFSET,\n\tPPC_INST_LD | __PPC_RT(R12) | __PPC_RA(R11) | 32,\n#ifdef PPC64_ELF_ABI_v1\n\t/* Set up new r2 from function descriptor */\n\tPPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R11) | 40,\n#endif\n\tPPC_INST_MTCTR | __PPC_RS(R12),\n\tPPC_INST_BCTR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nstatic u32 ppc64_stub_insns[] = {\n\tPPC_INST_ADDIS | __PPC_RT(R11) | __PPC_RA(R2),\n\tPPC_INST_ADDI | __PPC_RT(R11) | __PPC_RA(R11),\n\t/* Save current r2 value in magic place on the stack. */\n\tPPC_INST_STD | __PPC_RS(R2) | __PPC_RA(R1) | R2_STACK_OFFSET,\n\tPPC_INST_LD | __PPC_RT(R12) | __PPC_RA(R11) | 32,\n#ifdef PPC64_ELF_ABI_v1\n\t/* Set up new r2 from function descriptor */\n\tPPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R11) | 40,\n#endif\n\tPPC_INST_MTCTR | __PPC_RS(R12),\n\tPPC_INST_BCTR,\n};\n\nstatic inline int create_stub(const Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me,\n\t\t\t      const char *name)\n{\n\tlong reladdr;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn create_ftrace_stub(entry, addr, me);\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "func_addr",
          "args": [
            "addr"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "stub_func_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "77-80",
          "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "i >= num_stubs"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_for_addr(const Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me,\n\t\t\t\t   const char *name)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tif (WARN_ON(i >= num_stubs))\n\t\t\treturn 0;\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me, name))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}"
  },
  {
    "function_name": "create_stub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "435-463",
    "snippet": "static inline int create_stub(const Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me,\n\t\t\t      const char *name)\n{\n\tlong reladdr;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn create_ftrace_stub(entry, addr, me);\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STUB_MAGIC 0x73747562 /* stub */"
    ],
    "globals_used": [
      "static u32 ppc64_stub_insns[] = {\n\tPPC_INST_ADDIS | __PPC_RT(R11) | __PPC_RA(R2),\n\tPPC_INST_ADDI | __PPC_RT(R11) | __PPC_RA(R11),\n\t/* Save current r2 value in magic place on the stack. */\n\tPPC_INST_STD | __PPC_RS(R2) | __PPC_RA(R1) | R2_STACK_OFFSET,\n\tPPC_INST_LD | __PPC_RT(R12) | __PPC_RA(R11) | 32,\n#ifdef PPC64_ELF_ABI_v1\n\t/* Set up new r2 from function descriptor */\n\tPPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R11) | 40,\n#endif\n\tPPC_INST_MTCTR | __PPC_RS(R12),\n\tPPC_INST_BCTR,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "func_desc",
          "args": [
            "addr"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "func_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "69-72",
          "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_LO",
          "args": [
            "reladdr"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_HA",
          "args": [
            "reladdr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Stub %p get data from reladdr %li\\n\"",
            "entry",
            "reladdr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Address %p of stub out of range of %p.\\n\"",
            "me->name",
            "(void *)reladdr",
            "(void *)my_r2"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_r2",
          "args": [
            "sechdrs",
            "me"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "my_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "429-432",
          "snippet": "static inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->jump",
            "ppc64_stub_insns",
            "sizeof(ppc64_stub_insns)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_ftrace_stub",
          "args": [
            "entry",
            "addr",
            "me"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "create_ftrace_stub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "410-415",
          "snippet": "static inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mprofile_ftrace_call",
          "args": [
            "name"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "is_mprofile_ftrace_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "417-420",
          "snippet": "static bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nstatic u32 ppc64_stub_insns[] = {\n\tPPC_INST_ADDIS | __PPC_RT(R11) | __PPC_RA(R2),\n\tPPC_INST_ADDI | __PPC_RT(R11) | __PPC_RA(R11),\n\t/* Save current r2 value in magic place on the stack. */\n\tPPC_INST_STD | __PPC_RS(R2) | __PPC_RA(R1) | R2_STACK_OFFSET,\n\tPPC_INST_LD | __PPC_RT(R12) | __PPC_RA(R11) | 32,\n#ifdef PPC64_ELF_ABI_v1\n\t/* Set up new r2 from function descriptor */\n\tPPC_INST_LD | __PPC_RT(R2) | __PPC_RA(R11) | 40,\n#endif\n\tPPC_INST_MTCTR | __PPC_RS(R12),\n\tPPC_INST_BCTR,\n};\n\nstatic inline int create_stub(const Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me,\n\t\t\t      const char *name)\n{\n\tlong reladdr;\n\n\tif (is_mprofile_ftrace_call(name))\n\t\treturn create_ftrace_stub(entry, addr, me);\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "my_r2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "429-432",
    "snippet": "static inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(const Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn (sechdrs[me->arch.toc_section].sh_addr & ~0xfful) + 0x8000;\n}"
  },
  {
    "function_name": "is_mprofile_ftrace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "417-420",
    "snippet": "static bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic bool is_mprofile_ftrace_call(const char *name)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "create_ftrace_stub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "410-415",
    "snippet": "static inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "is_mprofile_ftrace_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "394-408",
    "snippet": "static bool is_mprofile_ftrace_call(const char *name)\n{\n\tif (!strcmp(\"_mcount\", name))\n\t\treturn true;\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!strcmp(\"ftrace_caller\", name))\n\t\treturn true;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tif (!strcmp(\"ftrace_regs_caller\", name))\n\t\treturn true;\n#endif\n#endif\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"ftrace_regs_caller\"",
            "name"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic bool is_mprofile_ftrace_call(const char *name)\n{\n\tif (!strcmp(\"_mcount\", name))\n\t\treturn true;\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (!strcmp(\"ftrace_caller\", name))\n\t\treturn true;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tif (!strcmp(\"ftrace_regs_caller\", name))\n\t\treturn true;\n#endif\n#endif\n\n\treturn false;\n}"
  },
  {
    "function_name": "create_ftrace_stub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "368-392",
    "snippet": "static inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, stub_insns, sizeof(stub_insns));\n\n\t/* Stub uses address relative to kernel toc (from the paca) */\n\treladdr = addr - kernel_toc_addr();\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address of %ps out of range of kernel_toc.\\n\",\n\t\t\t\t\t\t\tme->name, (void *)addr);\n\t\treturn 0;\n\t}\n\n\tentry->jump[1] |= PPC_HA(reladdr);\n\tentry->jump[2] |= PPC_LO(reladdr);\n\n\t/* Eventhough we don't use funcdata in the stub, it's needed elsewhere. */\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STUB_MAGIC 0x73747562 /* stub */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func_desc",
          "args": [
            "addr"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "func_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "69-72",
          "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_LO",
          "args": [
            "reladdr"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_HA",
          "args": [
            "reladdr"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Address of %ps out of range of kernel_toc.\\n\"",
            "me->name",
            "(void *)addr"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_toc_addr",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->jump",
            "stub_insns",
            "sizeof(stub_insns)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nstatic inline int create_ftrace_stub(struct ppc64_stub_entry *entry,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tstruct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, stub_insns, sizeof(stub_insns));\n\n\t/* Stub uses address relative to kernel toc (from the paca) */\n\treladdr = addr - kernel_toc_addr();\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address of %ps out of range of kernel_toc.\\n\",\n\t\t\t\t\t\t\tme->name, (void *)addr);\n\t\treturn 0;\n\t}\n\n\tentry->jump[1] |= PPC_HA(reladdr);\n\tentry->jump[2] |= PPC_LO(reladdr);\n\n\t/* Eventhough we don't use funcdata in the stub, it's needed elsewhere. */\n\tentry->funcdata = func_desc(addr);\n\tentry->magic = STUB_MAGIC;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "module_frob_arch_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "288-335",
    "snippet": "int module_frob_arch_sections(Elf64_Ehdr *hdr,\n\t\t\t      Elf64_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .toc and .stubs sections, symtab and strtab */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tchar *p;\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".stubs\") == 0)\n\t\t\tme->arch.stubs_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".toc\") == 0) {\n\t\t\tme->arch.toc_section = i;\n\t\t\tif (sechdrs[i].sh_addralign < 8)\n\t\t\t\tsechdrs[i].sh_addralign = 8;\n\t\t}\n\t\telse if (strcmp(secstrings+sechdrs[i].sh_name,\"__versions\")==0)\n\t\t\tdedotify_versions((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t\t  sechdrs[i].sh_size);\n\n\t\t/* We don't handle .init for the moment: rename to _init */\n\t\twhile ((p = strstr(secstrings + sechdrs[i].sh_name, \".init\")))\n\t\t\tp[0] = '_';\n\n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB)\n\t\t\tdedotify((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t sechdrs[i].sh_size / sizeof(Elf64_Sym),\n\t\t\t\t (void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset);\n\t}\n\n\tif (!me->arch.stubs_section) {\n\t\tpr_err(\"%s: doesn't contain .stubs.\\n\", me->name);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* If we don't have a .toc, just use .stubs.  We need to set r2\n\t   to some reasonable value in case the module calls out to\n\t   other functions via a stub, or if a function pointer escapes\n\t   the module by some means.  */\n\tif (!me->arch.toc_section)\n\t\tme->arch.toc_section = me->arch.stubs_section;\n\n\t/* Override the stubs size */\n\tsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stubs_size",
          "args": [
            "hdr",
            "sechdrs"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "get_stubs_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "195-236",
          "snippet": "static unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, NULL);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* an additional one for ftrace_regs_caller */\n\trelocs++;\n#endif\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, NULL);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* an additional one for ftrace_regs_caller */\n\trelocs++;\n#endif\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: doesn't contain .stubs.\\n\"",
            "me->name"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dedotify",
          "args": [
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size / sizeof(Elf64_Sym)",
            "(void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "dedotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "254-268",
          "snippet": "static void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.') {\n\t\t\t\tif (strcmp(name+1, \"TOC.\") == 0)\n\t\t\t\t\tsyms[i].st_shndx = SHN_ABS;\n\t\t\t\tsyms[i].st_name++;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.') {\n\t\t\t\tif (strcmp(name+1, \"TOC.\") == 0)\n\t\t\t\t\tsyms[i].st_shndx = SHN_ABS;\n\t\t\t\tsyms[i].st_name++;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".init\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "290-305",
          "snippet": "static char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dedotify_versions",
          "args": [
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "dedotify_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "239-248",
          "snippet": "static void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n\t\t}\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings+sechdrs[i].sh_name",
            "\"__versions\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint module_frob_arch_sections(Elf64_Ehdr *hdr,\n\t\t\t      Elf64_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .toc and .stubs sections, symtab and strtab */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tchar *p;\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".stubs\") == 0)\n\t\t\tme->arch.stubs_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".toc\") == 0) {\n\t\t\tme->arch.toc_section = i;\n\t\t\tif (sechdrs[i].sh_addralign < 8)\n\t\t\t\tsechdrs[i].sh_addralign = 8;\n\t\t}\n\t\telse if (strcmp(secstrings+sechdrs[i].sh_name,\"__versions\")==0)\n\t\t\tdedotify_versions((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t\t  sechdrs[i].sh_size);\n\n\t\t/* We don't handle .init for the moment: rename to _init */\n\t\twhile ((p = strstr(secstrings + sechdrs[i].sh_name, \".init\")))\n\t\t\tp[0] = '_';\n\n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB)\n\t\t\tdedotify((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t sechdrs[i].sh_size / sizeof(Elf64_Sym),\n\t\t\t\t (void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset);\n\t}\n\n\tif (!me->arch.stubs_section) {\n\t\tpr_err(\"%s: doesn't contain .stubs.\\n\", me->name);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* If we don't have a .toc, just use .stubs.  We need to set r2\n\t   to some reasonable value in case the module calls out to\n\t   other functions via a stub, or if a function pointer escapes\n\t   the module by some means.  */\n\tif (!me->arch.toc_section)\n\t\tme->arch.toc_section = me->arch.stubs_section;\n\n\t/* Override the stubs size */\n\tsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_dot_toc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "270-286",
    "snippet": "static Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_ABS\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strtab + syms[i].st_name",
            "\"TOC.\""
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_ABS\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dedotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "254-268",
    "snippet": "static void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.') {\n\t\t\t\tif (strcmp(name+1, \"TOC.\") == 0)\n\t\t\t\t\tsyms[i].st_shndx = SHN_ABS;\n\t\t\t\tsyms[i].st_name++;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name+1",
            "\"TOC.\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.') {\n\t\t\t\tif (strcmp(name+1, \"TOC.\") == 0)\n\t\t\t\t\tsyms[i].st_shndx = SHN_ABS;\n\t\t\t\tsyms[i].st_name++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dedotify_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "239-248",
    "snippet": "static void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n\t\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "vers->name",
            "vers->name+1",
            "strlen(vers->name)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vers->name"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "270-277",
          "snippet": "static size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n\t\t}\n}"
  },
  {
    "function_name": "get_stubs_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "195-236",
    "snippet": "static unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, NULL);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* an additional one for ftrace_regs_caller */\n\trelocs++;\n#endif\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Looks like a total of %lu stubs, max\\n\"",
            "relocs"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_relocs",
          "args": [
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "count_relocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "150-169",
          "snippet": "static unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size / sizeof(Elf64_Rela)",
            "sizeof(Elf64_Rela)",
            "relacmp",
            "NULL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Ptr: %p.  Number: %Lu\\n\"",
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size / sizeof(Elf64_Rela)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Found relocations in section %u\\n\"",
            "i"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, NULL);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* an additional one for ftrace_regs_caller */\n\trelocs++;\n#endif\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}"
  },
  {
    "function_name": "relacmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "171-192",
    "snippet": "static int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf64_Rela *x, *y;\n\n\ty = (Elf64_Rela *)_x;\n\tx = (Elf64_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF64_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf64_Rela *x, *y;\n\n\ty = (Elf64_Rela *)_x;\n\tx = (Elf64_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF64_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "count_relocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "150-169",
    "snippet": "static unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}"
  },
  {
    "function_name": "dereference_module_function_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "86-93",
    "snippet": "void *dereference_module_function_descriptor(struct module *mod, void *ptr)\n{\n\tif (ptr < (void *)mod->arch.start_opd ||\n\t\t\tptr >= (void *)mod->arch.end_opd)\n\t\treturn ptr;\n\n\treturn dereference_function_descriptor(ptr);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dereference_function_descriptor",
          "args": [
            "ptr"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nvoid *dereference_module_function_descriptor(struct module *mod, void *ptr)\n{\n\tif (ptr < (void *)mod->arch.start_opd ||\n\t\t\tptr >= (void *)mod->arch.end_opd)\n\t\treturn ptr;\n\n\treturn dereference_function_descriptor(ptr);\n}"
  },
  {
    "function_name": "local_entry_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "81-84",
    "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "stub_func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "77-80",
    "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}"
  },
  {
    "function_name": "func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "73-76",
    "snippet": "static unsigned long func_addr(unsigned long addr)\n{\n\treturn func_desc(addr).funcaddr;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func_desc",
          "args": [
            "addr"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "func_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "69-72",
          "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long func_addr(unsigned long addr)\n{\n\treturn func_desc(addr).funcaddr;\n}"
  },
  {
    "function_name": "func_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "69-72",
    "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
  },
  {
    "function_name": "local_entry_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "57-63",
    "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\t/* sym->st_other indicates offset to local entry point\n\t * (otherwise it will assume r12 is the address of the start\n\t * of function and try to derive r2 from it). */\n\treturn PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PPC64_LOCAL_ENTRY_OFFSET",
          "args": [
            "sym->st_other"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\t/* sym->st_other indicates offset to local entry point\n\t * (otherwise it will assume r12 is the address of the start\n\t * of function and try to derive r2 from it). */\n\treturn PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\n}"
  },
  {
    "function_name": "stub_func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "46-49",
    "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func;\n}"
  },
  {
    "function_name": "func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "42-45",
    "snippet": "static unsigned long func_addr(unsigned long addr)\n{\n\treturn addr;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long func_addr(unsigned long addr)\n{\n\treturn addr;\n}"
  },
  {
    "function_name": "func_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
    "lines": "38-41",
    "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn addr;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn addr;\n}"
  }
]