[
  {
    "function_name": "tm_cgpr32_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "781-787",
    "snippet": "int tm_cgpr32_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gpr32_set_common",
          "args": [
            "target",
            "regset",
            "pos",
            "count",
            "kbuf",
            "ubuf",
            "&target->thread.ckpt_regs.gpr[0]"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "gpr32_set_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "650-716",
          "snippet": "int gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cgpr32_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}"
  },
  {
    "function_name": "tm_cgpr32_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "773-779",
    "snippet": "int tm_cgpr32_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  struct membuf to)\n{\n\tgpr32_get_common(target, regset, to,\n\t\t\t\t&target->thread.ckpt_regs.gpr[0]);\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(u32));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_zero",
          "args": [
            "&to",
            "ELF_NGREG * sizeof(u32)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpr32_get_common",
          "args": [
            "target",
            "regset",
            "to",
            "&target->thread.ckpt_regs.gpr[0]"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "gpr32_get_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "636-648",
          "snippet": "int gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     struct membuf to, unsigned long *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < PT_MSR; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\tmembuf_store(&to, (u32)get_user_msr(target));\n\tfor (i++ ; i < PT_REGS_COUNT; i++)\n\t\tmembuf_store(&to, (u32)regs[i]);\n\treturn membuf_zero(&to, (ELF_NGREG - PT_REGS_COUNT) * sizeof(u32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cgpr32_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  struct membuf to)\n{\n\tgpr32_get_common(target, regset, to,\n\t\t\t\t&target->thread.ckpt_regs.gpr[0]);\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(u32));\n}"
  },
  {
    "function_name": "tm_dscr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "756-771",
    "snippet": "int tm_dscr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_dscr",
            "0",
            "sizeof(u64)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_dscr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_dscr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "744-754",
    "snippet": "int tm_dscr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_dscr, sizeof(u64));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_dscr",
            "sizeof(u64)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_dscr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_dscr, sizeof(u64));\n}"
  },
  {
    "function_name": "tm_dscr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "733-742",
    "snippet": "int tm_dscr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_dscr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tm_ppr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "716-731",
    "snippet": "int tm_ppr_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_ppr",
            "0",
            "sizeof(u64)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_ppr_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_ppr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "704-714",
    "snippet": "int tm_ppr_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_ppr, sizeof(u64));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_ppr",
            "sizeof(u64)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_ppr_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_ppr, sizeof(u64));\n}"
  },
  {
    "function_name": "tm_ppr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "692-701",
    "snippet": "int tm_ppr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_ppr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tm_tar_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "675-690",
    "snippet": "int tm_tar_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_tar",
            "0",
            "sizeof(u64)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_tar_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_tar_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "663-673",
    "snippet": "int tm_tar_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_tar, sizeof(u64));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_tar",
            "sizeof(u64)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_tar_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\treturn membuf_write(&to, &target->thread.tm_tar, sizeof(u64));\n}"
  },
  {
    "function_name": "tm_tar_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "652-661",
    "snippet": "int tm_tar_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_tar_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tm_spr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "615-650",
    "snippet": "int tm_spr_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t\t 2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.tm_tfiar,\n\t\t\t\t\t 2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_tfiar",
            "2 * sizeof(u64)",
            "3 * sizeof(u64)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_texasr",
            "sizeof(u64)",
            "2 * sizeof(u64)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.tm_tfhar",
            "0",
            "sizeof(u64)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ckpt_regs"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfiar"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfiar"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_texasr"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_texasr"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfhar"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_spr_set(struct task_struct *target, const struct user_regset *regset,\n\t       unsigned int pos, unsigned int count,\n\t       const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t\t 2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.tm_tfiar,\n\t\t\t\t\t 2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_spr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "573-595",
    "snippet": "int tm_spr_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tmembuf_write(&to, &target->thread.tm_tfhar, sizeof(u64));\n\t/* TEXASR register */\n\tmembuf_write(&to, &target->thread.tm_texasr, sizeof(u64));\n\t/* TFIAR register */\n\treturn membuf_write(&to, &target->thread.tm_tfiar, sizeof(u64));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_tfiar",
            "sizeof(u64)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_texasr",
            "sizeof(u64)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.tm_tfhar",
            "sizeof(u64)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "ckpt_regs"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfiar"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfiar"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_texasr"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_texasr"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSO",
          "args": [
            "tm_tfhar"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_spr_get(struct task_struct *target, const struct user_regset *regset,\n\t       struct membuf to)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tmembuf_write(&to, &target->thread.tm_tfhar, sizeof(u64));\n\t/* TEXASR register */\n\tmembuf_write(&to, &target->thread.tm_texasr, sizeof(u64));\n\t/* TFIAR register */\n\treturn membuf_write(&to, &target->thread.tm_tfiar, sizeof(u64));\n}"
  },
  {
    "function_name": "tm_spr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "550-556",
    "snippet": "int tm_spr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_spr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "tm_cvsx_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "511-540",
    "snippet": "int tm_cvsx_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "32 * sizeof(double)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvsx_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_cvsx_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "468-489",
    "snippet": "int tm_cvsx_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tu64 buf[32];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn membuf_write(&to, buf, 32 * sizeof(double));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "buf",
            "32 * sizeof(double)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvsx_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tu64 buf[32];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn membuf_write(&to, buf, 32 * sizeof(double));\n}"
  },
  {
    "function_name": "tm_cvsx_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "439-449",
    "snippet": "int tm_cvsx_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "355-365",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP)) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvsx_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}"
  },
  {
    "function_name": "tm_cvmx_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "392-429",
    "snippet": "int tm_cvmx_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.ckvr_state,\n\t\t\t\t 0, 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.ckvrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&vrsave",
            "33 * sizeof(vector128)",
            "-1"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vrsave",
            "0",
            "sizeof(vrsave)"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.ckvr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TVSO(vscr) != TVSO(vr[32])"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TVSO",
          "args": [
            "vr[32]"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TVSO",
          "args": [
            "vscr"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvmx_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &target->thread.ckvr_state,\n\t\t\t\t 0, 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.ckvrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_cvmx_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "341-368",
    "snippet": "int tm_cvmx_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tunion {\n\t\telf_vrreg_t reg;\n\t\tu32 word;\n\t} vrsave;\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tmembuf_write(&to, &target->thread.ckvr_state, 33 * sizeof(vector128));\n\t/*\n\t * Copy out only the low-order word of vrsave.\n\t */\n\tmemset(&vrsave, 0, sizeof(vrsave));\n\tvrsave.word = target->thread.ckvrsave;\n\treturn membuf_write(&to, &vrsave, sizeof(vrsave));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&vrsave",
            "sizeof(vrsave)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vrsave",
            "0",
            "sizeof(vrsave)"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.ckvr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "TVSO(vscr) != TVSO(vr[32])"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TVSO",
          "args": [
            "vr[32]"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TVSO",
          "args": [
            "vscr"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvmx_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tunion {\n\t\telf_vrreg_t reg;\n\t\tu32 word;\n\t} vrsave;\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tmembuf_write(&to, &target->thread.ckvr_state, 33 * sizeof(vector128));\n\t/*\n\t * Copy out only the low-order word of vrsave.\n\t */\n\tmemset(&vrsave, 0, sizeof(vrsave));\n\tvrsave.word = target->thread.ckvrsave;\n\treturn membuf_write(&to, &vrsave, sizeof(vrsave));\n}"
  },
  {
    "function_name": "tm_cvmx_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "311-320",
    "snippet": "int tm_cvmx_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cvmx_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "tm_cfpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "272-301",
    "snippet": "int tm_cfpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_CKFPR(i) = buf[i];\n\ttarget->thread.ckfp_state.fpscr = buf[32];\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target->thread.TS_CKFPR",
          "args": [
            "i"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "-1"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_CKFPR",
          "args": [
            "i"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cfpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_CKFPR(i) = buf[i];\n\ttarget->thread.ckfp_state.fpscr = buf[32];\n\treturn 0;\n}"
  },
  {
    "function_name": "tm_cfpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "228-249",
    "snippet": "int tm_cfpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\treturn membuf_write(&to, buf, sizeof(buf));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "buf",
            "sizeof(buf)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_CKFPR",
          "args": [
            "i"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cfpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\treturn membuf_write(&to, buf, sizeof(buf));\n}"
  },
  {
    "function_name": "tm_cfpr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "199-208",
    "snippet": "int tm_cfpr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cfpr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "tm_cgpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "133-189",
    "snippet": "int tm_cgpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.ckpt_regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\t\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_TRAP + 1) * sizeof(reg)",
            "-1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_ckpt_trap",
          "args": [
            "target",
            "reg"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_ckpt_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "44-48",
          "snippet": "static int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(&task->thread.ckpt_regs, trap);\n\treturn 0;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(&task->thread.ckpt_regs, trap);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_TRAP * sizeof(reg)",
            "(PT_TRAP + 1) * sizeof(reg)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)",
            "PT_TRAP * sizeof(reg)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.ckpt_regs.orig_gpr3",
            "PT_ORIG_R3 * sizeof(reg)",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_ckpt_msr",
          "args": [
            "target",
            "reg"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_ckpt_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "37-42",
          "snippet": "static int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_MSR * sizeof(reg)",
            "(PT_MSR + 1) * sizeof(reg)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.ckpt_regs",
            "0",
            "PT_MSR * sizeof(reg)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cgpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\tunsigned int pos, unsigned int count,\n\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.ckpt_regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\t\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tm_cgpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "86-111",
    "snippet": "int tm_cgpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tmembuf_write(&to, &target->thread.ckpt_regs,\n\t\t\toffsetof(struct pt_regs, msr));\n\tmembuf_store(&to, get_user_ckpt_msr(target));\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tmembuf_write(&to, &target->thread.ckpt_regs.orig_gpr3,\n\t\t\tsizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3));\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(unsigned long) -\n\t\t\tsizeof(struct user_pt_regs));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "membuf_zero",
          "args": [
            "&to",
            "ELF_NGREG * sizeof(unsigned long) -\n\t\t\tsizeof(struct user_pt_regs)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.ckpt_regs.orig_gpr3",
            "sizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membuf_store",
          "args": [
            "&to",
            "get_user_ckpt_msr(target)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ckpt_msr",
          "args": [
            "target"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_ckpt_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "32-35",
          "snippet": "static unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "membuf_write",
          "args": [
            "&to",
            "&target->thread.ckpt_regs",
            "offsetof(struct pt_regs, msr)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "288-298",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_altivec(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tmregs_to_thread",
          "args": [
            "target"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tmregs_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
          "lines": "11-30",
          "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cgpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\tstruct membuf to)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tmembuf_write(&to, &target->thread.ckpt_regs,\n\t\t\toffsetof(struct pt_regs, msr));\n\tmembuf_store(&to, get_user_ckpt_msr(target));\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tmembuf_write(&to, &target->thread.ckpt_regs.orig_gpr3,\n\t\t\tsizeof(struct user_pt_regs) -\n\t\t\toffsetof(struct pt_regs, orig_gpr3));\n\treturn membuf_zero(&to, ELF_NGREG * sizeof(unsigned long) -\n\t\t\tsizeof(struct user_pt_regs));\n}"
  },
  {
    "function_name": "tm_cgpr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "58-67",
    "snippet": "int tm_cgpr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "target->thread.regs->msr"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nint tm_cgpr_active(struct task_struct *target, const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}"
  },
  {
    "function_name": "set_user_ckpt_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "44-48",
    "snippet": "static int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(&task->thread.ckpt_regs, trap);\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_trap",
          "args": [
            "&task->thread.ckpt_regs",
            "trap"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\tset_trap(&task->thread.ckpt_regs, trap);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_ckpt_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "37-42",
    "snippet": "static int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_user_ckpt_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "32-35",
    "snippet": "static unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nstatic unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}"
  },
  {
    "function_name": "flush_tmregs_to_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-tm.c",
    "lines": "11-30",
    "snippet": "void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_save_sprs",
          "args": [
            "&tsk->thread"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_SIGNAL"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "959-963",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_SUSPENDED",
          "args": [
            "mfmsr()"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <linux/regset.h>\n\nvoid flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (!cpu_has_feature(CPU_FTR_TM) || tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&tsk->thread);\n\t}\n}"
  }
]