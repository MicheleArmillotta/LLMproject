[
  {
    "function_name": "vdso_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "692-791",
    "snippet": "static int __init vdso_init(void)\n{\n\tint i;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Fill up the \"systemcfg\" stuff for backward compatibility\n\t */\n\tstrcpy((char *)vdso_data->eye_catcher, \"SYSTEMCFG:PPC64\");\n\tvdso_data->version.major = SYSTEMCFG_MAJOR;\n\tvdso_data->version.minor = SYSTEMCFG_MINOR;\n\tvdso_data->processor = mfspr(SPRN_PVR);\n\t/*\n\t * Fake the old platform number for pSeries and add\n\t * in LPAR bit if necessary\n\t */\n\tvdso_data->platform = 0x100;\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\tvdso_data->platform |= 1;\n\tvdso_data->physicalMemorySize = memblock_phys_mem_size();\n\tvdso_data->dcache_size = ppc64_caches.l1d.size;\n\tvdso_data->dcache_line_size = ppc64_caches.l1d.line_size;\n\tvdso_data->icache_size = ppc64_caches.l1i.size;\n\tvdso_data->icache_line_size = ppc64_caches.l1i.line_size;\n\tvdso_data->dcache_block_size = ppc64_caches.l1d.block_size;\n\tvdso_data->icache_block_size = ppc64_caches.l1i.block_size;\n\tvdso_data->dcache_log_block_size = ppc64_caches.l1d.log_block_size;\n\tvdso_data->icache_log_block_size = ppc64_caches.l1i.log_block_size;\n\n\t/*\n\t * Calculate the size of the 64 bits vDSO\n\t */\n\tvdso64_pages = (&vdso64_end - &vdso64_start) >> PAGE_SHIFT;\n\tDBG(\"vdso64_kbase: %p, 0x%x pages\\n\", vdso64_kbase, vdso64_pages);\n#endif /* CONFIG_PPC64 */\n\n\n#ifdef CONFIG_VDSO32\n\tvdso32_kbase = &vdso32_start;\n\n\t/*\n\t * Calculate the size of the 32 bits vDSO\n\t */\n\tvdso32_pages = (&vdso32_end - &vdso32_start) >> PAGE_SHIFT;\n\tDBG(\"vdso32_kbase: %p, 0x%x pages\\n\", vdso32_kbase, vdso32_pages);\n#endif\n\n\n\t/*\n\t * Setup the syscall map in the vDOS\n\t */\n\tvdso_setup_syscall_map();\n\n\t/*\n\t * Initialize the vDSO images in memory, that is do necessary\n\t * fixups of vDSO symbols, locate trampolines, etc...\n\t */\n\tif (vdso_setup()) {\n\t\tprintk(KERN_ERR \"vDSO setup failure, not enabled !\\n\");\n\t\tvdso32_pages = 0;\n#ifdef CONFIG_PPC64\n\t\tvdso64_pages = 0;\n#endif\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_VDSO32\n\t/* Make sure pages are in the correct state */\n\tvdso32_pagelist = kcalloc(vdso32_pages + 2, sizeof(struct page *),\n\t\t\t\t  GFP_KERNEL);\n\tBUG_ON(vdso32_pagelist == NULL);\n\tfor (i = 0; i < vdso32_pages; i++) {\n\t\tstruct page *pg = virt_to_page(vdso32_kbase + i*PAGE_SIZE);\n\t\tget_page(pg);\n\t\tvdso32_pagelist[i] = pg;\n\t}\n\tvdso32_pagelist[i++] = virt_to_page(vdso_data);\n\tvdso32_pagelist[i] = NULL;\n#endif\n\n#ifdef CONFIG_PPC64\n\tvdso64_pagelist = kcalloc(vdso64_pages + 2, sizeof(struct page *),\n\t\t\t\t  GFP_KERNEL);\n\tBUG_ON(vdso64_pagelist == NULL);\n\tfor (i = 0; i < vdso64_pages; i++) {\n\t\tstruct page *pg = virt_to_page(vdso64_kbase + i*PAGE_SIZE);\n\t\tget_page(pg);\n\t\tvdso64_pagelist[i] = pg;\n\t}\n\tvdso64_pagelist[i++] = virt_to_page(vdso_data);\n\tvdso64_pagelist[i] = NULL;\n#endif /* CONFIG_PPC64 */\n\n\tget_page(virt_to_page(vdso_data));\n\n\tsmp_wmb();\n\tvdso_ready = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int vdso32_pages;",
      "static void *vdso32_kbase;",
      "static struct page **vdso32_pagelist;",
      "static int vdso_ready;",
      "static union {\n\tstruct vdso_data\tdata;\n\tu8\t\t\tpage[PAGE_SIZE];\n} vdso_data_store",
      "struct vdso_data *vdso_data = &vdso_data_store.data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "virt_to_page(vdso_data)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vdso_data"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vdso_data"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "pg"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vdso64_kbase + i*PAGE_SIZE"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vdso64_pagelist == NULL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "vdso64_pages + 2",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vdso_data"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "pg"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "vdso32_kbase + i*PAGE_SIZE"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vdso32_pagelist == NULL"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "vdso32_pages + 2",
            "sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO setup failure, not enabled !\\n\""
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdso_setup",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_setup_syscall_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "638-663",
          "snippet": "static void __init vdso_setup_syscall_map(void)\n{\n\tunsigned int i;\n\textern unsigned long *sys_call_table;\n#ifdef CONFIG_PPC64\n\textern unsigned long *compat_sys_call_table;\n#endif\n\textern unsigned long sys_ni_syscall;\n\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n#ifdef CONFIG_PPC64\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_64[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n\t\tif (IS_ENABLED(CONFIG_COMPAT) &&\n\t\t    compat_sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#else /* CONFIG_PPC64 */\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#endif /* CONFIG_PPC64 */\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vdso_data *vdso_data = &vdso_data_store.data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstruct vdso_data *vdso_data = &vdso_data_store.data;\n\nstatic void __init vdso_setup_syscall_map(void)\n{\n\tunsigned int i;\n\textern unsigned long *sys_call_table;\n#ifdef CONFIG_PPC64\n\textern unsigned long *compat_sys_call_table;\n#endif\n\textern unsigned long sys_ni_syscall;\n\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n#ifdef CONFIG_PPC64\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_64[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n\t\tif (IS_ENABLED(CONFIG_COMPAT) &&\n\t\t    compat_sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#else /* CONFIG_PPC64 */\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#endif /* CONFIG_PPC64 */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"vdso32_kbase: %p, 0x%x pages\\n\"",
            "vdso32_kbase",
            "vdso32_pages"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"vdso64_kbase: %p, 0x%x pages\\n\"",
            "vdso64_kbase",
            "vdso64_pages"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_LPAR"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *)vdso_data->eye_catcher",
            "\"SYSTEMCFG:PPC64\""
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "245-252",
          "snippet": "static char __init *prom_strcpy(char *dest, const char *src)\n{\n\tchar *tmp = dest;\n\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t/* nothing */;\n\treturn tmp;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic char __init *prom_strcpy(char *dest, const char *src)\n{\n\tchar *tmp = dest;\n\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t/* nothing */;\n\treturn tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned int vdso32_pages;\nstatic void *vdso32_kbase;\nstatic struct page **vdso32_pagelist;\nstatic int vdso_ready;\nstatic union {\n\tstruct vdso_data\tdata;\n\tu8\t\t\tpage[PAGE_SIZE];\n} vdso_data_store;\nstruct vdso_data *vdso_data = &vdso_data_store.data;\n\nstatic int __init vdso_init(void)\n{\n\tint i;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Fill up the \"systemcfg\" stuff for backward compatibility\n\t */\n\tstrcpy((char *)vdso_data->eye_catcher, \"SYSTEMCFG:PPC64\");\n\tvdso_data->version.major = SYSTEMCFG_MAJOR;\n\tvdso_data->version.minor = SYSTEMCFG_MINOR;\n\tvdso_data->processor = mfspr(SPRN_PVR);\n\t/*\n\t * Fake the old platform number for pSeries and add\n\t * in LPAR bit if necessary\n\t */\n\tvdso_data->platform = 0x100;\n\tif (firmware_has_feature(FW_FEATURE_LPAR))\n\t\tvdso_data->platform |= 1;\n\tvdso_data->physicalMemorySize = memblock_phys_mem_size();\n\tvdso_data->dcache_size = ppc64_caches.l1d.size;\n\tvdso_data->dcache_line_size = ppc64_caches.l1d.line_size;\n\tvdso_data->icache_size = ppc64_caches.l1i.size;\n\tvdso_data->icache_line_size = ppc64_caches.l1i.line_size;\n\tvdso_data->dcache_block_size = ppc64_caches.l1d.block_size;\n\tvdso_data->icache_block_size = ppc64_caches.l1i.block_size;\n\tvdso_data->dcache_log_block_size = ppc64_caches.l1d.log_block_size;\n\tvdso_data->icache_log_block_size = ppc64_caches.l1i.log_block_size;\n\n\t/*\n\t * Calculate the size of the 64 bits vDSO\n\t */\n\tvdso64_pages = (&vdso64_end - &vdso64_start) >> PAGE_SHIFT;\n\tDBG(\"vdso64_kbase: %p, 0x%x pages\\n\", vdso64_kbase, vdso64_pages);\n#endif /* CONFIG_PPC64 */\n\n\n#ifdef CONFIG_VDSO32\n\tvdso32_kbase = &vdso32_start;\n\n\t/*\n\t * Calculate the size of the 32 bits vDSO\n\t */\n\tvdso32_pages = (&vdso32_end - &vdso32_start) >> PAGE_SHIFT;\n\tDBG(\"vdso32_kbase: %p, 0x%x pages\\n\", vdso32_kbase, vdso32_pages);\n#endif\n\n\n\t/*\n\t * Setup the syscall map in the vDOS\n\t */\n\tvdso_setup_syscall_map();\n\n\t/*\n\t * Initialize the vDSO images in memory, that is do necessary\n\t * fixups of vDSO symbols, locate trampolines, etc...\n\t */\n\tif (vdso_setup()) {\n\t\tprintk(KERN_ERR \"vDSO setup failure, not enabled !\\n\");\n\t\tvdso32_pages = 0;\n#ifdef CONFIG_PPC64\n\t\tvdso64_pages = 0;\n#endif\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_VDSO32\n\t/* Make sure pages are in the correct state */\n\tvdso32_pagelist = kcalloc(vdso32_pages + 2, sizeof(struct page *),\n\t\t\t\t  GFP_KERNEL);\n\tBUG_ON(vdso32_pagelist == NULL);\n\tfor (i = 0; i < vdso32_pages; i++) {\n\t\tstruct page *pg = virt_to_page(vdso32_kbase + i*PAGE_SIZE);\n\t\tget_page(pg);\n\t\tvdso32_pagelist[i] = pg;\n\t}\n\tvdso32_pagelist[i++] = virt_to_page(vdso_data);\n\tvdso32_pagelist[i] = NULL;\n#endif\n\n#ifdef CONFIG_PPC64\n\tvdso64_pagelist = kcalloc(vdso64_pages + 2, sizeof(struct page *),\n\t\t\t\t  GFP_KERNEL);\n\tBUG_ON(vdso64_pagelist == NULL);\n\tfor (i = 0; i < vdso64_pages; i++) {\n\t\tstruct page *pg = virt_to_page(vdso64_kbase + i*PAGE_SIZE);\n\t\tget_page(pg);\n\t\tvdso64_pagelist[i] = pg;\n\t}\n\tvdso64_pagelist[i++] = virt_to_page(vdso_data);\n\tvdso64_pagelist[i] = NULL;\n#endif /* CONFIG_PPC64 */\n\n\tget_page(virt_to_page(vdso_data));\n\n\tsmp_wmb();\n\tvdso_ready = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_getcpu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "666-687",
    "snippet": "int vdso_getcpu_init(void)\n{\n\tunsigned long cpu, node, val;\n\n\t/*\n\t * SPRG_VDSO contains the CPU in the bottom 16 bits and the NUMA node\n\t * in the next 16 bits.  The VDSO uses this to implement getcpu().\n\t */\n\tcpu = get_cpu();\n\tWARN_ON_ONCE(cpu > 0xffff);\n\n\tnode = cpu_to_node(cpu);\n\tWARN_ON_ONCE(node > 0xffff);\n\n\tval = (cpu & 0xffff) | ((node & 0xffff) << 16);\n\tmtspr(SPRN_SPRG_VDSO_WRITE, val);\n\tget_paca()->sprg_vdso = val;\n\n\tput_cpu();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_SPRG_VDSO_WRITE",
            "val"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node > 0xffff"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu > 0xffff"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint vdso_getcpu_init(void)\n{\n\tunsigned long cpu, node, val;\n\n\t/*\n\t * SPRG_VDSO contains the CPU in the bottom 16 bits and the NUMA node\n\t * in the next 16 bits.  The VDSO uses this to implement getcpu().\n\t */\n\tcpu = get_cpu();\n\tWARN_ON_ONCE(cpu > 0xffff);\n\n\tnode = cpu_to_node(cpu);\n\tWARN_ON_ONCE(node > 0xffff);\n\n\tval = (cpu & 0xffff) | ((node & 0xffff) << 16);\n\tmtspr(SPRN_SPRG_VDSO_WRITE, val);\n\tget_paca()->sprg_vdso = val;\n\n\tput_cpu();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_setup_syscall_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "638-663",
    "snippet": "static void __init vdso_setup_syscall_map(void)\n{\n\tunsigned int i;\n\textern unsigned long *sys_call_table;\n#ifdef CONFIG_PPC64\n\textern unsigned long *compat_sys_call_table;\n#endif\n\textern unsigned long sys_ni_syscall;\n\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n#ifdef CONFIG_PPC64\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_64[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n\t\tif (IS_ENABLED(CONFIG_COMPAT) &&\n\t\t    compat_sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#else /* CONFIG_PPC64 */\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#endif /* CONFIG_PPC64 */\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vdso_data *vdso_data = &vdso_data_store.data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_COMPAT"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstruct vdso_data *vdso_data = &vdso_data_store.data;\n\nstatic void __init vdso_setup_syscall_map(void)\n{\n\tunsigned int i;\n\textern unsigned long *sys_call_table;\n#ifdef CONFIG_PPC64\n\textern unsigned long *compat_sys_call_table;\n#endif\n\textern unsigned long sys_ni_syscall;\n\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n#ifdef CONFIG_PPC64\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_64[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n\t\tif (IS_ENABLED(CONFIG_COMPAT) &&\n\t\t    compat_sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#else /* CONFIG_PPC64 */\n\t\tif (sys_call_table[i] != sys_ni_syscall)\n\t\t\tvdso_data->syscall_map_32[i >> 5] |=\n\t\t\t\t0x80000000UL >> (i & 0x1f);\n#endif /* CONFIG_PPC64 */\n\t}\n}"
  },
  {
    "function_name": "vdso_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "608-632",
    "snippet": "static __init int vdso_setup(void)\n{\n\tstruct lib32_elfinfo\tv32;\n\tstruct lib64_elfinfo\tv64;\n\n\tv32.hdr = vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64.hdr = vdso64_kbase;\n#endif\n\tif (vdso_do_find_sections(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_datapage(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_features(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_alt_funcs(&v32, &v64))\n\t\treturn -1;\n\n\tvdso_setup_trampolines(&v32, &v64);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *vdso32_kbase;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdso_setup_trampolines",
          "args": [
            "&v32",
            "&v64"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_setup_trampolines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "470-482",
          "snippet": "static __init void vdso_setup_trampolines(struct lib32_elfinfo *v32,\n\t\t\t\t\t  struct lib64_elfinfo *v64)\n{\n\t/*\n\t * Find signal trampolines\n\t */\n\n#ifdef CONFIG_PPC64\n\tvdso64_rt_sigtramp = find_function64(v64, \"__kernel_sigtramp_rt64\");\n#endif\n\tvdso32_sigtramp\t   = find_function32(v32, \"__kernel_sigtramp32\");\n\tvdso32_rt_sigtramp = find_function32(v32, \"__kernel_sigtramp_rt32\");\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long vdso32_sigtramp;",
            "unsigned long vdso32_rt_sigtramp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long vdso32_sigtramp;\nunsigned long vdso32_rt_sigtramp;\n\nstatic __init void vdso_setup_trampolines(struct lib32_elfinfo *v32,\n\t\t\t\t\t  struct lib64_elfinfo *v64)\n{\n\t/*\n\t * Find signal trampolines\n\t */\n\n#ifdef CONFIG_PPC64\n\tvdso64_rt_sigtramp = find_function64(v64, \"__kernel_sigtramp_rt64\");\n#endif\n\tvdso32_sigtramp\t   = find_function32(v32, \"__kernel_sigtramp32\");\n\tvdso32_rt_sigtramp = find_function32(v32, \"__kernel_sigtramp_rt32\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "vdso_fixup_alt_funcs",
          "args": [
            "&v32",
            "&v64"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_fixup_alt_funcs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "575-605",
          "snippet": "static __init int vdso_fixup_alt_funcs(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdso_patches); i++) {\n\t\tstruct vdso_patch_def *patch = &vdso_patches[i];\n\t\tint match = (cur_cpu_spec->cpu_features & patch->ftr_mask)\n\t\t\t== patch->ftr_value;\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tDBG(\"replacing %s with %s...\\n\", patch->gen_name,\n\t\t    patch->fix_name ? \"NONE\" : patch->fix_name);\n\n\t\t/*\n\t\t * Patch the 32 bits and 64 bits symbols. Note that we do not\n\t\t * patch the \".\" symbol on 64 bits.\n\t\t * It would be easy to do, but doesn't seem to be necessary,\n\t\t * patching the OPD symbol is enough.\n\t\t */\n\t\tvdso_do_func_patch32(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#ifdef CONFIG_PPC64\n\t\tvdso_do_func_patch64(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#endif /* CONFIG_PPC64 */\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vdso_patch_def vdso_patches[] = {\n\t{\n\t\tCPU_FTR_COHERENT_ICACHE, CPU_FTR_COHERENT_ICACHE,\n\t\t\"__kernel_sync_dicache\", \"__kernel_sync_dicache_p5\"\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct vdso_patch_def vdso_patches[] = {\n\t{\n\t\tCPU_FTR_COHERENT_ICACHE, CPU_FTR_COHERENT_ICACHE,\n\t\t\"__kernel_sync_dicache\", \"__kernel_sync_dicache_p5\"\n\t},\n};\n\nstatic __init int vdso_fixup_alt_funcs(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdso_patches); i++) {\n\t\tstruct vdso_patch_def *patch = &vdso_patches[i];\n\t\tint match = (cur_cpu_spec->cpu_features & patch->ftr_mask)\n\t\t\t== patch->ftr_value;\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tDBG(\"replacing %s with %s...\\n\", patch->gen_name,\n\t\t    patch->fix_name ? \"NONE\" : patch->fix_name);\n\n\t\t/*\n\t\t * Patch the 32 bits and 64 bits symbols. Note that we do not\n\t\t * patch the \".\" symbol on 64 bits.\n\t\t * It would be easy to do, but doesn't seem to be necessary,\n\t\t * patching the OPD symbol is enough.\n\t\t */\n\t\tvdso_do_func_patch32(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#ifdef CONFIG_PPC64\n\t\tvdso_do_func_patch64(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#endif /* CONFIG_PPC64 */\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vdso_fixup_features",
          "args": [
            "&v32",
            "&v64"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_fixup_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "520-573",
          "snippet": "static __init int vdso_fixup_features(struct lib32_elfinfo *v32,\n\t\t\t\t      struct lib64_elfinfo *v64)\n{\n\tunsigned long size;\n\tvoid *start;\n\n#ifdef CONFIG_PPC64\n\tstart = find_section64(v64->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tstart = find_section32(v32->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section32(v32->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n#ifdef CONFIG_PPC64\n\tstart = find_section32(v32->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n#endif /* CONFIG_PPC64 */\n\n\tstart = find_section32(v32->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic __init int vdso_fixup_features(struct lib32_elfinfo *v32,\n\t\t\t\t      struct lib64_elfinfo *v64)\n{\n\tunsigned long size;\n\tvoid *start;\n\n#ifdef CONFIG_PPC64\n\tstart = find_section64(v64->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tstart = find_section32(v32->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section32(v32->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n#ifdef CONFIG_PPC64\n\tstart = find_section32(v32->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n#endif /* CONFIG_PPC64 */\n\n\tstart = find_section32(v32->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vdso_fixup_datapage",
          "args": [
            "&v32",
            "&v64"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_fixup_datapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "484-517",
          "snippet": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n#ifdef CONFIG_VDSO32\n\tElf32_Sym *sym32;\n#endif\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int vdso32_pages;",
            "static void *vdso32_kbase;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned int vdso32_pages;\nstatic void *vdso32_kbase;\n\nstatic __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n#ifdef CONFIG_VDSO32\n\tElf32_Sym *sym32;\n#endif\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vdso_do_find_sections",
          "args": [
            "&v32",
            "&v64"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_do_find_sections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "428-468",
          "snippet": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\n\t/*\n\t * Locate symbol tables & text section\n\t */\n\n#ifdef CONFIG_VDSO32\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#endif\n\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif /* CONFIG_PPC64 */\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *vdso32_kbase;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void *vdso32_kbase;\n\nstatic __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\n\t/*\n\t * Locate symbol tables & text section\n\t */\n\n#ifdef CONFIG_VDSO32\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#endif\n\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif /* CONFIG_PPC64 */\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void *vdso32_kbase;\n\nstatic __init int vdso_setup(void)\n{\n\tstruct lib32_elfinfo\tv32;\n\tstruct lib64_elfinfo\tv64;\n\n\tv32.hdr = vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64.hdr = vdso64_kbase;\n#endif\n\tif (vdso_do_find_sections(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_datapage(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_features(&v32, &v64))\n\t\treturn -1;\n\n\tif (vdso_fixup_alt_funcs(&v32, &v64))\n\t\treturn -1;\n\n\tvdso_setup_trampolines(&v32, &v64);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_fixup_alt_funcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "575-605",
    "snippet": "static __init int vdso_fixup_alt_funcs(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdso_patches); i++) {\n\t\tstruct vdso_patch_def *patch = &vdso_patches[i];\n\t\tint match = (cur_cpu_spec->cpu_features & patch->ftr_mask)\n\t\t\t== patch->ftr_value;\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tDBG(\"replacing %s with %s...\\n\", patch->gen_name,\n\t\t    patch->fix_name ? \"NONE\" : patch->fix_name);\n\n\t\t/*\n\t\t * Patch the 32 bits and 64 bits symbols. Note that we do not\n\t\t * patch the \".\" symbol on 64 bits.\n\t\t * It would be easy to do, but doesn't seem to be necessary,\n\t\t * patching the OPD symbol is enough.\n\t\t */\n\t\tvdso_do_func_patch32(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#ifdef CONFIG_PPC64\n\t\tvdso_do_func_patch64(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#endif /* CONFIG_PPC64 */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vdso_patch_def vdso_patches[] = {\n\t{\n\t\tCPU_FTR_COHERENT_ICACHE, CPU_FTR_COHERENT_ICACHE,\n\t\t\"__kernel_sync_dicache\", \"__kernel_sync_dicache_p5\"\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdso_do_func_patch64",
          "args": [
            "v32",
            "v64",
            "patch->gen_name",
            "patch->fix_name"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_do_func_patch64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "396-423",
          "snippet": "static int __init vdso_do_func_patch64(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf64_Sym *sym64_gen, *sym64_fix;\n\n\tsym64_gen = find_symbol64(v64, orig);\n\tif (sym64_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym64_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym64_fix = find_symbol64(v64, fix);\n\tif (sym64_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym64_gen->st_value = sym64_fix->st_value;\n\tsym64_gen->st_size = sym64_fix->st_size;\n\tsym64_gen->st_info = sym64_fix->st_info;\n\tsym64_gen->st_other = sym64_fix->st_other;\n\tsym64_gen->st_shndx = sym64_fix->st_shndx;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init vdso_do_func_patch64(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf64_Sym *sym64_gen, *sym64_fix;\n\n\tsym64_gen = find_symbol64(v64, orig);\n\tif (sym64_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym64_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym64_fix = find_symbol64(v64, fix);\n\tif (sym64_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym64_gen->st_value = sym64_fix->st_value;\n\tsym64_gen->st_size = sym64_fix->st_size;\n\tsym64_gen->st_info = sym64_fix->st_info;\n\tsym64_gen->st_other = sym64_fix->st_other;\n\tsym64_gen->st_shndx = sym64_fix->st_shndx;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vdso_do_func_patch32",
          "args": [
            "v32",
            "v64",
            "patch->gen_name",
            "patch->fix_name"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "vdso_do_func_patch32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "325-330",
          "snippet": "static int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"replacing %s with %s...\\n\"",
            "patch->gen_name",
            "patch->fix_name ? \"NONE\" : patch->fix_name"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vdso_patches"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct vdso_patch_def vdso_patches[] = {\n\t{\n\t\tCPU_FTR_COHERENT_ICACHE, CPU_FTR_COHERENT_ICACHE,\n\t\t\"__kernel_sync_dicache\", \"__kernel_sync_dicache_p5\"\n\t},\n};\n\nstatic __init int vdso_fixup_alt_funcs(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vdso_patches); i++) {\n\t\tstruct vdso_patch_def *patch = &vdso_patches[i];\n\t\tint match = (cur_cpu_spec->cpu_features & patch->ftr_mask)\n\t\t\t== patch->ftr_value;\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tDBG(\"replacing %s with %s...\\n\", patch->gen_name,\n\t\t    patch->fix_name ? \"NONE\" : patch->fix_name);\n\n\t\t/*\n\t\t * Patch the 32 bits and 64 bits symbols. Note that we do not\n\t\t * patch the \".\" symbol on 64 bits.\n\t\t * It would be easy to do, but doesn't seem to be necessary,\n\t\t * patching the OPD symbol is enough.\n\t\t */\n\t\tvdso_do_func_patch32(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#ifdef CONFIG_PPC64\n\t\tvdso_do_func_patch64(v32, v64, patch->gen_name,\n\t\t\t\t     patch->fix_name);\n#endif /* CONFIG_PPC64 */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_fixup_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "520-573",
    "snippet": "static __init int vdso_fixup_features(struct lib32_elfinfo *v32,\n\t\t\t\t      struct lib64_elfinfo *v64)\n{\n\tunsigned long size;\n\tvoid *start;\n\n#ifdef CONFIG_PPC64\n\tstart = find_section64(v64->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tstart = find_section32(v32->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section32(v32->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n#ifdef CONFIG_PPC64\n\tstart = find_section32(v32->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n#endif /* CONFIG_PPC64 */\n\n\tstart = find_section32(v32->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lwsync_fixups",
          "args": [
            "cur_cpu_spec->cpu_features",
            "start",
            "start + size"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_section32",
          "args": [
            "v32->hdr",
            "\"__lwsync_fixup\"",
            "&size"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "find_section32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "231-252",
          "snippet": "static void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "powerpc_firmware_features",
            "start",
            "start + size"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "cur_cpu_spec->mmu_features",
            "start",
            "start + size"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "cur_cpu_spec->cpu_features",
            "start",
            "start + size"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_lwsync_fixups",
          "args": [
            "cur_cpu_spec->cpu_features",
            "start",
            "start + size"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_section64",
          "args": [
            "v64->hdr",
            "\"__lwsync_fixup\"",
            "&size"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "find_section64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "336-358",
          "snippet": "static void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "powerpc_firmware_features",
            "start",
            "start + size"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "cur_cpu_spec->mmu_features",
            "start",
            "start + size"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_feature_fixups",
          "args": [
            "cur_cpu_spec->cpu_features",
            "start",
            "start + size"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic __init int vdso_fixup_features(struct lib32_elfinfo *v32,\n\t\t\t\t      struct lib64_elfinfo *v64)\n{\n\tunsigned long size;\n\tvoid *start;\n\n#ifdef CONFIG_PPC64\n\tstart = find_section64(v64->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section64(v64->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tstart = find_section32(v32->hdr, \"__ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t  start, start + size);\n\n\tstart = find_section32(v32->hdr, \"__mmu_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(cur_cpu_spec->mmu_features,\n\t\t\t\t  start, start + size);\n\n#ifdef CONFIG_PPC64\n\tstart = find_section32(v32->hdr, \"__fw_ftr_fixup\", &size);\n\tif (start)\n\t\tdo_feature_fixups(powerpc_firmware_features,\n\t\t\t\t  start, start + size);\n#endif /* CONFIG_PPC64 */\n\n\tstart = find_section32(v32->hdr, \"__lwsync_fixup\", &size);\n\tif (start)\n\t\tdo_lwsync_fixups(cur_cpu_spec->cpu_features,\n\t\t\t\t start, start + size);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_fixup_datapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "484-517",
    "snippet": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n#ifdef CONFIG_VDSO32\n\tElf32_Sym *sym32;\n#endif\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int vdso32_pages;",
      "static void *vdso32_kbase;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_symbol32",
          "args": [
            "v32",
            "\"__kernel_datapage_offset\""
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "254-272",
          "snippet": "static Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_symbol64",
          "args": [
            "v64",
            "\"__kernel_datapage_offset\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "360-378",
          "snippet": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned int vdso32_pages;\nstatic void *vdso32_kbase;\n\nstatic __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n#ifdef CONFIG_VDSO32\n\tElf32_Sym *sym32;\n#endif\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_VDSO32\n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_setup_trampolines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "470-482",
    "snippet": "static __init void vdso_setup_trampolines(struct lib32_elfinfo *v32,\n\t\t\t\t\t  struct lib64_elfinfo *v64)\n{\n\t/*\n\t * Find signal trampolines\n\t */\n\n#ifdef CONFIG_PPC64\n\tvdso64_rt_sigtramp = find_function64(v64, \"__kernel_sigtramp_rt64\");\n#endif\n\tvdso32_sigtramp\t   = find_function32(v32, \"__kernel_sigtramp32\");\n\tvdso32_rt_sigtramp = find_function32(v32, \"__kernel_sigtramp_rt32\");\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long vdso32_sigtramp;",
      "unsigned long vdso32_rt_sigtramp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_function32",
          "args": [
            "v32",
            "\"__kernel_sigtramp_rt32\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "find_function32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "319-323",
          "snippet": "static unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_function64",
          "args": [
            "v64",
            "\"__kernel_sigtramp_rt64\""
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "find_function64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "383-394",
          "snippet": "static unsigned long __init find_function64(struct lib64_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf64_Sym *sym = find_symbol64(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO64: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO64_LBASE;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long __init find_function64(struct lib64_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf64_Sym *sym = find_symbol64(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO64: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO64_LBASE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long vdso32_sigtramp;\nunsigned long vdso32_rt_sigtramp;\n\nstatic __init void vdso_setup_trampolines(struct lib32_elfinfo *v32,\n\t\t\t\t\t  struct lib64_elfinfo *v64)\n{\n\t/*\n\t * Find signal trampolines\n\t */\n\n#ifdef CONFIG_PPC64\n\tvdso64_rt_sigtramp = find_function64(v64, \"__kernel_sigtramp_rt64\");\n#endif\n\tvdso32_sigtramp\t   = find_function32(v32, \"__kernel_sigtramp32\");\n\tvdso32_rt_sigtramp = find_function32(v32, \"__kernel_sigtramp_rt32\");\n}"
  },
  {
    "function_name": "vdso_do_find_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "428-468",
    "snippet": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\n\t/*\n\t * Locate symbol tables & text section\n\t */\n\n#ifdef CONFIG_VDSO32\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#endif\n\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif /* CONFIG_PPC64 */\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *vdso32_kbase;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO64: the .text section was not found\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_section64",
          "args": [
            "v64->hdr",
            "\".text\"",
            "NULL"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "find_section64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "336-358",
          "snippet": "static void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO64: required symbol section not found\\n\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO32: the .text section was not found\\n\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_section32",
          "args": [
            "v32->hdr",
            "\".text\"",
            "NULL"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "find_section32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "231-252",
          "snippet": "static void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO32: required symbol section not found\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void *vdso32_kbase;\n\nstatic __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\n\t/*\n\t * Locate symbol tables & text section\n\t */\n\n#ifdef CONFIG_VDSO32\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#endif\n\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif /* CONFIG_PPC64 */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_do_func_patch64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "396-423",
    "snippet": "static int __init vdso_do_func_patch64(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf64_Sym *sym64_gen, *sym64_fix;\n\n\tsym64_gen = find_symbol64(v64, orig);\n\tif (sym64_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym64_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym64_fix = find_symbol64(v64, fix);\n\tif (sym64_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym64_gen->st_value = sym64_fix->st_value;\n\tsym64_gen->st_size = sym64_fix->st_size;\n\tsym64_gen->st_info = sym64_fix->st_info;\n\tsym64_gen->st_other = sym64_fix->st_other;\n\tsym64_gen->st_shndx = sym64_fix->st_shndx;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO64: Can't find symbol %s !\\n\"",
            "fix"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_symbol64",
          "args": [
            "v64",
            "fix"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "360-378",
          "snippet": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init vdso_do_func_patch64(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf64_Sym *sym64_gen, *sym64_fix;\n\n\tsym64_gen = find_symbol64(v64, orig);\n\tif (sym64_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym64_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym64_fix = find_symbol64(v64, fix);\n\tif (sym64_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym64_gen->st_value = sym64_fix->st_value;\n\tsym64_gen->st_size = sym64_fix->st_size;\n\tsym64_gen->st_info = sym64_fix->st_info;\n\tsym64_gen->st_other = sym64_fix->st_other;\n\tsym64_gen->st_shndx = sym64_fix->st_shndx;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_function64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "383-394",
    "snippet": "static unsigned long __init find_function64(struct lib64_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf64_Sym *sym = find_symbol64(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO64: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO64_LBASE;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"vDSO64: function %s not found !\\n\"",
            "symname"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_symbol64",
          "args": [
            "lib",
            "symname"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "360-378",
          "snippet": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long __init find_function64(struct lib64_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf64_Sym *sym = find_symbol64(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO64: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO64_LBASE;\n}"
  },
  {
    "function_name": "find_symbol64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "360-378",
    "snippet": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define MAX_SYMNAME\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "symname",
            "name"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'@'"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "lib->dynstr + lib->dynsym[i].st_name",
            "MAX_SYMNAME"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_section64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "336-358",
    "snippet": "static void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secnames+sechdrs[i].sh_name",
            "secname"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section64(Elf64_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf64_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\tif (size)\n\t\t*size = 0;\n\treturn NULL;\n}"
  },
  {
    "function_name": "vdso_do_func_patch32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "325-330",
    "snippet": "static int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "find_function32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "319-323",
    "snippet": "static unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "vdso_do_func_patch32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "290-317",
    "snippet": "static int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf32_Sym *sym32_gen, *sym32_fix;\n\n\tsym32_gen = find_symbol32(v32, orig);\n\tif (sym32_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym32_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym32_fix = find_symbol32(v32, fix);\n\tif (sym32_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym32_gen->st_value = sym32_fix->st_value;\n\tsym32_gen->st_size = sym32_fix->st_size;\n\tsym32_gen->st_info = sym32_fix->st_info;\n\tsym32_gen->st_other = sym32_fix->st_other;\n\tsym32_gen->st_shndx = sym32_fix->st_shndx;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"vDSO32: Can't find symbol %s !\\n\"",
            "fix"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_symbol32",
          "args": [
            "v32",
            "fix"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "254-272",
          "snippet": "static Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int __init vdso_do_func_patch32(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64,\n\t\t\t\t       const char *orig, const char *fix)\n{\n\tElf32_Sym *sym32_gen, *sym32_fix;\n\n\tsym32_gen = find_symbol32(v32, orig);\n\tif (sym32_gen == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol %s !\\n\", orig);\n\t\treturn -1;\n\t}\n\tif (fix == NULL) {\n\t\tsym32_gen->st_name = 0;\n\t\treturn 0;\n\t}\n\tsym32_fix = find_symbol32(v32, fix);\n\tif (sym32_fix == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol %s !\\n\", fix);\n\t\treturn -1;\n\t}\n\tsym32_gen->st_value = sym32_fix->st_value;\n\tsym32_gen->st_size = sym32_fix->st_size;\n\tsym32_gen->st_info = sym32_fix->st_info;\n\tsym32_gen->st_other = sym32_fix->st_other;\n\tsym32_gen->st_shndx = sym32_fix->st_shndx;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_function32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "277-288",
    "snippet": "static unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf32_Sym *sym = find_symbol32(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO32: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO32_LBASE;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"vDSO32: function %s not found !\\n\"",
            "symname"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_symbol32",
          "args": [
            "lib",
            "symname"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "find_symbol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
          "lines": "254-272",
          "snippet": "static Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/vdso.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define MAX_SYMNAME\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long __init find_function32(struct lib32_elfinfo *lib,\n\t\t\t\t\t    const char *symname)\n{\n\tElf32_Sym *sym = find_symbol32(lib, symname);\n\n\tif (sym == NULL) {\n\t\tprintk(KERN_WARNING \"vDSO32: function %s not found !\\n\",\n\t\t       symname);\n\t\treturn 0;\n\t}\n\treturn sym->st_value - VDSO32_LBASE;\n}"
  },
  {
    "function_name": "find_symbol32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "254-272",
    "snippet": "static Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define MAX_SYMNAME\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "symname",
            "name"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'@'"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "name",
            "lib->dynstr + lib->dynsym[i].st_name",
            "MAX_SYMNAME"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_SYMNAME\t64\n\nstatic Elf32_Sym * __init find_symbol32(struct lib32_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf32_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_section32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "231-252",
    "snippet": "static void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secnames+sechdrs[i].sh_name",
            "secname"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void * __init find_section32(Elf32_Ehdr *ehdr, const char *secname,\n\t\t\t\t  unsigned long *size)\n{\n\tElf32_Shdr *sechdrs;\n\tunsigned int i;\n\tchar *secnames;\n\n\t/* Grab section headers and strings so we can tell who is who */\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\tsecnames = (void *)ehdr + sechdrs[ehdr->e_shstrndx].sh_offset;\n\n\t/* Find the section they want */\n\tfor (i = 1; i < ehdr->e_shnum; i++) {\n\t\tif (strcmp(secnames+sechdrs[i].sh_name, secname) == 0) {\n\t\t\tif (size)\n\t\t\t\t*size = sechdrs[i].sh_size;\n\t\t\treturn (void *)ehdr + sechdrs[i].sh_offset;\n\t\t}\n\t}\n\t*size = 0;\n\treturn NULL;\n}"
  },
  {
    "function_name": "arch_vma_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "221-226",
    "snippet": "const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\tif (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso_base)\n\t\treturn \"[vdso]\";\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nconst char *arch_vma_name(struct vm_area_struct *vma)\n{\n\tif (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso_base)\n\t\treturn \"[vdso]\";\n\treturn NULL;\n}"
  },
  {
    "function_name": "arch_setup_additional_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/vdso.c",
    "lines": "125-219",
    "snippet": "int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct page **vdso_pagelist;\n\tunsigned long vdso_pages;\n\tunsigned long vdso_base;\n\tint rc;\n\n\tif (!vdso_ready)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\tif (is_32bit_task()) {\n\t\tvdso_pagelist = vdso32_pagelist;\n\t\tvdso_pages = vdso32_pages;\n\t\tvdso_base = VDSO32_MBASE;\n\t} else {\n\t\tvdso_pagelist = vdso64_pagelist;\n\t\tvdso_pages = vdso64_pages;\n\t\t/*\n\t\t * On 64bit we don't have a preferred map address. This\n\t\t * allows get_unmapped_area to find an area near other mmaps\n\t\t * and most likely share a SLB entry.\n\t\t */\n\t\tvdso_base = 0;\n\t}\n#else\n\tvdso_pagelist = vdso32_pagelist;\n\tvdso_pages = vdso32_pages;\n\tvdso_base = VDSO32_MBASE;\n#endif\n\n\tcurrent->mm->context.vdso_base = 0;\n\n\t/* vDSO has a problem and was disabled, just don't \"enable\" it for the\n\t * process\n\t */\n\tif (vdso_pages == 0)\n\t\treturn 0;\n\t/* Add a page to the vdso size for the data page */\n\tvdso_pages ++;\n\n\t/*\n\t * pick a base address for the vDSO in process space. We try to put it\n\t * at vdso_base which is the \"natural\" base for it, but we might fail\n\t * and end up putting it elsewhere.\n\t * Add enough to the size so that the result can be aligned.\n\t */\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\tvdso_base = get_unmapped_area(NULL, vdso_base,\n\t\t\t\t      (vdso_pages << PAGE_SHIFT) +\n\t\t\t\t      ((VDSO_ALIGNMENT - 1) & PAGE_MASK),\n\t\t\t\t      0, 0);\n\tif (IS_ERR_VALUE(vdso_base)) {\n\t\trc = vdso_base;\n\t\tgoto fail_mmapsem;\n\t}\n\n\t/* Add required alignment. */\n\tvdso_base = ALIGN(vdso_base, VDSO_ALIGNMENT);\n\n\t/*\n\t * Put vDSO base into mm struct. We need to do this before calling\n\t * install_special_mapping or the perf counter mmap tracking code\n\t * will fail to recognise it as a vDSO (since arch_vma_name fails).\n\t */\n\tcurrent->mm->context.vdso_base = vdso_base;\n\n\t/*\n\t * our vma flags don't have VM_WRITE so by default, the process isn't\n\t * allowed to write those pages.\n\t * gdb can break that with ptrace interface, and thus trigger COW on\n\t * those pages but it's then your responsibility to never do that on\n\t * the \"data\" page of the vDSO or you'll stop getting kernel updates\n\t * and your nice userland gettimeofday will be totally dead.\n\t * It's fine to use that for setting breakpoints in the vDSO code\n\t * pages though.\n\t */\n\trc = install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT,\n\t\t\t\t     VM_READ|VM_EXEC|\n\t\t\t\t     VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,\n\t\t\t\t     vdso_pagelist);\n\tif (rc) {\n\t\tcurrent->mm->context.vdso_base = 0;\n\t\tgoto fail_mmapsem;\n\t}\n\n\tmmap_write_unlock(mm);\n\treturn 0;\n\n fail_mmapsem:\n\tmmap_write_unlock(mm);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <asm/vdso_datapage.h>",
      "#include <asm/vdso.h>",
      "#include <asm/firmware.h>",
      "#include <asm/sections.h>",
      "#include <asm/cputable.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <linux/memblock.h>",
      "#include <linux/security.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define VDSO_ALIGNMENT\t(1 << 16)"
    ],
    "globals_used": [
      "static unsigned int vdso32_pages;",
      "static struct page **vdso32_pagelist;",
      "static int vdso_ready;",
      "static union {\n\tstruct vdso_data\tdata;\n\tu8\t\t\tpage[PAGE_SIZE];\n} vdso_data_store"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap_write_unlock",
          "args": [
            "mm"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_write_unlock",
          "args": [
            "mm"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_special_mapping",
          "args": [
            "mm",
            "vdso_base",
            "vdso_pages << PAGE_SHIFT",
            "VM_READ|VM_EXEC|\n\t\t\t\t     VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC",
            "vdso_pagelist"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "vdso_base",
            "VDSO_ALIGNMENT"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "vdso_base"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "NULL",
            "vdso_base",
            "(vdso_pages << PAGE_SHIFT) +\n\t\t\t\t      ((VDSO_ALIGNMENT - 1) & PAGE_MASK)",
            "0",
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_write_lock_killable",
          "args": [
            "mm"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <asm/vdso_datapage.h>\n#include <asm/vdso.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu_context.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define VDSO_ALIGNMENT\t(1 << 16)\n\nstatic unsigned int vdso32_pages;\nstatic struct page **vdso32_pagelist;\nstatic int vdso_ready;\nstatic union {\n\tstruct vdso_data\tdata;\n\tu8\t\t\tpage[PAGE_SIZE];\n} vdso_data_store;\n\nint arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct page **vdso_pagelist;\n\tunsigned long vdso_pages;\n\tunsigned long vdso_base;\n\tint rc;\n\n\tif (!vdso_ready)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\tif (is_32bit_task()) {\n\t\tvdso_pagelist = vdso32_pagelist;\n\t\tvdso_pages = vdso32_pages;\n\t\tvdso_base = VDSO32_MBASE;\n\t} else {\n\t\tvdso_pagelist = vdso64_pagelist;\n\t\tvdso_pages = vdso64_pages;\n\t\t/*\n\t\t * On 64bit we don't have a preferred map address. This\n\t\t * allows get_unmapped_area to find an area near other mmaps\n\t\t * and most likely share a SLB entry.\n\t\t */\n\t\tvdso_base = 0;\n\t}\n#else\n\tvdso_pagelist = vdso32_pagelist;\n\tvdso_pages = vdso32_pages;\n\tvdso_base = VDSO32_MBASE;\n#endif\n\n\tcurrent->mm->context.vdso_base = 0;\n\n\t/* vDSO has a problem and was disabled, just don't \"enable\" it for the\n\t * process\n\t */\n\tif (vdso_pages == 0)\n\t\treturn 0;\n\t/* Add a page to the vdso size for the data page */\n\tvdso_pages ++;\n\n\t/*\n\t * pick a base address for the vDSO in process space. We try to put it\n\t * at vdso_base which is the \"natural\" base for it, but we might fail\n\t * and end up putting it elsewhere.\n\t * Add enough to the size so that the result can be aligned.\n\t */\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\tvdso_base = get_unmapped_area(NULL, vdso_base,\n\t\t\t\t      (vdso_pages << PAGE_SHIFT) +\n\t\t\t\t      ((VDSO_ALIGNMENT - 1) & PAGE_MASK),\n\t\t\t\t      0, 0);\n\tif (IS_ERR_VALUE(vdso_base)) {\n\t\trc = vdso_base;\n\t\tgoto fail_mmapsem;\n\t}\n\n\t/* Add required alignment. */\n\tvdso_base = ALIGN(vdso_base, VDSO_ALIGNMENT);\n\n\t/*\n\t * Put vDSO base into mm struct. We need to do this before calling\n\t * install_special_mapping or the perf counter mmap tracking code\n\t * will fail to recognise it as a vDSO (since arch_vma_name fails).\n\t */\n\tcurrent->mm->context.vdso_base = vdso_base;\n\n\t/*\n\t * our vma flags don't have VM_WRITE so by default, the process isn't\n\t * allowed to write those pages.\n\t * gdb can break that with ptrace interface, and thus trigger COW on\n\t * those pages but it's then your responsibility to never do that on\n\t * the \"data\" page of the vDSO or you'll stop getting kernel updates\n\t * and your nice userland gettimeofday will be totally dead.\n\t * It's fine to use that for setting breakpoints in the vDSO code\n\t * pages though.\n\t */\n\trc = install_special_mapping(mm, vdso_base, vdso_pages << PAGE_SHIFT,\n\t\t\t\t     VM_READ|VM_EXEC|\n\t\t\t\t     VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,\n\t\t\t\t     vdso_pagelist);\n\tif (rc) {\n\t\tcurrent->mm->context.vdso_base = 0;\n\t\tgoto fail_mmapsem;\n\t}\n\n\tmmap_write_unlock(mm);\n\treturn 0;\n\n fail_mmapsem:\n\tmmap_write_unlock(mm);\n\treturn rc;\n}"
  }
]