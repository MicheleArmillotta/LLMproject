[
  {
    "function_name": "hmi_exception_realmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "726-744",
    "snippet": "long hmi_exception_realmode(struct pt_regs *regs)\n{\t\n\tint ret;\n\n\tlocal_paca->hmi_irqs++;\n\n\tret = hmi_handle_debugtrig(regs);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\twait_for_subcore_guest_exit();\n\n\tif (ppc_md.hmi_exception_early)\n\t\tppc_md.hmi_exception_early(regs);\n\n\twait_for_tb_resync();\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_tb_resync",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.hmi_exception_early",
          "args": [
            "regs"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_subcore_guest_exit",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmi_handle_debugtrig",
          "args": [
            "regs"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "hmi_handle_debugtrig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "684-721",
          "snippet": "long hmi_handle_debugtrig(struct pt_regs *regs)\n{\n\tunsigned long hmer = mfspr(SPRN_HMER);\n\tlong ret = 0;\n\n\t/* HMER_DEBUG_TRIG bit is used for various workarounds on P9 */\n\tif (!((hmer & HMER_DEBUG_TRIG)\n\t      && hmer_debug_trig_function != DTRIG_UNKNOWN))\n\t\treturn -1;\n\t\t\n\thmer &= ~HMER_DEBUG_TRIG;\n\t/* HMER is a write-AND register */\n\tmtspr(SPRN_HMER, ~HMER_DEBUG_TRIG);\n\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\t/*\n\t\t * Now to avoid problems with soft-disable we\n\t\t * only do the emulation if we are coming from\n\t\t * host user space\n\t\t */\n\t\tif (regs && user_mode(regs))\n\t\t\tret = local_paca->hmi_p9_special_emu = 1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * See if any other HMI causes remain to be handled\n\t */\n\tif (hmer & mfspr(SPRN_HMEER))\n\t\treturn -1;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;\n\nlong hmi_handle_debugtrig(struct pt_regs *regs)\n{\n\tunsigned long hmer = mfspr(SPRN_HMER);\n\tlong ret = 0;\n\n\t/* HMER_DEBUG_TRIG bit is used for various workarounds on P9 */\n\tif (!((hmer & HMER_DEBUG_TRIG)\n\t      && hmer_debug_trig_function != DTRIG_UNKNOWN))\n\t\treturn -1;\n\t\t\n\thmer &= ~HMER_DEBUG_TRIG;\n\t/* HMER is a write-AND register */\n\tmtspr(SPRN_HMER, ~HMER_DEBUG_TRIG);\n\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\t/*\n\t\t * Now to avoid problems with soft-disable we\n\t\t * only do the emulation if we are coming from\n\t\t * host user space\n\t\t */\n\t\tif (regs && user_mode(regs))\n\t\t\tret = local_paca->hmi_p9_special_emu = 1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * See if any other HMI causes remain to be handled\n\t */\n\tif (hmer & mfspr(SPRN_HMEER))\n\t\treturn -1;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nlong hmi_exception_realmode(struct pt_regs *regs)\n{\t\n\tint ret;\n\n\tlocal_paca->hmi_irqs++;\n\n\tret = hmi_handle_debugtrig(regs);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\twait_for_subcore_guest_exit();\n\n\tif (ppc_md.hmi_exception_early)\n\t\tppc_md.hmi_exception_early(regs);\n\n\twait_for_tb_resync();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "hmi_handle_debugtrig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "684-721",
    "snippet": "long hmi_handle_debugtrig(struct pt_regs *regs)\n{\n\tunsigned long hmer = mfspr(SPRN_HMER);\n\tlong ret = 0;\n\n\t/* HMER_DEBUG_TRIG bit is used for various workarounds on P9 */\n\tif (!((hmer & HMER_DEBUG_TRIG)\n\t      && hmer_debug_trig_function != DTRIG_UNKNOWN))\n\t\treturn -1;\n\t\t\n\thmer &= ~HMER_DEBUG_TRIG;\n\t/* HMER is a write-AND register */\n\tmtspr(SPRN_HMER, ~HMER_DEBUG_TRIG);\n\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\t/*\n\t\t * Now to avoid problems with soft-disable we\n\t\t * only do the emulation if we are coming from\n\t\t * host user space\n\t\t */\n\t\tif (regs && user_mode(regs))\n\t\t\tret = local_paca->hmi_p9_special_emu = 1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * See if any other HMI causes remain to be handled\n\t */\n\tif (hmer & mfspr(SPRN_HMEER))\n\t\treturn -1;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HMEER"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_HMER",
            "~HMER_DEBUG_TRIG"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HMER"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;\n\nlong hmi_handle_debugtrig(struct pt_regs *regs)\n{\n\tunsigned long hmer = mfspr(SPRN_HMER);\n\tlong ret = 0;\n\n\t/* HMER_DEBUG_TRIG bit is used for various workarounds on P9 */\n\tif (!((hmer & HMER_DEBUG_TRIG)\n\t      && hmer_debug_trig_function != DTRIG_UNKNOWN))\n\t\treturn -1;\n\t\t\n\thmer &= ~HMER_DEBUG_TRIG;\n\t/* HMER is a write-AND register */\n\tmtspr(SPRN_HMER, ~HMER_DEBUG_TRIG);\n\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\t/*\n\t\t * Now to avoid problems with soft-disable we\n\t\t * only do the emulation if we are coming from\n\t\t * host user space\n\t\t */\n\t\tif (regs && user_mode(regs))\n\t\t\tret = local_paca->hmi_p9_special_emu = 1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * See if any other HMI causes remain to be handled\n\t */\n\tif (hmer & mfspr(SPRN_HMEER))\n\t\treturn -1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_debug_trig_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "625-674",
    "snippet": "static int init_debug_trig_function(void)\n{\n\tint pvr;\n\tstruct device_node *cpun;\n\tstruct property *prop = NULL;\n\tconst char *str;\n\n\t/* First look in the device tree */\n\tpreempt_disable();\n\tcpun = of_get_cpu_node(smp_processor_id(), NULL);\n\tif (cpun) {\n\t\tof_property_for_each_string(cpun, \"ibm,hmi-special-triggers\",\n\t\t\t\t\t    prop, str) {\n\t\t\tif (strcmp(str, \"bit17-vector-ci-load\") == 0)\n\t\t\t\thmer_debug_trig_function = DTRIG_VECTOR_CI;\n\t\t\telse if (strcmp(str, \"bit17-tm-suspend-escape\") == 0)\n\t\t\t\thmer_debug_trig_function = DTRIG_SUSPEND_ESCAPE;\n\t\t}\n\t\tof_node_put(cpun);\n\t}\n\tpreempt_enable();\n\n\t/* If we found the property, don't look at PVR */\n\tif (prop)\n\t\tgoto out;\n\n\tpvr = mfspr(SPRN_PVR);\n\t/* Check for POWER9 Nimbus (scale-out) */\n\tif ((PVR_VER(pvr) == PVR_POWER9) && (pvr & 0xe000) == 0) {\n\t\t/* DD2.2 and later */\n\t\tif ((pvr & 0xfff) >= 0x202)\n\t\t\thmer_debug_trig_function = DTRIG_SUSPEND_ESCAPE;\n\t\t/* DD2.0 and DD2.1 - used for vector CI load emulation */\n\t\telse if ((pvr & 0xfff) >= 0x200)\n\t\t\thmer_debug_trig_function = DTRIG_VECTOR_CI;\n\t}\n\n out:\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\tpr_debug(\"HMI debug trigger used for vector CI load\\n\");\n\t\tbreak;\n\tcase DTRIG_SUSPEND_ESCAPE:\n\t\tpr_debug(\"HMI debug trigger used for TM suspend escape\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"HMI debug trigger used for TM suspend escape\\n\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"HMI debug trigger used for vector CI load\\n\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PVR_VER",
          "args": [
            "pvr"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PVR"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "cpun"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"bit17-tm-suspend-escape\""
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_property_for_each_string",
          "args": [
            "cpun",
            "\"ibm,hmi-special-triggers\"",
            "prop",
            "str"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_cpu_node",
          "args": [
            "smp_processor_id()",
            "NULL"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic enum {\n\tDTRIG_UNKNOWN,\n\tDTRIG_VECTOR_CI,\t/* need to emulate vector CI load instr */\n\tDTRIG_SUSPEND_ESCAPE,\t/* need to escape from TM suspend mode */\n} hmer_debug_trig_function;\n\nstatic int init_debug_trig_function(void)\n{\n\tint pvr;\n\tstruct device_node *cpun;\n\tstruct property *prop = NULL;\n\tconst char *str;\n\n\t/* First look in the device tree */\n\tpreempt_disable();\n\tcpun = of_get_cpu_node(smp_processor_id(), NULL);\n\tif (cpun) {\n\t\tof_property_for_each_string(cpun, \"ibm,hmi-special-triggers\",\n\t\t\t\t\t    prop, str) {\n\t\t\tif (strcmp(str, \"bit17-vector-ci-load\") == 0)\n\t\t\t\thmer_debug_trig_function = DTRIG_VECTOR_CI;\n\t\t\telse if (strcmp(str, \"bit17-tm-suspend-escape\") == 0)\n\t\t\t\thmer_debug_trig_function = DTRIG_SUSPEND_ESCAPE;\n\t\t}\n\t\tof_node_put(cpun);\n\t}\n\tpreempt_enable();\n\n\t/* If we found the property, don't look at PVR */\n\tif (prop)\n\t\tgoto out;\n\n\tpvr = mfspr(SPRN_PVR);\n\t/* Check for POWER9 Nimbus (scale-out) */\n\tif ((PVR_VER(pvr) == PVR_POWER9) && (pvr & 0xe000) == 0) {\n\t\t/* DD2.2 and later */\n\t\tif ((pvr & 0xfff) >= 0x202)\n\t\t\thmer_debug_trig_function = DTRIG_SUSPEND_ESCAPE;\n\t\t/* DD2.0 and DD2.1 - used for vector CI load emulation */\n\t\telse if ((pvr & 0xfff) >= 0x200)\n\t\t\thmer_debug_trig_function = DTRIG_VECTOR_CI;\n\t}\n\n out:\n\tswitch (hmer_debug_trig_function) {\n\tcase DTRIG_VECTOR_CI:\n\t\tpr_debug(\"HMI debug trigger used for vector CI load\\n\");\n\t\tbreak;\n\tcase DTRIG_SUSPEND_ESCAPE:\n\t\tpr_debug(\"HMI debug trigger used for TM suspend escape\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "591-616",
    "snippet": "long notrace machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\tbool nested = in_nmi();\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tif (!nested)\n\t\tnmi_enter();\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t/*\n\t * See if platform is capable of handling machine check.\n\t */\n\tif (ppc_md.machine_check_early)\n\t\thandled = ppc_md.machine_check_early(regs);\n\n\tif (!nested)\n\t\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\treturn handled;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_set_ftrace_enabled",
          "args": [
            "ftrace_enabled"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmi_exit",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.machine_check_early",
          "args": [
            "regs"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "591-616",
          "snippet": "long notrace machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\tbool nested = in_nmi();\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tif (!nested)\n\t\tnmi_enter();\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t/*\n\t * See if platform is capable of handling machine check.\n\t */\n\tif (ppc_md.machine_check_early)\n\t\thandled = ppc_md.machine_check_early(regs);\n\n\tif (!nested)\n\t\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\treturn handled;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "hv_nmi_check_nonrecoverable",
          "args": [
            "regs"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "hv_nmi_check_nonrecoverable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "396-438",
          "snippet": "void hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid hv_nmi_check_nonrecoverable(struct pt_regs *regs)\n{\n#ifdef CONFIG_PPC_POWERNV\n\tunsigned long kbase = (unsigned long)_stext;\n\tunsigned long nip = regs->nip;\n\n\tif (!(regs->msr & MSR_RI))\n\t\treturn;\n\tif (!(regs->msr & MSR_HV))\n\t\treturn;\n\tif (regs->msr & MSR_PR)\n\t\treturn;\n\n\t/*\n\t * Now test if the interrupt has hit a range that may be using\n\t * HSPRG1 without having RI=0 (i.e., an HSRR interrupt). The\n\t * problem ranges all run un-relocated. Test real and virt modes\n\t * at the same time by droping the high bit of the nip (virt mode\n\t * entry points still have the +0x4000 offset).\n\t */\n\tnip &= ~0xc000000000000000ULL;\n\tif ((nip >= 0x500 && nip < 0x600) || (nip >= 0x4500 && nip < 0x4600))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0x980 && nip < 0xa00) || (nip >= 0x4980 && nip < 0x4a00))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xe00 && nip < 0xec0) || (nip >= 0x4e00 && nip < 0x4ec0))\n\t\tgoto nonrecoverable;\n\tif ((nip >= 0xf80 && nip < 0xfa0) || (nip >= 0x4f80 && nip < 0x4fa0))\n\t\tgoto nonrecoverable;\n\n\t/* Trampoline code runs un-relocated so subtract kbase. */\n\tif (nip >= (unsigned long)(start_real_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_real_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\tif (nip >= (unsigned long)(start_virt_trampolines - kbase) &&\n\t\t\tnip < (unsigned long)(end_virt_trampolines - kbase))\n\t\tgoto nonrecoverable;\n\treturn;\n\nnonrecoverable:\n\tregs->msr &= ~MSR_RI;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nmi_enter",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_set_ftrace_enabled",
          "args": [
            "0"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_get_ftrace_enabled",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nlong notrace machine_check_early(struct pt_regs *regs)\n{\n\tlong handled = 0;\n\tbool nested = in_nmi();\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tif (!nested)\n\t\tnmi_enter();\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t/*\n\t * See if platform is capable of handling machine check.\n\t */\n\tif (ppc_md.machine_check_early)\n\t\thandled = ppc_md.machine_check_early(regs);\n\n\tif (!nested)\n\t\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\treturn handled;\n}"
  },
  {
    "function_name": "machine_check_print_event_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "355-583",
    "snippet": "void machine_check_print_event_info(struct machine_check_event *evt,\n\t\t\t\t    bool user_mode, bool in_guest)\n{\n\tconst char *level, *sevstr, *subtype, *err_type, *initiator;\n\tuint64_t ea = 0, pa = 0;\n\tint n = 0;\n\tchar dar_str[50];\n\tchar pa_str[50];\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_user_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"tlbie(l) invalid\",\n\t\t\"scv invalid\",\n\t};\n\tstatic const char *mc_ra_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (bad)\",\n\t\t\"Instruction fetch (foreign)\",\n\t\t\"Page table walk ifetch (bad)\",\n\t\t\"Page table walk ifetch (foreign)\",\n\t\t\"Load (bad)\",\n\t\t\"Store (bad)\",\n\t\t\"Page table walk Load/Store (bad)\",\n\t\t\"Page table walk Load/Store (foreign)\",\n\t\t\"Load/Store (foreign)\",\n\t};\n\tstatic const char *mc_link_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (timeout)\",\n\t\t\"Page table walk ifetch (timeout)\",\n\t\t\"Load (timeout)\",\n\t\t\"Store (timeout)\",\n\t\t\"Page table walk Load/Store (timeout)\",\n\t};\n\tstatic const char *mc_error_class[] = {\n\t\t\"Unknown\",\n\t\t\"Hardware error\",\n\t\t\"Probable Hardware error (some chance of software cause)\",\n\t\t\"Software error\",\n\t\t\"Probable Software error (some chance of hardware cause)\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"Warning\";\n\t\tbreak;\n\tcase MCE_SEV_SEVERE:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tswitch(evt->initiator) {\n\tcase MCE_INITIATOR_CPU:\n\t\tinitiator = \"CPU\";\n\t\tbreak;\n\tcase MCE_INITIATOR_PCI:\n\t\tinitiator = \"PCI\";\n\t\tbreak;\n\tcase MCE_INITIATOR_ISA:\n\t\tinitiator = \"ISA\";\n\t\tbreak;\n\tcase MCE_INITIATOR_MEMORY:\n\t\tinitiator = \"Memory\";\n\t\tbreak;\n\tcase MCE_INITIATOR_POWERMGM:\n\t\tinitiator = \"Power Management\";\n\t\tbreak;\n\tcase MCE_INITIATOR_UNKNOWN:\n\tdefault:\n\t\tinitiator = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\terr_type = \"UE\";\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tea = evt->u.ue_error.effective_address;\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tpa = evt->u.ue_error.physical_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\terr_type = \"SLB\";\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tea = evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\terr_type = \"ERAT\";\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tea = evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\terr_type = \"TLB\";\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tea = evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\terr_type = \"User\";\n\t\tsubtype = evt->u.user_error.user_error_type <\n\t\t\tARRAY_SIZE(mc_user_types) ?\n\t\t\tmc_user_types[evt->u.user_error.user_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.user_error.effective_address_provided)\n\t\t\tea = evt->u.user_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\terr_type = \"Real address\";\n\t\tsubtype = evt->u.ra_error.ra_error_type <\n\t\t\tARRAY_SIZE(mc_ra_types) ?\n\t\t\tmc_ra_types[evt->u.ra_error.ra_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ra_error.effective_address_provided)\n\t\t\tea = evt->u.ra_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\terr_type = \"Link\";\n\t\tsubtype = evt->u.link_error.link_error_type <\n\t\t\tARRAY_SIZE(mc_link_types) ?\n\t\t\tmc_link_types[evt->u.link_error.link_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.link_error.effective_address_provided)\n\t\t\tea = evt->u.link_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_DCACHE:\n\t\terr_type = \"D-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ICACHE:\n\t\terr_type = \"I-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\terr_type = \"Unknown\";\n\t\tsubtype = \"\";\n\t\tbreak;\n\t}\n\n\tdar_str[0] = pa_str[0] = '\\0';\n\tif (ea && evt->srr0 != ea) {\n\t\t/* Load/Store address */\n\t\tn = sprintf(dar_str, \"DAR: %016llx \", ea);\n\t\tif (pa)\n\t\t\tsprintf(dar_str + n, \"paddr: %016llx \", pa);\n\t} else if (pa) {\n\t\tsprintf(pa_str, \" paddr: %016llx\", pa);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: machine check (%s) %s %s %s %s[%s]\\n\",\n\t\tlevel, evt->cpu, sevstr, in_guest ? \"Guest\" : \"Host\",\n\t\terr_type, subtype, dar_str,\n\t\tevt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t\t\"Recovered\" : \"Not recovered\");\n\n\tif (in_guest || user_mode) {\n\t\tprintk(\"%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\\n\",\n\t\t\tlevel, evt->cpu, current->pid, current->comm,\n\t\t\tin_guest ? \"Guest \" : \"\", evt->srr0, pa_str);\n\t} else {\n\t\tprintk(\"%sMCE: CPU%d: NIP: [%016llx] %pS%s\\n\",\n\t\t\tlevel, evt->cpu, evt->srr0, (void *)evt->srr0, pa_str);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: Initiator %s\\n\", level, evt->cpu, initiator);\n\n\tsubtype = evt->error_class < ARRAY_SIZE(mc_error_class) ?\n\t\tmc_error_class[evt->error_class] : \"Unknown\";\n\tprintk(\"%sMCE: CPU%d: %s\\n\", level, evt->cpu, subtype);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Display faulty slb contents for SLB errors. */\n\tif (evt->error_type == MCE_ERROR_TYPE_SLB)\n\t\tslb_dump_contents(local_paca->mce_faulty_slbs);\n#endif\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
      "static void machine_check_ue_event(struct machine_check_event *evt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slb_dump_contents",
          "args": [
            "local_paca->mce_faulty_slbs"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sMCE: CPU%d: %s\\n\"",
            "level",
            "evt->cpu",
            "subtype"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_error_class"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sMCE: CPU%d: Initiator %s\\n\"",
            "level",
            "evt->cpu",
            "initiator"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sMCE: CPU%d: NIP: [%016llx] %pS%s\\n\"",
            "level",
            "evt->cpu",
            "evt->srr0",
            "(void *)evt->srr0",
            "pa_str"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\\n\"",
            "level",
            "evt->cpu",
            "current->pid",
            "current->comm",
            "in_guest ? \"Guest \" : \"\"",
            "evt->srr0",
            "pa_str"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sMCE: CPU%d: machine check (%s) %s %s %s %s[%s]\\n\"",
            "level",
            "evt->cpu",
            "sevstr",
            "in_guest ? \"Guest\" : \"Host\"",
            "err_type",
            "subtype",
            "dar_str",
            "evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t\t\"Recovered\" : \"Not recovered\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pa_str",
            "\" paddr: %016llx\"",
            "pa"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dar_str + n",
            "\"paddr: %016llx \"",
            "pa"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dar_str",
            "\"DAR: %016llx \"",
            "ea"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_link_types"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_ra_types"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_user_types"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_tlb_types"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_erat_types"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_slb_types"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_ue_types"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Machine Check Exception, Unknown event version %d !\\n\"",
            "evt->version"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\n\nvoid machine_check_print_event_info(struct machine_check_event *evt,\n\t\t\t\t    bool user_mode, bool in_guest)\n{\n\tconst char *level, *sevstr, *subtype, *err_type, *initiator;\n\tuint64_t ea = 0, pa = 0;\n\tint n = 0;\n\tchar dar_str[50];\n\tchar pa_str[50];\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_user_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"tlbie(l) invalid\",\n\t\t\"scv invalid\",\n\t};\n\tstatic const char *mc_ra_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (bad)\",\n\t\t\"Instruction fetch (foreign)\",\n\t\t\"Page table walk ifetch (bad)\",\n\t\t\"Page table walk ifetch (foreign)\",\n\t\t\"Load (bad)\",\n\t\t\"Store (bad)\",\n\t\t\"Page table walk Load/Store (bad)\",\n\t\t\"Page table walk Load/Store (foreign)\",\n\t\t\"Load/Store (foreign)\",\n\t};\n\tstatic const char *mc_link_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (timeout)\",\n\t\t\"Page table walk ifetch (timeout)\",\n\t\t\"Load (timeout)\",\n\t\t\"Store (timeout)\",\n\t\t\"Page table walk Load/Store (timeout)\",\n\t};\n\tstatic const char *mc_error_class[] = {\n\t\t\"Unknown\",\n\t\t\"Hardware error\",\n\t\t\"Probable Hardware error (some chance of software cause)\",\n\t\t\"Software error\",\n\t\t\"Probable Software error (some chance of hardware cause)\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"Warning\";\n\t\tbreak;\n\tcase MCE_SEV_SEVERE:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tswitch(evt->initiator) {\n\tcase MCE_INITIATOR_CPU:\n\t\tinitiator = \"CPU\";\n\t\tbreak;\n\tcase MCE_INITIATOR_PCI:\n\t\tinitiator = \"PCI\";\n\t\tbreak;\n\tcase MCE_INITIATOR_ISA:\n\t\tinitiator = \"ISA\";\n\t\tbreak;\n\tcase MCE_INITIATOR_MEMORY:\n\t\tinitiator = \"Memory\";\n\t\tbreak;\n\tcase MCE_INITIATOR_POWERMGM:\n\t\tinitiator = \"Power Management\";\n\t\tbreak;\n\tcase MCE_INITIATOR_UNKNOWN:\n\tdefault:\n\t\tinitiator = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\terr_type = \"UE\";\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tea = evt->u.ue_error.effective_address;\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tpa = evt->u.ue_error.physical_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\terr_type = \"SLB\";\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tea = evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\terr_type = \"ERAT\";\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tea = evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\terr_type = \"TLB\";\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tea = evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\terr_type = \"User\";\n\t\tsubtype = evt->u.user_error.user_error_type <\n\t\t\tARRAY_SIZE(mc_user_types) ?\n\t\t\tmc_user_types[evt->u.user_error.user_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.user_error.effective_address_provided)\n\t\t\tea = evt->u.user_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\terr_type = \"Real address\";\n\t\tsubtype = evt->u.ra_error.ra_error_type <\n\t\t\tARRAY_SIZE(mc_ra_types) ?\n\t\t\tmc_ra_types[evt->u.ra_error.ra_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ra_error.effective_address_provided)\n\t\t\tea = evt->u.ra_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\terr_type = \"Link\";\n\t\tsubtype = evt->u.link_error.link_error_type <\n\t\t\tARRAY_SIZE(mc_link_types) ?\n\t\t\tmc_link_types[evt->u.link_error.link_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.link_error.effective_address_provided)\n\t\t\tea = evt->u.link_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_DCACHE:\n\t\terr_type = \"D-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ICACHE:\n\t\terr_type = \"I-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\terr_type = \"Unknown\";\n\t\tsubtype = \"\";\n\t\tbreak;\n\t}\n\n\tdar_str[0] = pa_str[0] = '\\0';\n\tif (ea && evt->srr0 != ea) {\n\t\t/* Load/Store address */\n\t\tn = sprintf(dar_str, \"DAR: %016llx \", ea);\n\t\tif (pa)\n\t\t\tsprintf(dar_str + n, \"paddr: %016llx \", pa);\n\t} else if (pa) {\n\t\tsprintf(pa_str, \" paddr: %016llx\", pa);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: machine check (%s) %s %s %s %s[%s]\\n\",\n\t\tlevel, evt->cpu, sevstr, in_guest ? \"Guest\" : \"Host\",\n\t\terr_type, subtype, dar_str,\n\t\tevt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t\t\"Recovered\" : \"Not recovered\");\n\n\tif (in_guest || user_mode) {\n\t\tprintk(\"%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\\n\",\n\t\t\tlevel, evt->cpu, current->pid, current->comm,\n\t\t\tin_guest ? \"Guest \" : \"\", evt->srr0, pa_str);\n\t} else {\n\t\tprintk(\"%sMCE: CPU%d: NIP: [%016llx] %pS%s\\n\",\n\t\t\tlevel, evt->cpu, evt->srr0, (void *)evt->srr0, pa_str);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: Initiator %s\\n\", level, evt->cpu, initiator);\n\n\tsubtype = evt->error_class < ARRAY_SIZE(mc_error_class) ?\n\t\tmc_error_class[evt->error_class] : \"Unknown\";\n\tprintk(\"%sMCE: CPU%d: %s\\n\", level, evt->cpu, subtype);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Display faulty slb contents for SLB errors. */\n\tif (evt->error_type == MCE_ERROR_TYPE_SLB)\n\t\tslb_dump_contents(local_paca->mce_faulty_slbs);\n#endif\n}"
  },
  {
    "function_name": "machine_check_process_queued_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "330-353",
    "snippet": "static void machine_check_process_queued_event(struct irq_work *work)\n{\n\tint index;\n\tstruct machine_check_event *evt;\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\t/*\n\t * For now just print it to console.\n\t * TODO: log this error event to FSP or nvram.\n\t */\n\twhile (__this_cpu_read(mce_queue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_queue_count) - 1;\n\t\tevt = this_cpu_ptr(&mce_event_queue[index]);\n\n\t\tif (evt->error_type == MCE_ERROR_TYPE_UE &&\n\t\t    evt->u.ue_error.ignore_event) {\n\t\t\t__this_cpu_dec(mce_queue_count);\n\t\t\tcontinue;\n\t\t}\n\t\tmachine_check_print_event_info(evt, false, false);\n\t\t__this_cpu_dec(mce_queue_count);\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(int, mce_queue_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "static void machine_check_ue_irq_work(struct irq_work *work);",
      "static void machine_check_ue_event(struct machine_check_event *evt);",
      "static void machine_process_ue_event(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_queue_count"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_check_print_event_info",
          "args": [
            "evt",
            "false",
            "false"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_print_event_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "355-583",
          "snippet": "void machine_check_print_event_info(struct machine_check_event *evt,\n\t\t\t\t    bool user_mode, bool in_guest)\n{\n\tconst char *level, *sevstr, *subtype, *err_type, *initiator;\n\tuint64_t ea = 0, pa = 0;\n\tint n = 0;\n\tchar dar_str[50];\n\tchar pa_str[50];\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_user_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"tlbie(l) invalid\",\n\t\t\"scv invalid\",\n\t};\n\tstatic const char *mc_ra_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (bad)\",\n\t\t\"Instruction fetch (foreign)\",\n\t\t\"Page table walk ifetch (bad)\",\n\t\t\"Page table walk ifetch (foreign)\",\n\t\t\"Load (bad)\",\n\t\t\"Store (bad)\",\n\t\t\"Page table walk Load/Store (bad)\",\n\t\t\"Page table walk Load/Store (foreign)\",\n\t\t\"Load/Store (foreign)\",\n\t};\n\tstatic const char *mc_link_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (timeout)\",\n\t\t\"Page table walk ifetch (timeout)\",\n\t\t\"Load (timeout)\",\n\t\t\"Store (timeout)\",\n\t\t\"Page table walk Load/Store (timeout)\",\n\t};\n\tstatic const char *mc_error_class[] = {\n\t\t\"Unknown\",\n\t\t\"Hardware error\",\n\t\t\"Probable Hardware error (some chance of software cause)\",\n\t\t\"Software error\",\n\t\t\"Probable Software error (some chance of hardware cause)\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"Warning\";\n\t\tbreak;\n\tcase MCE_SEV_SEVERE:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tswitch(evt->initiator) {\n\tcase MCE_INITIATOR_CPU:\n\t\tinitiator = \"CPU\";\n\t\tbreak;\n\tcase MCE_INITIATOR_PCI:\n\t\tinitiator = \"PCI\";\n\t\tbreak;\n\tcase MCE_INITIATOR_ISA:\n\t\tinitiator = \"ISA\";\n\t\tbreak;\n\tcase MCE_INITIATOR_MEMORY:\n\t\tinitiator = \"Memory\";\n\t\tbreak;\n\tcase MCE_INITIATOR_POWERMGM:\n\t\tinitiator = \"Power Management\";\n\t\tbreak;\n\tcase MCE_INITIATOR_UNKNOWN:\n\tdefault:\n\t\tinitiator = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\terr_type = \"UE\";\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tea = evt->u.ue_error.effective_address;\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tpa = evt->u.ue_error.physical_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\terr_type = \"SLB\";\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tea = evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\terr_type = \"ERAT\";\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tea = evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\terr_type = \"TLB\";\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tea = evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\terr_type = \"User\";\n\t\tsubtype = evt->u.user_error.user_error_type <\n\t\t\tARRAY_SIZE(mc_user_types) ?\n\t\t\tmc_user_types[evt->u.user_error.user_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.user_error.effective_address_provided)\n\t\t\tea = evt->u.user_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\terr_type = \"Real address\";\n\t\tsubtype = evt->u.ra_error.ra_error_type <\n\t\t\tARRAY_SIZE(mc_ra_types) ?\n\t\t\tmc_ra_types[evt->u.ra_error.ra_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ra_error.effective_address_provided)\n\t\t\tea = evt->u.ra_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\terr_type = \"Link\";\n\t\tsubtype = evt->u.link_error.link_error_type <\n\t\t\tARRAY_SIZE(mc_link_types) ?\n\t\t\tmc_link_types[evt->u.link_error.link_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.link_error.effective_address_provided)\n\t\t\tea = evt->u.link_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_DCACHE:\n\t\terr_type = \"D-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ICACHE:\n\t\terr_type = \"I-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\terr_type = \"Unknown\";\n\t\tsubtype = \"\";\n\t\tbreak;\n\t}\n\n\tdar_str[0] = pa_str[0] = '\\0';\n\tif (ea && evt->srr0 != ea) {\n\t\t/* Load/Store address */\n\t\tn = sprintf(dar_str, \"DAR: %016llx \", ea);\n\t\tif (pa)\n\t\t\tsprintf(dar_str + n, \"paddr: %016llx \", pa);\n\t} else if (pa) {\n\t\tsprintf(pa_str, \" paddr: %016llx\", pa);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: machine check (%s) %s %s %s %s[%s]\\n\",\n\t\tlevel, evt->cpu, sevstr, in_guest ? \"Guest\" : \"Host\",\n\t\terr_type, subtype, dar_str,\n\t\tevt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t\t\"Recovered\" : \"Not recovered\");\n\n\tif (in_guest || user_mode) {\n\t\tprintk(\"%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\\n\",\n\t\t\tlevel, evt->cpu, current->pid, current->comm,\n\t\t\tin_guest ? \"Guest \" : \"\", evt->srr0, pa_str);\n\t} else {\n\t\tprintk(\"%sMCE: CPU%d: NIP: [%016llx] %pS%s\\n\",\n\t\t\tlevel, evt->cpu, evt->srr0, (void *)evt->srr0, pa_str);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: Initiator %s\\n\", level, evt->cpu, initiator);\n\n\tsubtype = evt->error_class < ARRAY_SIZE(mc_error_class) ?\n\t\tmc_error_class[evt->error_class] : \"Unknown\";\n\tprintk(\"%sMCE: CPU%d: %s\\n\", level, evt->cpu, subtype);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Display faulty slb contents for SLB errors. */\n\tif (evt->error_type == MCE_ERROR_TYPE_SLB)\n\t\tslb_dump_contents(local_paca->mce_faulty_slbs);\n#endif\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
            "static void machine_check_ue_event(struct machine_check_event *evt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\n\nvoid machine_check_print_event_info(struct machine_check_event *evt,\n\t\t\t\t    bool user_mode, bool in_guest)\n{\n\tconst char *level, *sevstr, *subtype, *err_type, *initiator;\n\tuint64_t ea = 0, pa = 0;\n\tint n = 0;\n\tchar dar_str[50];\n\tchar pa_str[50];\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_user_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"tlbie(l) invalid\",\n\t\t\"scv invalid\",\n\t};\n\tstatic const char *mc_ra_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (bad)\",\n\t\t\"Instruction fetch (foreign)\",\n\t\t\"Page table walk ifetch (bad)\",\n\t\t\"Page table walk ifetch (foreign)\",\n\t\t\"Load (bad)\",\n\t\t\"Store (bad)\",\n\t\t\"Page table walk Load/Store (bad)\",\n\t\t\"Page table walk Load/Store (foreign)\",\n\t\t\"Load/Store (foreign)\",\n\t};\n\tstatic const char *mc_link_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch (timeout)\",\n\t\t\"Page table walk ifetch (timeout)\",\n\t\t\"Load (timeout)\",\n\t\t\"Store (timeout)\",\n\t\t\"Page table walk Load/Store (timeout)\",\n\t};\n\tstatic const char *mc_error_class[] = {\n\t\t\"Unknown\",\n\t\t\"Hardware error\",\n\t\t\"Probable Hardware error (some chance of software cause)\",\n\t\t\"Software error\",\n\t\t\"Probable Software error (some chance of hardware cause)\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"Warning\";\n\t\tbreak;\n\tcase MCE_SEV_SEVERE:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tswitch(evt->initiator) {\n\tcase MCE_INITIATOR_CPU:\n\t\tinitiator = \"CPU\";\n\t\tbreak;\n\tcase MCE_INITIATOR_PCI:\n\t\tinitiator = \"PCI\";\n\t\tbreak;\n\tcase MCE_INITIATOR_ISA:\n\t\tinitiator = \"ISA\";\n\t\tbreak;\n\tcase MCE_INITIATOR_MEMORY:\n\t\tinitiator = \"Memory\";\n\t\tbreak;\n\tcase MCE_INITIATOR_POWERMGM:\n\t\tinitiator = \"Power Management\";\n\t\tbreak;\n\tcase MCE_INITIATOR_UNKNOWN:\n\tdefault:\n\t\tinitiator = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\terr_type = \"UE\";\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tea = evt->u.ue_error.effective_address;\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tpa = evt->u.ue_error.physical_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\terr_type = \"SLB\";\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tea = evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\terr_type = \"ERAT\";\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tea = evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\terr_type = \"TLB\";\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tea = evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\terr_type = \"User\";\n\t\tsubtype = evt->u.user_error.user_error_type <\n\t\t\tARRAY_SIZE(mc_user_types) ?\n\t\t\tmc_user_types[evt->u.user_error.user_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.user_error.effective_address_provided)\n\t\t\tea = evt->u.user_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\terr_type = \"Real address\";\n\t\tsubtype = evt->u.ra_error.ra_error_type <\n\t\t\tARRAY_SIZE(mc_ra_types) ?\n\t\t\tmc_ra_types[evt->u.ra_error.ra_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.ra_error.effective_address_provided)\n\t\t\tea = evt->u.ra_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\terr_type = \"Link\";\n\t\tsubtype = evt->u.link_error.link_error_type <\n\t\t\tARRAY_SIZE(mc_link_types) ?\n\t\t\tmc_link_types[evt->u.link_error.link_error_type]\n\t\t\t: \"Unknown\";\n\t\tif (evt->u.link_error.effective_address_provided)\n\t\t\tea = evt->u.link_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_DCACHE:\n\t\terr_type = \"D-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ICACHE:\n\t\terr_type = \"I-Cache\";\n\t\tsubtype = \"Unknown\";\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\terr_type = \"Unknown\";\n\t\tsubtype = \"\";\n\t\tbreak;\n\t}\n\n\tdar_str[0] = pa_str[0] = '\\0';\n\tif (ea && evt->srr0 != ea) {\n\t\t/* Load/Store address */\n\t\tn = sprintf(dar_str, \"DAR: %016llx \", ea);\n\t\tif (pa)\n\t\t\tsprintf(dar_str + n, \"paddr: %016llx \", pa);\n\t} else if (pa) {\n\t\tsprintf(pa_str, \" paddr: %016llx\", pa);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: machine check (%s) %s %s %s %s[%s]\\n\",\n\t\tlevel, evt->cpu, sevstr, in_guest ? \"Guest\" : \"Host\",\n\t\terr_type, subtype, dar_str,\n\t\tevt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t\t\"Recovered\" : \"Not recovered\");\n\n\tif (in_guest || user_mode) {\n\t\tprintk(\"%sMCE: CPU%d: PID: %d Comm: %s %sNIP: [%016llx]%s\\n\",\n\t\t\tlevel, evt->cpu, current->pid, current->comm,\n\t\t\tin_guest ? \"Guest \" : \"\", evt->srr0, pa_str);\n\t} else {\n\t\tprintk(\"%sMCE: CPU%d: NIP: [%016llx] %pS%s\\n\",\n\t\t\tlevel, evt->cpu, evt->srr0, (void *)evt->srr0, pa_str);\n\t}\n\n\tprintk(\"%sMCE: CPU%d: Initiator %s\\n\", level, evt->cpu, initiator);\n\n\tsubtype = evt->error_class < ARRAY_SIZE(mc_error_class) ?\n\t\tmc_error_class[evt->error_class] : \"Unknown\";\n\tprintk(\"%sMCE: CPU%d: %s\\n\", level, evt->cpu, subtype);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Display faulty slb contents for SLB errors. */\n\tif (evt->error_type == MCE_ERROR_TYPE_SLB)\n\t\tslb_dump_contents(local_paca->mce_faulty_slbs);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_queue_count"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event_queue[index]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_queue_count"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_queue_count"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_MACHINE_CHECK",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(int, mce_queue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\nstatic void machine_process_ue_event(struct work_struct *work);\n\nstatic void machine_check_process_queued_event(struct irq_work *work)\n{\n\tint index;\n\tstruct machine_check_event *evt;\n\n\tadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\n\n\t/*\n\t * For now just print it to console.\n\t * TODO: log this error event to FSP or nvram.\n\t */\n\twhile (__this_cpu_read(mce_queue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_queue_count) - 1;\n\t\tevt = this_cpu_ptr(&mce_event_queue[index]);\n\n\t\tif (evt->error_type == MCE_ERROR_TYPE_UE &&\n\t\t    evt->u.ue_error.ignore_event) {\n\t\t\t__this_cpu_dec(mce_queue_count);\n\t\t\tcontinue;\n\t\t}\n\t\tmachine_check_print_event_info(evt, false, false);\n\t\t__this_cpu_dec(mce_queue_count);\n\t}\n}"
  },
  {
    "function_name": "machine_process_ue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "287-325",
    "snippet": "static void machine_process_ue_event(struct work_struct *work)\n{\n\tint index;\n\tstruct machine_check_event *evt;\n\n\twhile (__this_cpu_read(mce_ue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_ue_count) - 1;\n\t\tevt = this_cpu_ptr(&mce_ue_event_queue[index]);\n\t\tblocking_notifier_call_chain(&mce_notifier_list, 0, evt);\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t/*\n\t\t * This should probably queued elsewhere, but\n\t\t * oh! well\n\t\t *\n\t\t * Don't report this machine check because the caller has a\n\t\t * asked us to ignore the event, it has a fixup handler which\n\t\t * will do the appropriate error handling and reporting.\n\t\t */\n\t\tif (evt->error_type == MCE_ERROR_TYPE_UE) {\n\t\t\tif (evt->u.ue_error.ignore_event) {\n\t\t\t\t__this_cpu_dec(mce_ue_count);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (evt->u.ue_error.physical_address_provided) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tpfn = evt->u.ue_error.physical_address >>\n\t\t\t\t\tPAGE_SHIFT;\n\t\t\t\tmemory_failure(pfn, 0);\n\t\t\t} else\n\t\t\t\tpr_warn(\"Failed to identify bad address from \"\n\t\t\t\t\t\"where the uncorrectable error (UE) \"\n\t\t\t\t\t\"was generated\\n\");\n\t\t}\n#endif\n\t\t__this_cpu_dec(mce_ue_count);\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(int, mce_ue_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "static void machine_check_ue_irq_work(struct irq_work *work);",
      "static void machine_check_ue_event(struct machine_check_event *evt);",
      "static void machine_process_ue_event(struct work_struct *work);",
      "static BLOCKING_NOTIFIER_HEAD(mce_notifier_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_ue_count"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to identify bad address from \"\n\t\t\t\t\t\"where the uncorrectable error (UE) \"\n\t\t\t\t\t\"was generated\\n\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_failure",
          "args": [
            "pfn",
            "0"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_ue_count"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&mce_notifier_list",
            "0",
            "evt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_ue_event_queue[index]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_ue_count"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_ue_count"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(int, mce_ue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\nstatic void machine_process_ue_event(struct work_struct *work);\nstatic BLOCKING_NOTIFIER_HEAD(mce_notifier_list);\n\nstatic void machine_process_ue_event(struct work_struct *work)\n{\n\tint index;\n\tstruct machine_check_event *evt;\n\n\twhile (__this_cpu_read(mce_ue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_ue_count) - 1;\n\t\tevt = this_cpu_ptr(&mce_ue_event_queue[index]);\n\t\tblocking_notifier_call_chain(&mce_notifier_list, 0, evt);\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t/*\n\t\t * This should probably queued elsewhere, but\n\t\t * oh! well\n\t\t *\n\t\t * Don't report this machine check because the caller has a\n\t\t * asked us to ignore the event, it has a fixup handler which\n\t\t * will do the appropriate error handling and reporting.\n\t\t */\n\t\tif (evt->error_type == MCE_ERROR_TYPE_UE) {\n\t\t\tif (evt->u.ue_error.ignore_event) {\n\t\t\t\t__this_cpu_dec(mce_ue_count);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (evt->u.ue_error.physical_address_provided) {\n\t\t\t\tunsigned long pfn;\n\n\t\t\t\tpfn = evt->u.ue_error.physical_address >>\n\t\t\t\t\tPAGE_SHIFT;\n\t\t\t\tmemory_failure(pfn, 0);\n\t\t\t} else\n\t\t\t\tpr_warn(\"Failed to identify bad address from \"\n\t\t\t\t\t\"where the uncorrectable error (UE) \"\n\t\t\t\t\t\"was generated\\n\");\n\t\t}\n#endif\n\t\t__this_cpu_dec(mce_ue_count);\n\t}\n}"
  },
  {
    "function_name": "mce_common_process_ue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "271-281",
    "snippet": "void mce_common_process_ue(struct pt_regs *regs,\n\t\t\t   struct mce_error_info *mce_err)\n{\n\tconst struct exception_table_entry *entry;\n\n\tentry = search_kernel_exception_table(regs->nip);\n\tif (entry) {\n\t\tmce_err->ignore_event = true;\n\t\tregs->nip = extable_fixup(entry);\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extable_fixup",
          "args": [
            "entry"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_kernel_exception_table",
          "args": [
            "regs->nip"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nvoid mce_common_process_ue(struct pt_regs *regs,\n\t\t\t   struct mce_error_info *mce_err)\n{\n\tconst struct exception_table_entry *entry;\n\n\tentry = search_kernel_exception_table(regs->nip);\n\tif (entry) {\n\t\tmce_err->ignore_event = true;\n\t\tregs->nip = extable_fixup(entry);\n\t}\n}"
  },
  {
    "function_name": "machine_check_queue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "251-269",
    "snippet": "void machine_check_queue_event(void)\n{\n\tint index;\n\tstruct machine_check_event evt;\n\n\tif (!get_mce_event(&evt, MCE_EVENT_RELEASE))\n\t\treturn;\n\n\tindex = __this_cpu_inc_return(mce_queue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_queue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_event_queue[index]), &evt, sizeof(evt));\n\n\t/* Queue irq work to process this event later. */\n\tirq_work_queue(&mce_event_process_work);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(int, mce_queue_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "static void machine_check_ue_irq_work(struct irq_work *work);",
      "static void machine_check_ue_event(struct machine_check_event *evt);",
      "static void machine_process_ue_event(struct work_struct *work);",
      "static struct irq_work mce_event_process_work = {\n        .func = machine_check_process_queued_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&mce_event_process_work"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(&mce_event_queue[index])",
            "&evt",
            "sizeof(evt)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event_queue[index]"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_queue_count"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "mce_queue_count"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mce_event",
          "args": [
            "&evt",
            "MCE_EVENT_RELEASE"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "get_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "192-217",
          "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(int, mce_queue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\nstatic void machine_process_ue_event(struct work_struct *work);\nstatic struct irq_work mce_event_process_work = {\n        .func = machine_check_process_queued_event,\n};\n\nvoid machine_check_queue_event(void)\n{\n\tint index;\n\tstruct machine_check_event evt;\n\n\tif (!get_mce_event(&evt, MCE_EVENT_RELEASE))\n\t\treturn;\n\n\tindex = __this_cpu_inc_return(mce_queue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_queue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_event_queue[index]), &evt, sizeof(evt));\n\n\t/* Queue irq work to process this event later. */\n\tirq_work_queue(&mce_event_process_work);\n}"
  },
  {
    "function_name": "machine_check_ue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "232-246",
    "snippet": "static void machine_check_ue_event(struct machine_check_event *evt)\n{\n\tint index;\n\n\tindex = __this_cpu_inc_return(mce_ue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_ue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_ue_event_queue[index]), evt, sizeof(*evt));\n\n\t/* Queue work to process this event later. */\n\tirq_work_queue(&mce_ue_event_irq_work);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(int, mce_ue_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "static void machine_check_ue_irq_work(struct irq_work *work);",
      "static void machine_check_ue_event(struct machine_check_event *evt);",
      "static void machine_process_ue_event(struct work_struct *work);",
      "static struct irq_work mce_ue_event_irq_work = {\n\t.func = machine_check_ue_irq_work,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&mce_ue_event_irq_work"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(&mce_ue_event_queue[index])",
            "evt",
            "sizeof(*evt)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_ue_event_queue[index]"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_ue_count"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "mce_ue_count"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(int, mce_ue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\nstatic void machine_process_ue_event(struct work_struct *work);\nstatic struct irq_work mce_ue_event_irq_work = {\n\t.func = machine_check_ue_irq_work,\n};\n\nstatic void machine_check_ue_event(struct machine_check_event *evt)\n{\n\tint index;\n\n\tindex = __this_cpu_inc_return(mce_ue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_ue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_ue_event_queue[index]), evt, sizeof(*evt));\n\n\t/* Queue work to process this event later. */\n\tirq_work_queue(&mce_ue_event_irq_work);\n}"
  },
  {
    "function_name": "machine_check_ue_irq_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "224-227",
    "snippet": "static void machine_check_ue_irq_work(struct irq_work *work)\n{\n\tschedule_work(&mce_ue_event_work);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "static void machine_check_ue_irq_work(struct irq_work *work);",
      "static void machine_process_ue_event(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&mce_ue_event_work"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_process_ue_event(struct work_struct *work);\n\nstatic void machine_check_ue_irq_work(struct irq_work *work)\n{\n\tschedule_work(&mce_ue_event_work);\n}"
  },
  {
    "function_name": "release_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "219-222",
    "snippet": "void release_mce_event(void)\n{\n\tget_mce_event(NULL, true);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_mce_event",
          "args": [
            "NULL",
            "true"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "get_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "192-217",
          "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nvoid release_mce_event(void)\n{\n\tget_mce_event(NULL, true);\n}"
  },
  {
    "function_name": "get_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "192-217",
    "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, mce_nest_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_nest_count"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event[index]"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_nest_count"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "save_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "102-173",
    "snippet": "void save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr, uint64_t phys_addr)\n{\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\tmce->cpu = get_paca()->paca_index;\n\n\t/* Mark it recovered if we have handled it and MSR(RI=1). */\n\tif (handled && (regs->msr & MSR_RI))\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\n\tmce->initiator = mce_err->initiator;\n\tmce->severity = mce_err->severity;\n\tmce->sync_error = mce_err->sync_error;\n\tmce->error_class = mce_err->error_class;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_USER) {\n\t\tmce->u.user_error.effective_address_provided = true;\n\t\tmce->u.user_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_RA) {\n\t\tmce->u.ra_error.effective_address_provided = true;\n\t\tmce->u.ra_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_LINK) {\n\t\tmce->u.link_error.effective_address_provided = true;\n\t\tmce->u.link_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t\tif (phys_addr != ULONG_MAX) {\n\t\t\tmce->u.ue_error.physical_address_provided = true;\n\t\t\tmce->u.ue_error.physical_address = phys_addr;\n\t\t\tmce->u.ue_error.ignore_event = mce_err->ignore_event;\n\t\t\tmachine_check_ue_event(mce);\n\t\t}\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, mce_nest_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_check_ue_event",
          "args": [
            "mce"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_ue_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "232-246",
          "snippet": "static void machine_check_ue_event(struct machine_check_event *evt)\n{\n\tint index;\n\n\tindex = __this_cpu_inc_return(mce_ue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_ue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_ue_event_queue[index]), evt, sizeof(*evt));\n\n\t/* Queue work to process this event later. */\n\tirq_work_queue(&mce_ue_event_irq_work);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(int, mce_ue_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);",
            "static void machine_check_process_queued_event(struct irq_work *work);",
            "static void machine_check_ue_irq_work(struct irq_work *work);",
            "static void machine_check_ue_event(struct machine_check_event *evt);",
            "static void machine_process_ue_event(struct work_struct *work);",
            "static struct irq_work mce_ue_event_irq_work = {\n\t.func = machine_check_ue_irq_work,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(int, mce_ue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstatic void machine_check_ue_irq_work(struct irq_work *work);\nstatic void machine_check_ue_event(struct machine_check_event *evt);\nstatic void machine_process_ue_event(struct work_struct *work);\nstatic struct irq_work mce_ue_event_irq_work = {\n\t.func = machine_check_ue_irq_work,\n};\n\nstatic void machine_check_ue_event(struct machine_check_event *evt)\n{\n\tint index;\n\n\tindex = __this_cpu_inc_return(mce_ue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_ue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_ue_event_queue[index]), evt, sizeof(*evt));\n\n\t/* Queue work to process this event later. */\n\tirq_work_queue(&mce_ue_event_irq_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mce_set_error_info",
          "args": [
            "mce",
            "mce_err"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "mce_set_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
          "lines": "66-96",
          "snippet": "static void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\tmce->u.user_error.user_error_type = mce_err->u.user_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\tmce->u.ra_error.ra_error_type = mce_err->u.ra_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\tmce->u.link_error.link_error_type = mce_err->u.link_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/mce.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/extable.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nstatic void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\tmce->u.user_error.user_error_type = mce_err->u.user_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\tmce->u.ra_error.ra_error_type = mce_err->u.ra_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\tmce->u.link_error.link_error_type = mce_err->u.link_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event[index]"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "mce_nest_count"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nvoid save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr, uint64_t phys_addr)\n{\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\tmce->cpu = get_paca()->paca_index;\n\n\t/* Mark it recovered if we have handled it and MSR(RI=1). */\n\tif (handled && (regs->msr & MSR_RI))\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\n\tmce->initiator = mce_err->initiator;\n\tmce->severity = mce_err->severity;\n\tmce->sync_error = mce_err->sync_error;\n\tmce->error_class = mce_err->error_class;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_USER) {\n\t\tmce->u.user_error.effective_address_provided = true;\n\t\tmce->u.user_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_RA) {\n\t\tmce->u.ra_error.effective_address_provided = true;\n\t\tmce->u.ra_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_LINK) {\n\t\tmce->u.link_error.effective_address_provided = true;\n\t\tmce->u.link_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t\tif (phys_addr != ULONG_MAX) {\n\t\t\tmce->u.ue_error.physical_address_provided = true;\n\t\t\tmce->u.ue_error.physical_address = phys_addr;\n\t\t\tmce->u.ue_error.ignore_event = mce_err->ignore_event;\n\t\t\tmachine_check_ue_event(mce);\n\t\t}\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "mce_set_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "66-96",
    "snippet": "static void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\tmce->u.user_error.user_error_type = mce_err->u.user_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\tmce->u.ra_error.ra_error_type = mce_err->u.ra_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\tmce->u.link_error.link_error_type = mce_err->u.link_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT],\n\t\t\t\t\tmce_ue_event_queue);\n\nstatic void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_USER:\n\t\tmce->u.user_error.user_error_type = mce_err->u.user_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_RA:\n\t\tmce->u.ra_error.ra_error_type = mce_err->u.ra_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_LINK:\n\t\tmce->u.link_error.link_error_type = mce_err->u.link_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "mce_unregister_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "60-63",
    "snippet": "int mce_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&mce_notifier_list, nb);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(mce_notifier_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&mce_notifier_list",
            "nb"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(mce_notifier_list);\n\nint mce_unregister_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&mce_notifier_list, nb);\n}"
  },
  {
    "function_name": "mce_register_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/mce.c",
    "lines": "54-57",
    "snippet": "int mce_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&mce_notifier_list, nb);\n}",
    "includes": [
      "#include <asm/nmi.h>",
      "#include <asm/mce.h>",
      "#include <asm/machdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/extable.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/hardirq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(mce_notifier_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&mce_notifier_list",
            "nb"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/mce.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/extable.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n#include <linux/hardirq.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(mce_notifier_list);\n\nint mce_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&mce_notifier_list, nb);\n}"
  }
]