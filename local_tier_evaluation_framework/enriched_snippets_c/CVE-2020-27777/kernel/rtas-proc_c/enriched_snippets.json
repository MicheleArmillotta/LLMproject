[
  {
    "function_name": "ppc_rtas_rmo_buf_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "761-765",
    "snippet": "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%016lx %x\\n\", rtas_rmo_buf, RTAS_RMOBUF_MAX);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%016lx %x\\n\"",
            "rtas_rmo_buf",
            "RTAS_RMOBUF_MAX"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%016lx %x\\n\", rtas_rmo_buf, RTAS_RMOBUF_MAX);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_volume_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "752-756",
    "snippet": "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_volume);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rtas_tone_volume = 0;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "rtas_tone_volume"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long rtas_tone_volume = 0;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_volume);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_volume_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "732-750",
    "snippet": "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tu64 volume;\n\tint error = parse_number(buf, count, &volume);\n\tif (error)\n\t\treturn error;\n\n\tif (volume > 100)\n\t\tvolume = 100;\n\t\n        rtas_tone_volume = volume; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_VOLUME, 0, volume);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone volume returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define TONE_VOLUME\t\t0x0002 /* 0 - 100 (%) */"
    ],
    "globals_used": [
      "static unsigned long rtas_tone_volume = 0;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting tone volume returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-indicator\")",
            "3",
            "1",
            "NULL",
            "TONE_VOLUME",
            "0",
            "volume"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&volume"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "259-277",
          "snippet": "static int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define TONE_VOLUME\t\t0x0002 /* 0 - 100 (%) */\n\nstatic unsigned long rtas_tone_volume = 0;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tu64 volume;\n\tint error = parse_number(buf, count, &volume);\n\tif (error)\n\t\treturn error;\n\n\tif (volume > 100)\n\t\tvolume = 100;\n\t\n        rtas_tone_volume = volume; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_VOLUME, 0, volume);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone volume returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_freq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "724-728",
    "snippet": "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_frequency);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long rtas_tone_frequency = 1000;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "rtas_tone_frequency"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long rtas_tone_frequency = 1000;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%lu\\n\", rtas_tone_frequency);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_tone_freq_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "707-722",
    "snippet": "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tu64 freq;\n\tint error = parse_number(buf, count, &freq);\n\tif (error)\n\t\treturn error;\n\n\trtas_tone_frequency = freq; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_FREQUENCY, 0, freq);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone frequency returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define TONE_FREQUENCY\t\t0x0001 /* 0 - 1000 (HZ)*/"
    ],
    "globals_used": [
      "static unsigned long rtas_tone_frequency = 1000;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting tone frequency returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-indicator\")",
            "3",
            "1",
            "NULL",
            "TONE_FREQUENCY",
            "0",
            "freq"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&freq"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "259-277",
          "snippet": "static int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define TONE_FREQUENCY\t\t0x0001 /* 0 - 1000 (HZ)*/\n\nstatic unsigned long rtas_tone_frequency = 1000;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tu64 freq;\n\tint error = parse_number(buf, count, &freq);\n\tif (error)\n\t\treturn error;\n\n\trtas_tone_frequency = freq; /* save it for later */\n\terror = rtas_call(rtas_token(\"set-indicator\"), 3, 1, NULL,\n\t\t\tTONE_FREQUENCY, 0, freq);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting tone frequency returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "get_location_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "694-703",
    "snippet": "static void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "' '"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_location_string",
          "args": [
            "m",
            "loc"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "check_location_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "680-689",
          "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_location_string(struct seq_file *m, const char *c);",
            "static void check_location(struct seq_file *m, const char *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"---\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}"
  },
  {
    "function_name": "check_location_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "680-689",
    "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void check_location_string(struct seq_file *m, const char *c);",
      "static void check_location(struct seq_file *m, const char *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" at \""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_location",
          "args": [
            "m",
            "c"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "check_location_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "680-689",
          "snippet": "static void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "*c"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location_string(struct seq_file *m, const char *c)\n{\n\twhile (*c) {\n\t\tif (isalpha(*c) || *c == '.')\n\t\t\tcheck_location(m, c);\n\t\telse if (*c == '/' || *c == '-')\n\t\t\tseq_printf(m, \" at \");\n\t\tc++;\n\t}\n}"
  },
  {
    "function_name": "check_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "643-671",
    "snippet": "static void check_location(struct seq_file *m, const char *c)\n{\n\tswitch (c[0]) {\n\t\tcase LOC_PLANAR:\n\t\t\tseq_printf(m, \"Planar #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_CPU:\n\t\t\tseq_printf(m, \"CPU #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_FAN:\n\t\t\tseq_printf(m, \"Fan #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_RACKMOUNTED:\n\t\t\tseq_printf(m, \"Rack #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_LCD:\n\t\t\tseq_printf(m, \"LCD #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tseq_printf(m, \"- %c\", c[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"Unknown location\");\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define LOC_VOLTAGE\t\t'V'",
      "#define LOC_RACKMOUNTED\t\t'U' /* for _u_nit is rack mounted */",
      "#define LOC_PLANAR\t\t'P'",
      "#define LOC_LCD\t\t\t'L'",
      "#define LOC_FAN\t\t\t'F'",
      "#define LOC_CPU\t\t\t'C'"
    ],
    "globals_used": [
      "static void check_location_string(struct seq_file *m, const char *c);",
      "static void check_location(struct seq_file *m, const char *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Unknown location\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"- %c\"",
            "c[1]"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"LCD #%c\"",
            "c[1]"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Voltage #%c\"",
            "c[1]"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Rack #%c\"",
            "c[1]"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Fan #%c\"",
            "c[1]"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"CPU #%c\"",
            "c[1]"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Planar #%c\"",
            "c[1]"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LOC_VOLTAGE\t\t'V'\n#define LOC_RACKMOUNTED\t\t'U' /* for _u_nit is rack mounted */\n#define LOC_PLANAR\t\t'P'\n#define LOC_LCD\t\t\t'L'\n#define LOC_FAN\t\t\t'F'\n#define LOC_CPU\t\t\t'C'\n\nstatic void check_location_string(struct seq_file *m, const char *c);\nstatic void check_location(struct seq_file *m, const char *c);\n\nstatic void check_location(struct seq_file *m, const char *c)\n{\n\tswitch (c[0]) {\n\t\tcase LOC_PLANAR:\n\t\t\tseq_printf(m, \"Planar #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_CPU:\n\t\t\tseq_printf(m, \"CPU #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_FAN:\n\t\t\tseq_printf(m, \"Fan #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_RACKMOUNTED:\n\t\t\tseq_printf(m, \"Rack #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase LOC_LCD:\n\t\t\tseq_printf(m, \"LCD #%c\", c[1]);\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tseq_printf(m, \"- %c\", c[1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m, \"Unknown location\");\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_process_sensor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "490-639",
    "snippet": "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharging\",\n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */",
      "#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */",
      "#define IBM_VOLTAGE\t\t0x232a /* 9002 */",
      "#define IBM_FANRPM\t\t0x2329 /* 9001 */",
      "#define IBM_SURVEILLANCE\t0x2328 /* 9000 */",
      "#define BATTERY_CHARGING\t0x000b",
      "#define BATTERY_CYCLESTATE\t0x000a",
      "#define EPOW_SENSOR\t\t0x0009",
      "#define BATTERY_PERCENTAGE\t0x0008",
      "#define BATTERY_REMAINING\t0x0007",
      "#define BATTERY_VOLTAGE\t\t0x0006",
      "#define POWER_SOURCE\t\t0x0005",
      "#define LID_STATUS\t\t0x0004",
      "#define THERMAL_SENSOR\t\t0x0003",
      "#define ENCLOSURE_SWITCH\t0x0002",
      "#define KEY_SWITCH\t\t0x0001"
    ],
    "globals_used": [
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static char *ppc_rtas_process_error(int error);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_location_code",
          "args": [
            "m",
            "s",
            "loc"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "get_location_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "694-703",
          "snippet": "static void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
            "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void get_location_code(struct seq_file *m, struct individual_sensor *s,\n\t\tconst char *loc)\n{\n\tif (!loc || !*loc) {\n\t\tseq_printf(m, \"---\");/* does not have a location */\n\t} else {\n\t\tcheck_location_string(m, loc);\n\t}\n\tseq_putc(m, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%10d\\t\"",
            "state"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%4d /%4d\\t\"",
            "state",
            "cel_to_fahr(state)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cel_to_fahr",
          "args": [
            "state"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Unknown sensor (type %d), ignoring it\\n\"",
            "s->token"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Powersupply:\\t\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "ibm_drconnector[state]"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"DR connector:\\t\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Voltage (mv):\\t\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Fan (rpm):\\t\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Surveillance:\\t\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_charging[state]"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery Charging:\\t\""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_cyclestate[state]"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery cyclestate:\\t\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "epow_sensor[state]"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"EPOW Sensor:\\t\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery percentage:\\t\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "battery_remaining[state]"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery remaining:\\t\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Battery voltage:\\t\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "power_source[state]"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Power source:\\t\""
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "lid_status[state]"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Lid status:\\t\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Temp. (C/F):\\t\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "enclosure_switch[state]"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Enclosure switch:\\t\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\t\"",
            "key_switch[state]"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Key switch:\\t\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */\n#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */\n#define IBM_VOLTAGE\t\t0x232a /* 9002 */\n#define IBM_FANRPM\t\t0x2329 /* 9001 */\n#define IBM_SURVEILLANCE\t0x2328 /* 9000 */\n#define BATTERY_CHARGING\t0x000b\n#define BATTERY_CYCLESTATE\t0x000a\n#define EPOW_SENSOR\t\t0x0009\n#define BATTERY_PERCENTAGE\t0x0008\n#define BATTERY_REMAINING\t0x0007\n#define BATTERY_VOLTAGE\t\t0x0006\n#define POWER_SOURCE\t\t0x0005\n#define LID_STATUS\t\t0x0004\n#define THERMAL_SENSOR\t\t0x0003\n#define ENCLOSURE_SWITCH\t0x0002\n#define KEY_SWITCH\t\t0x0001\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharging\",\n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_process_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "457-483",
    "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define SENSOR_DR_ENTITY\t-9000",
      "#define SENSOR_NOT_EXIST\t-3",
      "#define SENSOR_BUSY\t\t-2",
      "#define SENSOR_HW_ERROR\t\t-1",
      "#define SENSOR_SUCCESS\t\t 0",
      "#define SENSOR_CRITICAL_LOW\t 9",
      "#define SENSOR_WARNING_LOW\t10",
      "#define SENSOR_NORMAL\t\t11",
      "#define SENSOR_WARNING_HIGH\t12",
      "#define SENSOR_CRITICAL_HIGH\t13"
    ],
    "globals_used": [
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
  },
  {
    "function_name": "ppc_rtas_find_all_sensors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "433-451",
    "snippet": "static int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static int ppc_rtas_find_all_sensors(void);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"error: could not get rtas-sensors\\n\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas_node",
            "\"rtas-sensors\"",
            "&len"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_find_all_sensors(void);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_sensors_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "389-429",
    "snippet": "static int ppc_rtas_sensors_show(struct seq_file *m, void *v)\n{\n\tint i,j;\n\tint state, error;\n\tint get_sensor_state = rtas_token(\"get-sensor-state\");\n\n\tseq_printf(m, \"RTAS (RunTime Abstraction Services) Sensor Information\\n\");\n\tseq_printf(m, \"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\");\n\tseq_printf(m, \"********************************************************\\n\");\n\n\tif (ppc_rtas_find_all_sensors() != 0) {\n\t\tseq_printf(m, \"\\nNo sensors are available\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tstruct individual_sensor *p = &sensors.sensor[i];\n\t\tchar rstr[64];\n\t\tconst char *loc;\n\t\tint llen, offs;\n\n\t\tsprintf (rstr, SENSOR_PREFIX\"%04d\", p->token);\n\t\tloc = of_get_property(rtas_node, rstr, &llen);\n\n\t\t/* A sensor may have multiple instances */\n\t\tfor (j = 0, offs = 0; j <= p->quant; j++) {\n\t\t\terror =\trtas_call(get_sensor_state, 2, 2, &state, \n\t\t\t\t  \t  p->token, j);\n\n\t\t\tppc_rtas_process_sensor(m, p, state, error, loc);\n\t\t\tseq_putc(m, '\\n');\n\t\t\tif (loc) {\n\t\t\t\toffs += strlen(loc) + 1;\n\t\t\t\tloc += strlen(loc) + 1;\n\t\t\t\tif (offs >= llen)\n\t\t\t\t\tloc = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define SENSOR_PREFIX\t\t\"ibm,sensor-\""
    ],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_find_all_sensors(void);",
      "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
      "static char *ppc_rtas_process_error(int error);",
      "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "loc"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "270-277",
          "snippet": "static size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic size_t __init prom_strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_sensor",
          "args": [
            "m",
            "p",
            "state",
            "error",
            "loc"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_sensor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "490-639",
          "snippet": "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharging\",\n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */",
            "#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */",
            "#define IBM_VOLTAGE\t\t0x232a /* 9002 */",
            "#define IBM_FANRPM\t\t0x2329 /* 9001 */",
            "#define IBM_SURVEILLANCE\t0x2328 /* 9000 */",
            "#define BATTERY_CHARGING\t0x000b",
            "#define BATTERY_CYCLESTATE\t0x000a",
            "#define EPOW_SENSOR\t\t0x0009",
            "#define BATTERY_PERCENTAGE\t0x0008",
            "#define BATTERY_REMAINING\t0x0007",
            "#define BATTERY_VOLTAGE\t\t0x0006",
            "#define POWER_SOURCE\t\t0x0005",
            "#define LID_STATUS\t\t0x0004",
            "#define THERMAL_SENSOR\t\t0x0003",
            "#define ENCLOSURE_SWITCH\t0x0002",
            "#define KEY_SWITCH\t\t0x0001"
          ],
          "globals_used": [
            "static void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);",
            "static char *ppc_rtas_process_error(int error);",
            "static void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define IBM_POWERSUPPLY\t\t0x232c /* 9004 */\n#define IBM_DRCONNECTOR\t\t0x232b /* 9003 */\n#define IBM_VOLTAGE\t\t0x232a /* 9002 */\n#define IBM_FANRPM\t\t0x2329 /* 9001 */\n#define IBM_SURVEILLANCE\t0x2328 /* 9000 */\n#define BATTERY_CHARGING\t0x000b\n#define BATTERY_CYCLESTATE\t0x000a\n#define EPOW_SENSOR\t\t0x0009\n#define BATTERY_PERCENTAGE\t0x0008\n#define BATTERY_REMAINING\t0x0007\n#define BATTERY_VOLTAGE\t\t0x0006\n#define POWER_SOURCE\t\t0x0005\n#define LID_STATUS\t\t0x0004\n#define THERMAL_SENSOR\t\t0x0003\n#define ENCLOSURE_SWITCH\t0x0002\n#define KEY_SWITCH\t\t0x0001\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc)\n{\n\t/* Defined return vales */\n\tconst char * key_switch[]        = { \"Off\\t\", \"Normal\\t\", \"Secure\\t\", \n\t\t\t\t\t\t\"Maintenance\" };\n\tconst char * enclosure_switch[]  = { \"Closed\", \"Open\" };\n\tconst char * lid_status[]        = { \" \", \"Open\", \"Closed\" };\n\tconst char * power_source[]      = { \"AC\\t\", \"Battery\", \n\t\t  \t\t\t\t\"AC & Battery\" };\n\tconst char * battery_remaining[] = { \"Very Low\", \"Low\", \"Mid\", \"High\" };\n\tconst char * epow_sensor[]       = { \n\t\t\"EPOW Reset\", \"Cooling warning\", \"Power warning\",\n\t\t\"System shutdown\", \"System halt\", \"EPOW main enclosure\",\n\t\t\"EPOW power off\" };\n\tconst char * battery_cyclestate[]  = { \"None\", \"In progress\", \n\t\t\t\t\t\t\"Requested\" };\n\tconst char * battery_charging[]    = { \"Charging\", \"Discharging\",\n\t\t\t\t\t\t\"No current flow\" };\n\tconst char * ibm_drconnector[]     = { \"Empty\", \"Present\", \"Unusable\", \n\t\t\t\t\t\t\"Exchange\" };\n\n\tint have_strings = 0;\n\tint num_states = 0;\n\tint temperature = 0;\n\tint unknown = 0;\n\n\t/* What kind of sensor do we have here? */\n\t\n\tswitch (s->token) {\n\t\tcase KEY_SWITCH:\n\t\t\tseq_printf(m, \"Key switch:\\t\");\n\t\t\tnum_states = sizeof(key_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", key_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCLOSURE_SWITCH:\n\t\t\tseq_printf(m, \"Enclosure switch:\\t\");\n\t\t\tnum_states = sizeof(enclosure_switch) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tenclosure_switch[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase THERMAL_SENSOR:\n\t\t\tseq_printf(m, \"Temp. (C/F):\\t\");\n\t\t\ttemperature = 1;\n\t\t\tbreak;\n\t\tcase LID_STATUS:\n\t\t\tseq_printf(m, \"Lid status:\\t\");\n\t\t\tnum_states = sizeof(lid_status) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", lid_status[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_SOURCE:\n\t\t\tseq_printf(m, \"Power source:\\t\");\n\t\t\tnum_states = sizeof(power_source) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tpower_source[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_VOLTAGE:\n\t\t\tseq_printf(m, \"Battery voltage:\\t\");\n\t\t\tbreak;\n\t\tcase BATTERY_REMAINING:\n\t\t\tseq_printf(m, \"Battery remaining:\\t\");\n\t\t\tnum_states = sizeof(battery_remaining) / sizeof(char *);\n\t\t\tif (state < num_states)\n\t\t\t{\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_remaining[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_PERCENTAGE:\n\t\t\tseq_printf(m, \"Battery percentage:\\t\");\n\t\t\tbreak;\n\t\tcase EPOW_SENSOR:\n\t\t\tseq_printf(m, \"EPOW Sensor:\\t\");\n\t\t\tnum_states = sizeof(epow_sensor) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", epow_sensor[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CYCLESTATE:\n\t\t\tseq_printf(m, \"Battery cyclestate:\\t\");\n\t\t\tnum_states = sizeof(battery_cyclestate) / \n\t\t\t\t     \tsizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_cyclestate[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BATTERY_CHARGING:\n\t\t\tseq_printf(m, \"Battery Charging:\\t\");\n\t\t\tnum_states = sizeof(battery_charging) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tbattery_charging[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_SURVEILLANCE:\n\t\t\tseq_printf(m, \"Surveillance:\\t\");\n\t\t\tbreak;\n\t\tcase IBM_FANRPM:\n\t\t\tseq_printf(m, \"Fan (rpm):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_VOLTAGE:\n\t\t\tseq_printf(m, \"Voltage (mv):\\t\");\n\t\t\tbreak;\n\t\tcase IBM_DRCONNECTOR:\n\t\t\tseq_printf(m, \"DR connector:\\t\");\n\t\t\tnum_states = sizeof(ibm_drconnector) / sizeof(char *);\n\t\t\tif (state < num_states) {\n\t\t\t\tseq_printf(m, \"%s\\t\", \n\t\t\t\t\t\tibm_drconnector[state]);\n\t\t\t\thave_strings = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IBM_POWERSUPPLY:\n\t\t\tseq_printf(m, \"Powersupply:\\t\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(m,  \"Unknown sensor (type %d), ignoring it\\n\",\n\t\t\t\t\ts->token);\n\t\t\tunknown = 1;\n\t\t\thave_strings = 1;\n\t\t\tbreak;\n\t}\n\tif (have_strings == 0) {\n\t\tif (temperature) {\n\t\t\tseq_printf(m, \"%4d /%4d\\t\", state, cel_to_fahr(state));\n\t\t} else\n\t\t\tseq_printf(m, \"%10d\\t\", state);\n\t}\n\tif (unknown == 0) {\n\t\tseq_printf(m, \"%s\\t\", ppc_rtas_process_error(error));\n\t\tget_location_code(m, s, loc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "get_sensor_state",
            "2",
            "2",
            "&state",
            "p->token",
            "j"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas_node",
            "rstr",
            "&llen"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "rstr",
            "SENSOR_PREFIX\"%04d\"",
            "p->token"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nNo sensors are available\\n\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_rtas_find_all_sensors",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_find_all_sensors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "433-451",
          "snippet": "static int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtas_sensors sensors;",
            "static struct device_node *rtas_node = NULL;",
            "static int ppc_rtas_find_all_sensors(void);",
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_find_all_sensors(void);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_find_all_sensors(void)\n{\n\tconst unsigned int *utmp;\n\tint len, i;\n\n\tutmp = of_get_property(rtas_node, \"rtas-sensors\", &len);\n\tif (utmp == NULL) {\n\t\tprintk (KERN_ERR \"error: could not get rtas-sensors\\n\");\n\t\treturn 1;\n\t}\n\n\tsensors.quant = len / 8;      /* int + int */\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tsensors.sensor[i].token = *utmp++;\n\t\tsensors.sensor[i].quant = *utmp++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"********************************************************\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"RTAS (RunTime Abstraction Services) Sensor Information\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_PREFIX\t\t\"ibm,sensor-\"\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_find_all_sensors(void);\nstatic void ppc_rtas_process_sensor(struct seq_file *m,\n\tstruct individual_sensor *s, int state, int error, const char *loc);\nstatic char *ppc_rtas_process_error(int error);\nstatic void get_location_code(struct seq_file *m,\n\tstruct individual_sensor *s, const char *loc);\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v)\n{\n\tint i,j;\n\tint state, error;\n\tint get_sensor_state = rtas_token(\"get-sensor-state\");\n\n\tseq_printf(m, \"RTAS (RunTime Abstraction Services) Sensor Information\\n\");\n\tseq_printf(m, \"Sensor\\t\\tValue\\t\\tCondition\\tLocation\\n\");\n\tseq_printf(m, \"********************************************************\\n\");\n\n\tif (ppc_rtas_find_all_sensors() != 0) {\n\t\tseq_printf(m, \"\\nNo sensors are available\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i=0; i<sensors.quant; i++) {\n\t\tstruct individual_sensor *p = &sensors.sensor[i];\n\t\tchar rstr[64];\n\t\tconst char *loc;\n\t\tint llen, offs;\n\n\t\tsprintf (rstr, SENSOR_PREFIX\"%04d\", p->token);\n\t\tloc = of_get_property(rtas_node, rstr, &llen);\n\n\t\t/* A sensor may have multiple instances */\n\t\tfor (j = 0, offs = 0; j <= p->quant; j++) {\n\t\t\terror =\trtas_call(get_sensor_state, 2, 2, &state, \n\t\t\t\t  \t  p->token, j);\n\n\t\t\tppc_rtas_process_sensor(m, p, state, error, loc);\n\t\t\tseq_putc(m, '\\n');\n\t\t\tif (loc) {\n\t\t\t\toffs += strlen(loc) + 1;\n\t\t\t\tloc += strlen(loc) + 1;\n\t\t\t\tif (offs >= llen)\n\t\t\t\t\tloc = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_clock_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "367-384",
    "snippet": "static int ppc_rtas_clock_show(struct seq_file *m, void *v)\n{\n\tint ret[8];\n\tint error = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\tif (error) {\n\t\tprintk(KERN_WARNING \"error: reading the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\t\tseq_printf(m, \"0\");\n\t} else { \n\t\tunsigned int year, mon, day, hour, min, sec;\n\t\tyear = ret[0]; mon  = ret[1]; day  = ret[2];\n\t\thour = ret[3]; min  = ret[4]; sec  = ret[5];\n\t\tseq_printf(m, \"%lld\\n\",\n\t\t\t\tmktime64(year, mon, day, hour, min, sec));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lld\\n\"",
            "mktime64(year, mon, day, hour, min, sec)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mktime64",
          "args": [
            "year",
            "mon",
            "day",
            "hour",
            "min",
            "sec"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: reading the clock returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"get-time-of-day\")",
            "0",
            "8",
            "ret"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-time-of-day\""
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v)\n{\n\tint ret[8];\n\tint error = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\tif (error) {\n\t\tprintk(KERN_WARNING \"error: reading the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\t\tseq_printf(m, \"0\");\n\t} else { \n\t\tunsigned int year, mon, day, hour, min, sec;\n\t\tyear = ret[0]; mon  = ret[1]; day  = ret[2];\n\t\thour = ret[3]; min  = ret[4]; sec  = ret[5];\n\t\tseq_printf(m, \"%lld\\n\",\n\t\t\t\tmktime64(year, mon, day, hour, min, sec));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_clock_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "348-365",
    "snippet": "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\ttime64_t nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\trtc_time64_to_tm(nowtime, &tm);\n\terror = rtas_call(rtas_token(\"set-time-of-day\"), 7, 1, NULL, \n\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting the clock returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-time-of-day\")",
            "7",
            "1",
            "NULL",
            "tm.tm_year + 1900",
            "tm.tm_mon + 1",
            "tm.tm_mday",
            "tm.tm_hour",
            "tm.tm_min",
            "tm.tm_sec",
            "0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-time-of-day\""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_time64_to_tm",
          "args": [
            "nowtime",
            "&tm"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&nowtime"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "259-277",
          "snippet": "static int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\ttime64_t nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\trtc_time64_to_tm(nowtime, &tm);\n\terror = rtas_call(rtas_token(\"set-time-of-day\"), 7, 1, NULL, \n\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting the clock returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "ppc_rtas_progress_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "338-343",
    "snippet": "static int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char progress_led[MAX_LINELENGTH];",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "progress_led"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_progress_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "316-336",
    "snippet": "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long hex;\n\n\tif (count >= MAX_LINELENGTH)\n\t\tcount = MAX_LINELENGTH -1;\n\tif (copy_from_user(progress_led, buf, count)) { /* save the string */\n\t\treturn -EFAULT;\n\t}\n\tprogress_led[count] = 0;\n\n\t/* Lets see if the user passed hexdigits */\n\thex = simple_strtoul(progress_led, NULL, 10);\n\n\trtas_progress ((char *)progress_led, hex);\n\treturn count;\n\n\t/* clear the line */\n\t/* rtas_progress(\"                   \", 0xffff);*/\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define MAX_LINELENGTH          256"
    ],
    "globals_used": [
      "static char progress_led[MAX_LINELENGTH];",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_progress",
          "args": [
            "(char *)progress_led",
            "hex"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_progress_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "338-343",
          "snippet": "static int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char progress_led[MAX_LINELENGTH];",
            "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
            "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v)\n{\n\tif (progress_led[0])\n\t\tseq_printf(m, \"%s\\n\", progress_led);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "progress_led",
            "NULL",
            "10"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "progress_led",
            "buf",
            "count"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define MAX_LINELENGTH          256\n\nstatic char progress_led[MAX_LINELENGTH];\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\n\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long hex;\n\n\tif (count >= MAX_LINELENGTH)\n\t\tcount = MAX_LINELENGTH -1;\n\tif (copy_from_user(progress_led, buf, count)) { /* save the string */\n\t\treturn -EFAULT;\n\t}\n\tprogress_led[count] = 0;\n\n\t/* Lets see if the user passed hexdigits */\n\thex = simple_strtoul(progress_led, NULL, 10);\n\n\trtas_progress ((char *)progress_led, hex);\n\treturn count;\n\n\t/* clear the line */\n\t/* rtas_progress(\"                   \", 0xffff);*/\n}"
  },
  {
    "function_name": "ppc_rtas_poweron_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "304-311",
    "snippet": "static int ppc_rtas_poweron_show(struct seq_file *m, void *v)\n{\n\tif (power_on_time == 0)\n\t\tseq_printf(m, \"Power on time not set\\n\");\n\telse\n\t\tseq_printf(m, \"%lu\\n\",power_on_time);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long power_on_time = 0;",
      "static int ppc_rtas_sensors_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_clock_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_progress_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_poweron_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);",
      "static int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "power_on_time"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Power on time not set\\n\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long power_on_time = 0;\nstatic int ppc_rtas_sensors_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_clock_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_progress_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_freq_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_tone_volume_show(struct seq_file *m, void *v);\nstatic int ppc_rtas_rmo_buf_show(struct seq_file *m, void *v);\n\nstatic int ppc_rtas_poweron_show(struct seq_file *m, void *v)\n{\n\tif (power_on_time == 0)\n\t\tseq_printf(m, \"Power on time not set\\n\");\n\telse\n\t\tseq_printf(m, \"%lu\\n\",power_on_time);\n\treturn 0;\n}"
  },
  {
    "function_name": "ppc_rtas_poweron_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "282-302",
    "snippet": "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\ttime64_t nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tpower_on_time = nowtime; /* save the time */\n\n\trtc_time64_to_tm(nowtime, &tm);\n\n\terror = rtas_call(rtas_token(\"set-time-for-power-on\"), 7, 1, NULL, \n\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting poweron time returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long power_on_time = 0;",
      "static ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);",
      "static char *ppc_rtas_process_error(int error);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"error: setting poweron time returned: %s\\n\"",
            "ppc_rtas_process_error(error)"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_rtas_process_error",
          "args": [
            "error"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_rtas_process_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "457-483",
          "snippet": "static char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define SENSOR_DR_ENTITY\t-9000",
            "#define SENSOR_NOT_EXIST\t-3",
            "#define SENSOR_BUSY\t\t-2",
            "#define SENSOR_HW_ERROR\t\t-1",
            "#define SENSOR_SUCCESS\t\t 0",
            "#define SENSOR_CRITICAL_LOW\t 9",
            "#define SENSOR_WARNING_LOW\t10",
            "#define SENSOR_NORMAL\t\t11",
            "#define SENSOR_WARNING_HIGH\t12",
            "#define SENSOR_CRITICAL_HIGH\t13"
          ],
          "globals_used": [
            "static char *ppc_rtas_process_error(int error);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define SENSOR_DR_ENTITY\t-9000\n#define SENSOR_NOT_EXIST\t-3\n#define SENSOR_BUSY\t\t-2\n#define SENSOR_HW_ERROR\t\t-1\n#define SENSOR_SUCCESS\t\t 0\n#define SENSOR_CRITICAL_LOW\t 9\n#define SENSOR_WARNING_LOW\t10\n#define SENSOR_NORMAL\t\t11\n#define SENSOR_WARNING_HIGH\t12\n#define SENSOR_CRITICAL_HIGH\t13\n\nstatic char *ppc_rtas_process_error(int error);\n\nstatic char *ppc_rtas_process_error(int error)\n{\n\tswitch (error) {\n\t\tcase SENSOR_CRITICAL_HIGH:\n\t\t\treturn \"(critical high)\";\n\t\tcase SENSOR_WARNING_HIGH:\n\t\t\treturn \"(warning high)\";\n\t\tcase SENSOR_NORMAL:\n\t\t\treturn \"(normal)\";\n\t\tcase SENSOR_WARNING_LOW:\n\t\t\treturn \"(warning low)\";\n\t\tcase SENSOR_CRITICAL_LOW:\n\t\t\treturn \"(critical low)\";\n\t\tcase SENSOR_SUCCESS:\n\t\t\treturn \"(read ok)\";\n\t\tcase SENSOR_HW_ERROR:\n\t\t\treturn \"(hardware error)\";\n\t\tcase SENSOR_BUSY:\n\t\t\treturn \"(busy)\";\n\t\tcase SENSOR_NOT_EXIST:\n\t\t\treturn \"(non existent)\";\n\t\tcase SENSOR_DR_ENTITY:\n\t\t\treturn \"(dr entity removed)\";\n\t\tdefault:\n\t\t\treturn \"(UNKNOWN)\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"set-time-for-power-on\")",
            "7",
            "1",
            "NULL",
            "tm.tm_year + 1900",
            "tm.tm_mon + 1",
            "tm.tm_mday",
            "tm.tm_hour",
            "tm.tm_min",
            "tm.tm_sec",
            "0/* nano */"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-time-for-power-on\""
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_time64_to_tm",
          "args": [
            "nowtime",
            "&tm"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_number",
          "args": [
            "buf",
            "count",
            "&nowtime"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "parse_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
          "lines": "259-277",
          "snippet": "static int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/machdep.h> /* for ppc_md */",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rtc.h>",
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/ctype.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic unsigned long power_on_time = 0;\nstatic ssize_t ppc_rtas_clock_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_progress_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_freq_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t ppc_rtas_tone_volume_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos);\nstatic char *ppc_rtas_process_error(int error);\n\nstatic ssize_t ppc_rtas_poweron_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct rtc_time tm;\n\ttime64_t nowtime;\n\tint error = parse_number(buf, count, &nowtime);\n\tif (error)\n\t\treturn error;\n\n\tpower_on_time = nowtime; /* save the time */\n\n\trtc_time64_to_tm(nowtime, &tm);\n\n\terror = rtas_call(rtas_token(\"set-time-for-power-on\"), 7, 1, NULL, \n\t\t\ttm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n\t\t\ttm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);\n\tif (error)\n\t\tprintk(KERN_WARNING \"error: setting poweron time returned: %s\\n\", \n\t\t\t\tppc_rtas_process_error(error));\n\treturn count;\n}"
  },
  {
    "function_name": "parse_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "259-277",
    "snippet": "static int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "buf",
            "&end",
            "10"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "p",
            "count"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int parse_number(const char __user *p, size_t count, u64 *val)\n{\n\tchar buf[40];\n\tchar *end;\n\n\tif (count > 39)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, p, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\n\n\t*val = simple_strtoull(buf, &end, 10);\n\tif (*end && *end != '\\n')\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_rtas_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "231-255",
    "snippet": "static int __init proc_rtas_init(void)\n{\n\tif (!machine_is(pseries))\n\t\treturn -ENODEV;\n\n\trtas_node = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas_node == NULL)\n\t\treturn -ENODEV;\n\n\tproc_create(\"powerpc/rtas/progress\", 0644, NULL,\n\t\t    &ppc_rtas_progress_proc_ops);\n\tproc_create(\"powerpc/rtas/clock\", 0644, NULL,\n\t\t    &ppc_rtas_clock_proc_ops);\n\tproc_create(\"powerpc/rtas/poweron\", 0644, NULL,\n\t\t    &ppc_rtas_poweron_proc_ops);\n\tproc_create_single(\"powerpc/rtas/sensors\", 0444, NULL,\n\t\t\tppc_rtas_sensors_show);\n\tproc_create(\"powerpc/rtas/frequency\", 0644, NULL,\n\t\t    &ppc_rtas_tone_freq_proc_ops);\n\tproc_create(\"powerpc/rtas/volume\", 0644, NULL,\n\t\t    &ppc_rtas_tone_volume_proc_ops);\n\tproc_create_single(\"powerpc/rtas/rmo_buffer\", 0400, NULL,\n\t\t\tppc_rtas_rmo_buf_show);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtas_sensors sensors;",
      "static struct device_node *rtas_node = NULL;",
      "static const struct proc_ops ppc_rtas_poweron_proc_ops = {\n\t.proc_open\t= poweron_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_poweron_write,\n\t.proc_release\t= single_release,\n};",
      "static const struct proc_ops ppc_rtas_progress_proc_ops = {\n\t.proc_open\t= progress_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_progress_write,\n\t.proc_release\t= single_release,\n};",
      "static const struct proc_ops ppc_rtas_clock_proc_ops = {\n\t.proc_open\t= clock_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_clock_write,\n\t.proc_release\t= single_release,\n};",
      "static const struct proc_ops ppc_rtas_tone_freq_proc_ops = {\n\t.proc_open\t= tone_freq_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_tone_freq_write,\n\t.proc_release\t= single_release,\n};",
      "static const struct proc_ops ppc_rtas_tone_volume_proc_ops = {\n\t.proc_open\t= tone_volume_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_tone_volume_write,\n\t.proc_release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"powerpc/rtas/rmo_buffer\"",
            "0400",
            "NULL",
            "ppc_rtas_rmo_buf_show"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/volume\"",
            "0644",
            "NULL",
            "&ppc_rtas_tone_volume_proc_ops"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/frequency\"",
            "0644",
            "NULL",
            "&ppc_rtas_tone_freq_proc_ops"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single",
          "args": [
            "\"powerpc/rtas/sensors\"",
            "0444",
            "NULL",
            "ppc_rtas_sensors_show"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/poweron\"",
            "0644",
            "NULL",
            "&ppc_rtas_poweron_proc_ops"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/clock\"",
            "0644",
            "NULL",
            "&ppc_rtas_clock_proc_ops"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/progress\"",
            "0644",
            "NULL",
            "&ppc_rtas_progress_proc_ops"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "\"rtas\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic struct rtas_sensors sensors;\nstatic struct device_node *rtas_node = NULL;\nstatic const struct proc_ops ppc_rtas_poweron_proc_ops = {\n\t.proc_open\t= poweron_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_poweron_write,\n\t.proc_release\t= single_release,\n};\nstatic const struct proc_ops ppc_rtas_progress_proc_ops = {\n\t.proc_open\t= progress_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_progress_write,\n\t.proc_release\t= single_release,\n};\nstatic const struct proc_ops ppc_rtas_clock_proc_ops = {\n\t.proc_open\t= clock_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_clock_write,\n\t.proc_release\t= single_release,\n};\nstatic const struct proc_ops ppc_rtas_tone_freq_proc_ops = {\n\t.proc_open\t= tone_freq_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_tone_freq_write,\n\t.proc_release\t= single_release,\n};\nstatic const struct proc_ops ppc_rtas_tone_volume_proc_ops = {\n\t.proc_open\t= tone_volume_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_write\t= ppc_rtas_tone_volume_write,\n\t.proc_release\t= single_release,\n};\n\nstatic int __init proc_rtas_init(void)\n{\n\tif (!machine_is(pseries))\n\t\treturn -ENODEV;\n\n\trtas_node = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas_node == NULL)\n\t\treturn -ENODEV;\n\n\tproc_create(\"powerpc/rtas/progress\", 0644, NULL,\n\t\t    &ppc_rtas_progress_proc_ops);\n\tproc_create(\"powerpc/rtas/clock\", 0644, NULL,\n\t\t    &ppc_rtas_clock_proc_ops);\n\tproc_create(\"powerpc/rtas/poweron\", 0644, NULL,\n\t\t    &ppc_rtas_poweron_proc_ops);\n\tproc_create_single(\"powerpc/rtas/sensors\", 0444, NULL,\n\t\t\tppc_rtas_sensors_show);\n\tproc_create(\"powerpc/rtas/frequency\", 0644, NULL,\n\t\t    &ppc_rtas_tone_freq_proc_ops);\n\tproc_create(\"powerpc/rtas/volume\", 0644, NULL,\n\t\t    &ppc_rtas_tone_volume_proc_ops);\n\tproc_create_single(\"powerpc/rtas/rmo_buffer\", 0400, NULL,\n\t\t\tppc_rtas_rmo_buf_show);\n\treturn 0;\n}"
  },
  {
    "function_name": "tone_volume_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "209-212",
    "snippet": "static int tone_volume_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_volume_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_tone_volume_show",
            "NULL"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int tone_volume_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_volume_show, NULL);\n}"
  },
  {
    "function_name": "tone_freq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "196-199",
    "snippet": "static int tone_freq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_freq_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_tone_freq_show",
            "NULL"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int tone_freq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_tone_freq_show, NULL);\n}"
  },
  {
    "function_name": "clock_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "183-186",
    "snippet": "static int clock_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_clock_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_clock_show",
            "NULL"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int clock_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_clock_show, NULL);\n}"
  },
  {
    "function_name": "progress_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "170-173",
    "snippet": "static int progress_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_progress_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_progress_show",
            "NULL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int progress_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_progress_show, NULL);\n}"
  },
  {
    "function_name": "poweron_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-proc.c",
    "lines": "157-160",
    "snippet": "static int poweron_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_poweron_show, NULL);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/machdep.h> /* for ppc_md */",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/rtc.h>",
      "#include <linux/bitops.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/ctype.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "ppc_rtas_poweron_show",
            "NULL"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/machdep.h> /* for ppc_md */\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/rtc.h>\n#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/ctype.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int poweron_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ppc_rtas_poweron_show, NULL);\n}"
  }
]