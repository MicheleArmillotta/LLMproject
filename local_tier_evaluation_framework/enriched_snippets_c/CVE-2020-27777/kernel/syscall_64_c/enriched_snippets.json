[
  {
    "function_name": "interrupt_exit_kernel_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
    "lines": "339-406",
    "snippet": "notrace unsigned long interrupt_exit_kernel_prepare(struct pt_regs *regs, unsigned long msr)\n{\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long flags;\n\tunsigned long ret = 0;\n\tunsigned long amr;\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && unlikely(!(regs->msr & MSR_RI)))\n\t\tunrecoverable_exception(regs);\n\tBUG_ON(regs->msr & MSR_PR);\n\tBUG_ON(!FULL_REGS(regs));\n\n\tamr = kuap_get_and_check_amr();\n\n\tif (unlikely(*ti_flagsp & _TIF_EMULATE_STACK_STORE)) {\n\t\tclear_bits(_TIF_EMULATE_STACK_STORE, ti_flagsp);\n\t\tret = 1;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tif (regs->softe == IRQS_ENABLED) {\n\t\t/* Returning to a kernel context with local irqs enabled. */\n\t\tWARN_ON_ONCE(!(regs->msr & MSR_EE));\nagain:\n\t\tif (IS_ENABLED(CONFIG_PREEMPT)) {\n\t\t\t/* Return to preemptible kernel context */\n\t\t\tif (unlikely(*ti_flagsp & _TIF_NEED_RESCHED)) {\n\t\t\t\tif (preempt_count() == 0)\n\t\t\t\t\tpreempt_schedule_irq();\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(!prep_irq_for_enabled_exit(true))) {\n\t\t\t/*\n\t\t\t * Can't local_irq_restore to replay if we were in\n\t\t\t * interrupt context. Must replay directly.\n\t\t\t */\n\t\t\tif (irqs_disabled_flags(flags)) {\n\t\t\t\treplay_soft_interrupts();\n\t\t\t} else {\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t}\n\t\t\t/* Took an interrupt, may have more exit work to do. */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\t/* Returning to a kernel context with local irqs disabled. */\n\t\t__hard_EE_RI_disable();\n\t\tif (regs->msr & MSR_EE)\n\t\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\t}\n\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\t/*\n\t * Don't want to mfspr(SPRN_AMR) here, because this comes after mtmsr,\n\t * which would cause Read-After-Write stalls. Hence, we take the AMR\n\t * value from the check above.\n\t */\n\tkuap_restore_amr(regs, amr);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/time.h>",
      "#include <asm/syscall.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/signal.h>",
      "#include <asm/reg.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cputime.h>",
      "#include <asm/book3s/64/kup-radix.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kuap_restore_amr",
          "args": [
            "regs",
            "amr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_EE_RI_disable",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "replay_soft_interrupts",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "replay_soft_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "215-312",
          "snippet": "void replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqs_disabled_flags",
          "args": [
            "flags"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prep_irq_for_enabled_exit(true)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_irq_for_enabled_exit",
          "args": [
            "true"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "prep_irq_for_enabled_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
          "lines": "118-141",
          "snippet": "static notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/time.h>",
            "#include <asm/syscall.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/signal.h>",
            "#include <asm/reg.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cputime.h>",
            "#include <asm/book3s/64/kup-radix.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nstatic notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_schedule_irq",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ti_flagsp & _TIF_NEED_RESCHED"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(regs->msr & MSR_EE)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bits",
          "args": [
            "_TIF_EMULATE_STACK_STORE",
            "ti_flagsp"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ti_flagsp & _TIF_EMULATE_STACK_STORE"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuap_get_and_check_amr",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "regs->msr & MSR_PR"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unrecoverable_exception",
          "args": [
            "regs"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "unrecoverable_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "2206-2211",
          "snippet": "void unrecoverable_exception(struct pt_regs *regs)\n{\n\tpr_emerg(\"Unrecoverable exception %lx at %lx (msr=%lx)\\n\",\n\t\t regs->trap, regs->nip, regs->msr);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid unrecoverable_exception(struct pt_regs *regs)\n{\n\tpr_emerg(\"Unrecoverable exception %lx at %lx (msr=%lx)\\n\",\n\t\t regs->trap, regs->nip, regs->msr);\n\tdie(\"Unrecoverable exception\", regs, SIGABRT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(regs->msr & MSR_RI)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nnotrace unsigned long interrupt_exit_kernel_prepare(struct pt_regs *regs, unsigned long msr)\n{\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long flags;\n\tunsigned long ret = 0;\n\tunsigned long amr;\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && unlikely(!(regs->msr & MSR_RI)))\n\t\tunrecoverable_exception(regs);\n\tBUG_ON(regs->msr & MSR_PR);\n\tBUG_ON(!FULL_REGS(regs));\n\n\tamr = kuap_get_and_check_amr();\n\n\tif (unlikely(*ti_flagsp & _TIF_EMULATE_STACK_STORE)) {\n\t\tclear_bits(_TIF_EMULATE_STACK_STORE, ti_flagsp);\n\t\tret = 1;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tif (regs->softe == IRQS_ENABLED) {\n\t\t/* Returning to a kernel context with local irqs enabled. */\n\t\tWARN_ON_ONCE(!(regs->msr & MSR_EE));\nagain:\n\t\tif (IS_ENABLED(CONFIG_PREEMPT)) {\n\t\t\t/* Return to preemptible kernel context */\n\t\t\tif (unlikely(*ti_flagsp & _TIF_NEED_RESCHED)) {\n\t\t\t\tif (preempt_count() == 0)\n\t\t\t\t\tpreempt_schedule_irq();\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(!prep_irq_for_enabled_exit(true))) {\n\t\t\t/*\n\t\t\t * Can't local_irq_restore to replay if we were in\n\t\t\t * interrupt context. Must replay directly.\n\t\t\t */\n\t\t\tif (irqs_disabled_flags(flags)) {\n\t\t\t\treplay_soft_interrupts();\n\t\t\t} else {\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t}\n\t\t\t/* Took an interrupt, may have more exit work to do. */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\t/* Returning to a kernel context with local irqs disabled. */\n\t\t__hard_EE_RI_disable();\n\t\tif (regs->msr & MSR_EE)\n\t\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\t}\n\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\t/*\n\t * Don't want to mfspr(SPRN_AMR) here, because this comes after mtmsr,\n\t * which would cause Read-After-Write stalls. Hence, we take the AMR\n\t * value from the check above.\n\t */\n\tkuap_restore_amr(regs, amr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "interrupt_exit_user_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
    "lines": "252-334",
    "snippet": "notrace unsigned long interrupt_exit_user_prepare(struct pt_regs *regs, unsigned long msr)\n{\n#ifdef CONFIG_PPC_BOOK3E\n\tstruct thread_struct *ts = &current->thread;\n#endif\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long ti_flags;\n\tunsigned long flags;\n\tunsigned long ret = 0;\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S))\n\t\tBUG_ON(!(regs->msr & MSR_RI));\n\tBUG_ON(!(regs->msr & MSR_PR));\n\tBUG_ON(!FULL_REGS(regs));\n\tBUG_ON(regs->softe != IRQS_ENABLED);\n\n\t/*\n\t * We don't need to restore AMR on the way back to userspace for KUAP.\n\t * AMR can only have been unlocked if we interrupted the kernel.\n\t */\n\tkuap_check_amr();\n\n\tlocal_irq_save(flags);\n\nagain:\n\tti_flags = READ_ONCE(*ti_flagsp);\n\twhile (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {\n\t\tlocal_irq_enable(); /* returning to user: may enable */\n\t\tif (ti_flags & _TIF_NEED_RESCHED) {\n\t\t\tschedule();\n\t\t} else {\n\t\t\tif (ti_flags & _TIF_SIGPENDING)\n\t\t\t\tret |= _TIF_RESTOREALL;\n\t\t\tdo_notify_resume(regs, ti_flags);\n\t\t}\n\t\tlocal_irq_disable();\n\t\tti_flags = READ_ONCE(*ti_flagsp);\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && IS_ENABLED(CONFIG_PPC_FPU)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_TRANSACTIONAL_MEM) &&\n\t\t\t\tunlikely((ti_flags & _TIF_RESTORE_TM))) {\n\t\t\trestore_tm_state(regs);\n\t\t} else {\n\t\t\tunsigned long mathflags = MSR_FP;\n\n\t\t\tif (cpu_has_feature(CPU_FTR_VSX))\n\t\t\t\tmathflags |= MSR_VEC | MSR_VSX;\n\t\t\telse if (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\t\t\tmathflags |= MSR_VEC;\n\n\t\t\t/* See above restore_math comment */\n\t\t\tif ((regs->msr & mathflags) != mathflags)\n\t\t\t\trestore_math(regs);\n\t\t}\n\t}\n\n\tif (unlikely(!prep_irq_for_enabled_exit(true))) {\n\t\tlocal_irq_enable();\n\t\tlocal_irq_disable();\n\t\tgoto again;\n\t}\n\n#ifdef CONFIG_PPC_BOOK3E\n\tif (unlikely(ts->debug.dbcr0 & DBCR0_IDM)) {\n\t\t/*\n\t\t * Check to see if the dbcr0 register is set up to debug.\n\t\t * Use the internal debug mode bit to do this.\n\t\t */\n\t\tmtmsr(mfmsr() & ~MSR_DE);\n\t\tmtspr(SPRN_DBCR0, ts->debug.dbcr0);\n\t\tmtspr(SPRN_DBSR, -1);\n\t}\n#endif\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\taccount_cpu_user_exit();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/time.h>",
      "#include <asm/syscall.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/signal.h>",
      "#include <asm/reg.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cputime.h>",
      "#include <asm/book3s/64/kup-radix.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_cpu_user_exit",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBSR",
            "-1"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "ts->debug.dbcr0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "mfmsr() & ~MSR_DE"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->debug.dbcr0 & DBCR0_IDM"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prep_irq_for_enabled_exit(true)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_irq_for_enabled_exit",
          "args": [
            "true"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "prep_irq_for_enabled_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
          "lines": "118-141",
          "snippet": "static notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/time.h>",
            "#include <asm/syscall.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/signal.h>",
            "#include <asm/reg.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cputime.h>",
            "#include <asm/book3s/64/kup-radix.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nstatic notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_math",
          "args": [
            "regs"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "restore_math",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "518-563",
          "snippet": "void notrace restore_math(struct pt_regs *regs)\n{\n\tunsigned long msr;\n\tunsigned long new_msr = 0;\n\n\tmsr = regs->msr;\n\n\t/*\n\t * new_msr tracks the facilities that are to be restored. Only reload\n\t * if the bit is not set in the user MSR (if it is set, the registers\n\t * are live for the user thread).\n\t */\n\tif ((!(msr & MSR_FP)) && should_restore_fp())\n\t\tnew_msr |= MSR_FP;\n\n\tif ((!(msr & MSR_VEC)) && should_restore_altivec())\n\t\tnew_msr |= MSR_VEC;\n\n\tif ((!(msr & MSR_VSX)) && should_restore_vsx()) {\n\t\tif (((msr | new_msr) & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC))\n\t\t\tnew_msr |= MSR_VSX;\n\t}\n\n\tif (new_msr) {\n\t\tunsigned long fpexc_mode = 0;\n\n\t\tmsr_check_and_set(new_msr);\n\n\t\tif (new_msr & MSR_FP) {\n\t\t\tdo_restore_fp();\n\n\t\t\t// This also covers VSX, because VSX implies FP\n\t\t\tfpexc_mode = current->thread.fpexc_mode;\n\t\t}\n\n\t\tif (new_msr & MSR_VEC)\n\t\t\tdo_restore_altivec();\n\n\t\tif (new_msr & MSR_VSX)\n\t\t\tdo_restore_vsx();\n\n\t\tmsr_check_and_clear(new_msr);\n\n\t\tregs->msr |= new_msr | fpexc_mode;\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid notrace restore_math(struct pt_regs *regs)\n{\n\tunsigned long msr;\n\tunsigned long new_msr = 0;\n\n\tmsr = regs->msr;\n\n\t/*\n\t * new_msr tracks the facilities that are to be restored. Only reload\n\t * if the bit is not set in the user MSR (if it is set, the registers\n\t * are live for the user thread).\n\t */\n\tif ((!(msr & MSR_FP)) && should_restore_fp())\n\t\tnew_msr |= MSR_FP;\n\n\tif ((!(msr & MSR_VEC)) && should_restore_altivec())\n\t\tnew_msr |= MSR_VEC;\n\n\tif ((!(msr & MSR_VSX)) && should_restore_vsx()) {\n\t\tif (((msr | new_msr) & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC))\n\t\t\tnew_msr |= MSR_VSX;\n\t}\n\n\tif (new_msr) {\n\t\tunsigned long fpexc_mode = 0;\n\n\t\tmsr_check_and_set(new_msr);\n\n\t\tif (new_msr & MSR_FP) {\n\t\t\tdo_restore_fp();\n\n\t\t\t// This also covers VSX, because VSX implies FP\n\t\t\tfpexc_mode = current->thread.fpexc_mode;\n\t\t}\n\n\t\tif (new_msr & MSR_VEC)\n\t\t\tdo_restore_altivec();\n\n\t\tif (new_msr & MSR_VSX)\n\t\t\tdo_restore_vsx();\n\n\t\tmsr_check_and_clear(new_msr);\n\n\t\tregs->msr |= new_msr | fpexc_mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_VSX"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_tm_state",
          "args": [
            "regs"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1103-1130",
          "snippet": "void restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\t/*\n\t * This is the only moment we should clear TIF_RESTORE_TM as\n\t * it is here that ckpt_regs.msr and pt_regs.msr become the same\n\t * again, anything else could lead to an incorrect ckpt_msr being\n\t * saved and therefore incorrect signal contexts.\n\t */\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\n\t/* Ensure that restore_math() will restore */\n\tif (msr_diff & MSR_FP)\n\t\tcurrent->thread.load_fp = 1;\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC) && msr_diff & MSR_VEC)\n\t\tcurrent->thread.load_vec = 1;\n#endif\n\trestore_math(regs);\n\n\tregs->msr |= msr_diff;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\t/*\n\t * This is the only moment we should clear TIF_RESTORE_TM as\n\t * it is here that ckpt_regs.msr and pt_regs.msr become the same\n\t * again, anything else could lead to an incorrect ckpt_msr being\n\t * saved and therefore incorrect signal contexts.\n\t */\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\n\t/* Ensure that restore_math() will restore */\n\tif (msr_diff & MSR_FP)\n\t\tcurrent->thread.load_fp = 1;\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC) && msr_diff & MSR_VEC)\n\t\tcurrent->thread.load_vec = 1;\n#endif\n\trestore_math(regs);\n\n\tregs->msr |= msr_diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ti_flags & _TIF_RESTORE_TM)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_TRANSACTIONAL_MEM"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_FPU"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ti_flagsp"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_notify_resume",
          "args": [
            "regs",
            "ti_flags"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "311-336",
          "snippet": "void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ti_flagsp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuap_check_amr",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "regs->softe != IRQS_ENABLED"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(regs->msr & MSR_PR)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(regs->msr & MSR_RI)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nnotrace unsigned long interrupt_exit_user_prepare(struct pt_regs *regs, unsigned long msr)\n{\n#ifdef CONFIG_PPC_BOOK3E\n\tstruct thread_struct *ts = &current->thread;\n#endif\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long ti_flags;\n\tunsigned long flags;\n\tunsigned long ret = 0;\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S))\n\t\tBUG_ON(!(regs->msr & MSR_RI));\n\tBUG_ON(!(regs->msr & MSR_PR));\n\tBUG_ON(!FULL_REGS(regs));\n\tBUG_ON(regs->softe != IRQS_ENABLED);\n\n\t/*\n\t * We don't need to restore AMR on the way back to userspace for KUAP.\n\t * AMR can only have been unlocked if we interrupted the kernel.\n\t */\n\tkuap_check_amr();\n\n\tlocal_irq_save(flags);\n\nagain:\n\tti_flags = READ_ONCE(*ti_flagsp);\n\twhile (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {\n\t\tlocal_irq_enable(); /* returning to user: may enable */\n\t\tif (ti_flags & _TIF_NEED_RESCHED) {\n\t\t\tschedule();\n\t\t} else {\n\t\t\tif (ti_flags & _TIF_SIGPENDING)\n\t\t\t\tret |= _TIF_RESTOREALL;\n\t\t\tdo_notify_resume(regs, ti_flags);\n\t\t}\n\t\tlocal_irq_disable();\n\t\tti_flags = READ_ONCE(*ti_flagsp);\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && IS_ENABLED(CONFIG_PPC_FPU)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_TRANSACTIONAL_MEM) &&\n\t\t\t\tunlikely((ti_flags & _TIF_RESTORE_TM))) {\n\t\t\trestore_tm_state(regs);\n\t\t} else {\n\t\t\tunsigned long mathflags = MSR_FP;\n\n\t\t\tif (cpu_has_feature(CPU_FTR_VSX))\n\t\t\t\tmathflags |= MSR_VEC | MSR_VSX;\n\t\t\telse if (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\t\t\tmathflags |= MSR_VEC;\n\n\t\t\t/* See above restore_math comment */\n\t\t\tif ((regs->msr & mathflags) != mathflags)\n\t\t\t\trestore_math(regs);\n\t\t}\n\t}\n\n\tif (unlikely(!prep_irq_for_enabled_exit(true))) {\n\t\tlocal_irq_enable();\n\t\tlocal_irq_disable();\n\t\tgoto again;\n\t}\n\n#ifdef CONFIG_PPC_BOOK3E\n\tif (unlikely(ts->debug.dbcr0 & DBCR0_IDM)) {\n\t\t/*\n\t\t * Check to see if the dbcr0 register is set up to debug.\n\t\t * Use the internal debug mode bit to do this.\n\t\t */\n\t\tmtmsr(mfmsr() & ~MSR_DE);\n\t\tmtspr(SPRN_DBCR0, ts->debug.dbcr0);\n\t\tmtspr(SPRN_DBSR, -1);\n\t}\n#endif\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\taccount_cpu_user_exit();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "syscall_exit_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
    "lines": "152-249",
    "snippet": "notrace unsigned long syscall_exit_prepare(unsigned long r3,\n\t\t\t\t\t   struct pt_regs *regs,\n\t\t\t\t\t   long scv)\n{\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long ti_flags;\n\tunsigned long ret = 0;\n\n\tkuap_check_amr();\n\n\tregs->result = r3;\n\n\t/* Check whether the syscall is issued inside a restartable sequence */\n\trseq_syscall(regs);\n\n\tti_flags = *ti_flagsp;\n\n\tif (unlikely(r3 >= (unsigned long)-MAX_ERRNO) && !scv) {\n\t\tif (likely(!(ti_flags & (_TIF_NOERROR | _TIF_RESTOREALL)))) {\n\t\t\tr3 = -r3;\n\t\t\tregs->ccr |= 0x10000000; /* Set SO bit in CR */\n\t\t}\n\t}\n\n\tif (unlikely(ti_flags & _TIF_PERSYSCALL_MASK)) {\n\t\tif (ti_flags & _TIF_RESTOREALL)\n\t\t\tret = _TIF_RESTOREALL;\n\t\telse\n\t\t\tregs->gpr[3] = r3;\n\t\tclear_bits(_TIF_PERSYSCALL_MASK, ti_flagsp);\n\t} else {\n\t\tregs->gpr[3] = r3;\n\t}\n\n\tif (unlikely(ti_flags & _TIF_SYSCALL_DOTRACE)) {\n\t\tdo_syscall_trace_leave(regs);\n\t\tret |= _TIF_RESTOREALL;\n\t}\n\nagain:\n\tlocal_irq_disable();\n\tti_flags = READ_ONCE(*ti_flagsp);\n\twhile (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {\n\t\tlocal_irq_enable();\n\t\tif (ti_flags & _TIF_NEED_RESCHED) {\n\t\t\tschedule();\n\t\t} else {\n\t\t\t/*\n\t\t\t * SIGPENDING must restore signal handler function\n\t\t\t * argument GPRs, and some non-volatiles (e.g., r1).\n\t\t\t * Restore all for now. This could be made lighter.\n\t\t\t */\n\t\t\tif (ti_flags & _TIF_SIGPENDING)\n\t\t\t\tret |= _TIF_RESTOREALL;\n\t\t\tdo_notify_resume(regs, ti_flags);\n\t\t}\n\t\tlocal_irq_disable();\n\t\tti_flags = READ_ONCE(*ti_flagsp);\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && IS_ENABLED(CONFIG_PPC_FPU)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_TRANSACTIONAL_MEM) &&\n\t\t\t\tunlikely((ti_flags & _TIF_RESTORE_TM))) {\n\t\t\trestore_tm_state(regs);\n\t\t} else {\n\t\t\tunsigned long mathflags = MSR_FP;\n\n\t\t\tif (cpu_has_feature(CPU_FTR_VSX))\n\t\t\t\tmathflags |= MSR_VEC | MSR_VSX;\n\t\t\telse if (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\t\t\tmathflags |= MSR_VEC;\n\n\t\t\t/*\n\t\t\t * If userspace MSR has all available FP bits set,\n\t\t\t * then they are live and no need to restore. If not,\n\t\t\t * it means the regs were given up and restore_math\n\t\t\t * may decide to restore them (to avoid taking an FP\n\t\t\t * fault).\n\t\t\t */\n\t\t\tif ((regs->msr & mathflags) != mathflags)\n\t\t\t\trestore_math(regs);\n\t\t}\n\t}\n\n\t/* scv need not set RI=0 because SRRs are not used */\n\tif (unlikely(!prep_irq_for_enabled_exit(!scv))) {\n\t\tlocal_irq_enable();\n\t\tgoto again;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\taccount_cpu_user_exit();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/time.h>",
      "#include <asm/syscall.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/signal.h>",
      "#include <asm/reg.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cputime.h>",
      "#include <asm/book3s/64/kup-radix.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_cpu_user_exit",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prep_irq_for_enabled_exit(!scv)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_irq_for_enabled_exit",
          "args": [
            "!scv"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "prep_irq_for_enabled_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
          "lines": "118-141",
          "snippet": "static notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/time.h>",
            "#include <asm/syscall.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/signal.h>",
            "#include <asm/reg.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/cputime.h>",
            "#include <asm/book3s/64/kup-radix.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nstatic notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_math",
          "args": [
            "regs"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "restore_math",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "518-563",
          "snippet": "void notrace restore_math(struct pt_regs *regs)\n{\n\tunsigned long msr;\n\tunsigned long new_msr = 0;\n\n\tmsr = regs->msr;\n\n\t/*\n\t * new_msr tracks the facilities that are to be restored. Only reload\n\t * if the bit is not set in the user MSR (if it is set, the registers\n\t * are live for the user thread).\n\t */\n\tif ((!(msr & MSR_FP)) && should_restore_fp())\n\t\tnew_msr |= MSR_FP;\n\n\tif ((!(msr & MSR_VEC)) && should_restore_altivec())\n\t\tnew_msr |= MSR_VEC;\n\n\tif ((!(msr & MSR_VSX)) && should_restore_vsx()) {\n\t\tif (((msr | new_msr) & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC))\n\t\t\tnew_msr |= MSR_VSX;\n\t}\n\n\tif (new_msr) {\n\t\tunsigned long fpexc_mode = 0;\n\n\t\tmsr_check_and_set(new_msr);\n\n\t\tif (new_msr & MSR_FP) {\n\t\t\tdo_restore_fp();\n\n\t\t\t// This also covers VSX, because VSX implies FP\n\t\t\tfpexc_mode = current->thread.fpexc_mode;\n\t\t}\n\n\t\tif (new_msr & MSR_VEC)\n\t\t\tdo_restore_altivec();\n\n\t\tif (new_msr & MSR_VSX)\n\t\t\tdo_restore_vsx();\n\n\t\tmsr_check_and_clear(new_msr);\n\n\t\tregs->msr |= new_msr | fpexc_mode;\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid notrace restore_math(struct pt_regs *regs)\n{\n\tunsigned long msr;\n\tunsigned long new_msr = 0;\n\n\tmsr = regs->msr;\n\n\t/*\n\t * new_msr tracks the facilities that are to be restored. Only reload\n\t * if the bit is not set in the user MSR (if it is set, the registers\n\t * are live for the user thread).\n\t */\n\tif ((!(msr & MSR_FP)) && should_restore_fp())\n\t\tnew_msr |= MSR_FP;\n\n\tif ((!(msr & MSR_VEC)) && should_restore_altivec())\n\t\tnew_msr |= MSR_VEC;\n\n\tif ((!(msr & MSR_VSX)) && should_restore_vsx()) {\n\t\tif (((msr | new_msr) & (MSR_FP | MSR_VEC)) == (MSR_FP | MSR_VEC))\n\t\t\tnew_msr |= MSR_VSX;\n\t}\n\n\tif (new_msr) {\n\t\tunsigned long fpexc_mode = 0;\n\n\t\tmsr_check_and_set(new_msr);\n\n\t\tif (new_msr & MSR_FP) {\n\t\t\tdo_restore_fp();\n\n\t\t\t// This also covers VSX, because VSX implies FP\n\t\t\tfpexc_mode = current->thread.fpexc_mode;\n\t\t}\n\n\t\tif (new_msr & MSR_VEC)\n\t\t\tdo_restore_altivec();\n\n\t\tif (new_msr & MSR_VSX)\n\t\t\tdo_restore_vsx();\n\n\t\tmsr_check_and_clear(new_msr);\n\n\t\tregs->msr |= new_msr | fpexc_mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_VSX"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_tm_state",
          "args": [
            "regs"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "1103-1130",
          "snippet": "void restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\t/*\n\t * This is the only moment we should clear TIF_RESTORE_TM as\n\t * it is here that ckpt_regs.msr and pt_regs.msr become the same\n\t * again, anything else could lead to an incorrect ckpt_msr being\n\t * saved and therefore incorrect signal contexts.\n\t */\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\n\t/* Ensure that restore_math() will restore */\n\tif (msr_diff & MSR_FP)\n\t\tcurrent->thread.load_fp = 1;\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC) && msr_diff & MSR_VEC)\n\t\tcurrent->thread.load_vec = 1;\n#endif\n\trestore_math(regs);\n\n\tregs->msr |= msr_diff;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\t/*\n\t * This is the only moment we should clear TIF_RESTORE_TM as\n\t * it is here that ckpt_regs.msr and pt_regs.msr become the same\n\t * again, anything else could lead to an incorrect ckpt_msr being\n\t * saved and therefore incorrect signal contexts.\n\t */\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\n\t/* Ensure that restore_math() will restore */\n\tif (msr_diff & MSR_FP)\n\t\tcurrent->thread.load_fp = 1;\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC) && msr_diff & MSR_VEC)\n\t\tcurrent->thread.load_vec = 1;\n#endif\n\trestore_math(regs);\n\n\tregs->msr |= msr_diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ti_flags & _TIF_RESTORE_TM)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_TRANSACTIONAL_MEM"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_FPU"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ti_flagsp"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_notify_resume",
          "args": [
            "regs",
            "ti_flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "311-336",
          "snippet": "void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ti_flagsp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_syscall_trace_leave",
          "args": [
            "regs"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "do_syscall_trace_leave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
          "lines": "359-373",
          "snippet": "void do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <trace/events/syscalls.h>",
            "#include <asm/debug.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/audit.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ti_flags & _TIF_SYSCALL_DOTRACE"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bits",
          "args": [
            "_TIF_PERSYSCALL_MASK",
            "ti_flagsp"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ti_flags & _TIF_PERSYSCALL_MASK"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(ti_flags & (_TIF_NOERROR | _TIF_RESTOREALL))"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r3 >= (unsigned long)-MAX_ERRNO"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_syscall",
          "args": [
            "regs"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuap_check_amr",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nnotrace unsigned long syscall_exit_prepare(unsigned long r3,\n\t\t\t\t\t   struct pt_regs *regs,\n\t\t\t\t\t   long scv)\n{\n\tunsigned long *ti_flagsp = &current_thread_info()->flags;\n\tunsigned long ti_flags;\n\tunsigned long ret = 0;\n\n\tkuap_check_amr();\n\n\tregs->result = r3;\n\n\t/* Check whether the syscall is issued inside a restartable sequence */\n\trseq_syscall(regs);\n\n\tti_flags = *ti_flagsp;\n\n\tif (unlikely(r3 >= (unsigned long)-MAX_ERRNO) && !scv) {\n\t\tif (likely(!(ti_flags & (_TIF_NOERROR | _TIF_RESTOREALL)))) {\n\t\t\tr3 = -r3;\n\t\t\tregs->ccr |= 0x10000000; /* Set SO bit in CR */\n\t\t}\n\t}\n\n\tif (unlikely(ti_flags & _TIF_PERSYSCALL_MASK)) {\n\t\tif (ti_flags & _TIF_RESTOREALL)\n\t\t\tret = _TIF_RESTOREALL;\n\t\telse\n\t\t\tregs->gpr[3] = r3;\n\t\tclear_bits(_TIF_PERSYSCALL_MASK, ti_flagsp);\n\t} else {\n\t\tregs->gpr[3] = r3;\n\t}\n\n\tif (unlikely(ti_flags & _TIF_SYSCALL_DOTRACE)) {\n\t\tdo_syscall_trace_leave(regs);\n\t\tret |= _TIF_RESTOREALL;\n\t}\n\nagain:\n\tlocal_irq_disable();\n\tti_flags = READ_ONCE(*ti_flagsp);\n\twhile (unlikely(ti_flags & (_TIF_USER_WORK_MASK & ~_TIF_RESTORE_TM))) {\n\t\tlocal_irq_enable();\n\t\tif (ti_flags & _TIF_NEED_RESCHED) {\n\t\t\tschedule();\n\t\t} else {\n\t\t\t/*\n\t\t\t * SIGPENDING must restore signal handler function\n\t\t\t * argument GPRs, and some non-volatiles (e.g., r1).\n\t\t\t * Restore all for now. This could be made lighter.\n\t\t\t */\n\t\t\tif (ti_flags & _TIF_SIGPENDING)\n\t\t\t\tret |= _TIF_RESTOREALL;\n\t\t\tdo_notify_resume(regs, ti_flags);\n\t\t}\n\t\tlocal_irq_disable();\n\t\tti_flags = READ_ONCE(*ti_flagsp);\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && IS_ENABLED(CONFIG_PPC_FPU)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_TRANSACTIONAL_MEM) &&\n\t\t\t\tunlikely((ti_flags & _TIF_RESTORE_TM))) {\n\t\t\trestore_tm_state(regs);\n\t\t} else {\n\t\t\tunsigned long mathflags = MSR_FP;\n\n\t\t\tif (cpu_has_feature(CPU_FTR_VSX))\n\t\t\t\tmathflags |= MSR_VEC | MSR_VSX;\n\t\t\telse if (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\t\t\tmathflags |= MSR_VEC;\n\n\t\t\t/*\n\t\t\t * If userspace MSR has all available FP bits set,\n\t\t\t * then they are live and no need to restore. If not,\n\t\t\t * it means the regs were given up and restore_math\n\t\t\t * may decide to restore them (to avoid taking an FP\n\t\t\t * fault).\n\t\t\t */\n\t\t\tif ((regs->msr & mathflags) != mathflags)\n\t\t\t\trestore_math(regs);\n\t\t}\n\t}\n\n\t/* scv need not set RI=0 because SRRs are not used */\n\tif (unlikely(!prep_irq_for_enabled_exit(!scv))) {\n\t\tlocal_irq_enable();\n\t\tgoto again;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tlocal_paca->tm_scratch = regs->msr;\n#endif\n\n\taccount_cpu_user_exit();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prep_irq_for_enabled_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
    "lines": "118-141",
    "snippet": "static notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/time.h>",
      "#include <asm/syscall.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/signal.h>",
      "#include <asm/reg.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cputime.h>",
      "#include <asm/book3s/64/kup-radix.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_soft_mask_set",
          "args": [
            "IRQS_ENABLED"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_RI_enable",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lazy_irq_pending_nocheck()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_irq_pending_nocheck",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_EE_RI_disable",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nstatic notrace inline bool prep_irq_for_enabled_exit(bool clear_ri)\n{\n\t/* This must be done with RI=1 because tracing may touch vmaps */\n\ttrace_hardirqs_on();\n\n\t/* This pattern matches prep_irq_for_idle */\n\tif (clear_ri)\n\t\t__hard_EE_RI_disable();\n\telse\n\t\t__hard_irq_disable();\n\tif (unlikely(lazy_irq_pending_nocheck())) {\n\t\t/* Took an interrupt, may have more exit work to do. */\n\t\tif (clear_ri)\n\t\t\t__hard_RI_enable();\n\t\ttrace_hardirqs_off();\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t\treturn false;\n\t}\n\tlocal_paca->irq_happened = 0;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\treturn true;\n}"
  },
  {
    "function_name": "system_call_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/syscall_64.c",
    "lines": "21-112",
    "snippet": "notrace long system_call_exception(long r3, long r4, long r5,\n\t\t\t\t   long r6, long r7, long r8,\n\t\t\t\t   unsigned long r0, struct pt_regs *regs)\n{\n\tsyscall_fn f;\n\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tBUG_ON(irq_soft_mask_return() != IRQS_ALL_DISABLED);\n\n\ttrace_hardirqs_off(); /* finish reconciling */\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S))\n\t\tBUG_ON(!(regs->msr & MSR_RI));\n\tBUG_ON(!(regs->msr & MSR_PR));\n\tBUG_ON(!FULL_REGS(regs));\n\tBUG_ON(regs->softe != IRQS_ENABLED);\n\n\tkuap_check_amr();\n\n\taccount_cpu_user_entry();\n\n#ifdef CONFIG_PPC_SPLPAR\n\tif (IS_ENABLED(CONFIG_VIRT_CPU_ACCOUNTING_NATIVE) &&\n\t    firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tstruct lppaca *lp = local_paca->lppaca_ptr;\n\n\t\tif (unlikely(local_paca->dtl_ridx != be64_to_cpu(lp->dtl_idx)))\n\t\t\taccumulate_stolen_time();\n\t}\n#endif\n\n\t/*\n\t * This is not required for the syscall exit path, but makes the\n\t * stack frame look nicer. If this was initialised in the first stack\n\t * frame, or if the unwinder was taught the first stack frame always\n\t * returns to user with IRQS_ENABLED, this store could be avoided!\n\t */\n\tregs->softe = IRQS_ENABLED;\n\n\tlocal_irq_enable();\n\n\tif (unlikely(current_thread_info()->flags & _TIF_SYSCALL_DOTRACE)) {\n\t\tif (unlikely(regs->trap == 0x7ff0)) {\n\t\t\t/* Unsupported scv vector */\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\t\treturn regs->gpr[3];\n\t\t}\n\t\t/*\n\t\t * We use the return value of do_syscall_trace_enter() as the\n\t\t * syscall number. If the syscall was rejected for any reason\n\t\t * do_syscall_trace_enter() returns an invalid syscall number\n\t\t * and the test against NR_syscalls will fail and the return\n\t\t * value to be used is in regs->gpr[3].\n\t\t */\n\t\tr0 = do_syscall_trace_enter(regs);\n\t\tif (unlikely(r0 >= NR_syscalls))\n\t\t\treturn regs->gpr[3];\n\t\tr3 = regs->gpr[3];\n\t\tr4 = regs->gpr[4];\n\t\tr5 = regs->gpr[5];\n\t\tr6 = regs->gpr[6];\n\t\tr7 = regs->gpr[7];\n\t\tr8 = regs->gpr[8];\n\n\t} else if (unlikely(r0 >= NR_syscalls)) {\n\t\tif (unlikely(regs->trap == 0x7ff0)) {\n\t\t\t/* Unsupported scv vector */\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\t\treturn regs->gpr[3];\n\t\t}\n\t\treturn -ENOSYS;\n\t}\n\n\t/* May be faster to do array_index_nospec? */\n\tbarrier_nospec();\n\n\tif (unlikely(is_32bit_task())) {\n\t\tf = (void *)compat_sys_call_table[r0];\n\n\t\tr3 &= 0x00000000ffffffffULL;\n\t\tr4 &= 0x00000000ffffffffULL;\n\t\tr5 &= 0x00000000ffffffffULL;\n\t\tr6 &= 0x00000000ffffffffULL;\n\t\tr7 &= 0x00000000ffffffffULL;\n\t\tr8 &= 0x00000000ffffffffULL;\n\n\t} else {\n\t\tf = (void *)sys_call_table[r0];\n\t}\n\n\treturn f(r3, r4, r5, r6, r7, r8);\n}",
    "includes": [
      "#include <asm/unistd.h>",
      "#include <asm/time.h>",
      "#include <asm/syscall.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/signal.h>",
      "#include <asm/reg.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cputime.h>",
      "#include <asm/book3s/64/kup-radix.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f",
          "args": [
            "r3",
            "r4",
            "r5",
            "r6",
            "r7",
            "r8"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/udbg.c",
          "lines": "121-132",
          "snippet": "void udbg_printf(const char *fmt, ...)\n{\n\tif (udbg_putc) {\n\t\tchar buf[UDBG_BUFSIZE];\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tvsnprintf(buf, UDBG_BUFSIZE, fmt, args);\n\t\tudbg_puts(buf);\n\t\tva_end(args);\n\t}\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/processor.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define UDBG_BUFSIZE 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/processor.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define UDBG_BUFSIZE 256\n\nvoid udbg_printf(const char *fmt, ...)\n{\n\tif (udbg_putc) {\n\t\tchar buf[UDBG_BUFSIZE];\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tvsnprintf(buf, UDBG_BUFSIZE, fmt, args);\n\t\tudbg_puts(buf);\n\t\tva_end(args);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_32bit_task()"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier_nospec",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "barrier_nospec_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "104-110",
          "snippet": "static __init int barrier_nospec_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"barrier_nospec\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_barrier_nospec);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int barrier_nospec_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"barrier_nospec\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_barrier_nospec);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exception",
          "args": [
            "SIGILL",
            "regs",
            "ILL_ILLOPC",
            "regs->nip"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "367-373",
          "snippet": "void _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid _exception(int signr, struct pt_regs *regs, int code, unsigned long addr)\n{\n\tif (!exception_common(signr, regs, code, addr))\n\t\treturn;\n\n\tforce_sig_fault(signr, code, (void __user *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "regs->trap == 0x7ff0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r0 >= NR_syscalls"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "r0 >= NR_syscalls"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_syscall_trace_enter",
          "args": [
            "regs"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "do_syscall_trace_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
          "lines": "289-357",
          "snippet": "long do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tu32 flags;\n\n\tuser_exit();\n\n\tflags = READ_ONCE(current_thread_info()->flags) &\n\t\t(_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE);\n\n\tif (flags) {\n\t\tint rc = tracehook_report_syscall_entry(regs);\n\n\t\tif (unlikely(flags & _TIF_SYSCALL_EMU)) {\n\t\t\t/*\n\t\t\t * A nonzero return code from\n\t\t\t * tracehook_report_syscall_entry() tells us to prevent\n\t\t\t * the syscall execution, but we are not going to\n\t\t\t * execute it anyway.\n\t\t\t *\n\t\t\t * Returning -1 will skip the syscall execution. We want\n\t\t\t * to avoid clobbering any registers, so we don't goto\n\t\t\t * the skip label below.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * The tracer decided to abort the syscall. Note that\n\t\t\t * the tracer may also just change regs->gpr[0] to an\n\t\t\t * invalid syscall number, that is handled below on the\n\t\t\t * exit path.\n\t\t\t */\n\t\t\tgoto skip;\n\t\t}\n\t}\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <trace/events/syscalls.h>",
            "#include <asm/debug.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/audit.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nlong do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tu32 flags;\n\n\tuser_exit();\n\n\tflags = READ_ONCE(current_thread_info()->flags) &\n\t\t(_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE);\n\n\tif (flags) {\n\t\tint rc = tracehook_report_syscall_entry(regs);\n\n\t\tif (unlikely(flags & _TIF_SYSCALL_EMU)) {\n\t\t\t/*\n\t\t\t * A nonzero return code from\n\t\t\t * tracehook_report_syscall_entry() tells us to prevent\n\t\t\t * the syscall execution, but we are not going to\n\t\t\t * execute it anyway.\n\t\t\t *\n\t\t\t * Returning -1 will skip the syscall execution. We want\n\t\t\t * to avoid clobbering any registers, so we don't goto\n\t\t\t * the skip label below.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * The tracer decided to abort the syscall. Note that\n\t\t\t * the tracer may also just change regs->gpr[0] to an\n\t\t\t * invalid syscall number, that is handled below on the\n\t\t\t * exit path.\n\t\t\t */\n\t\t\tgoto skip;\n\t\t}\n\t}\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "regs->trap == 0x7ff0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current_thread_info()->flags & _TIF_SYSCALL_DOTRACE"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_stolen_time",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_stolen_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/time.c",
          "lines": "237-258",
          "snippet": "void notrace accumulate_stolen_time(void)\n{\n\tu64 sst, ust;\n\tunsigned long save_irq_soft_mask = irq_soft_mask_return();\n\tstruct cpu_accounting_data *acct = &local_paca->accounting;\n\n\t/* We are called early in the exception entry, before\n\t * soft/hard_enabled are sync'ed to the expected state\n\t * for the exception. We are hard disabled but the PACA\n\t * needs to reflect that so various debug stuff doesn't\n\t * complain\n\t */\n\tirq_soft_mask_set(IRQS_DISABLED);\n\n\tsst = scan_dispatch_log(acct->starttime_user);\n\tust = scan_dispatch_log(acct->starttime);\n\tacct->stime -= sst;\n\tacct->utime -= ust;\n\tacct->steal_time += ust + sst;\n\n\tirq_soft_mask_set(save_irq_soft_mask);\n}",
          "includes": [
            "#include <asm/dtl.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/processor.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/suspend.h>",
            "#include <linux/of_clk.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/dtl.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/asm-prototypes.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <linux/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/processor.h>\n#include <linux/sched/cputime.h>\n#include <linux/suspend.h>\n#include <linux/of_clk.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nvoid notrace accumulate_stolen_time(void)\n{\n\tu64 sst, ust;\n\tunsigned long save_irq_soft_mask = irq_soft_mask_return();\n\tstruct cpu_accounting_data *acct = &local_paca->accounting;\n\n\t/* We are called early in the exception entry, before\n\t * soft/hard_enabled are sync'ed to the expected state\n\t * for the exception. We are hard disabled but the PACA\n\t * needs to reflect that so various debug stuff doesn't\n\t * complain\n\t */\n\tirq_soft_mask_set(IRQS_DISABLED);\n\n\tsst = scan_dispatch_log(acct->starttime_user);\n\tust = scan_dispatch_log(acct->starttime);\n\tacct->stime -= sst;\n\tacct->utime -= ust;\n\tacct->steal_time += ust + sst;\n\n\tirq_soft_mask_set(save_irq_soft_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "local_paca->dtl_ridx != be64_to_cpu(lp->dtl_idx)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lp->dtl_idx"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_SPLPAR"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_VIRT_CPU_ACCOUNTING_NATIVE"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_cpu_user_entry",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuap_check_amr",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "regs->softe != IRQS_ENABLED"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(regs->msr & MSR_PR)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(regs->msr & MSR_RI)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq_soft_mask_return() != IRQS_ALL_DISABLED"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_soft_mask_return",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_IRQ_SOFT_MASK_DEBUG"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/time.h>\n#include <asm/syscall.h>\n#include <asm/switch_to.h>\n#include <asm/signal.h>\n#include <asm/reg.h>\n#include <asm/ptrace.h>\n#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <asm/hw_irq.h>\n#include <asm/cputime.h>\n#include <asm/book3s/64/kup-radix.h>\n#include <asm/asm-prototypes.h>\n#include <linux/err.h>\n\nnotrace long system_call_exception(long r3, long r4, long r5,\n\t\t\t\t   long r6, long r7, long r8,\n\t\t\t\t   unsigned long r0, struct pt_regs *regs)\n{\n\tsyscall_fn f;\n\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tBUG_ON(irq_soft_mask_return() != IRQS_ALL_DISABLED);\n\n\ttrace_hardirqs_off(); /* finish reconciling */\n\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S))\n\t\tBUG_ON(!(regs->msr & MSR_RI));\n\tBUG_ON(!(regs->msr & MSR_PR));\n\tBUG_ON(!FULL_REGS(regs));\n\tBUG_ON(regs->softe != IRQS_ENABLED);\n\n\tkuap_check_amr();\n\n\taccount_cpu_user_entry();\n\n#ifdef CONFIG_PPC_SPLPAR\n\tif (IS_ENABLED(CONFIG_VIRT_CPU_ACCOUNTING_NATIVE) &&\n\t    firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tstruct lppaca *lp = local_paca->lppaca_ptr;\n\n\t\tif (unlikely(local_paca->dtl_ridx != be64_to_cpu(lp->dtl_idx)))\n\t\t\taccumulate_stolen_time();\n\t}\n#endif\n\n\t/*\n\t * This is not required for the syscall exit path, but makes the\n\t * stack frame look nicer. If this was initialised in the first stack\n\t * frame, or if the unwinder was taught the first stack frame always\n\t * returns to user with IRQS_ENABLED, this store could be avoided!\n\t */\n\tregs->softe = IRQS_ENABLED;\n\n\tlocal_irq_enable();\n\n\tif (unlikely(current_thread_info()->flags & _TIF_SYSCALL_DOTRACE)) {\n\t\tif (unlikely(regs->trap == 0x7ff0)) {\n\t\t\t/* Unsupported scv vector */\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\t\treturn regs->gpr[3];\n\t\t}\n\t\t/*\n\t\t * We use the return value of do_syscall_trace_enter() as the\n\t\t * syscall number. If the syscall was rejected for any reason\n\t\t * do_syscall_trace_enter() returns an invalid syscall number\n\t\t * and the test against NR_syscalls will fail and the return\n\t\t * value to be used is in regs->gpr[3].\n\t\t */\n\t\tr0 = do_syscall_trace_enter(regs);\n\t\tif (unlikely(r0 >= NR_syscalls))\n\t\t\treturn regs->gpr[3];\n\t\tr3 = regs->gpr[3];\n\t\tr4 = regs->gpr[4];\n\t\tr5 = regs->gpr[5];\n\t\tr6 = regs->gpr[6];\n\t\tr7 = regs->gpr[7];\n\t\tr8 = regs->gpr[8];\n\n\t} else if (unlikely(r0 >= NR_syscalls)) {\n\t\tif (unlikely(regs->trap == 0x7ff0)) {\n\t\t\t/* Unsupported scv vector */\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\t\treturn regs->gpr[3];\n\t\t}\n\t\treturn -ENOSYS;\n\t}\n\n\t/* May be faster to do array_index_nospec? */\n\tbarrier_nospec();\n\n\tif (unlikely(is_32bit_task())) {\n\t\tf = (void *)compat_sys_call_table[r0];\n\n\t\tr3 &= 0x00000000ffffffffULL;\n\t\tr4 &= 0x00000000ffffffffULL;\n\t\tr5 &= 0x00000000ffffffffULL;\n\t\tr6 &= 0x00000000ffffffffULL;\n\t\tr7 &= 0x00000000ffffffffULL;\n\t\tr8 &= 0x00000000ffffffffULL;\n\n\t} else {\n\t\tf = (void *)sys_call_table[r0];\n\t}\n\n\treturn f(r3, r4, r5, r6, r7, r8);\n}"
  }
]