[
  {
    "function_name": "kvm_guest_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "703-720",
    "snippet": "static int __init kvm_guest_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn 0;\n\n\tif (!epapr_paravirt_enabled)\n\t\treturn 0;\n\n\tif (kvm_para_has_feature(KVM_FEATURE_MAGIC_PAGE))\n\t\tkvm_use_magic_page();\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Enable napping */\n\tpowersave_nap = 1;\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_use_magic_page",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_use_magic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "662-701",
          "snippet": "static void __init kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (!fault_in_pages_readable((const char *)KVM_MAGIC_PAGE, sizeof(u32))) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAGIC_PAGE\t\t(-4096L)"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_template_start[];",
            "extern u32 kvm_template_end[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_template_start[];\nextern u32 kvm_template_end[];\n\nstatic void __init kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (!fault_in_pages_readable((const char *)KVM_MAGIC_PAGE, sizeof(u32))) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_para_has_feature",
          "args": [
            "KVM_FEATURE_MAGIC_PAGE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_para_available",
          "args": [],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic int __init kvm_guest_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn 0;\n\n\tif (!epapr_paravirt_enabled)\n\t\treturn 0;\n\n\tif (kvm_para_has_feature(KVM_FEATURE_MAGIC_PAGE))\n\t\tkvm_use_magic_page();\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/* Enable napping */\n\tpowersave_nap = 1;\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_use_magic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "662-701",
    "snippet": "static void __init kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (!fault_in_pages_readable((const char *)KVM_MAGIC_PAGE, sizeof(u32))) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAGIC_PAGE\t\t(-4096L)"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_template_start[];",
      "extern u32 kvm_template_end[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"KVM: Live patching for a fast VM %s\\n\"",
            "kvm_patching_worked ? \"worked\" : \"failed\""
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_ins",
          "args": [
            "p",
            "features"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_ins",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "418-657",
          "snippet": "static void __init kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_MTSRIN\t\t0x7c0001e4",
            "#define KVM_INST_WRTEEI_1\t0x7c008146",
            "#define KVM_INST_WRTEEI_0\t0x7c000146",
            "#define KVM_INST_WRTEE\t\t0x7c000106",
            "#define KVM_INST_MTMSR\t\t0x7c000124",
            "#define KVM_INST_MTMSRD_L1\t0x7c010164",
            "#define KVM_INST_MTMSRD_L0\t0x7c000164",
            "#define KVM_INST_TLBSYNC\t0x7c00046c",
            "#define KVM_INST_MFMSR\t\t0x7c0000a6",
            "#define KVM_MASK_RB\t\t0x0000f800",
            "#define KVM_MASK_RT\t\t0x03e00000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_MTSRIN\t\t0x7c0001e4\n#define KVM_INST_WRTEEI_1\t0x7c008146\n#define KVM_INST_WRTEEI_0\t0x7c000146\n#define KVM_INST_WRTEE\t\t0x7c000106\n#define KVM_INST_MTMSR\t\t0x7c000124\n#define KVM_INST_MTMSRD_L1\t0x7c010164\n#define KVM_INST_MTMSRD_L0\t0x7c000164\n#define KVM_INST_TLBSYNC\t0x7c00046c\n#define KVM_INST_MFMSR\t\t0x7c0000a6\n#define KVM_MASK_RB\t\t0x0000f800\n#define KVM_MASK_RT\t\t0x03e00000\n\nstatic void __init kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_in_pages_readable",
          "args": [
            "(const char *)KVM_MAGIC_PAGE",
            "sizeof(u32)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "kvm_map_magic_page",
            "&features",
            "1"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_template_start[];\nextern u32 kvm_template_end[];\n\nstatic void __init kvm_use_magic_page(void)\n{\n\tu32 *p;\n\tu32 *start, *end;\n\tu32 features;\n\n\t/* Tell the host to map the magic page to -4096 on all CPUs */\n\ton_each_cpu(kvm_map_magic_page, &features, 1);\n\n\t/* Quick self-test to see if the mapping works */\n\tif (!fault_in_pages_readable((const char *)KVM_MAGIC_PAGE, sizeof(u32))) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Now loop through all code and find instructions */\n\tstart = (void*)_stext;\n\tend = (void*)_etext;\n\n\t/*\n\t * Being interrupted in the middle of patching would\n\t * be bad for SPRG4-7, which KVM can't keep in sync\n\t * with emulated accesses because reads don't trap.\n\t */\n\tlocal_irq_disable();\n\n\tfor (p = start; p < end; p++) {\n\t\t/* Avoid patching the template code */\n\t\tif (p >= kvm_template_start && p < kvm_template_end) {\n\t\t\tp = kvm_template_end - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tkvm_check_ins(p, features);\n\t}\n\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"KVM: Live patching for a fast VM %s\\n\",\n\t\t\t kvm_patching_worked ? \"worked\" : \"failed\");\n}"
  },
  {
    "function_name": "kvm_check_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "418-657",
    "snippet": "static void __init kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_MTSRIN\t\t0x7c0001e4",
      "#define KVM_INST_WRTEEI_1\t0x7c008146",
      "#define KVM_INST_WRTEEI_0\t0x7c000146",
      "#define KVM_INST_WRTEE\t\t0x7c000106",
      "#define KVM_INST_MTMSR\t\t0x7c000124",
      "#define KVM_INST_MTMSRD_L1\t0x7c010164",
      "#define KVM_INST_MTMSRD_L0\t0x7c000164",
      "#define KVM_INST_TLBSYNC\t0x7c00046c",
      "#define KVM_INST_MFMSR\t\t0x7c0000a6",
      "#define KVM_MASK_RB\t\t0x0000f800",
      "#define KVM_MASK_RT\t\t0x03e00000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_wrtee",
          "args": [
            "inst",
            "0",
            "1"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_wrtee",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "269-320",
          "snippet": "static void __init kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_LI\t\t0x38000000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_LI\t\t0x38000000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_wrteei_0",
          "args": [
            "inst"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_wrteei_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "326-354",
          "snippet": "static void __init kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtsrin",
          "args": [
            "inst",
            "inst_rt",
            "inst_rb"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtsrin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "367-399",
          "snippet": "static void __init kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtmsr",
          "args": [
            "inst",
            "inst_rt"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_mtmsrd",
          "args": [
            "inst",
            "inst_rt"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsrd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "155-199",
          "snippet": "static void __init kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsrd_branch_offs;",
            "extern u32 kvm_emulate_mtmsrd_reg_offs;",
            "extern u32 kvm_emulate_mtmsrd_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsrd_len;",
            "extern u32 kvm_emulate_mtmsrd[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsrd_branch_offs;\nextern u32 kvm_emulate_mtmsrd_reg_offs;\nextern u32 kvm_emulate_mtmsrd_orig_ins_offs;\nextern u32 kvm_emulate_mtmsrd_len;\nextern u32 kvm_emulate_mtmsrd[];\n\nstatic void __init kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_nop",
          "args": [
            "inst"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_nop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "114-117",
          "snippet": "static void __init kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_NOP\t\t0x60000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_NOP\t\t0x60000000\n\nstatic void __init kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_stw",
          "args": [
            "inst",
            "magic_var(esr)",
            "inst_rt"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_stw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "109-112",
          "snippet": "static void __init kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_STW\t\t0x90000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void __init kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "esr"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_ESR"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_std",
          "args": [
            "inst",
            "magic_var(sprg7)",
            "inst_rt"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_std",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "100-107",
          "snippet": "static void __init kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_STD\t\t0xf8000000",
            "#define KVM_INST_STW\t\t0x90000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STD\t\t0xf8000000\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void __init kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg7"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG7"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg6"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG6"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg5"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG5"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg4"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG4"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS7"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas6"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS6"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas4"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS4"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS3"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas2"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS2"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_MAS0"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dsisr"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DSISR"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dar"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DAR"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_DEAR"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr1"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SRR1"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr0"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SRR0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg3"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG3"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg2"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG2"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg0"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MTSPR",
          "args": [
            "SPRN_SPRG0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_lwz",
          "args": [
            "inst",
            "magic_var(pir)",
            "inst_rt"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_lwz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "95-98",
          "snippet": "static void __init kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "pir"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_PIR"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "esr"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_ESR"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ld",
          "args": [
            "inst",
            "magic_var(sprg7)",
            "inst_rt"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ld",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "86-93",
          "snippet": "static void __init kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg7"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG7R"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG7"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg6"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG6R"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG6"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg5"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG5R"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG5"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg4"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG4R"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG4"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS7"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas6"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS6"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas4"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS4"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas7_3"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS3"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas2"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS2"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas1"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS1"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "mas0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_MAS0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dsisr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DSISR"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "dar"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DAR"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_DEAR"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr1"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SRR1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "srr0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SRR0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg3"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG3"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg2"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG2"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg1"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG1"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "sprg0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_INST_MFSPR",
          "args": [
            "SPRN_SPRG0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "msr"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_MTSRIN\t\t0x7c0001e4\n#define KVM_INST_WRTEEI_1\t0x7c008146\n#define KVM_INST_WRTEEI_0\t0x7c000146\n#define KVM_INST_WRTEE\t\t0x7c000106\n#define KVM_INST_MTMSR\t\t0x7c000124\n#define KVM_INST_MTMSRD_L1\t0x7c010164\n#define KVM_INST_MTMSRD_L0\t0x7c000164\n#define KVM_INST_TLBSYNC\t0x7c00046c\n#define KVM_INST_MFMSR\t\t0x7c0000a6\n#define KVM_MASK_RB\t\t0x0000f800\n#define KVM_MASK_RT\t\t0x03e00000\n\nstatic void __init kvm_check_ins(u32 *inst, u32 features)\n{\n\tu32 _inst = *inst;\n\tu32 inst_no_rt = _inst & ~KVM_MASK_RT;\n\tu32 inst_rt = _inst & KVM_MASK_RT;\n\n\tswitch (inst_no_rt) {\n\t/* Loads */\n\tcase KVM_INST_MFMSR:\n\t\tkvm_patch_ins_ld(inst, magic_var(msr), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_ld(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_ld(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MFSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_ld(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_lwz(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MFSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MFSPR(SPRN_SPRG4):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG4R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG5):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG5R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG6):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG6R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MFSPR(SPRN_SPRG7):\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_SPRG7R):\n#endif\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_ld(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MFSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\tcase KVM_INST_MFSPR(SPRN_PIR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_lwz(inst, magic_var(pir), inst_rt);\n\t\tbreak;\n\n\n\t/* Stores */\n\tcase KVM_INST_MTSPR(SPRN_SPRG0):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG1):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG2):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG3):\n\t\tkvm_patch_ins_std(inst, magic_var(sprg3), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR0):\n\t\tkvm_patch_ins_std(inst, magic_var(srr0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SRR1):\n\t\tkvm_patch_ins_std(inst, magic_var(srr1), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_DEAR):\n#else\n\tcase KVM_INST_MTSPR(SPRN_DAR):\n#endif\n\t\tkvm_patch_ins_std(inst, magic_var(dar), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_DSISR):\n\t\tkvm_patch_ins_stw(inst, magic_var(dsisr), inst_rt);\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3E_MMU\n\tcase KVM_INST_MTSPR(SPRN_MAS0):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas0), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS1):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas1), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS2):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(mas2), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS3):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3) + 4, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_MAS7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(mas7_3), inst_rt);\n\t\tbreak;\n#endif /* CONFIG_PPC_BOOK3E_MMU */\n\n\tcase KVM_INST_MTSPR(SPRN_SPRG4):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg4), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG5):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg5), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG6):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg6), inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTSPR(SPRN_SPRG7):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_std(inst, magic_var(sprg7), inst_rt);\n\t\tbreak;\n\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_MTSPR(SPRN_ESR):\n\t\tif (features & KVM_MAGIC_FEAT_MAS0_TO_SPRG7)\n\t\t\tkvm_patch_ins_stw(inst, magic_var(esr), inst_rt);\n\t\tbreak;\n#endif\n\n\t/* Nops */\n\tcase KVM_INST_TLBSYNC:\n\t\tkvm_patch_ins_nop(inst);\n\t\tbreak;\n\n\t/* Rewrites */\n\tcase KVM_INST_MTMSRD_L1:\n\t\tkvm_patch_ins_mtmsrd(inst, inst_rt);\n\t\tbreak;\n\tcase KVM_INST_MTMSR:\n\tcase KVM_INST_MTMSRD_L0:\n\t\tkvm_patch_ins_mtmsr(inst, inst_rt);\n\t\tbreak;\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEE:\n\t\tkvm_patch_ins_wrtee(inst, inst_rt, 0);\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (inst_no_rt & ~KVM_MASK_RB) {\n#ifdef CONFIG_PPC_BOOK3S_32\n\tcase KVM_INST_MTSRIN:\n\t\tif (features & KVM_MAGIC_FEAT_SR) {\n\t\t\tu32 inst_rb = _inst & KVM_MASK_RB;\n\t\t\tkvm_patch_ins_mtsrin(inst, inst_rt, inst_rb);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\tswitch (_inst) {\n#ifdef CONFIG_BOOKE\n\tcase KVM_INST_WRTEEI_0:\n\t\tkvm_patch_ins_wrteei_0(inst);\n\t\tbreak;\n\n\tcase KVM_INST_WRTEEI_1:\n\t\tkvm_patch_ins_wrtee(inst, 0, 1);\n\t\tbreak;\n#endif\n\t}\n}"
  },
  {
    "function_name": "kvm_map_magic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "403-416",
    "snippet": "static void __init kvm_map_magic_page(void *data)\n{\n\tu32 *features = data;\n\n\tulong in[8] = {0};\n\tulong out[8];\n\n\tin[0] = KVM_MAGIC_PAGE;\n\tin[1] = KVM_MAGIC_PAGE | MAGIC_PAGE_FLAG_NOT_MAPPED_NX;\n\n\tepapr_hypercall(in, out, KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE));\n\n\t*features = out[0];\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_MAGIC_PAGE\t\t(-4096L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "epapr_hypercall",
          "args": [
            "in",
            "out",
            "KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_HCALL_TOKEN",
          "args": [
            "KVM_HC_PPC_MAP_MAGIC_PAGE"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_MAGIC_PAGE\t\t(-4096L)\n\nstatic void __init kvm_map_magic_page(void *data)\n{\n\tu32 *features = data;\n\n\tulong in[8] = {0};\n\tulong out[8];\n\n\tin[0] = KVM_MAGIC_PAGE;\n\tin[1] = KVM_MAGIC_PAGE | MAGIC_PAGE_FLAG_NOT_MAPPED_NX;\n\n\tepapr_hypercall(in, out, KVM_HCALL_TOKEN(KVM_HC_PPC_MAP_MAGIC_PAGE));\n\n\t*features = out[0];\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtsrin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "367-399",
    "snippet": "static void __init kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "119-130",
          "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtsrin_len * 4"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtsrin",
            "kvm_emulate_mtsrin_len * 4"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtsrin_len * 4"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "132-147",
          "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern char kvm_tmp[];",
            "extern char kvm_tmp_end[];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_mtsrin(u32 *inst, u32 rt, u32 rb)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtsrin_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtsrin_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtsrin, kvm_emulate_mtsrin_len * 4);\n\tp[kvm_emulate_mtsrin_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tp[kvm_emulate_mtsrin_reg1_offs] |= (rb << 10);\n\tp[kvm_emulate_mtsrin_reg2_offs] |= rt;\n\tp[kvm_emulate_mtsrin_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtsrin_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_wrteei_0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "326-354",
    "snippet": "static void __init kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "119-130",
          "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_wrteei_0",
            "kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_wrteei_0_len * 4"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "132-147",
          "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern char kvm_tmp[];",
            "extern char kvm_tmp_end[];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_wrteei_0(u32 *inst)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrteei_0_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrteei_0_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\tmemcpy(p, kvm_emulate_wrteei_0, kvm_emulate_wrteei_0_len * 4);\n\tp[kvm_emulate_wrteei_0_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrteei_0_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_wrtee",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "269-320",
    "snippet": "static void __init kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_LI\t\t0x38000000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "119-130",
          "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_wrtee_len * 4"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_wrtee_reg_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "77-84",
          "snippet": "static void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "48-85",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__PPC_RT",
          "args": [
            "R30"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_wrtee",
            "kvm_emulate_wrtee_len * 4"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_wrtee_len * 4"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "132-147",
          "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern char kvm_tmp[];",
            "extern char kvm_tmp_end[];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_LI\t\t0x38000000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\n\nstatic void __init kvm_patch_ins_wrtee(u32 *inst, u32 rt, int imm_one)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_wrtee_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_wrtee_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_wrtee, kvm_emulate_wrtee_len * 4);\n\tp[kvm_emulate_wrtee_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\tif (imm_one) {\n\t\tp[kvm_emulate_wrtee_reg_offs] =\n\t\t\tKVM_INST_LI | __PPC_RT(R30) | MSR_EE;\n\t} else {\n\t\t/* Make clobbered registers work too */\n\t\tswitch (get_rt(rt)) {\n\t\tcase 30:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\t\tbreak;\n\t\tcase 31:\n\t\t\tkvm_patch_ins_ll(&p[kvm_emulate_wrtee_reg_offs],\n\t\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp[kvm_emulate_wrtee_reg_offs] |= rt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp[kvm_emulate_wrtee_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_wrtee_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtmsr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "208-259",
    "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_emulate_mtmsr_branch_offs;",
      "extern u32 kvm_emulate_mtmsr_reg1_offs;",
      "extern u32 kvm_emulate_mtmsr_reg2_offs;",
      "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
      "extern u32 kvm_emulate_mtmsr_len;",
      "extern u32 kvm_emulate_mtmsr[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "119-130",
          "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtmsr_len * 4"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_mtmsr_reg2_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "77-84",
          "snippet": "static void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "48-85",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtmsr",
            "kvm_emulate_mtmsr_len * 4"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtmsr_len * 4"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "132-147",
          "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern char kvm_tmp[];",
            "extern char kvm_tmp_end[];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_patch_ins_mtmsrd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "155-199",
    "snippet": "static void __init kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_RT_30\t\t0x03c00000",
      "#define KVM_INST_B_MAX\t\t0x01ffffff",
      "#define KVM_INST_B_MASK\t\t0x03ffffff"
    ],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern u32 kvm_emulate_mtmsrd_branch_offs;",
      "extern u32 kvm_emulate_mtmsrd_reg_offs;",
      "extern u32 kvm_emulate_mtmsrd_orig_ins_offs;",
      "extern u32 kvm_emulate_mtmsrd_len;",
      "extern u32 kvm_emulate_mtmsrd[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins_b",
          "args": [
            "inst",
            "distance_start"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_b",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "119-130",
          "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_B_MASK\t\t0x03ffffff",
            "#define KVM_INST_B\t\t0x48000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)p",
            "(ulong)p + kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_patch_ins_ll",
          "args": [
            "&p[kvm_emulate_mtmsrd_reg_offs]",
            "magic_var(scratch1)",
            "KVM_RT_30"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "77-84",
          "snippet": "static void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_INST_LD\t\t0xe8000000",
            "#define KVM_INST_LWZ\t\t0x80000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "magic_var",
          "args": [
            "scratch2"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rt",
          "args": [
            "rt"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_rtc_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas-rtc.c",
          "lines": "48-85",
          "snippet": "void rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/delay.h>",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>",
            "#include <linux/timer.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_RTC_WAIT 5000\t/* 5 sec */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/ratelimit.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n\n#define MAX_RTC_WAIT 5000\t/* 5 sec */\n\nvoid rtas_get_rtc_time(struct rtc_time *rtc_tm)\n{\n        int ret[8];\n\tint error;\n\tunsigned int wait_time;\n\tu64 max_wait_tb;\n\n\tmax_wait_tb = get_tb() + tb_ticks_per_usec * 1000 * MAX_RTC_WAIT;\n\tdo {\n\t\terror = rtas_call(rtas_token(\"get-time-of-day\"), 0, 8, ret);\n\n\t\twait_time = rtas_busy_delay_time(error);\n\t\tif (wait_time) {\n\t\t\tif (in_interrupt()) {\n\t\t\t\tmemset(rtc_tm, 0, sizeof(struct rtc_time));\n\t\t\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t\t\t   \"error: reading clock \"\n\t\t\t\t\t\t   \"would delay interrupt\\n\");\n\t\t\t\treturn;\t/* delay not allowed */\n\t\t\t}\n\t\t\tmsleep(wait_time);\n\t\t}\n\t} while (wait_time && (get_tb() < max_wait_tb));\n\n\tif (error != 0) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\t   \"error: reading the clock failed (%d)\\n\",\n\t\t\t\t   error);\n\t\treturn;\n        }\n\n\trtc_tm->tm_sec = ret[5];\n\trtc_tm->tm_min = ret[4];\n\trtc_tm->tm_hour = ret[3];\n\trtc_tm->tm_mday = ret[2];\n\trtc_tm->tm_mon = ret[1] - 1;\n\trtc_tm->tm_year = ret[0] - 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "kvm_emulate_mtmsrd",
            "kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_alloc",
          "args": [
            "kvm_emulate_mtmsrd_len * 4"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "132-147",
          "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern char kvm_tmp[];",
            "extern char kvm_tmp_end[];",
            "static int kvm_tmp_index;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsrd_branch_offs;\nextern u32 kvm_emulate_mtmsrd_reg_offs;\nextern u32 kvm_emulate_mtmsrd_orig_ins_offs;\nextern u32 kvm_emulate_mtmsrd_len;\nextern u32 kvm_emulate_mtmsrd[];\n\nstatic void __init kvm_patch_ins_mtmsrd(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsrd_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsrd_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsrd, kvm_emulate_mtmsrd_len * 4);\n\tp[kvm_emulate_mtmsrd_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsrd_reg_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsrd_reg_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsrd_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsrd_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
  },
  {
    "function_name": "kvm_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "132-147",
    "snippet": "static u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_patching_worked = true;",
      "extern char kvm_tmp[];",
      "extern char kvm_tmp_end[];",
      "static int kvm_tmp_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"KVM: No more space (%d + %d)\\n\"",
            "kvm_tmp_index",
            "len"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_patching_worked = true;\nextern char kvm_tmp[];\nextern char kvm_tmp_end[];\nstatic int kvm_tmp_index;\n\nstatic u32 * __init kvm_alloc(int len)\n{\n\tu32 *p;\n\n\tif ((kvm_tmp_index + len) > (kvm_tmp_end - kvm_tmp)) {\n\t\tprintk(KERN_ERR \"KVM: No more space (%d + %d)\\n\",\n\t\t\t\tkvm_tmp_index, len);\n\t\tkvm_patching_worked = false;\n\t\treturn NULL;\n\t}\n\n\tp = (void*)&kvm_tmp[kvm_tmp_index];\n\tkvm_tmp_index += len;\n\n\treturn p;\n}"
  },
  {
    "function_name": "kvm_patch_ins_b",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "119-130",
    "snippet": "static void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_B_MASK\t\t0x03ffffff",
      "#define KVM_INST_B\t\t0x48000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_B | (addr & KVM_INST_B_MASK)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_B_MASK\t\t0x03ffffff\n#define KVM_INST_B\t\t0x48000000\n\nstatic void __init kvm_patch_ins_b(u32 *inst, int addr)\n{\n#if defined(CONFIG_RELOCATABLE) && defined(CONFIG_PPC_BOOK3S)\n\t/* On relocatable kernels interrupts handlers and our code\n\t   can be in different regions, so we don't patch them */\n\n\tif ((ulong)inst < (ulong)&__end_interrupts)\n\t\treturn;\n#endif\n\n\tkvm_patch_ins(inst, KVM_INST_B | (addr & KVM_INST_B_MASK));\n}"
  },
  {
    "function_name": "kvm_patch_ins_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "114-117",
    "snippet": "static void __init kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_NOP\t\t0x60000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_NOP"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_NOP\t\t0x60000000\n\nstatic void __init kvm_patch_ins_nop(u32 *inst)\n{\n\tkvm_patch_ins(inst, KVM_INST_NOP);\n}"
  },
  {
    "function_name": "kvm_patch_ins_stw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "109-112",
    "snippet": "static void __init kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_STW\t\t0x90000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_STW | rt | (addr & 0x0000fffc)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void __init kvm_patch_ins_stw(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | (addr & 0x0000fffc));\n}"
  },
  {
    "function_name": "kvm_patch_ins_std",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "100-107",
    "snippet": "static void __init kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_STD\t\t0xf8000000",
      "#define KVM_INST_STW\t\t0x90000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc)"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_STD\t\t0xf8000000\n#define KVM_INST_STW\t\t0x90000000\n\nstatic void __init kvm_patch_ins_std(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_STD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_STW | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins_lwz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "95-98",
    "snippet": "static void __init kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | (addr & 0x0000ffff)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_lwz(u32 *inst, long addr, u32 rt)\n{\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000ffff));\n}"
  },
  {
    "function_name": "kvm_patch_ins_ld",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "86-93",
    "snippet": "static void __init kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LD\t\t0xe8000000",
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ld(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | ((addr + 4) & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins_ll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "77-84",
    "snippet": "static void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define KVM_INST_LD\t\t0xe8000000",
      "#define KVM_INST_LWZ\t\t0x80000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_patch_ins",
          "args": [
            "inst",
            "KVM_INST_LWZ | rt | (addr & 0x0000fffc)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_patch_ins_mtmsr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
          "lines": "208-259",
          "snippet": "static void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/disassemble.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/reg.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/of.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_para.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_RT_30\t\t0x03c00000",
            "#define KVM_INST_B_MAX\t\t0x01ffffff",
            "#define KVM_INST_B_MASK\t\t0x03ffffff"
          ],
          "globals_used": [
            "static bool kvm_patching_worked = true;",
            "extern u32 kvm_emulate_mtmsr_branch_offs;",
            "extern u32 kvm_emulate_mtmsr_reg1_offs;",
            "extern u32 kvm_emulate_mtmsr_reg2_offs;",
            "extern u32 kvm_emulate_mtmsr_orig_ins_offs;",
            "extern u32 kvm_emulate_mtmsr_len;",
            "extern u32 kvm_emulate_mtmsr[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_RT_30\t\t0x03c00000\n#define KVM_INST_B_MAX\t\t0x01ffffff\n#define KVM_INST_B_MASK\t\t0x03ffffff\n\nstatic bool kvm_patching_worked = true;\nextern u32 kvm_emulate_mtmsr_branch_offs;\nextern u32 kvm_emulate_mtmsr_reg1_offs;\nextern u32 kvm_emulate_mtmsr_reg2_offs;\nextern u32 kvm_emulate_mtmsr_orig_ins_offs;\nextern u32 kvm_emulate_mtmsr_len;\nextern u32 kvm_emulate_mtmsr[];\n\nstatic void __init kvm_patch_ins_mtmsr(u32 *inst, u32 rt)\n{\n\tu32 *p;\n\tint distance_start;\n\tint distance_end;\n\tulong next_inst;\n\n\tp = kvm_alloc(kvm_emulate_mtmsr_len * 4);\n\tif (!p)\n\t\treturn;\n\n\t/* Find out where we are and put everything there */\n\tdistance_start = (ulong)p - (ulong)inst;\n\tnext_inst = ((ulong)inst + 4);\n\tdistance_end = next_inst - (ulong)&p[kvm_emulate_mtmsr_branch_offs];\n\n\t/* Make sure we only write valid b instructions */\n\tif (distance_start > KVM_INST_B_MAX) {\n\t\tkvm_patching_worked = false;\n\t\treturn;\n\t}\n\n\t/* Modify the chunk to fit the invocation */\n\tmemcpy(p, kvm_emulate_mtmsr, kvm_emulate_mtmsr_len * 4);\n\tp[kvm_emulate_mtmsr_branch_offs] |= distance_end & KVM_INST_B_MASK;\n\n\t/* Make clobbered registers work too */\n\tswitch (get_rt(rt)) {\n\tcase 30:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch2), KVM_RT_30);\n\t\tbreak;\n\tcase 31:\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg1_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tkvm_patch_ins_ll(&p[kvm_emulate_mtmsr_reg2_offs],\n\t\t\t\t magic_var(scratch1), KVM_RT_30);\n\t\tbreak;\n\tdefault:\n\t\tp[kvm_emulate_mtmsr_reg1_offs] |= rt;\n\t\tp[kvm_emulate_mtmsr_reg2_offs] |= rt;\n\t\tbreak;\n\t}\n\n\tp[kvm_emulate_mtmsr_orig_ins_offs] = *inst;\n\tflush_icache_range((ulong)p, (ulong)p + kvm_emulate_mtmsr_len * 4);\n\n\t/* Patch the invocation */\n\tkvm_patch_ins_b(inst, distance_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\n#define KVM_INST_LD\t\t0xe8000000\n#define KVM_INST_LWZ\t\t0x80000000\n\nstatic void __init kvm_patch_ins_ll(u32 *inst, long addr, u32 rt)\n{\n#ifdef CONFIG_64BIT\n\tkvm_patch_ins(inst, KVM_INST_LD | rt | (addr & 0x0000fffc));\n#else\n\tkvm_patch_ins(inst, KVM_INST_LWZ | rt | (addr & 0x0000fffc));\n#endif\n}"
  },
  {
    "function_name": "kvm_patch_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kvm.c",
    "lines": "71-75",
    "snippet": "static void __init kvm_patch_ins(u32 *inst, u32 new_inst)\n{\n\t*inst = new_inst;\n\tflush_icache_range((ulong)inst, (ulong)inst + 4);\n}",
    "includes": [
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/ppc-opcode.h>",
      "#include <asm/disassemble.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <asm/reg.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/of.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_para.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(ulong)inst",
            "(ulong)inst + 4"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/ppc-opcode.h>\n#include <asm/disassemble.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <asm/reg.h>\n#include <linux/pagemap.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/kvm_para.h>\n#include <linux/kmemleak.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kvm_host.h>\n\nstatic void __init kvm_patch_ins(u32 *inst, u32 new_inst)\n{\n\t*inst = new_inst;\n\tflush_icache_range((ulong)inst, (ulong)inst + 4);\n}"
  }
]