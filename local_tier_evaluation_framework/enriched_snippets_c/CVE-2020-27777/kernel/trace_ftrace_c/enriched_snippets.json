[
  {
    "function_name": "arch_ftrace_match_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "982-988",
    "snippet": "char *arch_ftrace_match_adjust(char *str, const char *search)\n{\n\tif (str[0] == '.' && search[0] != '.')\n\t\treturn str + 1;\n\telse\n\t\treturn str;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nchar *arch_ftrace_match_adjust(char *str, const char *search)\n{\n\tif (str[0] == '.' && search[0] != '.')\n\t\treturn str + 1;\n\telse\n\t\treturn str;\n}"
  },
  {
    "function_name": "prepare_ftrace_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "961-978",
    "snippet": "unsigned long prepare_ftrace_return(unsigned long parent, unsigned long ip,\n\t\t\t\t\t\tunsigned long sp)\n{\n\tunsigned long return_hooker;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\tgoto out;\n\n\tif (unlikely(atomic_read(&current->tracing_graph_pause)))\n\t\tgoto out;\n\n\treturn_hooker = ppc_function_entry(return_to_handler);\n\n\tif (!function_graph_enter(parent, ip, 0, (unsigned long *)sp))\n\t\tparent = return_hooker;\nout:\n\treturn parent;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "function_graph_enter",
          "args": [
            "parent",
            "ip",
            "0",
            "(unsigned long *)sp"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "return_to_handler"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&current->tracing_graph_pause)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->tracing_graph_pause"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_graph_is_dead()"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_is_dead",
          "args": [],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nunsigned long prepare_ftrace_return(unsigned long parent, unsigned long ip,\n\t\t\t\t\t\tunsigned long sp)\n{\n\tunsigned long return_hooker;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\tgoto out;\n\n\tif (unlikely(atomic_read(&current->tracing_graph_pause)))\n\t\tgoto out;\n\n\treturn_hooker = ppc_function_entry(return_to_handler);\n\n\tif (!function_graph_enter(parent, ip, 0, (unsigned long *)sp))\n\t\tparent = return_hooker;\nout:\n\treturn parent;\n}"
  },
  {
    "function_name": "ftrace_disable_ftrace_graph_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "944-955",
    "snippet": "int ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tstruct ppc_inst old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "stub",
            "0"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_disable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tstruct ppc_inst old, new;\n\n\told = ftrace_call_replace(ip, addr, 0);\n\tnew = ftrace_call_replace(ip, stub, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
  },
  {
    "function_name": "ftrace_enable_ftrace_graph_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "931-942",
    "snippet": "int ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tstruct ppc_inst old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "0"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_enable_ftrace_graph_caller(void)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_graph_call);\n\tunsigned long addr = (unsigned long)(&ftrace_graph_caller);\n\tunsigned long stub = (unsigned long)(&ftrace_graph_stub);\n\tstruct ppc_inst old, new;\n\n\told = ftrace_call_replace(ip, stub, 0);\n\tnew = ftrace_call_replace(ip, addr, 0);\n\n\treturn ftrace_modify_code(ip, old, new);\n}"
  },
  {
    "function_name": "ftrace_dyn_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "919-922",
    "snippet": "int __init ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint __init ftrace_dyn_arch_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_dyn_arch_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "885-917",
    "snippet": "int __init ftrace_dyn_arch_init(void)\n{\n\tint i;\n\tunsigned int *tramp[] = { ftrace_tramp_text, ftrace_tramp_init };\n\tu32 stub_insns[] = {\n\t\t0xe98d0000 | PACATOC,\t/* ld      r12,PACATOC(r13)\t*/\n\t\t0x3d8c0000,\t\t/* addis   r12,r12,<high>\t*/\n\t\t0x398c0000,\t\t/* addi    r12,r12,<low>\t*/\n\t\t0x7d8903a6,\t\t/* mtctr   r12\t\t\t*/\n\t\t0x4e800420,\t\t/* bctr\t\t\t\t*/\n\t};\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tunsigned long addr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tunsigned long addr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tlong reladdr = addr - kernel_toc_addr();\n\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"Address of %ps out of range of kernel_toc.\\n\",\n\t\t\t\t(void *)addr);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tmemcpy(tramp[i], stub_insns, sizeof(stub_insns));\n\t\ttramp[i][1] |= PPC_HA(reladdr);\n\t\ttramp[i][2] |= PPC_LO(reladdr);\n\t\tadd_ftrace_tramp((unsigned long)tramp[i]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define PACATOC offsetof(struct paca_struct, kernel_toc)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_ftrace_tramp",
          "args": [
            "(unsigned long)tramp[i]"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "add_ftrace_tramp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "310-321",
          "snippet": "static int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define\tNUM_FTRACE_TRAMPS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_LO",
          "args": [
            "reladdr"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_HA",
          "args": [
            "reladdr"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tramp[i]",
            "stub_insns",
            "sizeof(stub_insns)"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Address of %ps out of range of kernel_toc.\\n\"",
            "(void *)addr"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_toc_addr",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_caller"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_regs_caller"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define PACATOC offsetof(struct paca_struct, kernel_toc)\n\nint __init ftrace_dyn_arch_init(void)\n{\n\tint i;\n\tunsigned int *tramp[] = { ftrace_tramp_text, ftrace_tramp_init };\n\tu32 stub_insns[] = {\n\t\t0xe98d0000 | PACATOC,\t/* ld      r12,PACATOC(r13)\t*/\n\t\t0x3d8c0000,\t\t/* addis   r12,r12,<high>\t*/\n\t\t0x398c0000,\t\t/* addi    r12,r12,<low>\t*/\n\t\t0x7d8903a6,\t\t/* mtctr   r12\t\t\t*/\n\t\t0x4e800420,\t\t/* bctr\t\t\t\t*/\n\t};\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tunsigned long addr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tunsigned long addr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tlong reladdr = addr - kernel_toc_addr();\n\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"Address of %ps out of range of kernel_toc.\\n\",\n\t\t\t\t(void *)addr);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tmemcpy(tramp[i], stub_insns, sizeof(stub_insns));\n\t\ttramp[i][1] |= PPC_HA(reladdr);\n\t\ttramp[i][2] |= PPC_LO(reladdr);\n\t\tadd_ftrace_tramp((unsigned long)tramp[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_ftrace_update_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "875-878",
    "snippet": "void arch_ftrace_update_code(int command)\n{\n\tftrace_modify_all_code(command);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_all_code",
          "args": [
            "command"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nvoid arch_ftrace_update_code(int command)\n{\n\tftrace_modify_all_code(command);\n}"
  },
  {
    "function_name": "ftrace_update_ftrace_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "848-869",
    "snippet": "int ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tstruct ppc_inst old, new;\n\tint ret;\n\n\told = ppc_inst_read((struct ppc_inst *)&ftrace_call);\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* Also update the regs callback function */\n\tif (!ret) {\n\t\tip = (unsigned long)(&ftrace_regs_call);\n\t\told = ppc_inst_read((struct ppc_inst *)&ftrace_regs_call);\n\t\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\t\tret = ftrace_modify_code(ip, old, new);\n\t}\n#endif\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "(unsigned long)func",
            "1"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)&ftrace_regs_call"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)&ftrace_call"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_update_ftrace_func(ftrace_func_t func)\n{\n\tunsigned long ip = (unsigned long)(&ftrace_call);\n\tstruct ppc_inst old, new;\n\tint ret;\n\n\told = ppc_inst_read((struct ppc_inst *)&ftrace_call);\n\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\tret = ftrace_modify_code(ip, old, new);\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t/* Also update the regs callback function */\n\tif (!ret) {\n\t\tip = (unsigned long)(&ftrace_regs_call);\n\t\told = ppc_inst_read((struct ppc_inst *)&ftrace_regs_call);\n\t\tnew = ftrace_call_replace(ip, (unsigned long)func, 1);\n\t\tret = ftrace_modify_code(ip, old, new);\n\t}\n#endif\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_modify_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "807-845",
    "snippet": "int ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\tunsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr) && test_24bit_addr(ip, old_addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, old_addr, 1);\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip)) {\n\t\t/*\n\t\t * We always patch out of range locations to go to the regs\n\t\t * variant, so there is nothing to do here\n\t\t */\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_modify_call(rec, old_addr, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_modify_call",
          "args": [
            "rec",
            "old_addr",
            "addr"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_modify_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "713-804",
          "snippet": "static int\n__ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\tunsigned long entry, ptr, tramp;\n\tstruct module *mod = rec->arch.mod;\n\n\t/* If we never set up ftrace trampolines, then bail */\n\tif (!mod->arch.tramp || !mod->arch.tramp_regs) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\tentry = ppc_global_function_entry((void *)old_addr);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (tramp != entry) {\n\t\t/* old_addr is not within range, so we must have used a trampoline */\n\t\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpr_devel(\"trampoline target %lx\", ptr);\n\n\t\t/* This should match what was called */\n\t\tif (ptr != entry) {\n\t\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* The new target may be within range */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\tif (patch_branch((struct ppc_inst *)ip, addr, BRANCH_SET_LINK)) {\n\t\t\tpr_err(\"REL24 out of range!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\ttramp = mod->arch.tramp_regs;\n\telse\n\t\ttramp = mod->arch.tramp;\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (create_branch(&op, (struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\tunsigned long entry, ptr, tramp;\n\tstruct module *mod = rec->arch.mod;\n\n\t/* If we never set up ftrace trampolines, then bail */\n\tif (!mod->arch.tramp || !mod->arch.tramp_regs) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\tentry = ppc_global_function_entry((void *)old_addr);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (tramp != entry) {\n\t\t/* old_addr is not within range, so we must have used a trampoline */\n\t\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpr_devel(\"trampoline target %lx\", ptr);\n\n\t\t/* This should match what was called */\n\t\tif (ptr != entry) {\n\t\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* The new target may be within range */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\tif (patch_branch((struct ppc_inst *)ip, addr, BRANCH_SET_LINK)) {\n\t\t\tpr_err(\"REL24 out of range!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\ttramp = mod->arch.tramp_regs;\n\telse\n\t\ttramp = mod->arch.tramp;\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (create_branch(&op, (struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No module loaded\\n\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_kernel_text",
          "args": [
            "ip"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "1"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "old_addr"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "91-98",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\tunsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr) && test_24bit_addr(ip, old_addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, old_addr, 1);\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip)) {\n\t\t/*\n\t\t * We always patch out of range locations to go to the regs\n\t\t * variant, so there is nothing to do here\n\t\t */\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_modify_call(rec, old_addr, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
  },
  {
    "function_name": "__ftrace_modify_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "713-804",
    "snippet": "static int\n__ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\tunsigned long entry, ptr, tramp;\n\tstruct module *mod = rec->arch.mod;\n\n\t/* If we never set up ftrace trampolines, then bail */\n\tif (!mod->arch.tramp || !mod->arch.tramp_regs) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\tentry = ppc_global_function_entry((void *)old_addr);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (tramp != entry) {\n\t\t/* old_addr is not within range, so we must have used a trampoline */\n\t\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpr_devel(\"trampoline target %lx\", ptr);\n\n\t\t/* This should match what was called */\n\t\tif (ptr != entry) {\n\t\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* The new target may be within range */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\tif (patch_branch((struct ppc_inst *)ip, addr, BRANCH_SET_LINK)) {\n\t\t\tpr_err(\"REL24 out of range!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\ttramp = mod->arch.tramp_regs;\n\telse\n\t\ttramp = mod->arch.tramp;\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (create_branch(&op, (struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "(struct ppc_inst *)ip",
            "tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Branch out of range\\n\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&op",
            "(struct ppc_inst *)ip",
            "tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"addr %lx does not match expected %lx\\n\"",
            "ptr",
            "entry"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"trampoline target %lx\"",
            "ptr"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to get trampoline target\\n\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_trampoline_target",
          "args": [
            "mod",
            "tramp",
            "&ptr"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "module_trampoline_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "745-779",
          "snippet": "int module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STUB_MAGIC 0x73747562 /* stub */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nint module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "(struct ppc_inst *)ip",
            "addr",
            "BRANCH_SET_LINK"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "addr"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "91-98",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"addr %lx does not match expected %lx\\n\"",
            "ptr",
            "entry"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"trampoline target %lx\"",
            "ptr"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to get trampoline target\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %lx\"",
            "ip",
            "tramp"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)old_addr"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "110-120",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %s\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "100-103",
          "snippet": "static int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Fetching opcode failed.\\n\""
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)ip"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampoline\\n\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\tunsigned long entry, ptr, tramp;\n\tstruct module *mod = rec->arch.mod;\n\n\t/* If we never set up ftrace trampolines, then bail */\n\tif (!mod->arch.tramp || !mod->arch.tramp_regs) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\tentry = ppc_global_function_entry((void *)old_addr);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (tramp != entry) {\n\t\t/* old_addr is not within range, so we must have used a trampoline */\n\t\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpr_devel(\"trampoline target %lx\", ptr);\n\n\t\t/* This should match what was called */\n\t\tif (ptr != entry) {\n\t\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* The new target may be within range */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\tif (patch_branch((struct ppc_inst *)ip, addr, BRANCH_SET_LINK)) {\n\t\t\tpr_err(\"REL24 out of range!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (rec->flags & FTRACE_FL_REGS)\n\t\ttramp = mod->arch.tramp_regs;\n\telse\n\t\ttramp = mod->arch.tramp;\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure branch is within 24 bits */\n\tif (create_branch(&op, (struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Branch out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "675-709",
    "snippet": "int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ppc_inst(PPC_INST_NOP);\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip))\n\t\treturn __ftrace_make_call_kernel(rec, addr);\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_make_call",
          "args": [
            "rec",
            "addr"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_make_call_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "628-673",
          "snippet": "static int __ftrace_make_call_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tvoid *ip = (void *)rec->ip;\n\tunsigned long tramp, entry, ptr;\n\n\t/* Make sure we're being asked to patch branch to a known ftrace addr */\n\tentry = ppc_global_function_entry((void *)ftrace_caller);\n\tptr = ppc_global_function_entry((void *)addr);\n\n\tif (ptr != entry) {\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\tentry = ppc_global_function_entry((void *)ftrace_regs_caller);\n\t\tif (ptr != entry) {\n#endif\n\t\t\tpr_err(\"Unknown ftrace addr to patch: %ps\\n\", (void *)ptr);\n\t\t\treturn -EINVAL;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\t}\n#endif\n\t}\n\n\t/* Make sure we have a nop */\n\tif (probe_kernel_read_inst(&op, ip)) {\n\t\tpr_err(\"Unable to read ftrace location %p\\n\", ip);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Unexpected call sequence at %p: %s\\n\", ip, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = find_ftrace_tramp((unsigned long)ip);\n\tif (!tramp) {\n\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\", ip);\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Error patching branch to ftrace tramp!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_make_call_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tvoid *ip = (void *)rec->ip;\n\tunsigned long tramp, entry, ptr;\n\n\t/* Make sure we're being asked to patch branch to a known ftrace addr */\n\tentry = ppc_global_function_entry((void *)ftrace_caller);\n\tptr = ppc_global_function_entry((void *)addr);\n\n\tif (ptr != entry) {\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\tentry = ppc_global_function_entry((void *)ftrace_regs_caller);\n\t\tif (ptr != entry) {\n#endif\n\t\t\tpr_err(\"Unknown ftrace addr to patch: %ps\\n\", (void *)ptr);\n\t\t\treturn -EINVAL;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\t}\n#endif\n\t}\n\n\t/* Make sure we have a nop */\n\tif (probe_kernel_read_inst(&op, ip)) {\n\t\tpr_err(\"Unable to read ftrace location %p\\n\", ip);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Unexpected call sequence at %p: %s\\n\", ip, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = find_ftrace_tramp((unsigned long)ip);\n\tif (!tramp) {\n\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\", ip);\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Error patching branch to ftrace tramp!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No module loaded\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_kernel_text",
          "args": [
            "ip"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "1"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "addr"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "91-98",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ppc_inst(PPC_INST_NOP);\n\t\tnew = ftrace_call_replace(ip, addr, 1);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip))\n\t\treturn __ftrace_make_call_kernel(rec, addr);\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * Being that we are converting from nop, it had better\n\t * already have a module defined.\n\t */\n\tif (!rec->arch.mod) {\n\t\tpr_err(\"No module loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __ftrace_make_call(rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
  },
  {
    "function_name": "__ftrace_make_call_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "628-673",
    "snippet": "static int __ftrace_make_call_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tvoid *ip = (void *)rec->ip;\n\tunsigned long tramp, entry, ptr;\n\n\t/* Make sure we're being asked to patch branch to a known ftrace addr */\n\tentry = ppc_global_function_entry((void *)ftrace_caller);\n\tptr = ppc_global_function_entry((void *)addr);\n\n\tif (ptr != entry) {\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\tentry = ppc_global_function_entry((void *)ftrace_regs_caller);\n\t\tif (ptr != entry) {\n#endif\n\t\t\tpr_err(\"Unknown ftrace addr to patch: %ps\\n\", (void *)ptr);\n\t\t\treturn -EINVAL;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\t}\n#endif\n\t}\n\n\t/* Make sure we have a nop */\n\tif (probe_kernel_read_inst(&op, ip)) {\n\t\tpr_err(\"Unable to read ftrace location %p\\n\", ip);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Unexpected call sequence at %p: %s\\n\", ip, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = find_ftrace_tramp((unsigned long)ip);\n\tif (!tramp) {\n\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\", ip);\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Error patching branch to ftrace tramp!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error patching branch to ftrace tramp!\\n\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "ip",
            "tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampolines reachable from %ps\\n\"",
            "ip"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_ftrace_tramp",
          "args": [
            "(unsigned long)ip"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "find_ftrace_tramp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "291-308",
          "snippet": "static unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define\tNUM_FTRACE_TRAMPS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unexpected call sequence at %p: %s\\n\"",
            "ip",
            "ppc_inst_as_str(op)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to read ftrace location %p\\n\"",
            "ip"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "ip"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unknown ftrace addr to patch: %ps\\n\"",
            "(void *)ptr"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_regs_caller"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_caller"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_make_call_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tvoid *ip = (void *)rec->ip;\n\tunsigned long tramp, entry, ptr;\n\n\t/* Make sure we're being asked to patch branch to a known ftrace addr */\n\tentry = ppc_global_function_entry((void *)ftrace_caller);\n\tptr = ppc_global_function_entry((void *)addr);\n\n\tif (ptr != entry) {\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\tentry = ppc_global_function_entry((void *)ftrace_regs_caller);\n\t\tif (ptr != entry) {\n#endif\n\t\t\tpr_err(\"Unknown ftrace addr to patch: %ps\\n\", (void *)ptr);\n\t\t\treturn -EINVAL;\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\t\t}\n#endif\n\t}\n\n\t/* Make sure we have a nop */\n\tif (probe_kernel_read_inst(&op, ip)) {\n\t\tpr_err(\"Unable to read ftrace location %p\\n\", ip);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Unexpected call sequence at %p: %s\\n\", ip, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = find_ftrace_tramp((unsigned long)ip);\n\tif (!tramp) {\n\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\", ip);\n\t\treturn -EINVAL;\n\t}\n\n\tif (patch_branch(ip, tramp, BRANCH_SET_LINK)) {\n\t\tpr_err(\"Error patching branch to ftrace tramp!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_make_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "587-624",
    "snippet": "static int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tint err;\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (!ppc_inst_equal(op,  ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Expected NOP but have %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\terr = create_branch(&op, (struct ppc_inst *)ip,\n\t\t\t    rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (err) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)ip",
            "op"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"write to %lx\\n\"",
            "rec->ip"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&op",
            "(struct ppc_inst *)ip",
            "rec->arch.mod->arch.tramp",
            "BRANCH_SET_LINK"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampoline\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Expected NOP but have %s\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)ip"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tint err;\n\tstruct ppc_inst op;\n\tunsigned long ip = rec->ip;\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* It should be pointing to a nop */\n\tif (!ppc_inst_equal(op,  ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Expected NOP but have %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we never set up a trampoline to ftrace_caller, then bail */\n\tif (!rec->arch.mod->arch.tramp) {\n\t\tpr_err(\"No ftrace trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* create the branch to the trampoline */\n\terr = create_branch(&op, (struct ppc_inst *)ip,\n\t\t\t    rec->arch.mod->arch.tramp, BRANCH_SET_LINK);\n\tif (err) {\n\t\tpr_err(\"REL24 out of range!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_devel(\"write to %lx\\n\", rec->ip);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "expected_nop_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "509-516",
    "snippet": "static int\nexpected_nop_sequence(void *ip, struct ppc_inst op0, struct ppc_inst op1)\n{\n\t/* look for patched \"NOP\" on ppc64 with -mprofile-kernel */\n\tif (!ppc_inst_equal(op0, ppc_inst(PPC_INST_NOP)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op0",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nexpected_nop_sequence(void *ip, struct ppc_inst op0, struct ppc_inst op1)\n{\n\t/* look for patched \"NOP\" on ppc64 with -mprofile-kernel */\n\tif (!ppc_inst_equal(op0, ppc_inst(PPC_INST_NOP)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "expected_nop_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "491-507",
    "snippet": "static int\nexpected_nop_sequence(void *ip, struct ppc_inst op0, struct ppc_inst op1)\n{\n\t/*\n\t * We expect to see:\n\t *\n\t * b +8\n\t * ld r2,XX(r1)\n\t *\n\t * The load offset is different depending on the ABI. For simplicity\n\t * just mask it out when doing the compare.\n\t */\n\tif (!ppc_inst_equal(op0, ppc_inst(0x48000008)) ||\n\t    (ppc_inst_val(op1) & 0xffff0000) != 0xe8410000)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "op1"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op0",
            "ppc_inst(0x48000008)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "0x48000008"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nexpected_nop_sequence(void *ip, struct ppc_inst op0, struct ppc_inst op1)\n{\n\t/*\n\t * We expect to see:\n\t *\n\t * b +8\n\t * ld r2,XX(r1)\n\t *\n\t * The load offset is different depending on the ABI. For simplicity\n\t * just mask it out when doing the compare.\n\t */\n\tif (!ppc_inst_equal(op0, ppc_inst(0x48000008)) ||\n\t    (ppc_inst_val(op1) & 0xffff0000) != 0xe8410000)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "435-481",
    "snippet": "int ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = ppc_inst(PPC_INST_NOP);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip))\n\t\treturn __ftrace_make_nop_kernel(rec, addr);\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_make_nop",
          "args": [
            "mod",
            "rec",
            "addr"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_make_nop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "220-287",
          "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (copy_from_kernel_nofault(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (copy_from_kernel_nofault(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = ppc_inst(PPC_INST_NOP);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (copy_from_kernel_nofault(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (copy_from_kernel_nofault(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = ppc_inst(PPC_INST_NOP);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Record mod %p not equal to passed in mod %p\\n\"",
            "rec->arch.mod",
            "mod"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No module loaded addr=%lx\\n\"",
            "addr"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_make_nop_kernel",
          "args": [
            "rec",
            "addr"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_make_nop_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "396-433",
          "snippet": "static int __ftrace_make_nop_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long tramp, ip = rec->ip;\n\tstruct ppc_inst op;\n\n\t/* Read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Let's find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (setup_mcount_compiler_tramp(tramp)) {\n\t\t/* Are other trampolines reachable? */\n\t\tif (!find_ftrace_tramp(ip)) {\n\t\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\",\n\t\t\t\t\t(void *)ip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (patch_instruction((struct ppc_inst *)ip, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_make_nop_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long tramp, ip = rec->ip;\n\tstruct ppc_inst op;\n\n\t/* Read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Let's find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (setup_mcount_compiler_tramp(tramp)) {\n\t\t/* Are other trampolines reachable? */\n\t\tif (!find_ftrace_tramp(ip)) {\n\t\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\",\n\t\t\t\t\t(void *)ip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (patch_instruction((struct ppc_inst *)ip, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_kernel_text",
          "args": [
            "ip"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_modify_code",
          "args": [
            "ip",
            "old",
            "new"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_modify_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "57-86",
          "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_call_replace",
          "args": [
            "ip",
            "addr",
            "1"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_call_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "44-55",
          "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_24bit_addr",
          "args": [
            "ip",
            "addr"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "test_24bit_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "91-98",
          "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nint ftrace_make_nop(struct module *mod,\n\t\t    struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst old, new;\n\n\t/*\n\t * If the calling address is more that 24 bits away,\n\t * then we had to use a trampoline to make the call.\n\t * Otherwise just update the call site.\n\t */\n\tif (test_24bit_addr(ip, addr)) {\n\t\t/* within range */\n\t\told = ftrace_call_replace(ip, addr, 1);\n\t\tnew = ppc_inst(PPC_INST_NOP);\n\t\treturn ftrace_modify_code(ip, old, new);\n\t} else if (core_kernel_text(ip))\n\t\treturn __ftrace_make_nop_kernel(rec, addr);\n\n#ifdef CONFIG_MODULES\n\t/*\n\t * Out of range jumps are called from modules.\n\t * We should either already have a pointer to the module\n\t * or it has been passed in.\n\t */\n\tif (!rec->arch.mod) {\n\t\tif (!mod) {\n\t\t\tpr_err(\"No module loaded addr=%lx\\n\", addr);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trec->arch.mod = mod;\n\t} else if (mod) {\n\t\tif (mod != rec->arch.mod) {\n\t\t\tpr_err(\"Record mod %p not equal to passed in mod %p\\n\",\n\t\t\t       rec->arch.mod, mod);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* nothing to do if mod == rec->arch.mod */\n\t} else\n\t\tmod = rec->arch.mod;\n\n\treturn __ftrace_make_nop(mod, rec, addr);\n#else\n\t/* We should not get here without modules */\n\treturn -EINVAL;\n#endif /* CONFIG_MODULES */\n}"
  },
  {
    "function_name": "__ftrace_make_nop_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "396-433",
    "snippet": "static int __ftrace_make_nop_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long tramp, ip = rec->ip;\n\tstruct ppc_inst op;\n\n\t/* Read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Let's find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (setup_mcount_compiler_tramp(tramp)) {\n\t\t/* Are other trampolines reachable? */\n\t\tif (!find_ftrace_tramp(ip)) {\n\t\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\",\n\t\t\t\t\t(void *)ip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (patch_instruction((struct ppc_inst *)ip, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Patching NOP failed.\\n\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)ip",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No ftrace trampolines reachable from %ps\\n\"",
            "(void *)ip"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_ftrace_tramp",
          "args": [
            "ip"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "find_ftrace_tramp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "291-308",
          "snippet": "static unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define\tNUM_FTRACE_TRAMPS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_mcount_compiler_tramp",
          "args": [
            "tramp"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "setup_mcount_compiler_tramp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "329-394",
          "snippet": "static int setup_mcount_compiler_tramp(unsigned long tramp)\n{\n\tint i;\n\tstruct ppc_inst op;\n\tunsigned long ptr;\n\tstruct ppc_inst instr;\n\tstatic unsigned long ftrace_plt_tramps[NUM_FTRACE_TRAMPS];\n\n\t/* Is this a known long jump tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_tramps[i] == tramp)\n\t\t\treturn 0;\n\n\t/* Is this a known plt tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_plt_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_plt_tramps[i] == tramp)\n\t\t\treturn -1;\n\n\t/* New trampoline -- read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)tramp)) {\n\t\tpr_debug(\"Fetching opcode failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Is this a 24 bit branch? */\n\tif (!is_b_op(op)) {\n\t\tpr_debug(\"Trampoline is not a long branch tramp.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* lets find where the pointer goes */\n\tptr = find_bl_target(tramp, op);\n\n\tif (ptr != ppc_global_function_entry((void *)_mcount)) {\n\t\tpr_debug(\"Trampoline target %p is not _mcount\\n\", (void *)ptr);\n\t\treturn -1;\n\t}\n\n\t/* Let's re-write the tramp to go to ftrace_[regs_]caller */\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tptr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tptr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tif (create_branch(&instr, (void *)tramp, ptr, 0)) {\n\t\tpr_debug(\"%ps is not reachable from existing mcount tramp\\n\",\n\t\t\t\t(void *)ptr);\n\t\treturn -1;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)tramp, ptr, 0)) {\n\t\tpr_debug(\"REL24 out of range!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (add_ftrace_tramp(tramp)) {\n\t\tpr_debug(\"No tramp locations left\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define\tNUM_FTRACE_TRAMPS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic int setup_mcount_compiler_tramp(unsigned long tramp)\n{\n\tint i;\n\tstruct ppc_inst op;\n\tunsigned long ptr;\n\tstruct ppc_inst instr;\n\tstatic unsigned long ftrace_plt_tramps[NUM_FTRACE_TRAMPS];\n\n\t/* Is this a known long jump tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_tramps[i] == tramp)\n\t\t\treturn 0;\n\n\t/* Is this a known plt tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_plt_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_plt_tramps[i] == tramp)\n\t\t\treturn -1;\n\n\t/* New trampoline -- read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)tramp)) {\n\t\tpr_debug(\"Fetching opcode failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Is this a 24 bit branch? */\n\tif (!is_b_op(op)) {\n\t\tpr_debug(\"Trampoline is not a long branch tramp.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* lets find where the pointer goes */\n\tptr = find_bl_target(tramp, op);\n\n\tif (ptr != ppc_global_function_entry((void *)_mcount)) {\n\t\tpr_debug(\"Trampoline target %p is not _mcount\\n\", (void *)ptr);\n\t\treturn -1;\n\t}\n\n\t/* Let's re-write the tramp to go to ftrace_[regs_]caller */\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tptr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tptr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tif (create_branch(&instr, (void *)tramp, ptr, 0)) {\n\t\tpr_debug(\"%ps is not reachable from existing mcount tramp\\n\",\n\t\t\t\t(void *)ptr);\n\t\treturn -1;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)tramp, ptr, 0)) {\n\t\tpr_debug(\"REL24 out of range!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (add_ftrace_tramp(tramp)) {\n\t\tpr_debug(\"No tramp locations left\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %lx\"",
            "ip",
            "tramp"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "110-120",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %s\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "100-103",
          "snippet": "static int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Fetching opcode failed.\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)ip"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int __ftrace_make_nop_kernel(struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long tramp, ip = rec->ip;\n\tstruct ppc_inst op;\n\n\t/* Read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Let's find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (setup_mcount_compiler_tramp(tramp)) {\n\t\t/* Are other trampolines reachable? */\n\t\tif (!find_ftrace_tramp(ip)) {\n\t\t\tpr_err(\"No ftrace trampolines reachable from %ps\\n\",\n\t\t\t\t\t(void *)ip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (patch_instruction((struct ppc_inst *)ip, ppc_inst(PPC_INST_NOP))) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_mcount_compiler_tramp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "329-394",
    "snippet": "static int setup_mcount_compiler_tramp(unsigned long tramp)\n{\n\tint i;\n\tstruct ppc_inst op;\n\tunsigned long ptr;\n\tstruct ppc_inst instr;\n\tstatic unsigned long ftrace_plt_tramps[NUM_FTRACE_TRAMPS];\n\n\t/* Is this a known long jump tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_tramps[i] == tramp)\n\t\t\treturn 0;\n\n\t/* Is this a known plt tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_plt_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_plt_tramps[i] == tramp)\n\t\t\treturn -1;\n\n\t/* New trampoline -- read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)tramp)) {\n\t\tpr_debug(\"Fetching opcode failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Is this a 24 bit branch? */\n\tif (!is_b_op(op)) {\n\t\tpr_debug(\"Trampoline is not a long branch tramp.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* lets find where the pointer goes */\n\tptr = find_bl_target(tramp, op);\n\n\tif (ptr != ppc_global_function_entry((void *)_mcount)) {\n\t\tpr_debug(\"Trampoline target %p is not _mcount\\n\", (void *)ptr);\n\t\treturn -1;\n\t}\n\n\t/* Let's re-write the tramp to go to ftrace_[regs_]caller */\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tptr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tptr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tif (create_branch(&instr, (void *)tramp, ptr, 0)) {\n\t\tpr_debug(\"%ps is not reachable from existing mcount tramp\\n\",\n\t\t\t\t(void *)ptr);\n\t\treturn -1;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)tramp, ptr, 0)) {\n\t\tpr_debug(\"REL24 out of range!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (add_ftrace_tramp(tramp)) {\n\t\tpr_debug(\"No tramp locations left\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define\tNUM_FTRACE_TRAMPS\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"No tramp locations left\\n\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_ftrace_tramp",
          "args": [
            "tramp"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "add_ftrace_tramp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "310-321",
          "snippet": "static int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define\tNUM_FTRACE_TRAMPS\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"REL24 out of range!\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch",
          "args": [
            "(struct ppc_inst *)tramp",
            "ptr",
            "0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%ps is not reachable from existing mcount tramp\\n\"",
            "(void *)ptr"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&instr",
            "(void *)tramp",
            "ptr",
            "0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_caller"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)ftrace_regs_caller"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Trampoline target %p is not _mcount\\n\"",
            "(void *)ptr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)_mcount"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "tramp",
            "op"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "110-120",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Trampoline is not a long branch tramp.\\n\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_b_op",
          "args": [
            "op"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "is_b_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "105-108",
          "snippet": "static int is_b_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000000;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_b_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Fetching opcode failed.\\n\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)tramp"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic int setup_mcount_compiler_tramp(unsigned long tramp)\n{\n\tint i;\n\tstruct ppc_inst op;\n\tunsigned long ptr;\n\tstruct ppc_inst instr;\n\tstatic unsigned long ftrace_plt_tramps[NUM_FTRACE_TRAMPS];\n\n\t/* Is this a known long jump tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_tramps[i] == tramp)\n\t\t\treturn 0;\n\n\t/* Is this a known plt tramp? */\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_plt_tramps[i])\n\t\t\tbreak;\n\t\telse if (ftrace_plt_tramps[i] == tramp)\n\t\t\treturn -1;\n\n\t/* New trampoline -- read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)tramp)) {\n\t\tpr_debug(\"Fetching opcode failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Is this a 24 bit branch? */\n\tif (!is_b_op(op)) {\n\t\tpr_debug(\"Trampoline is not a long branch tramp.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* lets find where the pointer goes */\n\tptr = find_bl_target(tramp, op);\n\n\tif (ptr != ppc_global_function_entry((void *)_mcount)) {\n\t\tpr_debug(\"Trampoline target %p is not _mcount\\n\", (void *)ptr);\n\t\treturn -1;\n\t}\n\n\t/* Let's re-write the tramp to go to ftrace_[regs_]caller */\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tptr = ppc_global_function_entry((void *)ftrace_regs_caller);\n#else\n\tptr = ppc_global_function_entry((void *)ftrace_caller);\n#endif\n\tif (create_branch(&instr, (void *)tramp, ptr, 0)) {\n\t\tpr_debug(\"%ps is not reachable from existing mcount tramp\\n\",\n\t\t\t\t(void *)ptr);\n\t\treturn -1;\n\t}\n\n\tif (patch_branch((struct ppc_inst *)tramp, ptr, 0)) {\n\t\tpr_debug(\"REL24 out of range!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (add_ftrace_tramp(tramp)) {\n\t\tpr_debug(\"No tramp locations left\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_ftrace_tramp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "310-321",
    "snippet": "static int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define\tNUM_FTRACE_TRAMPS\t8"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic int add_ftrace_tramp(unsigned long tramp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_FTRACE_TRAMPS; i++)\n\t\tif (!ftrace_tramps[i]) {\n\t\t\tftrace_tramps[i] = tramp;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "find_ftrace_tramp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "291-308",
    "snippet": "static unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [
      "#define\tNUM_FTRACE_TRAMPS\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&instr",
            "(void *)ip",
            "ftrace_tramps[i]",
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\n#define\tNUM_FTRACE_TRAMPS\t8\n\nstatic unsigned long find_ftrace_tramp(unsigned long ip)\n{\n\tint i;\n\tstruct ppc_inst instr;\n\n\t/*\n\t * We have the compiler generated long_branch tramps at the end\n\t * and we prefer those\n\t */\n\tfor (i = NUM_FTRACE_TRAMPS - 1; i >= 0; i--)\n\t\tif (!ftrace_tramps[i])\n\t\t\tcontinue;\n\t\telse if (create_branch(&instr, (void *)ip,\n\t\t\t\t       ftrace_tramps[i], 0) == 0)\n\t\t\treturn ftrace_tramps[i];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "220-287",
    "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (copy_from_kernel_nofault(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (copy_from_kernel_nofault(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = ppc_inst(PPC_INST_NOP);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)ip",
            "op"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Trampoline location %08lx does not match addr\\n\"",
            "tramp"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\" %lx \"",
            "tramp"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not a trampoline\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\" %08x %08x \"",
            "jmp[0]",
            "jmp[1]"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to read %lx\\n\"",
            "tramp"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "jmp",
            "(void *)tramp",
            "sizeof(jmp)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %lx\"",
            "ip",
            "tramp"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "110-120",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %s\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "100-103",
          "snippet": "static int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&op",
            "(void *)ip",
            "MCOUNT_INSN_SIZE"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\tunsigned int jmp[4];\n\tunsigned long ip = rec->ip;\n\tunsigned long tramp;\n\n\tif (copy_from_kernel_nofault(&op, (void *)ip, MCOUNT_INSN_SIZE))\n\t\treturn -EFAULT;\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\t/*\n\t * On PPC32 the trampoline looks like:\n\t *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha\n\t *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l\n\t *  0x7d, 0x89, 0x03, 0xa6  mtctr r12\n\t *  0x4e, 0x80, 0x04, 0x20  bctr\n\t */\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\t/* Find where the trampoline jumps to */\n\tif (copy_from_kernel_nofault(jmp, (void *)tramp, sizeof(jmp))) {\n\t\tpr_err(\"Failed to read %lx\\n\", tramp);\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\" %08x %08x \", jmp[0], jmp[1]);\n\n\t/* verify that this is what we expect it to be */\n\tif (((jmp[0] & 0xffff0000) != 0x3d800000) ||\n\t    ((jmp[1] & 0xffff0000) != 0x398c0000) ||\n\t    (jmp[2] != 0x7d8903a6) ||\n\t    (jmp[3] != 0x4e800420)) {\n\t\tpr_err(\"Not a trampoline\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttramp = (jmp[1] & 0xffff) |\n\t\t((jmp[0] & 0xffff) << 16);\n\tif (tramp & 0x8000)\n\t\ttramp -= 0x10000;\n\n\tpr_devel(\" %lx \", tramp);\n\n\tif (tramp != addr) {\n\t\tpr_err(\"Trampoline location %08lx does not match addr\\n\",\n\t\t       tramp);\n\t\treturn -EINVAL;\n\t}\n\n\top = ppc_inst(PPC_INST_NOP);\n\n\tif (patch_instruction((struct ppc_inst *)ip, op))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ftrace_make_nop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "124-217",
    "snippet": "static int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long entry, ptr, tramp;\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst op, pop;\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_MPROFILE_KERNEL\n\t/* When using -mkernel_profile there is no load to jump over */\n\tpop = ppc_inst(PPC_INST_NOP);\n\n\tif (probe_kernel_read_inst(&op, (void *)(ip - 4))) {\n\t\tpr_err(\"Fetching instruction at %lx failed.\\n\", ip - 4);\n\t\treturn -EFAULT;\n\t}\n\n\t/* We expect either a mflr r0, or a std r0, LRSAVE(r1) */\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_MFLR)) &&\n\t    !ppc_inst_equal(op, ppc_inst(PPC_INST_STD_LR))) {\n\t\tpr_err(\"Unexpected instruction %s around bl _mcount\\n\",\n\t\t       ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n#else\n\t/*\n\t * Our original call site looks like:\n\t *\n\t * bl <tramp>\n\t * ld r2,XX(r1)\n\t *\n\t * Milton Miller pointed out that we can not simply nop the branch.\n\t * If a task was preempted when calling a trace function, the nops\n\t * will remove the way to restore the TOC in r2 and the r2 TOC will\n\t * get corrupted.\n\t *\n\t * Use a b +8 to jump over the load.\n\t */\n\n\tpop = ppc_inst(PPC_INST_BRANCH | 8);\t/* b +8 */\n\n\t/*\n\t * Check what is in the next instruction. We can see ld r2,40(r1), but\n\t * on first pass after boot we will see mflr r0.\n\t */\n\tif (probe_kernel_read_inst(&op, (void *)(ip + 4))) {\n\t\tpr_err(\"Fetching op failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op,  ppc_inst(PPC_INST_LD_TOC))) {\n\t\tpr_err(\"Expected %08x found %s\\n\", PPC_INST_LD_TOC, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n#endif /* CONFIG_MPROFILE_KERNEL */\n\n\tif (patch_instruction((struct ppc_inst *)ip, pop)) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Patching NOP failed.\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)ip",
            "pop"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Expected %08x found %s\\n\"",
            "PPC_INST_LD_TOC",
            "ppc_inst_as_str(op)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op",
            "ppc_inst(PPC_INST_LD_TOC)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_LD_TOC"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Fetching op failed.\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)(ip + 4)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_BRANCH | 8"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unexpected instruction %s around bl _mcount\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op",
            "ppc_inst(PPC_INST_STD_LR)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_STD_LR"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "op",
            "ppc_inst(PPC_INST_MFLR)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_MFLR"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Fetching instruction at %lx failed.\\n\"",
            "ip - 4"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)(ip - 4)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"addr %lx does not match expected %lx\\n\"",
            "ptr",
            "entry"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"trampoline target %lx\"",
            "ptr"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to get trampoline target\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_trampoline_target",
          "args": [
            "mod",
            "tramp",
            "&ptr"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "module_trampoline_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/module_64.c",
          "lines": "745-779",
          "snippet": "int module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STUB_MAGIC 0x73747562 /* stub */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define STUB_MAGIC 0x73747562 /* stub */\n\nint module_trampoline_target(struct module *mod, unsigned long addr,\n\t\t\t     unsigned long *target)\n{\n\tstruct ppc64_stub_entry *stub;\n\tfunc_desc_t funcdata;\n\tu32 magic;\n\n\tif (!within_module_core(addr, mod)) {\n\t\tpr_err(\"%s: stub %lx not in module %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tstub = (struct ppc64_stub_entry *)addr;\n\n\tif (copy_from_kernel_nofault(&magic, &stub->magic,\n\t\t\tsizeof(magic))) {\n\t\tpr_err(\"%s: fault reading magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (magic != STUB_MAGIC) {\n\t\tpr_err(\"%s: bad magic for stub %lx for %s\\n\", __func__, addr, mod->name);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_from_kernel_nofault(&funcdata, &stub->funcdata,\n\t\t\tsizeof(funcdata))) {\n\t\tpr_err(\"%s: fault reading funcdata for stub %lx for %s\\n\", __func__, addr, mod->name);\n                return -EFAULT;\n\t}\n\n\t*target = stub_func_addr(funcdata);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_devel",
          "args": [
            "\"ip:%lx jumps to %lx\"",
            "ip",
            "tramp"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_bl_target",
          "args": [
            "ip",
            "op"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "find_bl_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "110-120",
          "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not expected bl: opcode is %s\\n\"",
            "ppc_inst_as_str(op)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "op"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bl_op",
          "args": [
            "op"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "is_bl_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
          "lines": "100-103",
          "snippet": "static int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/syscall.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Fetching opcode failed.\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&op",
            "(void *)ip"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\n__ftrace_make_nop(struct module *mod,\n\t\t  struct dyn_ftrace *rec, unsigned long addr)\n{\n\tunsigned long entry, ptr, tramp;\n\tunsigned long ip = rec->ip;\n\tstruct ppc_inst op, pop;\n\n\t/* read where this goes */\n\tif (probe_kernel_read_inst(&op, (void *)ip)) {\n\t\tpr_err(\"Fetching opcode failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Make sure that that this is still a 24bit jump */\n\tif (!is_bl_op(op)) {\n\t\tpr_err(\"Not expected bl: opcode is %s\\n\", ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n\n\t/* lets find where the pointer goes */\n\ttramp = find_bl_target(ip, op);\n\n\tpr_devel(\"ip:%lx jumps to %lx\", ip, tramp);\n\n\tif (module_trampoline_target(mod, tramp, &ptr)) {\n\t\tpr_err(\"Failed to get trampoline target\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tpr_devel(\"trampoline target %lx\", ptr);\n\n\tentry = ppc_global_function_entry((void *)addr);\n\t/* This should match what was called */\n\tif (ptr != entry) {\n\t\tpr_err(\"addr %lx does not match expected %lx\\n\", ptr, entry);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_MPROFILE_KERNEL\n\t/* When using -mkernel_profile there is no load to jump over */\n\tpop = ppc_inst(PPC_INST_NOP);\n\n\tif (probe_kernel_read_inst(&op, (void *)(ip - 4))) {\n\t\tpr_err(\"Fetching instruction at %lx failed.\\n\", ip - 4);\n\t\treturn -EFAULT;\n\t}\n\n\t/* We expect either a mflr r0, or a std r0, LRSAVE(r1) */\n\tif (!ppc_inst_equal(op, ppc_inst(PPC_INST_MFLR)) &&\n\t    !ppc_inst_equal(op, ppc_inst(PPC_INST_STD_LR))) {\n\t\tpr_err(\"Unexpected instruction %s around bl _mcount\\n\",\n\t\t       ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n#else\n\t/*\n\t * Our original call site looks like:\n\t *\n\t * bl <tramp>\n\t * ld r2,XX(r1)\n\t *\n\t * Milton Miller pointed out that we can not simply nop the branch.\n\t * If a task was preempted when calling a trace function, the nops\n\t * will remove the way to restore the TOC in r2 and the r2 TOC will\n\t * get corrupted.\n\t *\n\t * Use a b +8 to jump over the load.\n\t */\n\n\tpop = ppc_inst(PPC_INST_BRANCH | 8);\t/* b +8 */\n\n\t/*\n\t * Check what is in the next instruction. We can see ld r2,40(r1), but\n\t * on first pass after boot we will see mflr r0.\n\t */\n\tif (probe_kernel_read_inst(&op, (void *)(ip + 4))) {\n\t\tpr_err(\"Fetching op failed.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!ppc_inst_equal(op,  ppc_inst(PPC_INST_LD_TOC))) {\n\t\tpr_err(\"Expected %08x found %s\\n\", PPC_INST_LD_TOC, ppc_inst_as_str(op));\n\t\treturn -EINVAL;\n\t}\n#endif /* CONFIG_MPROFILE_KERNEL */\n\n\tif (patch_instruction((struct ppc_inst *)ip, pop)) {\n\t\tpr_err(\"Patching NOP failed.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_bl_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "110-120",
    "snippet": "static unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "op"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic unsigned long find_bl_target(unsigned long ip, struct ppc_inst op)\n{\n\tint offset;\n\n\toffset = (ppc_inst_val(op) & 0x03fffffc);\n\t/* make it signed */\n\tif (offset & 0x02000000)\n\t\toffset |= 0xfe000000;\n\n\treturn ip + (long)offset;\n}"
  },
  {
    "function_name": "is_b_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "105-108",
    "snippet": "static int is_b_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000000;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "op"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_b_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000000;\n}"
  },
  {
    "function_name": "is_bl_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "100-103",
    "snippet": "static int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "op"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int is_bl_op(struct ppc_inst op)\n{\n\treturn (ppc_inst_val(op) & 0xfc000003) == 0x48000001;\n}"
  },
  {
    "function_name": "test_24bit_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "91-98",
    "snippet": "static int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&op",
            "(struct ppc_inst *)ip",
            "addr",
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int test_24bit_addr(unsigned long ip, unsigned long addr)\n{\n\tstruct ppc_inst op;\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* use the create_branch to verify that this offset can be branched */\n\treturn create_branch(&op, (struct ppc_inst *)ip, addr, 0) == 0;\n}"
  },
  {
    "function_name": "ftrace_modify_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "57-86",
    "snippet": "static int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)ip",
            "new"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%p: replaced (%s) != old (%s)\"",
            "(void *)ip",
            "ppc_inst_as_str(replaced)",
            "ppc_inst_as_str(old)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "old"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "replaced"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "replaced",
            "old"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read_inst",
          "args": [
            "&replaced",
            "(void *)ip"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic int\nftrace_modify_code(unsigned long ip, struct ppc_inst old, struct ppc_inst new)\n{\n\tstruct ppc_inst replaced;\n\n\t/*\n\t * Note:\n\t * We are paranoid about modifying text, as if a bug was to happen, it\n\t * could cause us to read or write to someplace that could cause harm.\n\t * Carefully read and modify the code with probe_kernel_*(), and make\n\t * sure what we read is what we expected it to be before modifying it.\n\t */\n\n\t/* read the text we want to modify */\n\tif (probe_kernel_read_inst(&replaced, (void *)ip))\n\t\treturn -EFAULT;\n\n\t/* Make sure it is what we expect it to be */\n\tif (!ppc_inst_equal(replaced, old)) {\n\t\tpr_err(\"%p: replaced (%s) != old (%s)\",\n\t\t(void *)ip, ppc_inst_as_str(replaced), ppc_inst_as_str(old));\n\t\treturn -EINVAL;\n\t}\n\n\t/* replace the text with the new text */\n\tif (patch_instruction((struct ppc_inst *)ip, new))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_call_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/trace/ftrace.c",
    "lines": "44-55",
    "snippet": "static struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/syscall.h>",
      "#include <asm/ftrace.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_branch",
          "args": [
            "&op",
            "(struct ppc_inst *)ip",
            "addr",
            "link ? 1 : 0"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "(void *)addr"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/syscall.h>\n#include <asm/ftrace.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/asm-prototypes.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n\nstatic struct ppc_inst\nftrace_call_replace(unsigned long ip, unsigned long addr, int link)\n{\n\tstruct ppc_inst op;\n\n\taddr = ppc_function_entry((void *)addr);\n\n\t/* if (link) set op to 'bl' else 'b' */\n\tcreate_branch(&op, (struct ppc_inst *)ip, addr, link ? 1 : 0);\n\n\treturn op;\n}"
  }
]