[
  {
    "function_name": "pt_regs_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "381-481",
    "snippet": "void __init pt_regs_check(void)\n{\n\tBUILD_BUG_ON(offsetof(struct pt_regs, gpr) !=\n\t\t     offsetof(struct user_pt_regs, gpr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, nip) !=\n\t\t     offsetof(struct user_pt_regs, nip));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct user_pt_regs, orig_gpr3));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, ctr) !=\n\t\t     offsetof(struct user_pt_regs, ctr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, link) !=\n\t\t     offsetof(struct user_pt_regs, link));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, xer) !=\n\t\t     offsetof(struct user_pt_regs, xer));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, ccr) !=\n\t\t     offsetof(struct user_pt_regs, ccr));\n#ifdef __powerpc64__\n\tBUILD_BUG_ON(offsetof(struct pt_regs, softe) !=\n\t\t     offsetof(struct user_pt_regs, softe));\n#else\n\tBUILD_BUG_ON(offsetof(struct pt_regs, mq) !=\n\t\t     offsetof(struct user_pt_regs, mq));\n#endif\n\tBUILD_BUG_ON(offsetof(struct pt_regs, trap) !=\n\t\t     offsetof(struct user_pt_regs, trap));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, dar) !=\n\t\t     offsetof(struct user_pt_regs, dar));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, dsisr) !=\n\t\t     offsetof(struct user_pt_regs, dsisr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, result) !=\n\t\t     offsetof(struct user_pt_regs, result));\n\n\tBUILD_BUG_ON(sizeof(struct user_pt_regs) > sizeof(struct pt_regs));\n\n\t// Now check that the pt_regs offsets match the uapi #defines\n\t#define CHECK_REG(_pt, _reg) \\\n\t\tBUILD_BUG_ON(_pt != (offsetof(struct user_pt_regs, _reg) / \\\n\t\t\t\t     sizeof(unsigned long)));\n\n\tCHECK_REG(PT_R0,  gpr[0]);\n\tCHECK_REG(PT_R1,  gpr[1]);\n\tCHECK_REG(PT_R2,  gpr[2]);\n\tCHECK_REG(PT_R3,  gpr[3]);\n\tCHECK_REG(PT_R4,  gpr[4]);\n\tCHECK_REG(PT_R5,  gpr[5]);\n\tCHECK_REG(PT_R6,  gpr[6]);\n\tCHECK_REG(PT_R7,  gpr[7]);\n\tCHECK_REG(PT_R8,  gpr[8]);\n\tCHECK_REG(PT_R9,  gpr[9]);\n\tCHECK_REG(PT_R10, gpr[10]);\n\tCHECK_REG(PT_R11, gpr[11]);\n\tCHECK_REG(PT_R12, gpr[12]);\n\tCHECK_REG(PT_R13, gpr[13]);\n\tCHECK_REG(PT_R14, gpr[14]);\n\tCHECK_REG(PT_R15, gpr[15]);\n\tCHECK_REG(PT_R16, gpr[16]);\n\tCHECK_REG(PT_R17, gpr[17]);\n\tCHECK_REG(PT_R18, gpr[18]);\n\tCHECK_REG(PT_R19, gpr[19]);\n\tCHECK_REG(PT_R20, gpr[20]);\n\tCHECK_REG(PT_R21, gpr[21]);\n\tCHECK_REG(PT_R22, gpr[22]);\n\tCHECK_REG(PT_R23, gpr[23]);\n\tCHECK_REG(PT_R24, gpr[24]);\n\tCHECK_REG(PT_R25, gpr[25]);\n\tCHECK_REG(PT_R26, gpr[26]);\n\tCHECK_REG(PT_R27, gpr[27]);\n\tCHECK_REG(PT_R28, gpr[28]);\n\tCHECK_REG(PT_R29, gpr[29]);\n\tCHECK_REG(PT_R30, gpr[30]);\n\tCHECK_REG(PT_R31, gpr[31]);\n\tCHECK_REG(PT_NIP, nip);\n\tCHECK_REG(PT_MSR, msr);\n\tCHECK_REG(PT_ORIG_R3, orig_gpr3);\n\tCHECK_REG(PT_CTR, ctr);\n\tCHECK_REG(PT_LNK, link);\n\tCHECK_REG(PT_XER, xer);\n\tCHECK_REG(PT_CCR, ccr);\n#ifdef CONFIG_PPC64\n\tCHECK_REG(PT_SOFTE, softe);\n#else\n\tCHECK_REG(PT_MQ, mq);\n#endif\n\tCHECK_REG(PT_TRAP, trap);\n\tCHECK_REG(PT_DAR, dar);\n\tCHECK_REG(PT_DSISR, dsisr);\n\tCHECK_REG(PT_RESULT, result);\n\t#undef CHECK_REG\n\n\tBUILD_BUG_ON(PT_REGS_COUNT != sizeof(struct user_pt_regs) / sizeof(unsigned long));\n\n\t/*\n\t * PT_DSCR isn't a real reg, but it's important that it doesn't overlap the\n\t * real registers.\n\t */\n\tBUILD_BUG_ON(PT_DSCR < sizeof(struct user_pt_regs) / sizeof(unsigned long));\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __init pt_regs_check(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PT_DSCR < sizeof(struct user_pt_regs) / sizeof(unsigned long)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PT_REGS_COUNT != sizeof(struct user_pt_regs) / sizeof(unsigned long)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_RESULT",
            "result"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_DSISR",
            "dsisr"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_DAR",
            "dar"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_TRAP",
            "trap"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_MQ",
            "mq"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_SOFTE",
            "softe"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_CCR",
            "ccr"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_XER",
            "xer"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_LNK",
            "link"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_CTR",
            "ctr"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_ORIG_R3",
            "orig_gpr3"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_MSR",
            "msr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_NIP",
            "nip"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R31",
            "gpr[31]"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R30",
            "gpr[30]"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R29",
            "gpr[29]"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R28",
            "gpr[28]"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R27",
            "gpr[27]"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R26",
            "gpr[26]"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R25",
            "gpr[25]"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R24",
            "gpr[24]"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R23",
            "gpr[23]"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R22",
            "gpr[22]"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R21",
            "gpr[21]"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R20",
            "gpr[20]"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R19",
            "gpr[19]"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R18",
            "gpr[18]"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R17",
            "gpr[17]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R16",
            "gpr[16]"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R15",
            "gpr[15]"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R14",
            "gpr[14]"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R13",
            "gpr[13]"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R12",
            "gpr[12]"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R11",
            "gpr[11]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R10",
            "gpr[10]"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R9",
            "gpr[9]"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R8",
            "gpr[8]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R7",
            "gpr[7]"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R6",
            "gpr[6]"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R5",
            "gpr[5]"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R4",
            "gpr[4]"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R3",
            "gpr[3]"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R2",
            "gpr[2]"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R1",
            "gpr[1]"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_REG",
          "args": [
            "PT_R0",
            "gpr[0]"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct user_pt_regs) > sizeof(struct pt_regs)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, result) !=\n\t\t     offsetof(struct user_pt_regs, result)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, dsisr) !=\n\t\t     offsetof(struct user_pt_regs, dsisr)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, dar) !=\n\t\t     offsetof(struct user_pt_regs, dar)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, trap) !=\n\t\t     offsetof(struct user_pt_regs, trap)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, mq) !=\n\t\t     offsetof(struct user_pt_regs, mq)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, softe) !=\n\t\t     offsetof(struct user_pt_regs, softe)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, ccr) !=\n\t\t     offsetof(struct user_pt_regs, ccr)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, xer) !=\n\t\t     offsetof(struct user_pt_regs, xer)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, link) !=\n\t\t     offsetof(struct user_pt_regs, link)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, ctr) !=\n\t\t     offsetof(struct user_pt_regs, ctr)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct user_pt_regs, orig_gpr3)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, nip) !=\n\t\t     offsetof(struct user_pt_regs, nip)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, gpr) !=\n\t\t     offsetof(struct user_pt_regs, gpr)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nvoid __init pt_regs_check(void);\n\nvoid __init pt_regs_check(void)\n{\n\tBUILD_BUG_ON(offsetof(struct pt_regs, gpr) !=\n\t\t     offsetof(struct user_pt_regs, gpr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, nip) !=\n\t\t     offsetof(struct user_pt_regs, nip));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, msr) !=\n\t\t     offsetof(struct user_pt_regs, msr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct user_pt_regs, orig_gpr3));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, ctr) !=\n\t\t     offsetof(struct user_pt_regs, ctr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, link) !=\n\t\t     offsetof(struct user_pt_regs, link));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, xer) !=\n\t\t     offsetof(struct user_pt_regs, xer));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, ccr) !=\n\t\t     offsetof(struct user_pt_regs, ccr));\n#ifdef __powerpc64__\n\tBUILD_BUG_ON(offsetof(struct pt_regs, softe) !=\n\t\t     offsetof(struct user_pt_regs, softe));\n#else\n\tBUILD_BUG_ON(offsetof(struct pt_regs, mq) !=\n\t\t     offsetof(struct user_pt_regs, mq));\n#endif\n\tBUILD_BUG_ON(offsetof(struct pt_regs, trap) !=\n\t\t     offsetof(struct user_pt_regs, trap));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, dar) !=\n\t\t     offsetof(struct user_pt_regs, dar));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, dsisr) !=\n\t\t     offsetof(struct user_pt_regs, dsisr));\n\tBUILD_BUG_ON(offsetof(struct pt_regs, result) !=\n\t\t     offsetof(struct user_pt_regs, result));\n\n\tBUILD_BUG_ON(sizeof(struct user_pt_regs) > sizeof(struct pt_regs));\n\n\t// Now check that the pt_regs offsets match the uapi #defines\n\t#define CHECK_REG(_pt, _reg) \\\n\t\tBUILD_BUG_ON(_pt != (offsetof(struct user_pt_regs, _reg) / \\\n\t\t\t\t     sizeof(unsigned long)));\n\n\tCHECK_REG(PT_R0,  gpr[0]);\n\tCHECK_REG(PT_R1,  gpr[1]);\n\tCHECK_REG(PT_R2,  gpr[2]);\n\tCHECK_REG(PT_R3,  gpr[3]);\n\tCHECK_REG(PT_R4,  gpr[4]);\n\tCHECK_REG(PT_R5,  gpr[5]);\n\tCHECK_REG(PT_R6,  gpr[6]);\n\tCHECK_REG(PT_R7,  gpr[7]);\n\tCHECK_REG(PT_R8,  gpr[8]);\n\tCHECK_REG(PT_R9,  gpr[9]);\n\tCHECK_REG(PT_R10, gpr[10]);\n\tCHECK_REG(PT_R11, gpr[11]);\n\tCHECK_REG(PT_R12, gpr[12]);\n\tCHECK_REG(PT_R13, gpr[13]);\n\tCHECK_REG(PT_R14, gpr[14]);\n\tCHECK_REG(PT_R15, gpr[15]);\n\tCHECK_REG(PT_R16, gpr[16]);\n\tCHECK_REG(PT_R17, gpr[17]);\n\tCHECK_REG(PT_R18, gpr[18]);\n\tCHECK_REG(PT_R19, gpr[19]);\n\tCHECK_REG(PT_R20, gpr[20]);\n\tCHECK_REG(PT_R21, gpr[21]);\n\tCHECK_REG(PT_R22, gpr[22]);\n\tCHECK_REG(PT_R23, gpr[23]);\n\tCHECK_REG(PT_R24, gpr[24]);\n\tCHECK_REG(PT_R25, gpr[25]);\n\tCHECK_REG(PT_R26, gpr[26]);\n\tCHECK_REG(PT_R27, gpr[27]);\n\tCHECK_REG(PT_R28, gpr[28]);\n\tCHECK_REG(PT_R29, gpr[29]);\n\tCHECK_REG(PT_R30, gpr[30]);\n\tCHECK_REG(PT_R31, gpr[31]);\n\tCHECK_REG(PT_NIP, nip);\n\tCHECK_REG(PT_MSR, msr);\n\tCHECK_REG(PT_ORIG_R3, orig_gpr3);\n\tCHECK_REG(PT_CTR, ctr);\n\tCHECK_REG(PT_LNK, link);\n\tCHECK_REG(PT_XER, xer);\n\tCHECK_REG(PT_CCR, ccr);\n#ifdef CONFIG_PPC64\n\tCHECK_REG(PT_SOFTE, softe);\n#else\n\tCHECK_REG(PT_MQ, mq);\n#endif\n\tCHECK_REG(PT_TRAP, trap);\n\tCHECK_REG(PT_DAR, dar);\n\tCHECK_REG(PT_DSISR, dsisr);\n\tCHECK_REG(PT_RESULT, result);\n\t#undef CHECK_REG\n\n\tBUILD_BUG_ON(PT_REGS_COUNT != sizeof(struct user_pt_regs) / sizeof(unsigned long));\n\n\t/*\n\t * PT_DSCR isn't a real reg, but it's important that it doesn't overlap the\n\t * real registers.\n\t */\n\tBUILD_BUG_ON(PT_DSCR < sizeof(struct user_pt_regs) / sizeof(unsigned long));\n}"
  },
  {
    "function_name": "do_syscall_trace_leave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "359-373",
    "snippet": "void do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_report_syscall_exit",
          "args": [
            "regs",
            "step"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACE"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sys_exit",
          "args": [
            "regs",
            "regs->result"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_thread_flag(TIF_SYSCALL_TRACEPOINT)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_syscall_exit",
          "args": [
            "regs"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}"
  },
  {
    "function_name": "do_syscall_trace_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "289-357",
    "snippet": "long do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tu32 flags;\n\n\tuser_exit();\n\n\tflags = READ_ONCE(current_thread_info()->flags) &\n\t\t(_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE);\n\n\tif (flags) {\n\t\tint rc = tracehook_report_syscall_entry(regs);\n\n\t\tif (unlikely(flags & _TIF_SYSCALL_EMU)) {\n\t\t\t/*\n\t\t\t * A nonzero return code from\n\t\t\t * tracehook_report_syscall_entry() tells us to prevent\n\t\t\t * the syscall execution, but we are not going to\n\t\t\t * execute it anyway.\n\t\t\t *\n\t\t\t * Returning -1 will skip the syscall execution. We want\n\t\t\t * to avoid clobbering any registers, so we don't goto\n\t\t\t * the skip label below.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * The tracer decided to abort the syscall. Note that\n\t\t\t * the tracer may also just change regs->gpr[0] to an\n\t\t\t * invalid syscall number, that is handled below on the\n\t\t\t * exit path.\n\t\t\t */\n\t\t\tgoto skip;\n\t\t}\n\t}\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_syscall_entry",
          "args": [
            "regs->gpr[0]",
            "regs->gpr[3] & 0xffffffff",
            "regs->gpr[4] & 0xffffffff",
            "regs->gpr[5] & 0xffffffff",
            "regs->gpr[6] & 0xffffffff"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_syscall_entry",
          "args": [
            "regs->gpr[0]",
            "regs->gpr[3]",
            "regs->gpr[4]",
            "regs->gpr[5]",
            "regs->gpr[6]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sys_enter",
          "args": [
            "regs",
            "regs->gpr[0]"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_thread_flag(TIF_SYSCALL_TRACEPOINT)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_seccomp",
          "args": [
            "regs"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "do_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
          "lines": "267-267",
          "snippet": "static inline int do_seccomp(struct pt_regs *regs) { return 0; }",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <trace/events/syscalls.h>",
            "#include <asm/debug.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/audit.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & _TIF_SYSCALL_EMU"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_report_syscall_entry",
          "args": [
            "regs"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "current_thread_info()->flags"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nlong do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tu32 flags;\n\n\tuser_exit();\n\n\tflags = READ_ONCE(current_thread_info()->flags) &\n\t\t(_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE);\n\n\tif (flags) {\n\t\tint rc = tracehook_report_syscall_entry(regs);\n\n\t\tif (unlikely(flags & _TIF_SYSCALL_EMU)) {\n\t\t\t/*\n\t\t\t * A nonzero return code from\n\t\t\t * tracehook_report_syscall_entry() tells us to prevent\n\t\t\t * the syscall execution, but we are not going to\n\t\t\t * execute it anyway.\n\t\t\t *\n\t\t\t * Returning -1 will skip the syscall execution. We want\n\t\t\t * to avoid clobbering any registers, so we don't goto\n\t\t\t * the skip label below.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * The tracer decided to abort the syscall. Note that\n\t\t\t * the tracer may also just change regs->gpr[0] to an\n\t\t\t * invalid syscall number, that is handled below on the\n\t\t\t * exit path.\n\t\t\t */\n\t\t\tgoto skip;\n\t\t}\n\t}\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "267-267",
    "snippet": "static inline int do_seccomp(struct pt_regs *regs) { return 0; }",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "233-265",
    "snippet": "static int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing(NULL))\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what audit expects.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__secure_computing",
          "args": [
            "NULL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SECCOMP"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nstatic int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing(NULL))\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what audit expects.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "44-230",
    "snippet": "long arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tppc_gethwdinfo(&dbginfo);\n\n\t\tif (copy_to_user(datavp, &dbginfo,\n\t\t\t\t sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (copy_from_user(&bp_info, datavp,\n\t\t\t\t   sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\treturn ppc_set_hwdebug(child, &bp_info);\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG:\n\t\tret = ptrace_get_debugreg(child, addr, datalp);\n\t\tbreak;\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct user_pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct user_pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_request",
          "args": [
            "child",
            "request",
            "addr",
            "data"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_SPE",
            "0",
            "35 * sizeof(u32)",
            "datavp"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_SPE",
            "0",
            "35 * sizeof(u32)",
            "datavp"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VSX",
            "0",
            "32 * sizeof(double)",
            "datavp"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VSX",
            "0",
            "32 * sizeof(double)",
            "datavp"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VMX",
            "0",
            "(33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32))",
            "datavp"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VMX",
            "0",
            "(33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32))",
            "datavp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_FPR",
            "0",
            "sizeof(elf_fpregset_t)",
            "datavp"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_FPR",
            "0",
            "sizeof(elf_fpregset_t)",
            "datavp"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_GPR",
            "0",
            "sizeof(struct user_pt_regs)",
            "datavp"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_GPR",
            "0",
            "sizeof(struct user_pt_regs)",
            "datavp"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_set_debugreg",
          "args": [
            "child",
            "addr",
            "data"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_set_debugreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "83-137",
          "snippet": "int ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0 register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0 accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n\treturn 0;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_set_debugreg(struct task_struct *task, unsigned long addr, unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &task->thread;\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0 register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0 accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_get_debugreg",
          "args": [
            "child",
            "addr",
            "datalp"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_get_debugreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "74-81",
          "snippet": "int ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\treturn put_user(child->thread.debug.dac1, datalp);\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nint ptrace_get_debugreg(struct task_struct *child, unsigned long addr,\n\t\t\tunsigned long __user *datalp)\n{\n\t/* We only support one DABR and no IABRS at the moment */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\treturn put_user(child->thread.debug.dac1, datalp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_del_hwdebug",
          "args": [
            "child",
            "data"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_del_hwdebug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "475-492",
          "snippet": "long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_del_hwdebug(struct task_struct *child, long data)\n{\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_set_hwdebug",
          "args": [
            "child",
            "&bp_info"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_set_hwdebug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "439-473",
          "snippet": "long ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif (bp_info->trigger_type == 0 ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif (bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE ||\n\t\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nlong ppc_set_hwdebug(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif (bp_info->trigger_type == 0 ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif (bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE ||\n\t\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&bp_info",
            "datavp",
            "sizeof(struct ppc_hw_breakpoint)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "datavp",
            "&dbginfo",
            "sizeof(struct ppc_debug_info)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_gethwdinfo",
          "args": [
            "&dbginfo"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_gethwdinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "59-72",
          "snippet": "void ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\tdbginfo->num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\tdbginfo->num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\tdbginfo->data_bp_alignment = 4;\n\tdbginfo->sizeof_condition = 4;\n\tdbginfo->features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t    PPC_DEBUG_FEATURE_INSN_BP_MASK;\n\tif (IS_ENABLED(CONFIG_PPC_ADV_DEBUG_DAC_RANGE))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t     PPC_DEBUG_FEATURE_DATA_BP_MASK;\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid ppc_gethwdinfo(struct ppc_debug_info *dbginfo)\n{\n\tdbginfo->version = 1;\n\tdbginfo->num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\tdbginfo->num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\tdbginfo->num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\tdbginfo->data_bp_alignment = 4;\n\tdbginfo->sizeof_condition = 4;\n\tdbginfo->features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t    PPC_DEBUG_FEATURE_INSN_BP_MASK;\n\tif (IS_ENABLED(CONFIG_PPC_ADV_DEBUG_DAC_RANGE))\n\t\tdbginfo->features |= PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t     PPC_DEBUG_FEATURE_DATA_BP_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&child->thread.TS_FPR(fpidx)",
            "&data",
            "sizeof(long)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "child->thread.TS_FPR",
          "args": [
            "fpidx"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "child"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "180-205",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n\t\t\tgiveup_fpu(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_put_reg",
          "args": [
            "child",
            "index",
            "data"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_put_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "197-215",
          "snippet": "int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\tregno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\tregno = array_index_nospec(regno, PT_MAX_PUT_REG + 1);\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tmp",
            "datalp"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child->thread.TS_FPR",
          "args": [
            "fpidx"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_get_reg",
          "args": [
            "child",
            "(int) index",
            "&tmp"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-view.c",
          "lines": "159-192",
          "snippet": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tunsigned int regs_max;\n\n\tif (task->thread.regs == NULL || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\t/*\n\t * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is\n\t * no more used as a flag, lets force usr to alway see the softe value as 1\n\t * which means interrupts are not soft disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {\n\t\t*data = 1;\n\t\treturn  0;\n\t}\n\n\tregs_max = sizeof(struct user_pt_regs) / sizeof(unsigned long);\n\tif (regno < regs_max) {\n\t\tregno = array_index_nospec(regno, regs_max);\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include \"ptrace-decl.h\"",
            "#include <linux/pkeys.h>",
            "#include <linux/nospec.h>",
            "#include <linux/elf.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include \"ptrace-decl.h\"\n#include <linux/pkeys.h>\n#include <linux/nospec.h>\n#include <linux/elf.h>\n#include <linux/regset.h>\n\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tunsigned int regs_max;\n\n\tif (task->thread.regs == NULL || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\t/*\n\t * softe copies paca->irq_soft_mask variable state. Since irq_soft_mask is\n\t * no more used as a flag, lets force usr to alway see the softe value as 1\n\t * which means interrupts are not soft disabled.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC64) && regno == PT_SOFTE) {\n\t\t*data = 1;\n\t\treturn  0;\n\t}\n\n\tregs_max = sizeof(struct user_pt_regs) / sizeof(unsigned long);\n\tif (regno < regs_max) {\n\t\tregno = array_index_nospec(regno, regs_max);\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tppc_gethwdinfo(&dbginfo);\n\n\t\tif (copy_to_user(datavp, &dbginfo,\n\t\t\t\t sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (copy_from_user(&bp_info, datavp,\n\t\t\t\t   sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\treturn ppc_set_hwdebug(child, &bp_info);\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG:\n\t\tret = ptrace_get_debugreg(child, addr, datalp);\n\t\tbreak;\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct user_pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct user_pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace.c",
    "lines": "38-42",
    "snippet": "void ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}",
    "includes": [
      "#include \"ptrace-decl.h\"",
      "#include <trace/events/syscalls.h>",
      "#include <asm/debug.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/audit.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_disable_single_step",
          "args": [
            "child"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "user_disable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "32-57",
          "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC | DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC | DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <trace/events/syscalls.h>\n#include <asm/debug.h>\n#include <asm/asm-prototypes.h>\n#include <asm/switch_to.h>\n#include <linux/syscalls.h>\n#include <linux/context_tracking.h>\n#include <linux/audit.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}"
  }
]