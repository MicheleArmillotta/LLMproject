[
  {
    "function_name": "arch_trampoline_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "610-616",
    "snippet": "int arch_trampoline_kprobe(struct kprobe *p)\n{\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint arch_trampoline_kprobe(struct kprobe *p)\n{\n\tif (p->addr == (kprobe_opcode_t *)&kretprobe_trampoline)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_init_kprobes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "605-608",
    "snippet": "int __init arch_init_kprobes(void)\n{\n\treturn register_kprobe(&trampoline_p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kprobe trampoline_p = {\n\t.addr = (kprobe_opcode_t *) &kretprobe_trampoline,\n\t.pre_handler = trampoline_probe_handler\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&trampoline_p"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe trampoline_p = {\n\t.addr = (kprobe_opcode_t *) &kretprobe_trampoline,\n\t.pre_handler = trampoline_probe_handler\n};\n\nint __init arch_init_kprobes(void)\n{\n\treturn register_kprobe(&trampoline_p);\n}"
  },
  {
    "function_name": "arch_deref_entry_point",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "589-597",
    "snippet": "unsigned long arch_deref_entry_point(void *entry)\n{\n#ifdef PPC64_ELF_ABI_v1\n\tif (!kernel_text_address((unsigned long)entry))\n\t\treturn ppc_global_function_entry(entry);\n\telse\n#endif\n\t\treturn (unsigned long)entry;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_global_function_entry",
          "args": [
            "entry"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "(unsigned long)entry"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nunsigned long arch_deref_entry_point(void *entry)\n{\n#ifdef PPC64_ELF_ABI_v1\n\tif (!kernel_text_address((unsigned long)entry))\n\t\treturn ppc_global_function_entry(entry);\n\telse\n#endif\n\t\treturn (unsigned long)entry;\n}"
  },
  {
    "function_name": "kprobe_fault_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "524-586",
    "snippet": "int kprobe_fault_handler(struct pt_regs *regs, int trapnr)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\tconst struct exception_table_entry *entry;\n\n\tswitch(kcb->kprobe_status) {\n\tcase KPROBE_HIT_SS:\n\tcase KPROBE_REENTER:\n\t\t/*\n\t\t * We are here because the instruction being single\n\t\t * stepped caused a page fault. We reset the current\n\t\t * kprobe and the nip points back to the probe address\n\t\t * and allow the page fault handler to continue as a\n\t\t * normal page fault.\n\t\t */\n\t\tregs->nip = (unsigned long)cur->addr;\n\t\tregs->msr &= ~MSR_SINGLESTEP; /* Turn off 'trace' bits */\n\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\tif (kcb->kprobe_status == KPROBE_REENTER)\n\t\t\trestore_previous_kprobe(kcb);\n\t\telse\n\t\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\tbreak;\n\tcase KPROBE_HIT_ACTIVE:\n\tcase KPROBE_HIT_SSDONE:\n\t\t/*\n\t\t * We increment the nmissed count for accounting,\n\t\t * we can also use npre/npostfault count for accounting\n\t\t * these specific fault cases.\n\t\t */\n\t\tkprobes_inc_nmissed_count(cur);\n\n\t\t/*\n\t\t * We come here because instructions in the pre/post\n\t\t * handler caused the page_fault, this could happen\n\t\t * if handler tries to access user space by\n\t\t * copy_from_user(), get_user() etc. Let the\n\t\t * user-specified handler try to fix it first.\n\t\t */\n\t\tif (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * In case the user-specified fault handler returned\n\t\t * zero, try to fix up.\n\t\t */\n\t\tif ((entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * fixup_exception() could not handle it,\n\t\t * Let do_page_fault() fix it.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "extable_fixup",
          "args": [
            "entry"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_exception_tables",
          "args": [
            "regs->nip"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->fault_handler",
          "args": [
            "cur",
            "regs",
            "trapnr"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobes_inc_nmissed_count",
          "args": [
            "cur"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "restore_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "191-196",
          "snippet": "static nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_fault_handler(struct pt_regs *regs, int trapnr)\n{\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\tconst struct exception_table_entry *entry;\n\n\tswitch(kcb->kprobe_status) {\n\tcase KPROBE_HIT_SS:\n\tcase KPROBE_REENTER:\n\t\t/*\n\t\t * We are here because the instruction being single\n\t\t * stepped caused a page fault. We reset the current\n\t\t * kprobe and the nip points back to the probe address\n\t\t * and allow the page fault handler to continue as a\n\t\t * normal page fault.\n\t\t */\n\t\tregs->nip = (unsigned long)cur->addr;\n\t\tregs->msr &= ~MSR_SINGLESTEP; /* Turn off 'trace' bits */\n\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\tif (kcb->kprobe_status == KPROBE_REENTER)\n\t\t\trestore_previous_kprobe(kcb);\n\t\telse\n\t\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\tbreak;\n\tcase KPROBE_HIT_ACTIVE:\n\tcase KPROBE_HIT_SSDONE:\n\t\t/*\n\t\t * We increment the nmissed count for accounting,\n\t\t * we can also use npre/npostfault count for accounting\n\t\t * these specific fault cases.\n\t\t */\n\t\tkprobes_inc_nmissed_count(cur);\n\n\t\t/*\n\t\t * We come here because instructions in the pre/post\n\t\t * handler caused the page_fault, this could happen\n\t\t * if handler tries to access user space by\n\t\t * copy_from_user(), get_user() etc. Let the\n\t\t * user-specified handler try to fix it first.\n\t\t */\n\t\tif (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * In case the user-specified fault handler returned\n\t\t * zero, try to fix up.\n\t\t */\n\t\tif ((entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t\tregs->nip = extable_fixup(entry);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * fixup_exception() could not handle it,\n\t\t * Let do_page_fault() fix it.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_post_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "480-521",
    "snippet": "int kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "restore_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "191-196",
          "snippet": "static nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->post_handler",
          "args": [
            "cur",
            "regs",
            "0"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_len",
          "args": [
            "ppc_inst_read((struct ppc_inst *)cur->ainsn.insn)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)cur->ainsn.insn"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_post_handler(struct pt_regs *regs)\n{\n\tint len;\n\tstruct kprobe *cur = kprobe_running();\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\tif (!cur || user_mode(regs))\n\t\treturn 0;\n\n\tlen = ppc_inst_len(ppc_inst_read((struct ppc_inst *)cur->ainsn.insn));\n\t/* make sure we got here for instruction we have a kprobe on */\n\tif (((unsigned long)cur->ainsn.insn + len) != regs->nip)\n\t\treturn 0;\n\n\tif ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {\n\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\tcur->post_handler(cur, regs, 0);\n\t}\n\n\t/* Adjust nip to after the single-stepped instruction */\n\tregs->nip = (unsigned long)cur->addr + len;\n\tregs->msr |= kcb->kprobe_saved_msr;\n\n\t/*Restore back the original saved kprobes variables and continue. */\n\tif (kcb->kprobe_status == KPROBE_REENTER) {\n\t\trestore_previous_kprobe(kcb);\n\t\tgoto out;\n\t}\n\treset_current_kprobe();\nout:\n\tpreempt_enable_no_resched();\n\n\t/*\n\t * if somebody else is singlestepping across a probe point, msr\n\t * will have DE/SE set, in which case, continue the remaining processing\n\t * of do_debug, as if this is not a probe hit.\n\t */\n\tif (regs->msr & MSR_SINGLESTEP)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "trampoline_probe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "397-469",
    "snippet": "static int trampoline_probe_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long flags, orig_ret_address = 0;\n\tunsigned long trampoline_address =(unsigned long)&kretprobe_trampoline;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\tkretprobe_hash_lock(current, &head, &flags);\n\n\t/*\n\t * It is possible to have multiple instances associated with a given\n\t * task either because an multiple functions in the call path\n\t * have a return probe installed on them, and/or more than one return\n\t * return probe was registered for a target function.\n\t *\n\t * We can handle this because:\n\t *     - instances are always inserted at the head of the list\n\t *     - when multiple return probes are registered for the same\n\t *       function, the first instance's ret_addr will point to the\n\t *       real return address, and all the rest will point to\n\t *       kretprobe_trampoline\n\t */\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task != current)\n\t\t\t/* another task is sharing our hash bucket */\n\t\t\tcontinue;\n\n\t\tif (ri->rp && ri->rp->handler)\n\t\t\tri->rp->handler(ri, regs);\n\n\t\torig_ret_address = (unsigned long)ri->ret_addr;\n\t\trecycle_rp_inst(ri, &empty_rp);\n\n\t\tif (orig_ret_address != trampoline_address)\n\t\t\t/*\n\t\t\t * This is the real return address. Any other\n\t\t\t * instances associated with this task are for\n\t\t\t * other calls deeper on the call stack\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tkretprobe_assert(ri, orig_ret_address, trampoline_address);\n\n\t/*\n\t * We get here through one of two paths:\n\t * 1. by taking a trap -> kprobe_handler() -> here\n\t * 2. by optprobe branch -> optimized_callback() -> opt_pre_handler() -> here\n\t *\n\t * When going back through (1), we need regs->nip to be setup properly\n\t * as it is used to determine the return address from the trap.\n\t * For (2), since nip is not honoured with optprobes, we instead setup\n\t * the link register properly so that the subsequent 'blr' in\n\t * kretprobe_trampoline jumps back to the right instruction.\n\t *\n\t * For nip, we should set the address to the previous instruction since\n\t * we end up emulating it in kprobe_handler(), which increments the nip\n\t * again.\n\t */\n\tregs->nip = orig_ret_address - 4;\n\tregs->link = orig_ret_address;\n\n\tkretprobe_hash_unlock(current, &flags);\n\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&ri->hlist"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "&empty_rp",
            "hlist"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_hash_unlock",
          "args": [
            "current",
            "&flags"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_assert",
          "args": [
            "ri",
            "orig_ret_address",
            "trampoline_address"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recycle_rp_inst",
          "args": [
            "ri",
            "&empty_rp"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ri->rp->handler",
          "args": [
            "ri",
            "regs"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "ri",
            "tmp",
            "head",
            "hlist"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kretprobe_hash_lock",
          "args": [
            "current",
            "&head",
            "&flags"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&empty_rp"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int trampoline_probe_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct hlist_head *head, empty_rp;\n\tstruct hlist_node *tmp;\n\tunsigned long flags, orig_ret_address = 0;\n\tunsigned long trampoline_address =(unsigned long)&kretprobe_trampoline;\n\n\tINIT_HLIST_HEAD(&empty_rp);\n\tkretprobe_hash_lock(current, &head, &flags);\n\n\t/*\n\t * It is possible to have multiple instances associated with a given\n\t * task either because an multiple functions in the call path\n\t * have a return probe installed on them, and/or more than one return\n\t * return probe was registered for a target function.\n\t *\n\t * We can handle this because:\n\t *     - instances are always inserted at the head of the list\n\t *     - when multiple return probes are registered for the same\n\t *       function, the first instance's ret_addr will point to the\n\t *       real return address, and all the rest will point to\n\t *       kretprobe_trampoline\n\t */\n\thlist_for_each_entry_safe(ri, tmp, head, hlist) {\n\t\tif (ri->task != current)\n\t\t\t/* another task is sharing our hash bucket */\n\t\t\tcontinue;\n\n\t\tif (ri->rp && ri->rp->handler)\n\t\t\tri->rp->handler(ri, regs);\n\n\t\torig_ret_address = (unsigned long)ri->ret_addr;\n\t\trecycle_rp_inst(ri, &empty_rp);\n\n\t\tif (orig_ret_address != trampoline_address)\n\t\t\t/*\n\t\t\t * This is the real return address. Any other\n\t\t\t * instances associated with this task are for\n\t\t\t * other calls deeper on the call stack\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tkretprobe_assert(ri, orig_ret_address, trampoline_address);\n\n\t/*\n\t * We get here through one of two paths:\n\t * 1. by taking a trap -> kprobe_handler() -> here\n\t * 2. by optprobe branch -> optimized_callback() -> opt_pre_handler() -> here\n\t *\n\t * When going back through (1), we need regs->nip to be setup properly\n\t * as it is used to determine the return address from the trap.\n\t * For (2), since nip is not honoured with optprobes, we instead setup\n\t * the link register properly so that the subsequent 'blr' in\n\t * kretprobe_trampoline jumps back to the right instruction.\n\t *\n\t * For nip, we should set the address to the previous instruction since\n\t * we end up emulating it in kprobe_handler(), which increments the nip\n\t * again.\n\t */\n\tregs->nip = orig_ret_address - 4;\n\tregs->link = orig_ret_address;\n\n\tkretprobe_hash_unlock(current, &flags);\n\n\thlist_for_each_entry_safe(ri, tmp, &empty_rp, hlist) {\n\t\thlist_del(&ri->hlist);\n\t\tkfree(ri);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "268-378",
    "snippet": "int kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (!(regs->msr & MSR_IR) || !(regs->msr & MSR_DR))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tunsigned int instr;\n\n\t\tif (get_kernel_nofault(instr, addr))\n\t\t\tgoto no_kprobe;\n\n\t\tif (instr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tif (is_trap(instr))\n\t\t\t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\tif (kcb->kprobe_status == KPROBE_HIT_SS && is_trap(insn)) {\n\t\t\t/* Turn off 'trace' bits */\n\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\tgoto no_kprobe;\n\t\t}\n\n\t\t/*\n\t\t * We have reentered the kprobe_handler(), since another probe\n\t\t * was hit while within the handler. We here save the original\n\t\t * kprobes variables and just single step on the instruction of\n\t\t * the new probe without calling any user handlers.\n\t\t */\n\t\tsave_previous_kprobe(kcb);\n\t\tset_current_kprobe(p, regs, kcb);\n\t\tkprobes_inc_nmissed_count(p);\n\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\tif (p->ainsn.boostable >= 0) {\n\t\t\tret = try_to_emulate(p, regs);\n\n\t\t\tif (ret > 0) {\n\t\t\t\trestore_previous_kprobe(kcb);\n\t\t\t\tpreempt_enable_no_resched();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tprepare_singlestep(p, regs);\n\t\treturn 1;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs)) {\n\t\t/* handler changed execution path, so skip ss setup */\n\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\treturn 1;\n\t}\n\n\tif (p->ainsn.boostable >= 0) {\n\t\tret = try_to_emulate(p, regs);\n\n\t\tif (ret > 0) {\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_singlestep",
          "args": [
            "p",
            "regs"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_singlestep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "171-182",
          "snippet": "static nokprobe_inline void prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic nokprobe_inline void prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->post_handler",
          "args": [
            "p",
            "regs",
            "0"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_emulate",
          "args": [
            "p",
            "regs"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_emulate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "227-265",
          "snippet": "static int try_to_emulate(struct kprobe *p, struct pt_regs *regs)\n{\n\tint ret;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\n\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\tret = emulate_step(regs, insn);\n\tif (ret > 0) {\n\t\t/*\n\t\t * Once this instruction has been boosted\n\t\t * successfully, set the boostable flag\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\tp->ainsn.boostable = 1;\n\t} else if (ret < 0) {\n\t\t/*\n\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t * So, we should never get here... but, its still\n\t\t * good to catch them, just in case...\n\t\t */\n\t\tprintk(\"Can't step on instruction %s\\n\", ppc_inst_as_str(insn));\n\t\tBUG();\n\t} else {\n\t\t/*\n\t\t * If we haven't previously emulated this instruction, then it\n\t\t * can't be boosted. Note it down so we don't try to do so again.\n\t\t *\n\t\t * If, however, we had emulated this instruction in the past,\n\t\t * then this is just an error with the current run (for\n\t\t * instance, exceptions due to a load/store). We return 0 so\n\t\t * that this is now single-stepped, but continue to try\n\t\t * emulating it in subsequent probe hits.\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable != 1))\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int try_to_emulate(struct kprobe *p, struct pt_regs *regs)\n{\n\tint ret;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\n\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\tret = emulate_step(regs, insn);\n\tif (ret > 0) {\n\t\t/*\n\t\t * Once this instruction has been boosted\n\t\t * successfully, set the boostable flag\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\tp->ainsn.boostable = 1;\n\t} else if (ret < 0) {\n\t\t/*\n\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t * So, we should never get here... but, its still\n\t\t * good to catch them, just in case...\n\t\t */\n\t\tprintk(\"Can't step on instruction %s\\n\", ppc_inst_as_str(insn));\n\t\tBUG();\n\t} else {\n\t\t/*\n\t\t * If we haven't previously emulated this instruction, then it\n\t\t * can't be boosted. Note it down so we don't try to do so again.\n\t\t *\n\t\t * If, however, we had emulated this instruction in the past,\n\t\t * then this is just an error with the current run (for\n\t\t * instance, exceptions due to a load/store). We return 0 so\n\t\t * that this is now single-stepped, but continue to try\n\t\t * emulating it in subsequent probe hits.\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable != 1))\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_current_kprobe",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->pre_handler",
          "args": [
            "p",
            "regs"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_kprobe",
          "args": [
            "p",
            "regs",
            "kcb"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "set_current_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "198-203",
          "snippet": "static nokprobe_inline void set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "restore_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "191-196",
          "snippet": "static nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobes_inc_nmissed_count",
          "args": [
            "p"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_previous_kprobe",
          "args": [
            "kcb"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "save_previous_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "184-189",
          "snippet": "static nokprobe_inline void save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/sections.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/extable.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic nokprobe_inline void save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_trap",
          "args": [
            "insn"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "is_trap_insn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/uprobes.c",
          "lines": "26-29",
          "snippet": "bool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/sstep.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/sstep.h>\n#include <linux/kdebug.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nbool is_trap_insn(uprobe_opcode_t *insn)\n{\n\treturn (is_trap(*insn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kernel_nofault",
          "args": [
            "instr",
            "addr"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "addr"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint kprobe_handler(struct pt_regs *regs)\n{\n\tstruct kprobe *p;\n\tint ret = 0;\n\tunsigned int *addr = (unsigned int *)regs->nip;\n\tstruct kprobe_ctlblk *kcb;\n\n\tif (user_mode(regs))\n\t\treturn 0;\n\n\tif (!(regs->msr & MSR_IR) || !(regs->msr & MSR_DR))\n\t\treturn 0;\n\n\t/*\n\t * We don't want to be preempted for the entire\n\t * duration of kprobe processing\n\t */\n\tpreempt_disable();\n\tkcb = get_kprobe_ctlblk();\n\n\tp = get_kprobe(addr);\n\tif (!p) {\n\t\tunsigned int instr;\n\n\t\tif (get_kernel_nofault(instr, addr))\n\t\t\tgoto no_kprobe;\n\n\t\tif (instr != BREAKPOINT_INSTRUCTION) {\n\t\t\t/*\n\t\t\t * PowerPC has multiple variants of the \"trap\"\n\t\t\t * instruction. If the current instruction is a\n\t\t\t * trap variant, it could belong to someone else\n\t\t\t */\n\t\t\tif (is_trap(instr))\n\t\t\t\tgoto no_kprobe;\n\t\t\t/*\n\t\t\t * The breakpoint instruction was removed right\n\t\t\t * after we hit it.  Another cpu has removed\n\t\t\t * either a probepoint or a debugger breakpoint\n\t\t\t * at this address.  In either case, no further\n\t\t\t * handling of this interrupt is appropriate.\n\t\t\t */\n\t\t\tret = 1;\n\t\t}\n\t\t/* Not one of ours: let kernel handle it */\n\t\tgoto no_kprobe;\n\t}\n\n\t/* Check we're not actually recursing */\n\tif (kprobe_running()) {\n\t\tkprobe_opcode_t insn = *p->ainsn.insn;\n\t\tif (kcb->kprobe_status == KPROBE_HIT_SS && is_trap(insn)) {\n\t\t\t/* Turn off 'trace' bits */\n\t\t\tregs->msr &= ~MSR_SINGLESTEP;\n\t\t\tregs->msr |= kcb->kprobe_saved_msr;\n\t\t\tgoto no_kprobe;\n\t\t}\n\n\t\t/*\n\t\t * We have reentered the kprobe_handler(), since another probe\n\t\t * was hit while within the handler. We here save the original\n\t\t * kprobes variables and just single step on the instruction of\n\t\t * the new probe without calling any user handlers.\n\t\t */\n\t\tsave_previous_kprobe(kcb);\n\t\tset_current_kprobe(p, regs, kcb);\n\t\tkprobes_inc_nmissed_count(p);\n\t\tkcb->kprobe_status = KPROBE_REENTER;\n\t\tif (p->ainsn.boostable >= 0) {\n\t\t\tret = try_to_emulate(p, regs);\n\n\t\t\tif (ret > 0) {\n\t\t\t\trestore_previous_kprobe(kcb);\n\t\t\t\tpreempt_enable_no_resched();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tprepare_singlestep(p, regs);\n\t\treturn 1;\n\t}\n\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n\tset_current_kprobe(p, regs, kcb);\n\tif (p->pre_handler && p->pre_handler(p, regs)) {\n\t\t/* handler changed execution path, so skip ss setup */\n\t\treset_current_kprobe();\n\t\tpreempt_enable_no_resched();\n\t\treturn 1;\n\t}\n\n\tif (p->ainsn.boostable >= 0) {\n\t\tret = try_to_emulate(p, regs);\n\n\t\tif (ret > 0) {\n\t\t\tif (p->post_handler)\n\t\t\t\tp->post_handler(p, regs, 0);\n\n\t\t\tkcb->kprobe_status = KPROBE_HIT_SSDONE;\n\t\t\treset_current_kprobe();\n\t\t\tpreempt_enable_no_resched();\n\t\t\treturn 1;\n\t\t}\n\t}\n\tprepare_singlestep(p, regs);\n\tkcb->kprobe_status = KPROBE_HIT_SS;\n\treturn 1;\n\nno_kprobe:\n\tpreempt_enable_no_resched();\n\treturn ret;\n}"
  },
  {
    "function_name": "try_to_emulate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "227-265",
    "snippet": "static int try_to_emulate(struct kprobe *p, struct pt_regs *regs)\n{\n\tint ret;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\n\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\tret = emulate_step(regs, insn);\n\tif (ret > 0) {\n\t\t/*\n\t\t * Once this instruction has been boosted\n\t\t * successfully, set the boostable flag\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\tp->ainsn.boostable = 1;\n\t} else if (ret < 0) {\n\t\t/*\n\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t * So, we should never get here... but, its still\n\t\t * good to catch them, just in case...\n\t\t */\n\t\tprintk(\"Can't step on instruction %s\\n\", ppc_inst_as_str(insn));\n\t\tBUG();\n\t} else {\n\t\t/*\n\t\t * If we haven't previously emulated this instruction, then it\n\t\t * can't be boosted. Note it down so we don't try to do so again.\n\t\t *\n\t\t * If, however, we had emulated this instruction in the past,\n\t\t * then this is just an error with the current run (for\n\t\t * instance, exceptions due to a load/store). We return 0 so\n\t\t * that this is now single-stepped, but continue to try\n\t\t * emulating it in subsequent probe hits.\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable != 1))\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ainsn.boostable != 1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Can't step on instruction %s\\n\"",
            "ppc_inst_as_str(insn)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst_as_str",
          "args": [
            "insn"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ainsn.boostable == 0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_step",
          "args": [
            "regs",
            "insn"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)p->ainsn.insn"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic int try_to_emulate(struct kprobe *p, struct pt_regs *regs)\n{\n\tint ret;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->ainsn.insn);\n\n\t/* regs->nip is also adjusted if emulate_step returns 1 */\n\tret = emulate_step(regs, insn);\n\tif (ret > 0) {\n\t\t/*\n\t\t * Once this instruction has been boosted\n\t\t * successfully, set the boostable flag\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable == 0))\n\t\t\tp->ainsn.boostable = 1;\n\t} else if (ret < 0) {\n\t\t/*\n\t\t * We don't allow kprobes on mtmsr(d)/rfi(d), etc.\n\t\t * So, we should never get here... but, its still\n\t\t * good to catch them, just in case...\n\t\t */\n\t\tprintk(\"Can't step on instruction %s\\n\", ppc_inst_as_str(insn));\n\t\tBUG();\n\t} else {\n\t\t/*\n\t\t * If we haven't previously emulated this instruction, then it\n\t\t * can't be boosted. Note it down so we don't try to do so again.\n\t\t *\n\t\t * If, however, we had emulated this instruction in the past,\n\t\t * then this is just an error with the current run (for\n\t\t * instance, exceptions due to a load/store). We return 0 so\n\t\t * that this is now single-stepped, but continue to try\n\t\t * emulating it in subsequent probe hits.\n\t\t */\n\t\tif (unlikely(p->ainsn.boostable != 1))\n\t\t\tp->ainsn.boostable = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "arch_prepare_kretprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "218-224",
    "snippet": "void arch_prepare_kretprobe(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tri->ret_addr = (kprobe_opcode_t *)regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = (unsigned long)kretprobe_trampoline;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid arch_prepare_kretprobe(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tri->ret_addr = (kprobe_opcode_t *)regs->link;\n\n\t/* Replace the return addr with trampoline addr */\n\tregs->link = (unsigned long)kretprobe_trampoline;\n}"
  },
  {
    "function_name": "arch_kprobe_on_func_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "205-216",
    "snippet": "bool arch_kprobe_on_func_entry(unsigned long offset)\n{\n#ifdef PPC64_ELF_ABI_v2\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\treturn offset <= 16;\n#else\n\treturn offset <= 8;\n#endif\n#else\n\treturn !offset;\n#endif\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nbool arch_kprobe_on_func_entry(unsigned long offset)\n{\n#ifdef PPC64_ELF_ABI_v2\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\treturn offset <= 16;\n#else\n\treturn offset <= 8;\n#endif\n#else\n\treturn !offset;\n#endif\n}"
  },
  {
    "function_name": "set_current_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "198-203",
    "snippet": "static nokprobe_inline void set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "p"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void set_current_kprobe(struct kprobe *p, struct pt_regs *regs,\n\t\t\t\tstruct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, p);\n\tkcb->kprobe_saved_msr = regs->msr;\n}"
  },
  {
    "function_name": "restore_previous_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "191-196",
    "snippet": "static nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "kcb->prev_kprobe.kp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nDEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;\n\nstatic nokprobe_inline void restore_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\t__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);\n\tkcb->kprobe_status = kcb->prev_kprobe.status;\n\tkcb->kprobe_saved_msr = kcb->prev_kprobe.saved_msr;\n}"
  },
  {
    "function_name": "save_previous_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "184-189",
    "snippet": "static nokprobe_inline void save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic nokprobe_inline void save_previous_kprobe(struct kprobe_ctlblk *kcb)\n{\n\tkcb->prev_kprobe.kp = kprobe_running();\n\tkcb->prev_kprobe.status = kcb->kprobe_status;\n\tkcb->prev_kprobe.saved_msr = kcb->kprobe_saved_msr;\n}"
  },
  {
    "function_name": "prepare_singlestep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "171-182",
    "snippet": "static nokprobe_inline void prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_single_step",
          "args": [
            "regs"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "user_enable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/ptrace/ptrace-adv.c",
          "lines": "8-18",
          "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include \"ptrace-decl.h\"",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ptrace-decl.h\"\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nstatic nokprobe_inline void prepare_singlestep(struct kprobe *p, struct pt_regs *regs)\n{\n\tenable_single_step(regs);\n\n\t/*\n\t * On powerpc we should single step on the original\n\t * instruction even if the probed insn is a trap\n\t * variant as values in regs could play a part in\n\t * if the trap is taken or not\n\t */\n\tregs->nip = (unsigned long)p->ainsn.insn;\n}"
  },
  {
    "function_name": "arch_remove_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "162-168",
    "snippet": "void arch_remove_kprobe(struct kprobe *p)\n{\n\tif (p->ainsn.insn) {\n\t\tfree_insn_slot(p->ainsn.insn, 0);\n\t\tp->ainsn.insn = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_insn_slot",
          "args": [
            "p->ainsn.insn",
            "0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid arch_remove_kprobe(struct kprobe *p)\n{\n\tif (p->ainsn.insn) {\n\t\tfree_insn_slot(p->ainsn.insn, 0);\n\t\tp->ainsn.insn = NULL;\n\t}\n}"
  },
  {
    "function_name": "arch_disarm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "156-159",
    "snippet": "void arch_disarm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(p->opcode));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)p->addr",
            "ppc_inst(p->opcode)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "p->opcode"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid arch_disarm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(p->opcode));\n}"
  },
  {
    "function_name": "arch_arm_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "150-153",
    "snippet": "void arch_arm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(BREAKPOINT_INSTRUCTION));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)p->addr",
            "ppc_inst(BREAKPOINT_INSTRUCTION)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "BREAKPOINT_INSTRUCTION"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nvoid arch_arm_kprobe(struct kprobe *p)\n{\n\tpatch_instruction((struct ppc_inst *)p->addr, ppc_inst(BREAKPOINT_INSTRUCTION));\n}"
  },
  {
    "function_name": "arch_prepare_kprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "106-147",
    "snippet": "int arch_prepare_kprobe(struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *prev;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->addr);\n\tstruct ppc_inst prefix = ppc_inst_read((struct ppc_inst *)(p->addr - 1));\n\n\tif ((unsigned long)p->addr & 0x03) {\n\t\tprintk(\"Attempt to register kprobe at an unaligned address\\n\");\n\t\tret = -EINVAL;\n\t} else if (IS_MTMSRD(insn) || IS_RFID(insn) || IS_RFI(insn)) {\n\t\tprintk(\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\");\n\t\tret = -EINVAL;\n\t} else if (ppc_inst_prefixed(prefix)) {\n\t\tprintk(\"Cannot register a kprobe on the second word of prefixed instruction\\n\");\n\t\tret = -EINVAL;\n\t}\n\tpreempt_disable();\n\tprev = get_kprobe(p->addr - 1);\n\tpreempt_enable_no_resched();\n\tif (prev &&\n\t    ppc_inst_prefixed(ppc_inst_read((struct ppc_inst *)prev->ainsn.insn))) {\n\t\tprintk(\"Cannot register a kprobe on the second word of prefixed instruction\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\t/* insn must be on a special executable page on ppc64.  This is\n\t * not explicitly required on ppc32 (right now), but it doesn't hurt */\n\tif (!ret) {\n\t\tp->ainsn.insn = get_insn_slot();\n\t\tif (!p->ainsn.insn)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tif (!ret) {\n\t\tpatch_instruction((struct ppc_inst *)p->ainsn.insn, insn);\n\t\tp->opcode = ppc_inst_val(insn);\n\t}\n\n\tp->ainsn.boostable = 0;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_inst_val",
          "args": [
            "insn"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction",
          "args": [
            "(struct ppc_inst *)p->ainsn.insn",
            "insn"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_insn_slot",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cannot register a kprobe on the second word of prefixed instruction\\n\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_prefixed",
          "args": [
            "ppc_inst_read((struct ppc_inst *)prev->ainsn.insn)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)prev->ainsn.insn"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "p->addr - 1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cannot register a kprobe on the second word of prefixed instruction\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_prefixed",
          "args": [
            "prefix"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RFI",
          "args": [
            "insn"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RFID",
          "args": [
            "insn"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MTMSRD",
          "args": [
            "insn"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Attempt to register kprobe at an unaligned address\\n\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)(p->addr - 1)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_read",
          "args": [
            "(struct ppc_inst *)p->addr"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint arch_prepare_kprobe(struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *prev;\n\tstruct ppc_inst insn = ppc_inst_read((struct ppc_inst *)p->addr);\n\tstruct ppc_inst prefix = ppc_inst_read((struct ppc_inst *)(p->addr - 1));\n\n\tif ((unsigned long)p->addr & 0x03) {\n\t\tprintk(\"Attempt to register kprobe at an unaligned address\\n\");\n\t\tret = -EINVAL;\n\t} else if (IS_MTMSRD(insn) || IS_RFID(insn) || IS_RFI(insn)) {\n\t\tprintk(\"Cannot register a kprobe on rfi/rfid or mtmsr[d]\\n\");\n\t\tret = -EINVAL;\n\t} else if (ppc_inst_prefixed(prefix)) {\n\t\tprintk(\"Cannot register a kprobe on the second word of prefixed instruction\\n\");\n\t\tret = -EINVAL;\n\t}\n\tpreempt_disable();\n\tprev = get_kprobe(p->addr - 1);\n\tpreempt_enable_no_resched();\n\tif (prev &&\n\t    ppc_inst_prefixed(ppc_inst_read((struct ppc_inst *)prev->ainsn.insn))) {\n\t\tprintk(\"Cannot register a kprobe on the second word of prefixed instruction\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\t/* insn must be on a special executable page on ppc64.  This is\n\t * not explicitly required on ppc32 (right now), but it doesn't hurt */\n\tif (!ret) {\n\t\tp->ainsn.insn = get_insn_slot();\n\t\tif (!p->ainsn.insn)\n\t\t\tret = -ENOMEM;\n\t}\n\n\tif (!ret) {\n\t\tpatch_instruction((struct ppc_inst *)p->ainsn.insn, insn);\n\t\tp->opcode = ppc_inst_val(insn);\n\t}\n\n\tp->ainsn.boostable = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_lookup_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "42-104",
    "snippet": "kprobe_opcode_t *kprobe_lookup_name(const char *name, unsigned int offset)\n{\n\tkprobe_opcode_t *addr = NULL;\n\n#ifdef PPC64_ELF_ABI_v2\n\t/* PPC64 ABIv2 needs local entry point */\n\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n\tif (addr && !offset) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\tunsigned long faddr;\n\t\t/*\n\t\t * Per livepatch.h, ftrace location is always within the first\n\t\t * 16 bytes of a function on powerpc with -mprofile-kernel.\n\t\t */\n\t\tfaddr = ftrace_location_range((unsigned long)addr,\n\t\t\t\t\t      (unsigned long)addr + 16);\n\t\tif (faddr)\n\t\t\taddr = (kprobe_opcode_t *)faddr;\n\t\telse\n#endif\n\t\t\taddr = (kprobe_opcode_t *)ppc_function_entry(addr);\n\t}\n#elif defined(PPC64_ELF_ABI_v1)\n\t/*\n\t * 64bit powerpc ABIv1 uses function descriptors:\n\t * - Check for the dot variant of the symbol first.\n\t * - If that fails, try looking up the symbol provided.\n\t *\n\t * This ensures we always get to the actual symbol and not\n\t * the descriptor.\n\t *\n\t * Also handle <module:symbol> format.\n\t */\n\tchar dot_name[MODULE_NAME_LEN + 1 + KSYM_NAME_LEN];\n\tbool dot_appended = false;\n\tconst char *c;\n\tssize_t ret = 0;\n\tint len = 0;\n\n\tif ((c = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tc++;\n\t\tlen = c - name;\n\t\tmemcpy(dot_name, name, len);\n\t} else\n\t\tc = name;\n\n\tif (*c != '\\0' && *c != '.') {\n\t\tdot_name[len++] = '.';\n\t\tdot_appended = true;\n\t}\n\tret = strscpy(dot_name + len, c, KSYM_NAME_LEN);\n\tif (ret > 0)\n\t\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(dot_name);\n\n\t/* Fallback to the original non-dot symbol lookup */\n\tif (!addr && dot_appended)\n\t\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n#else\n\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n#endif\n\n\treturn addr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "name"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "name"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "dot_name"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "dot_name + len",
            "c",
            "KSYM_NAME_LEN"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dot_name",
            "name",
            "len"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnchr",
          "args": [
            "name",
            "MODULE_NAME_LEN",
            "':'"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "addr"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_location_range",
          "args": [
            "(unsigned long)addr",
            "(unsigned long)addr + 16"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "name"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nkprobe_opcode_t *kprobe_lookup_name(const char *name, unsigned int offset)\n{\n\tkprobe_opcode_t *addr = NULL;\n\n#ifdef PPC64_ELF_ABI_v2\n\t/* PPC64 ABIv2 needs local entry point */\n\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n\tif (addr && !offset) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\tunsigned long faddr;\n\t\t/*\n\t\t * Per livepatch.h, ftrace location is always within the first\n\t\t * 16 bytes of a function on powerpc with -mprofile-kernel.\n\t\t */\n\t\tfaddr = ftrace_location_range((unsigned long)addr,\n\t\t\t\t\t      (unsigned long)addr + 16);\n\t\tif (faddr)\n\t\t\taddr = (kprobe_opcode_t *)faddr;\n\t\telse\n#endif\n\t\t\taddr = (kprobe_opcode_t *)ppc_function_entry(addr);\n\t}\n#elif defined(PPC64_ELF_ABI_v1)\n\t/*\n\t * 64bit powerpc ABIv1 uses function descriptors:\n\t * - Check for the dot variant of the symbol first.\n\t * - If that fails, try looking up the symbol provided.\n\t *\n\t * This ensures we always get to the actual symbol and not\n\t * the descriptor.\n\t *\n\t * Also handle <module:symbol> format.\n\t */\n\tchar dot_name[MODULE_NAME_LEN + 1 + KSYM_NAME_LEN];\n\tbool dot_appended = false;\n\tconst char *c;\n\tssize_t ret = 0;\n\tint len = 0;\n\n\tif ((c = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tc++;\n\t\tlen = c - name;\n\t\tmemcpy(dot_name, name, len);\n\t} else\n\t\tc = name;\n\n\tif (*c != '\\0' && *c != '.') {\n\t\tdot_name[len++] = '.';\n\t\tdot_appended = true;\n\t}\n\tret = strscpy(dot_name + len, c, KSYM_NAME_LEN);\n\tif (ret > 0)\n\t\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(dot_name);\n\n\t/* Fallback to the original non-dot symbol lookup */\n\tif (!addr && dot_appended)\n\t\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n#else\n\taddr = (kprobe_opcode_t *)kallsyms_lookup_name(name);\n#endif\n\n\treturn addr;\n}"
  },
  {
    "function_name": "arch_within_kprobe_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/kprobes.c",
    "lines": "34-40",
    "snippet": "bool arch_within_kprobe_blacklist(unsigned long addr)\n{\n\treturn  (addr >= (unsigned long)__kprobes_text_start &&\n\t\t addr < (unsigned long)__kprobes_text_end) ||\n\t\t(addr >= (unsigned long)_stext &&\n\t\t addr < (unsigned long)__head_end);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/sections.h>",
      "#include <asm/sstep.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/code-patching.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/extable.h>",
      "#include <linux/preempt.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/sections.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/extable.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nbool arch_within_kprobe_blacklist(unsigned long addr)\n{\n\treturn  (addr >= (unsigned long)__kprobes_text_start &&\n\t\t addr < (unsigned long)__kprobes_text_end) ||\n\t\t(addr >= (unsigned long)_stext &&\n\t\t addr < (unsigned long)__head_end);\n}"
  }
]