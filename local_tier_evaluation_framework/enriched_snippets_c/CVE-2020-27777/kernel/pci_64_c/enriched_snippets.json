[
  {
    "function_name": "pcibus_to_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "281-285",
    "snippet": "int pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}"
  },
  {
    "function_name": "pcibios_setup_phb_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "215-218",
    "snippet": "void pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tpcibios_map_phb_io_space(hose);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_map_phb_io_space",
          "args": [
            "hose"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_map_phb_io_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "151-193",
          "snippet": "static int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tpcibios_map_phb_io_space(hose);\n}"
  },
  {
    "function_name": "pcibios_map_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "195-212",
    "snippet": "int pcibios_map_io_space(struct pci_bus *bus)\n{\n\tWARN_ON(bus == NULL);\n\n\t/* If this not a PHB, nothing to do, page tables still exist and\n\t * thus HPTEs will be faulted in when needed\n\t */\n\tif (bus->self) {\n\t\tpr_debug(\"IO mapping for PCI-PCI bridge %s\\n\",\n\t\t\t pci_name(bus->self));\n\t\tpr_debug(\"  virt=0x%016llx...0x%016llx\\n\",\n\t\t\t bus->resource[0]->start + _IO_BASE,\n\t\t\t bus->resource[0]->end + _IO_BASE);\n\t\treturn 0;\n\t}\n\n\treturn pcibios_map_phb_io_space(pci_bus_to_host(bus));\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_map_phb_io_space",
          "args": [
            "pci_bus_to_host(bus)"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_map_phb_io_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "151-193",
          "snippet": "static int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  virt=0x%016llx...0x%016llx\\n\"",
            "bus->resource[0]->start + _IO_BASE",
            "bus->resource[0]->end + _IO_BASE"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"IO mapping for PCI-PCI bridge %s\\n\"",
            "pci_name(bus->self)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "bus->self"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bus == NULL"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_map_io_space(struct pci_bus *bus)\n{\n\tWARN_ON(bus == NULL);\n\n\t/* If this not a PHB, nothing to do, page tables still exist and\n\t * thus HPTEs will be faulted in when needed\n\t */\n\tif (bus->self) {\n\t\tpr_debug(\"IO mapping for PCI-PCI bridge %s\\n\",\n\t\t\t pci_name(bus->self));\n\t\tpr_debug(\"  virt=0x%016llx...0x%016llx\\n\",\n\t\t\t bus->resource[0]->start + _IO_BASE,\n\t\t\t bus->resource[0]->end + _IO_BASE);\n\t\treturn 0;\n\t}\n\n\treturn pcibios_map_phb_io_space(pci_bus_to_host(bus));\n}"
  },
  {
    "function_name": "pcibios_map_phb_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "151-193",
    "snippet": "static int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  hose->io_resource=%pR\\n\"",
            "&hose->io_resource"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_space_offset",
          "args": [
            "hose"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_space_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1537-1540",
          "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  size=0x%016llx (alloc=0x%016lx)\\n\"",
            "hose->pci_io_size",
            "size_page"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\"",
            "hose->io_base_phys",
            "hose->io_base_virt",
            "hose->io_base_alloc"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"IO mapping for PHB %pOF\\n\"",
            "hose->dn"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap_phb",
          "args": [
            "phys_page",
            "size_page"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "hose->pci_io_size",
            "PAGE_SIZE"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "hose->io_base_phys",
            "PAGE_SIZE"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_map_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long phys_page;\n\tunsigned long size_page;\n\tunsigned long io_virt_offset;\n\n\tphys_page = ALIGN_DOWN(hose->io_base_phys, PAGE_SIZE);\n\tsize_page = ALIGN(hose->pci_io_size, PAGE_SIZE);\n\n\t/* Make sure IO area address is clear */\n\those->io_base_alloc = NULL;\n\n\t/* If there's no IO to map on that bus, get away too */\n\tif (hose->pci_io_size == 0 || hose->io_base_phys == 0)\n\t\treturn 0;\n\n\t/* Let's allocate some IO space for that guy. We don't pass\n\t * VM_IOREMAP because we don't care about alignment tricks that\n\t * the core does in that case. Maybe we should due to stupid card\n\t * with incomplete address decoding but I'd rather not deal with\n\t * those outside of the reserved 64K legacy region.\n\t */\n\those->io_base_alloc = ioremap_phb(phys_page, size_page);\n\tif (!hose->io_base_alloc)\n\t\treturn -ENOMEM;\n\those->io_base_virt = hose->io_base_alloc +\n\t\t\t\those->io_base_phys - phys_page;\n\n\tpr_debug(\"IO mapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  phys=0x%016llx, virt=0x%p (alloc=0x%p)\\n\",\n\t\t hose->io_base_phys, hose->io_base_virt, hose->io_base_alloc);\n\tpr_debug(\"  size=0x%016llx (alloc=0x%016lx)\\n\",\n\t\t hose->pci_io_size, size_page);\n\n\t/* Fixup hose IO resource */\n\tio_virt_offset = pcibios_io_space_offset(hose);\n\those->io_resource.start += io_virt_offset;\n\those->io_resource.end += io_virt_offset;\n\n\tpr_debug(\"  hose->io_resource=%pR\\n\", &hose->io_resource);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ioremap_phb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "120-148",
    "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_kernel_range",
          "args": [
            "addr",
            "size"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap_page_range",
          "args": [
            "addr",
            "addr + size",
            "paddr",
            "pgprot_noncached(PAGE_KERNEL)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "PAGE_KERNEL"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_vm_area_caller",
          "args": [
            "size",
            "0",
            "PHB_IO_BASE",
            "PHB_IO_END",
            "__builtin_return_address(0)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "size & ~PAGE_MASK"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "paddr & ~PAGE_MASK"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
  },
  {
    "function_name": "pcibios_unmap_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "78-117",
    "snippet": "int pcibios_unmap_io_space(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose;\n\n\tWARN_ON(bus == NULL);\n\n\t/* If this is not a PHB, we only flush the hash table over\n\t * the area mapped by this bridge. We don't play with the PTE\n\t * mappings since we might have to deal with sub-page alignments\n\t * so flushing the hash table is the only sane way to make sure\n\t * that no hash entries are covering that removed bridge area\n\t * while still allowing other busses overlapping those pages\n\t *\n\t * Note: If we ever support P2P hotplug on Book3E, we'll have\n\t * to do an appropriate TLB flush here too\n\t */\n\tif (bus->self) {\n#ifdef CONFIG_PPC_BOOK3S_64\n\t\tstruct resource *res = bus->resource[0];\n#endif\n\n\t\tpr_debug(\"IO unmapping for PCI-PCI bridge %s\\n\",\n\t\t\t pci_name(bus->self));\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t\t__flush_hash_table_range(res->start + _IO_BASE,\n\t\t\t\t\t res->end + _IO_BASE + 1);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* Get the host bridge */\n\those = pci_bus_to_host(bus);\n\n\tpr_debug(\"IO unmapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  alloc=0x%p\\n\", hose->io_base_alloc);\n\n\tiounmap(hose->io_base_alloc);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "hose->io_base_alloc"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  alloc=0x%p\\n\"",
            "hose->io_base_alloc"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"IO unmapping for PHB %pOF\\n\"",
            "hose->dn"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_hash_table_range",
          "args": [
            "res->start + _IO_BASE",
            "res->end + _IO_BASE + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"IO unmapping for PCI-PCI bridge %s\\n\"",
            "pci_name(bus->self)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "bus->self"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bus == NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_unmap_io_space(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose;\n\n\tWARN_ON(bus == NULL);\n\n\t/* If this is not a PHB, we only flush the hash table over\n\t * the area mapped by this bridge. We don't play with the PTE\n\t * mappings since we might have to deal with sub-page alignments\n\t * so flushing the hash table is the only sane way to make sure\n\t * that no hash entries are covering that removed bridge area\n\t * while still allowing other busses overlapping those pages\n\t *\n\t * Note: If we ever support P2P hotplug on Book3E, we'll have\n\t * to do an appropriate TLB flush here too\n\t */\n\tif (bus->self) {\n#ifdef CONFIG_PPC_BOOK3S_64\n\t\tstruct resource *res = bus->resource[0];\n#endif\n\n\t\tpr_debug(\"IO unmapping for PCI-PCI bridge %s\\n\",\n\t\t\t pci_name(bus->self));\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t\t__flush_hash_table_range(res->start + _IO_BASE,\n\t\t\t\t\t res->end + _IO_BASE + 1);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* Get the host bridge */\n\those = pci_bus_to_host(bus);\n\n\tpr_debug(\"IO unmapping for PHB %pOF\\n\", hose->dn);\n\tpr_debug(\"  alloc=0x%p\\n\", hose->io_base_alloc);\n\n\tiounmap(hose->io_base_alloc);\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "40-74",
    "snippet": "static int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\t/* For now, override phys_mem_access_prot. If we need it,g\n\t * later, we may move that initialization to each ppc_md\n\t */\n\tppc_md.phys_mem_access_prot = pci_phys_mem_access_prot;\n\n\t/* On ppc64, we always enable PCI domains and we keep domain 0\n\t * backward compatible in /proc for video cards\n\t */\n\tpci_add_flags(PCI_ENABLE_PROC_DOMAINS | PCI_COMPAT_DOMAIN_0);\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tpcibios_scan_phb(hose);\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Add devices. */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tpci_bus_add_devices(hose->bus);\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n\n\tprintk(KERN_DEBUG \"PCI: Probing PCI hardware done\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"PCI: Probing PCI hardware done\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "hose->bus"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_survey",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_resource_survey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1427-1455",
          "snippet": "void __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_scan_phb",
          "args": [
            "hose"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_scan_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1659-1719",
          "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_flags",
          "args": [
            "PCI_ENABLE_PROC_DOMAINS | PCI_COMPAT_DOMAIN_0"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"PCI: Probing PCI hardware\\n\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\t/* For now, override phys_mem_access_prot. If we need it,g\n\t * later, we may move that initialization to each ppc_md\n\t */\n\tppc_md.phys_mem_access_prot = pci_phys_mem_access_prot;\n\n\t/* On ppc64, we always enable PCI domains and we keep domain 0\n\t * backward compatible in /proc for video cards\n\t */\n\tpci_add_flags(PCI_ENABLE_PROC_DOMAINS | PCI_COMPAT_DOMAIN_0);\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tpcibios_scan_phb(hose);\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Add devices. */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tpci_bus_add_devices(hose->bus);\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n\n\tprintk(KERN_DEBUG \"PCI: Probing PCI hardware done\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pciconfig_iobase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
    "lines": "226-278",
    "snippet": "SYSCALL_DEFINE3(pciconfig_iobase, long, which, unsigned long, in_bus,\n\t\t\t  unsigned long, in_devfn)\n{\n\tstruct pci_controller* hose;\n\tstruct pci_bus *tmp_bus, *bus = NULL;\n\tstruct device_node *hose_node;\n\n\t/* Argh ! Please forgive me for that hack, but that's the\n\t * simplest way to get existing XFree to not lockup on some\n\t * G5 machines... So when something asks for bus 0 io base\n\t * (bus 0 is HT root), we return the AGP one instead.\n\t */\n\tif (in_bus == 0 && of_machine_is_compatible(\"MacRISC4\")) {\n\t\tstruct device_node *agp;\n\n\t\tagp = of_find_compatible_node(NULL, NULL, \"u3-agp\");\n\t\tif (agp)\n\t\t\tin_bus = 0xf0;\n\t\tof_node_put(agp);\n\t}\n\n\t/* That syscall isn't quite compatible with PCI domains, but it's\n\t * used on pre-domains setup. We return the first match\n\t */\n\n\tlist_for_each_entry(tmp_bus, &pci_root_buses, node) {\n\t\tif (in_bus >= tmp_bus->number &&\n\t\t    in_bus <= tmp_bus->busn_res.end) {\n\t\t\tbus = tmp_bus;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bus == NULL || bus->dev.of_node == NULL)\n\t\treturn -ENODEV;\n\n\those_node = bus->dev.of_node;\n\those = PCI_DN(hose_node)->phb;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/mm.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define IOBASE_ISA_MEM\t\t4",
      "#define IOBASE_ISA_IO\t\t3",
      "#define IOBASE_IO\t\t2",
      "#define IOBASE_MEMORY\t\t1",
      "#define IOBASE_BRIDGE_NUMBER\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define IOBASE_ISA_MEM\t\t4\n#define IOBASE_ISA_IO\t\t3\n#define IOBASE_IO\t\t2\n#define IOBASE_MEMORY\t\t1\n#define IOBASE_BRIDGE_NUMBER\t0\n\nSYSCALL_DEFINE3(pciconfig_iobase, long, which, unsigned long, in_bus,\n\t\t\t  unsigned long, in_devfn)\n{\n\tstruct pci_controller* hose;\n\tstruct pci_bus *tmp_bus, *bus = NULL;\n\tstruct device_node *hose_node;\n\n\t/* Argh ! Please forgive me for that hack, but that's the\n\t * simplest way to get existing XFree to not lockup on some\n\t * G5 machines... So when something asks for bus 0 io base\n\t * (bus 0 is HT root), we return the AGP one instead.\n\t */\n\tif (in_bus == 0 && of_machine_is_compatible(\"MacRISC4\")) {\n\t\tstruct device_node *agp;\n\n\t\tagp = of_find_compatible_node(NULL, NULL, \"u3-agp\");\n\t\tif (agp)\n\t\t\tin_bus = 0xf0;\n\t\tof_node_put(agp);\n\t}\n\n\t/* That syscall isn't quite compatible with PCI domains, but it's\n\t * used on pre-domains setup. We return the first match\n\t */\n\n\tlist_for_each_entry(tmp_bus, &pci_root_buses, node) {\n\t\tif (in_bus >= tmp_bus->number &&\n\t\t    in_bus <= tmp_bus->busn_res.end) {\n\t\t\tbus = tmp_bus;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bus == NULL || bus->dev.of_node == NULL)\n\t\treturn -ENODEV;\n\n\those_node = bus->dev.of_node;\n\those = PCI_DN(hose_node)->phb;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EOPNOTSUPP;\n}"
  }
]