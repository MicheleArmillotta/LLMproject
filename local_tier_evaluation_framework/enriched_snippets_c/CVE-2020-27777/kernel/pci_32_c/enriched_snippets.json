[
  {
    "function_name": "pci_bus_to_hose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "279-288",
    "snippet": "static struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}"
  },
  {
    "function_name": "pcibios_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "234-275",
    "snippet": "static int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint next_busno = 0;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\tif (pci_has_flag(PCI_REASSIGN_ALL_BUS))\n\t\tpci_assign_all_buses = 1;\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tif (pci_assign_all_buses)\n\t\t\those->first_busno = next_busno;\n\t\those->last_busno = 0xff;\n\t\tpcibios_scan_phb(hose);\n\t\tpci_bus_add_devices(hose->bus);\n\t\tif (pci_assign_all_buses || next_busno <= hose->last_busno)\n\t\t\tnext_busno = hose->last_busno + pcibios_assign_bus_offset;\n\t}\n\tpci_bus_count = next_busno;\n\n\t/* OpenFirmware based machines need a map of OF bus\n\t * numbers vs. kernel bus numbers since we may have to\n\t * remap them.\n\t */\n\tif (pci_assign_all_buses)\n\t\tpcibios_make_OF_bus_map();\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n\n\t/* Call machine dependent post-init code */\n\tif (ppc_md.pcibios_after_init)\n\t\tppc_md.pcibios_after_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcibios_assign_bus_offset = 1;",
      "void pcibios_make_OF_bus_map(void);",
      "static int pci_assign_all_buses;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_after_init",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_survey",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_resource_survey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1427-1455",
          "snippet": "void __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_make_OF_bus_map",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_make_OF_bus_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "112-155",
          "snippet": "void\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pcibios_make_OF_bus_map(void);",
            "static u8* pci_to_OF_bus_map;",
            "static int pci_bus_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_make_OF_bus_map(void);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nvoid\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "hose->bus"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_scan_phb",
          "args": [
            "hose"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_scan_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1659-1719",
          "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_BUS"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"PCI: Probing PCI hardware\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_assign_bus_offset = 1;\nvoid pcibios_make_OF_bus_map(void);\nstatic int pci_assign_all_buses;\nstatic int pci_bus_count;\n\nstatic int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint next_busno = 0;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\tif (pci_has_flag(PCI_REASSIGN_ALL_BUS))\n\t\tpci_assign_all_buses = 1;\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tif (pci_assign_all_buses)\n\t\t\those->first_busno = next_busno;\n\t\those->last_busno = 0xff;\n\t\tpcibios_scan_phb(hose);\n\t\tpci_bus_add_devices(hose->bus);\n\t\tif (pci_assign_all_buses || next_busno <= hose->last_busno)\n\t\t\tnext_busno = hose->last_busno + pcibios_assign_bus_offset;\n\t}\n\tpci_bus_count = next_busno;\n\n\t/* OpenFirmware based machines need a map of OF bus\n\t * numbers vs. kernel bus numbers since we may have to\n\t * remap them.\n\t */\n\tif (pci_assign_all_buses)\n\t\tpcibios_make_OF_bus_map();\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n\n\t/* Call machine dependent post-init code */\n\tif (ppc_md.pcibios_after_init)\n\t\tppc_md.pcibios_after_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_setup_phb_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "223-232",
    "snippet": "void pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_io_space_offset",
          "args": [
            "hose"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_space_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1537-1540",
          "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}"
  },
  {
    "function_name": "pci_create_OF_bus_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "201-221",
    "snippet": "void __init\npci_create_OF_bus_map(void)\n{\n\tstruct property* of_prop;\n\tstruct device_node *dn;\n\n\tof_prop = memblock_alloc(sizeof(struct property) + 256,\n\t\t\t\t SMP_CACHE_BYTES);\n\tif (!of_prop)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(struct property) + 256);\n\tdn = of_find_node_by_path(\"/\");\n\tif (dn) {\n\t\tmemset(of_prop, -1, sizeof(struct property) + 256);\n\t\tof_prop->name = \"pci-OF-bus-map\";\n\t\tof_prop->length = 256;\n\t\tof_prop->value = &of_prop[1];\n\t\tof_add_property(dn, of_prop);\n\t\tof_node_put(dn);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "dn"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "dn",
            "of_prop"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "of_prop",
            "-1",
            "sizeof(struct property) + 256"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: Failed to allocate %zu bytes\\n\"",
            "__func__",
            "sizeof(struct property) + 256"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_panic_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/setup-common.c",
          "lines": "691-708",
          "snippet": "static int ppc_panic_event(struct notifier_block *this,\n                             unsigned long event, void *ptr)\n{\n\t/*\n\t * panic does a local_irq_disable, but we really\n\t * want interrupts to be hard disabled.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If firmware-assisted dump has been registered then trigger\n\t * firmware-assisted dump and let firmware handle everything else.\n\t */\n\tcrash_fadump(NULL, ptr);\n\tif (ppc_md.panic)\n\t\tppc_md.panic(ptr);  /* May not return */\n\treturn NOTIFY_DONE;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include \"setup.h\"",
            "#include <asm/kasan.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/hugetlb.h>",
            "#include <asm/udbg.h>",
            "#include <asm/fadump.h>",
            "#include <mm/mmu_decl.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/xmon.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/firmware.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/paca.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/screen_info.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct machdep_calls ppc_md;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include \"setup.h\"\n#include <asm/kasan.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/mmu_context.h>\n#include <asm/livepatch.h>\n#include <asm/hugetlb.h>\n#include <asm/udbg.h>\n#include <asm/fadump.h>\n#include <mm/mmu_decl.h>\n#include <asm/cputhreads.h>\n#include <asm/xmon.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/firmware.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/vdso_datapage.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/paca.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/pgtable.h>\n#include <linux/hugetlb.h>\n#include <linux/of_platform.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/screen_info.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nstruct machdep_calls ppc_md;\n\nstatic int ppc_panic_event(struct notifier_block *this,\n                             unsigned long event, void *ptr)\n{\n\t/*\n\t * panic does a local_irq_disable, but we really\n\t * want interrupts to be hard disabled.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * If firmware-assisted dump has been registered then trigger\n\t * firmware-assisted dump and let firmware handle everything else.\n\t */\n\tcrash_fadump(NULL, ptr);\n\tif (ppc_md.panic)\n\t\tppc_md.panic(ptr);  /* May not return */\n\treturn NOTIFY_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "sizeof(struct property) + 256",
            "SMP_CACHE_BYTES"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init\npci_create_OF_bus_map(void)\n{\n\tstruct property* of_prop;\n\tstruct device_node *dn;\n\n\tof_prop = memblock_alloc(sizeof(struct property) + 256,\n\t\t\t\t SMP_CACHE_BYTES);\n\tif (!of_prop)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__,\n\t\t      sizeof(struct property) + 256);\n\tdn = of_find_node_by_path(\"/\");\n\tif (dn) {\n\t\tmemset(of_prop, -1, sizeof(struct property) + 256);\n\t\tof_prop->name = \"pci-OF-bus-map\";\n\t\tof_prop->length = 256;\n\t\tof_prop->value = &of_prop[1];\n\t\tof_add_property(dn, of_prop);\n\t\tof_node_put(dn);\n\t}\n}"
  },
  {
    "function_name": "pci_device_from_OF_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "161-195",
    "snippet": "int pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint size;\n\n\t/* Check if it might have a chance to be a PCI device */\n\tif (!pci_find_hose_for_OF_device(node))\n\t\treturn -ENODEV;\n\n\treg = of_get_property(node, \"reg\", &size);\n\tif (!reg || size < 5 * sizeof(u32))\n\t\treturn -ENODEV;\n\n\t*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\n\t*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\n\n\t/* Ok, here we need some tweak. If we have already renumbered\n\t * all busses, we can't rely on the OF bus number any more.\n\t * the pci_to_OF_bus_map is not enough as several PCI busses\n\t * may match the same OF bus number.\n\t */\n\tif (!pci_to_OF_bus_map)\n\t\treturn 0;\n\n\tfor_each_pci_dev(dev)\n\t\tif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\n\t\t\t\tdev->devfn == *devfn) {\n\t\t\t*bus = dev->bus->number;\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);",
      "static u8* pci_to_OF_bus_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "&reg[0]"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "&reg[0]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"reg\"",
            "&size"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_hose_for_OF_device",
          "args": [
            "node"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "pci_find_hose_for_OF_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "333-343",
          "snippet": "struct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\n\nint pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint size;\n\n\t/* Check if it might have a chance to be a PCI device */\n\tif (!pci_find_hose_for_OF_device(node))\n\t\treturn -ENODEV;\n\n\treg = of_get_property(node, \"reg\", &size);\n\tif (!reg || size < 5 * sizeof(u32))\n\t\treturn -ENODEV;\n\n\t*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\n\t*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\n\n\t/* Ok, here we need some tweak. If we have already renumbered\n\t * all busses, we can't rely on the OF bus number any more.\n\t * the pci_to_OF_bus_map is not enough as several PCI busses\n\t * may match the same OF bus number.\n\t */\n\tif (!pci_to_OF_bus_map)\n\t\treturn 0;\n\n\tfor_each_pci_dev(dev)\n\t\tif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\n\t\t\t\tdev->devfn == *devfn) {\n\t\t\t*bus = dev->bus->number;\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "pcibios_make_OF_bus_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "112-155",
    "snippet": "void\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pcibios_make_OF_bus_map(void);",
      "static u8* pci_to_OF_bus_map;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%d -> %d\\n\"",
            "i",
            "pci_to_OF_bus_map[i]"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"PCI->OF bus map:\\n\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "dn"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map_prop->value",
            "pci_to_OF_bus_map",
            "pci_bus_count"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pci_bus_count > map_prop->length"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "dn",
            "\"pci-OF-bus-map\"",
            "NULL"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_node_map",
          "args": [
            "node",
            "hose->first_busno"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "make_one_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "74-110",
          "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\", node);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_domain_bus_and_slot(0, pci_bus,\n\t\t\t\t\t\t  ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void fixup_cpc710_pci64(struct pci_dev* dev);",
            "static u8* pci_to_OF_bus_map;",
            "static int pci_bus_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nstatic void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\", node);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_domain_bus_and_slot(0, pci_bus,\n\t\t\t\t\t\t  ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't allocate OF bus map !\\n\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pci_bus_count",
            "GFP_KERNEL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_make_OF_bus_map(void);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nvoid\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}"
  },
  {
    "function_name": "make_one_node_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "74-110",
    "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\", node);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_domain_bus_and_slot(0, pci_bus,\n\t\t\t\t\t\t  ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);",
      "static u8* pci_to_OF_bus_map;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_node_map",
          "args": [
            "node",
            "dev->subordinate->number"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "make_one_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "74-110",
          "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\", node);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_domain_bus_and_slot(0, pci_bus,\n\t\t\t\t\t\t  ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_domain_bus_and_slot",
          "args": [
            "0",
            "pci_bus",
            "((reg[0] >> 8) & 0xff)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"reg\"",
            "NULL"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"class-code\"",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_child_of_node",
          "args": [
            "node",
            "node"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\"",
            "node"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"bus-range\"",
            "&len"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nstatic void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %pOF, \"\n\t\t       \"assuming it starts at 0\\n\", node);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_domain_bus_and_slot(0, pci_bus,\n\t\t\t\t\t\t  ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}"
  },
  {
    "function_name": "fixup_cpc710_pci64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "58-68",
    "snippet": "static void\nfixup_cpc710_pci64(struct pci_dev* dev)\n{\n\t/* Hide the PCI64 BARs from the kernel as their content doesn't\n\t * fit well in the resource management\n\t */\n\tdev->resource[0].start = dev->resource[0].end = 0;\n\tdev->resource[0].flags = 0;\n\tdev->resource[1].start = dev->resource[1].end = 0;\n\tdev->resource[1].flags = 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\n\nstatic void\nfixup_cpc710_pci64(struct pci_dev* dev)\n{\n\t/* Hide the PCI64 BARs from the kernel as their content doesn't\n\t * fit well in the resource management\n\t */\n\tdev->resource[0].start = dev->resource[0].end = 0;\n\tdev->resource[0].flags = 0;\n\tdev->resource[1].start = dev->resource[1].end = 0;\n\tdev->resource[1].flags = 0;\n}"
  },
  {
    "function_name": "pciconfig_iobase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "296-320",
    "snippet": "SYSCALL_DEFINE3(pciconfig_iobase, long, which,\n\t\tunsigned long, bus, unsigned long, devfn)\n{\n\tstruct pci_controller* hose;\n\tlong result = -EOPNOTSUPP;\n\n\those = pci_bus_to_hose(bus);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn (long)isa_mem_base;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/memblock.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base     = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base     = 0;\n\nSYSCALL_DEFINE3(pciconfig_iobase, long, which,\n\t\tunsigned long, bus, unsigned long, devfn)\n{\n\tstruct pci_controller* hose;\n\tlong result = -EOPNOTSUPP;\n\n\those = pci_bus_to_hose(bus);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn (long)isa_mem_base;\n\t}\n\n\treturn result;\n}"
  }
]