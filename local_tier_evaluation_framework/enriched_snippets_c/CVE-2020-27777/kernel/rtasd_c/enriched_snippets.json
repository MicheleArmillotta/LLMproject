[
  {
    "function_name": "rtasmsgs_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "578-581",
    "snippet": "static int __init rtasmsgs_setup(char *str)\n{\n\treturn (kstrtobool(str, &full_rtas_msgs) == 0);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool full_rtas_msgs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&full_rtas_msgs"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\n\nstatic int __init rtasmsgs_setup(char *str)\n{\n\treturn (kstrtobool(str, &full_rtas_msgs) == 0);\n}"
  },
  {
    "function_name": "surveillance_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "561-575",
    "snippet": "static int __init surveillance_setup(char *str)\n{\n\tint i;\n\n\t/* We only do surveillance on pseries */\n\tif (!machine_is(pseries))\n\t\treturn 0;\n\n\tif (get_option(&str,&i)) {\n\t\tif (i >= 0 && i <= 255)\n\t\t\tsurveillance_timeout = i;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int surveillance_timeout = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&i"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int surveillance_timeout = -1;\n\nstatic int __init surveillance_setup(char *str)\n{\n\tint i;\n\n\t/* We only do surveillance on pseries */\n\tif (!machine_is(pseries))\n\t\treturn 0;\n\n\tif (get_option(&str,&i)) {\n\t\tif (i >= 0 && i <= 255)\n\t\t\tsurveillance_timeout = i;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "rtas_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "542-558",
    "snippet": "static int __init rtas_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\tif (!rtas_log_buf)\n\t\treturn -ENODEV;\n\n\tentry = proc_create(\"powerpc/rtas/error_log\", 0400, NULL,\n\t\t\t    &rtas_log_proc_ops);\n\tif (!entry)\n\t\tprintk(KERN_ERR \"Failed to create error_log proc entry\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_log_buf;",
      "static const struct proc_ops rtas_log_proc_ops = {\n\t.proc_read\t= rtas_log_read,\n\t.proc_poll\t= rtas_log_poll,\n\t.proc_open\t= rtas_log_open,\n\t.proc_release\t= rtas_log_release,\n\t.proc_lseek\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Failed to create error_log proc entry\\n\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"powerpc/rtas/error_log\"",
            "0400",
            "NULL",
            "&rtas_log_proc_ops"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "chrp"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_log_buf;\nstatic const struct proc_ops rtas_log_proc_ops = {\n\t.proc_read\t= rtas_log_read,\n\t.proc_poll\t= rtas_log_poll,\n\t.proc_open\t= rtas_log_open,\n\t.proc_release\t= rtas_log_release,\n\t.proc_lseek\t= noop_llseek,\n};\n\nstatic int __init rtas_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\tif (!rtas_log_buf)\n\t\treturn -ENODEV;\n\n\tentry = proc_create(\"powerpc/rtas/error_log\", 0400, NULL,\n\t\t\t    &rtas_log_proc_ops);\n\tif (!entry)\n\t\tprintk(KERN_ERR \"Failed to create error_log proc entry\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_event_scan_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "501-539",
    "snippet": "static int __init rtas_event_scan_init(void)\n{\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\t/* No RTAS */\n\tevent_scan = rtas_token(\"event-scan\");\n\tif (event_scan == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_INFO \"rtasd: No event-scan on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trtas_event_scan_rate = rtas_token(\"rtas-event-scan-rate\");\n\tif (rtas_event_scan_rate == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!rtas_event_scan_rate) {\n\t\t/* Broken firmware: take a rate of zero to mean don't scan */\n\t\tprintk(KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Make room for the sequence number */\n\trtas_error_log_max = rtas_get_error_log_max();\n\trtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);\n\n\trtas_log_buf = vmalloc(array_size(LOG_NUMBER,\n\t\t\t\t\t  rtas_error_log_buffer_max));\n\tif (!rtas_log_buf) {\n\t\tprintk(KERN_ERR \"rtasd: no memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstart_event_scan();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_log_buf;",
      "static unsigned int rtas_error_log_max;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static unsigned int event_scan;",
      "static unsigned int rtas_event_scan_rate;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_event_scan",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "start_event_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "481-492",
          "snippet": "static void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretrieve_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_event_scan_rate;",
            "static unsigned long event_scan_delay = 1*HZ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_event_scan_rate;\nstatic unsigned long event_scan_delay = 1*HZ;\n\nstatic void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretrieve_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: no memory\\n\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "array_size(LOG_NUMBER,\n\t\t\t\t\t  rtas_error_log_buffer_max)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_size",
          "args": [
            "LOG_NUMBER",
            "rtas_error_log_buffer_max"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "339-353",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-event-scan-rate\""
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "317-324",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"rtasd: No event-scan on system\\n\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "chrp"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_log_buf;\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic unsigned int event_scan;\nstatic unsigned int rtas_event_scan_rate;\n\nstatic int __init rtas_event_scan_init(void)\n{\n\tif (!machine_is(pseries) && !machine_is(chrp))\n\t\treturn 0;\n\n\t/* No RTAS */\n\tevent_scan = rtas_token(\"event-scan\");\n\tif (event_scan == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_INFO \"rtasd: No event-scan on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trtas_event_scan_rate = rtas_token(\"rtas-event-scan-rate\");\n\tif (rtas_event_scan_rate == RTAS_UNKNOWN_SERVICE) {\n\t\tprintk(KERN_ERR \"rtasd: no rtas-event-scan-rate on system\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!rtas_event_scan_rate) {\n\t\t/* Broken firmware: take a rate of zero to mean don't scan */\n\t\tprintk(KERN_DEBUG \"rtasd: scan rate is 0, not scanning\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Make room for the sequence number */\n\trtas_error_log_max = rtas_get_error_log_max();\n\trtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);\n\n\trtas_log_buf = vmalloc(array_size(LOG_NUMBER,\n\t\t\t\t\t  rtas_error_log_buffer_max));\n\tif (!rtas_log_buf) {\n\t\tprintk(KERN_ERR \"rtasd: no memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstart_event_scan();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_cancel_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "495-498",
    "snippet": "void rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&event_scan_work"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nvoid rtas_cancel_event_scan(void)\n{\n\tcancel_delayed_work_sync(&event_scan_work);\n}"
  },
  {
    "function_name": "start_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "481-492",
    "snippet": "static void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretrieve_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_event_scan_rate;",
      "static unsigned long event_scan_delay = 1*HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpumask_first(cpu_online_mask)",
            "&event_scan_work",
            "event_scan_delay"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retrieve_nvram_error_log",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_nvram_error_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "476-478",
          "snippet": "static void retrieve_nvram_error_log(void)\n{\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void retrieve_nvram_error_log(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: will sleep for %d milliseconds\\n\"",
            "(30000 / rtas_event_scan_rate)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"RTAS daemon started\\n\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_event_scan_rate;\nstatic unsigned long event_scan_delay = 1*HZ;\n\nstatic void start_event_scan(void)\n{\n\tprintk(KERN_DEBUG \"RTAS daemon started\\n\");\n\tpr_debug(\"rtasd: will sleep for %d milliseconds\\n\",\n\t\t (30000 / rtas_event_scan_rate));\n\n\t/* Retrieve errors from nvram if any */\n\tretrieve_nvram_error_log();\n\n\tschedule_delayed_work_on(cpumask_first(cpu_online_mask),\n\t\t\t\t &event_scan_work, event_scan_delay);\n}"
  },
  {
    "function_name": "retrieve_nvram_error_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "476-478",
    "snippet": "static void retrieve_nvram_error_log(void)\n{\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void retrieve_nvram_error_log(void)\n{\n}"
  },
  {
    "function_name": "retrieve_nvram_error_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "458-474",
    "snippet": "static void retrieve_nvram_error_log(void)\n{\n\tunsigned int err_type ;\n\tint rc ;\n\n\t/* See if we have any error stored in NVRAM */\n\tmemset(logdata, 0, rtas_error_log_max);\n\trc = nvram_read_error_log(logdata, rtas_error_log_max,\n\t                          &err_type, &error_log_cnt);\n\t/* We can use rtas_log_buf now */\n\tlogging_enabled = 1;\n\tif (!rc) {\n\t\tif (err_type != ERR_FLAG_ALREADY_LOGGED) {\n\t\t\tpSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_log_buf;",
      "static unsigned int rtas_error_log_max;",
      "static int logging_enabled;",
      "static int error_log_cnt;",
      "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pSeries_log_error",
          "args": [
            "logdata",
            "err_type | ERR_FLAG_BOOT",
            "0"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "198-274",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_read_error_log",
          "args": [
            "logdata",
            "rtas_error_log_max",
            "&err_type",
            "&error_log_cnt"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "logdata",
            "0",
            "rtas_error_log_max"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_log_buf;\nstatic unsigned int rtas_error_log_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void retrieve_nvram_error_log(void)\n{\n\tunsigned int err_type ;\n\tint rc ;\n\n\t/* See if we have any error stored in NVRAM */\n\tmemset(logdata, 0, rtas_error_log_max);\n\trc = nvram_read_error_log(logdata, rtas_error_log_max,\n\t                          &err_type, &error_log_cnt);\n\t/* We can use rtas_log_buf now */\n\tlogging_enabled = 1;\n\tif (!rc) {\n\t\tif (err_type != ERR_FLAG_ALREADY_LOGGED) {\n\t\t\tpSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rtas_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "426-455",
    "snippet": "static void rtas_event_scan(struct work_struct *w)\n{\n\tunsigned int cpu;\n\n\tdo_event_scan();\n\n\tget_online_cpus();\n\n\t/* raw_ OK because just using CPU as starting point. */\n\tcpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n        if (cpu >= nr_cpu_ids) {\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t\tif (first_pass) {\n\t\t\tfirst_pass = 0;\n\t\t\tevent_scan_delay = 30*HZ/rtas_event_scan_rate;\n\n\t\t\tif (surveillance_timeout != -1) {\n\t\t\t\tpr_debug(\"rtasd: enabling surveillance\\n\");\n\t\t\t\tenable_surveillance(surveillance_timeout);\n\t\t\t\tpr_debug(\"rtasd: surveillance enabled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tschedule_delayed_work_on(cpu, &event_scan_work,\n\t\t__round_jiffies_relative(event_scan_delay, cpu));\n\n\tput_online_cpus();\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int surveillance_timeout = -1;",
      "static unsigned int rtas_event_scan_rate;",
      "static void rtas_event_scan(struct work_struct *w);",
      "static DECLARE_DELAYED_WORK(event_scan_work, rtas_event_scan);",
      "static unsigned long event_scan_delay = 1*HZ;",
      "static int first_pass = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work_on",
          "args": [
            "cpu",
            "&event_scan_work",
            "__round_jiffies_relative(event_scan_delay, cpu)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__round_jiffies_relative",
          "args": [
            "event_scan_delay",
            "cpu"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: surveillance enabled\\n\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_surveillance",
          "args": [
            "surveillance_timeout"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "enable_surveillance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "374-390",
          "snippet": "static int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: enabling surveillance\\n\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "raw_smp_processor_id()",
            "cpu_online_mask"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_event_scan",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "do_event_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "392-414",
          "snippet": "static void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tif (rtas_error_type((struct rtas_error_log *)logdata) !=\n\t\t\t    RTAS_TYPE_PRRN)\n\t\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG,\n\t\t\t\t\t\t  0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_error_log_max;",
            "static unsigned int event_scan;",
            "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int event_scan;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tif (rtas_error_type((struct rtas_error_log *)logdata) !=\n\t\t\t    RTAS_TYPE_PRRN)\n\t\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG,\n\t\t\t\t\t\t  0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int surveillance_timeout = -1;\nstatic unsigned int rtas_event_scan_rate;\nstatic void rtas_event_scan(struct work_struct *w);\nstatic DECLARE_DELAYED_WORK(event_scan_work, rtas_event_scan);\nstatic unsigned long event_scan_delay = 1*HZ;\nstatic int first_pass = 1;\n\nstatic void rtas_event_scan(struct work_struct *w)\n{\n\tunsigned int cpu;\n\n\tdo_event_scan();\n\n\tget_online_cpus();\n\n\t/* raw_ OK because just using CPU as starting point. */\n\tcpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n        if (cpu >= nr_cpu_ids) {\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t\tif (first_pass) {\n\t\t\tfirst_pass = 0;\n\t\t\tevent_scan_delay = 30*HZ/rtas_event_scan_rate;\n\n\t\t\tif (surveillance_timeout != -1) {\n\t\t\t\tpr_debug(\"rtasd: enabling surveillance\\n\");\n\t\t\t\tenable_surveillance(surveillance_timeout);\n\t\t\t\tpr_debug(\"rtasd: surveillance enabled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tschedule_delayed_work_on(cpu, &event_scan_work,\n\t\t__round_jiffies_relative(event_scan_delay, cpu));\n\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "do_event_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "392-414",
    "snippet": "static void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tif (rtas_error_type((struct rtas_error_log *)logdata) !=\n\t\t\t    RTAS_TYPE_PRRN)\n\t\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG,\n\t\t\t\t\t\t  0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_error_log_max;",
      "static unsigned int event_scan;",
      "static unsigned char logdata[RTAS_ERROR_LOG_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_rtas_event",
          "args": [
            "(struct rtas_error_log *)logdata"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rtas_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "276-283",
          "snippet": "static void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (!machine_is(pseries))\n\t\treturn;\n\n\tif (rtas_error_type(log) == RTAS_TYPE_PRRN)\n\t\tpr_info_ratelimited(\"Platform resource reassignment ignored.\\n\");\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (!machine_is(pseries))\n\t\treturn;\n\n\tif (rtas_error_type(log) == RTAS_TYPE_PRRN)\n\t\tpr_info_ratelimited(\"Platform resource reassignment ignored.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pSeries_log_error",
          "args": [
            "logdata",
            "ERR_TYPE_RTAS_LOG",
            "0"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "198-274",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "(struct rtas_error_log *)logdata"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"event-scan failed\\n\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "event_scan",
            "4",
            "1",
            "NULL",
            "RTAS_EVENT_SCAN_ALL_EVENTS",
            "0",
            "__pa(logdata)",
            "rtas_error_log_max"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call_reentrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "918-949",
          "snippet": "int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tstruct rtas_args *args;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\n\t/* We use the per-cpu (PACA) rtas args buffer */\n\targs = local_paca->rtas_args_reentrant;\n\n\tva_start(list, outputs);\n\tva_rtas_call_unlocked(args, token, nargs, nret, list);\n\tva_end(list);\n\n\tif (nret > 1 && outputs)\n\t\tfor (i = 0; i < nret - 1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(args->rets[i + 1]);\n\n\tif (nret > 0)\n\t\tret = be32_to_cpu(args->rets[0]);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "logdata"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "logdata",
            "0",
            "rtas_error_log_max"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\nstatic unsigned int event_scan;\nstatic unsigned char logdata[RTAS_ERROR_LOG_MAX];\n\nstatic void do_event_scan(void)\n{\n\tint error;\n\tdo {\n\t\tmemset(logdata, 0, rtas_error_log_max);\n\t\terror = rtas_call(event_scan, 4, 1, NULL,\n\t\t\t\t  RTAS_EVENT_SCAN_ALL_EVENTS, 0,\n\t\t\t\t  __pa(logdata), rtas_error_log_max);\n\t\tif (error == -1) {\n\t\t\tprintk(KERN_ERR \"event-scan failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tif (rtas_error_type((struct rtas_error_log *)logdata) !=\n\t\t\t    RTAS_TYPE_PRRN)\n\t\t\t\tpSeries_log_error(logdata, ERR_TYPE_RTAS_LOG,\n\t\t\t\t\t\t  0);\n\t\t\thandle_rtas_event((struct rtas_error_log *)logdata);\n\t\t}\n\n\t} while(error == 0);\n}"
  },
  {
    "function_name": "enable_surveillance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "374-390",
    "snippet": "static int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtasd: could not update surveillance\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"rtasd: surveillance not supported\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_set_indicator",
          "args": [
            "SURVEILLANCE_TOKEN",
            "0",
            "timeout"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_set_indicator_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "668-685",
          "snippet": "int rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int enable_surveillance(int timeout)\n{\n\tint error;\n\n\terror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\n\n\tif (error == 0)\n\t\treturn 0;\n\n\tif (error == -EINVAL) {\n\t\tprintk(KERN_DEBUG \"rtasd: surveillance not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_ERR \"rtasd: could not update surveillance\\n\");\n\treturn -1;\n}"
  },
  {
    "function_name": "rtas_log_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "358-364",
    "snippet": "static __poll_t rtas_log_poll(struct file *file, poll_table * wait)\n{\n\tpoll_wait(file, &rtas_log_wait, wait);\n\tif (rtas_log_size)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static unsigned long rtas_log_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&rtas_log_wait",
            "wait"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic unsigned long rtas_log_size;\n\nstatic __poll_t rtas_log_poll(struct file *file, poll_table * wait)\n{\n\tpoll_wait(file, &rtas_log_wait, wait);\n\tif (rtas_log_size)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_log_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "299-356",
    "snippet": "static ssize_t rtas_log_read(struct file * file, char __user * buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint error;\n\tchar *tmp;\n\tunsigned long s;\n\tunsigned long offset;\n\n\tif (!buf || count < rtas_error_log_buffer_max)\n\t\treturn -EINVAL;\n\n\tcount = rtas_error_log_buffer_max;\n\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* if it's 0, then we know we got the last one (the one in NVRAM) */\n\twhile (rtas_log_size == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!logging_enabled) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_PPC64\n\t\tnvram_clear_error_log();\n#endif /* CONFIG_PPC64 */\n\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\terror = wait_event_interruptible(rtas_log_wait, rtas_log_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&rtasd_log_lock, s);\n\t}\n\n\toffset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);\n\tmemcpy(tmp, &rtas_log_buf[offset], count);\n\n\trtas_log_start += 1;\n\trtas_log_size -= 1;\n\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\n\terror = copy_to_user(buf, tmp, count) ? -EFAULT : count;\nout:\n\tkfree(tmp);\n\treturn error;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(rtasd_log_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static char *rtas_log_buf;",
      "static unsigned long rtas_log_start;",
      "static unsigned long rtas_log_size;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static int logging_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "tmp",
            "count"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "&rtas_log_buf[offset]",
            "count"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "rtas_log_wait",
            "rtas_log_size"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_clear_error_log",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "buf",
            "count"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\n\nstatic ssize_t rtas_log_read(struct file * file, char __user * buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint error;\n\tchar *tmp;\n\tunsigned long s;\n\tunsigned long offset;\n\n\tif (!buf || count < rtas_error_log_buffer_max)\n\t\treturn -EINVAL;\n\n\tcount = rtas_error_log_buffer_max;\n\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* if it's 0, then we know we got the last one (the one in NVRAM) */\n\twhile (rtas_log_size == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!logging_enabled) {\n\t\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\t\terror = -ENODATA;\n\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_PPC64\n\t\tnvram_clear_error_log();\n#endif /* CONFIG_PPC64 */\n\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\terror = wait_event_interruptible(rtas_log_wait, rtas_log_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tspin_lock_irqsave(&rtasd_log_lock, s);\n\t}\n\n\toffset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);\n\tmemcpy(tmp, &rtas_log_buf[offset], count);\n\n\trtas_log_start += 1;\n\trtas_log_size -= 1;\n\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\n\terror = copy_to_user(buf, tmp, count) ? -EFAULT : count;\nout:\n\tkfree(tmp);\n\treturn error;\n}"
  },
  {
    "function_name": "rtas_log_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "290-293",
    "snippet": "static int rtas_log_release(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int rtas_log_release(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "rtas_log_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "285-288",
    "snippet": "static int rtas_log_open(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int rtas_log_open(struct inode * inode, struct file * file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_rtas_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "276-283",
    "snippet": "static void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (!machine_is(pseries))\n\t\treturn;\n\n\tif (rtas_error_type(log) == RTAS_TYPE_PRRN)\n\t\tpr_info_ratelimited(\"Platform resource reassignment ignored.\\n\");\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"Platform resource reassignment ignored.\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "log"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic void handle_rtas_event(const struct rtas_error_log *log)\n{\n\tif (!machine_is(pseries))\n\t\treturn;\n\n\tif (rtas_error_type(log) == RTAS_TYPE_PRRN)\n\t\tpr_info_ratelimited(\"Platform resource reassignment ignored.\\n\");\n}"
  },
  {
    "function_name": "pSeries_log_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "198-274",
    "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(rtasd_log_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
      "static char *rtas_log_buf;",
      "static unsigned long rtas_log_start;",
      "static unsigned long rtas_log_size;",
      "static unsigned int rtas_error_log_buffer_max;",
      "static int logging_enabled;",
      "static int error_log_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&rtas_log_wait"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rtas_log_buf[offset]",
            "buf",
            "len"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_log_rtas",
          "args": [
            "buf",
            "len"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_write_error_log",
          "args": [
            "buf",
            "len",
            "err_type",
            "error_log_cnt"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rtas_len",
          "args": [
            "buf"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "log_rtas_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "159-182",
          "snippet": "static int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int rtas_error_log_max;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\n\nstatic int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtasd_log_lock",
            "s"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rtasd: logging event\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "log_rtas_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "159-182",
    "snippet": "static int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int rtas_error_log_max;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
          "lines": "339-353",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_extended",
          "args": [
            "err"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_extended_log_length",
          "args": [
            "err"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic unsigned int rtas_error_log_max;\n\nstatic int log_rtas_len(char * buf)\n{\n\tint len;\n\tstruct rtas_error_log *err;\n\tuint32_t extended_log_length;\n\n\t/* rtas fixed header */\n\tlen = 8;\n\terr = (struct rtas_error_log *)buf;\n\textended_log_length = rtas_error_extended_log_length(err);\n\tif (rtas_error_extended(err) && extended_log_length) {\n\n\t\t/* extended header */\n\t\tlen += extended_log_length;\n\t}\n\n\tif (rtas_error_log_max == 0)\n\t\trtas_error_log_max = rtas_get_error_log_max();\n\n\tif (len > rtas_error_log_max)\n\t\tlen = rtas_error_log_max;\n\n\treturn len;\n}"
  },
  {
    "function_name": "printk_log_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "110-157",
    "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool full_rtas_msgs;",
      "static int error_log_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\"",
            "error_log_cnt",
            "rtas_event_type(rtas_error_type(errlog))",
            "rtas_error_type(errlog)",
            "rtas_error_severity(errlog)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_severity",
          "args": [
            "errlog"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "errlog"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_event_type",
          "args": [
            "rtas_error_type(errlog)"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_event_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "70-95",
          "snippet": "static char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t\tcase RTAS_TYPE_HOTPLUG:\n\t\t\treturn \"Hotplug Event\";\n\t}\n\n\treturn rtas_type[0];\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};\n\nstatic char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t\tcase RTAS_TYPE_HOTPLUG:\n\t\t\treturn \"Hotplug Event\";\n\t}\n\n\treturn rtas_type[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_error_type",
          "args": [
            "errlog"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"%d -------- %s end ----------\\n\"",
            "error_log_cnt",
            "str"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s\\n\"",
            "buffer"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer+n",
            "\"%02x\"",
            "(unsigned char)buf[i]"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer+n",
            "\" \""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"RTAS %d:\"",
            "i/perline"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "122-147",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "RTAS_DEBUG \"%d -------- %s begin --------\\n\"",
            "error_log_cnt",
            "str"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
  },
  {
    "function_name": "rtas_event_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
    "lines": "70-95",
    "snippet": "static char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t\tcase RTAS_TYPE_HOTPLUG:\n\t\t\treturn \"Hotplug Event\";\n\t}\n\n\treturn rtas_type[0];\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/machdep.h>",
      "#include <linux/atomic.h>",
      "#include <asm/nvram.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/topology.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/cpu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/init.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic char *rtas_type[] = {\n\t\"Unknown\", \"Retry\", \"TCE Error\", \"Internal Device Failure\",\n\t\"Timeout\", \"Data Parity\", \"Address Parity\", \"Cache Parity\",\n\t\"Address Invalid\", \"ECC Uncorrected\", \"ECC Corrupted\",\n};\n\nstatic char *rtas_event_type(int type)\n{\n\tif ((type > 0) && (type < 11))\n\t\treturn rtas_type[type];\n\n\tswitch (type) {\n\t\tcase RTAS_TYPE_EPOW:\n\t\t\treturn \"EPOW\";\n\t\tcase RTAS_TYPE_PLATFORM:\n\t\t\treturn \"Platform Error\";\n\t\tcase RTAS_TYPE_IO:\n\t\t\treturn \"I/O Event\";\n\t\tcase RTAS_TYPE_INFO:\n\t\t\treturn \"Platform Information Event\";\n\t\tcase RTAS_TYPE_DEALLOC:\n\t\t\treturn \"Resource Deallocation Event\";\n\t\tcase RTAS_TYPE_DUMP:\n\t\t\treturn \"Dump Notification Event\";\n\t\tcase RTAS_TYPE_PRRN:\n\t\t\treturn \"Platform Resource Reassignment Event\";\n\t\tcase RTAS_TYPE_HOTPLUG:\n\t\t\treturn \"Hotplug Event\";\n\t}\n\n\treturn rtas_type[0];\n}"
  }
]