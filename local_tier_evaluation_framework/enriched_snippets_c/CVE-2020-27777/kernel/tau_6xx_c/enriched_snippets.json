[
  {
    "function_name": "tau_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "237-240",
    "snippet": "u32 tau_interrupts(unsigned long cpu)\n{\n\treturn (tau[cpu].interrupts);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nu32 tau_interrupts(unsigned long cpu)\n{\n\treturn (tau[cpu].interrupts);\n}"
  },
  {
    "function_name": "cpu_temp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "232-235",
    "snippet": "u32 cpu_temp(unsigned long cpu)\n{\n\treturn ((tau[cpu].high + tau[cpu].low) / 2);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nu32 cpu_temp(unsigned long cpu)\n{\n\treturn ((tau[cpu].high + tau[cpu].low) / 2);\n}"
  },
  {
    "function_name": "cpu_temp_both",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "227-230",
    "snippet": "u32 cpu_temp_both(unsigned long cpu)\n{\n\treturn ((tau[cpu].high << 16) | tau[cpu].low);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nu32 cpu_temp_both(unsigned long cpu)\n{\n\treturn ((tau[cpu].high << 16) | tau[cpu].low);\n}"
  },
  {
    "function_name": "TAU_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "192-219",
    "snippet": "static int __init TAU_init(void)\n{\n\t/* We assume in SMP that if one CPU has TAU support, they\n\t * all have it --BenH\n\t */\n\tif (!cpu_has_feature(CPU_FTR_TAU)) {\n\t\tprintk(\"Thermal assist unit not available\\n\");\n\t\ttau_initialized = 0;\n\t\treturn 1;\n\t}\n\n\ttau_int_enable = IS_ENABLED(CONFIG_TAU_INT) &&\n\t\t\t !strcmp(cur_cpu_spec->platform, \"ppc750\");\n\n\ttau_workq = alloc_workqueue(\"tau\", WQ_UNBOUND, 1, 0);\n\tif (!tau_workq)\n\t\treturn -ENOMEM;\n\n\ton_each_cpu(TAU_init_smp, NULL, 0);\n\n\tqueue_work(tau_workq, &tau_work);\n\n\tpr_info(\"Thermal assist unit using %s, shrink_timer: %d ms\\n\",\n\t\ttau_int_enable ? \"interrupts\" : \"workqueue\", shrink_timer);\n\ttau_initialized = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define shrink_timer\t2000\t/* period between shrinking the window */"
    ],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];",
      "static bool tau_int_enable;",
      "static struct workqueue_struct *tau_workq;",
      "int tau_initialized = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Thermal assist unit using %s, shrink_timer: %d ms\\n\"",
            "tau_int_enable ? \"interrupts\" : \"workqueue\"",
            "shrink_timer"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "tau_workq",
            "&tau_work"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "TAU_init_smp",
            "NULL",
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"tau\"",
            "WQ_UNBOUND",
            "1",
            "0"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cur_cpu_spec->platform",
            "\"ppc750\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TAU_INT"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Thermal assist unit not available\\n\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TAU"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define shrink_timer\t2000\t/* period between shrinking the window */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\nstatic bool tau_int_enable;\nstatic struct workqueue_struct *tau_workq;\nint tau_initialized = 0;\n\nstatic int __init TAU_init(void)\n{\n\t/* We assume in SMP that if one CPU has TAU support, they\n\t * all have it --BenH\n\t */\n\tif (!cpu_has_feature(CPU_FTR_TAU)) {\n\t\tprintk(\"Thermal assist unit not available\\n\");\n\t\ttau_initialized = 0;\n\t\treturn 1;\n\t}\n\n\ttau_int_enable = IS_ENABLED(CONFIG_TAU_INT) &&\n\t\t\t !strcmp(cur_cpu_spec->platform, \"ppc750\");\n\n\ttau_workq = alloc_workqueue(\"tau\", WQ_UNBOUND, 1, 0);\n\tif (!tau_workq)\n\t\treturn -ENOMEM;\n\n\ton_each_cpu(TAU_init_smp, NULL, 0);\n\n\tqueue_work(tau_workq, &tau_work);\n\n\tpr_info(\"Thermal assist unit using %s, shrink_timer: %d ms\\n\",\n\t\ttau_int_enable ? \"interrupts\" : \"workqueue\", shrink_timer);\n\ttau_initialized = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "TAU_init_smp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "180-190",
    "snippet": "static void __init TAU_init_smp(void *info)\n{\n\tunsigned long cpu = smp_processor_id();\n\n\t/* set these to a reasonable value and let the timer shrink the\n\t * window */\n\ttau[cpu].low = 5;\n\ttau[cpu].high = 120;\n\n\tset_thresholds(cpu);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thresholds",
          "args": [
            "cpu"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "set_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "55-64",
          "snippet": "static void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];",
            "static bool tau_int_enable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\nstatic bool tau_int_enable;\n\nstatic void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nstatic void __init TAU_init_smp(void *info)\n{\n\tunsigned long cpu = smp_processor_id();\n\n\t/* set these to a reasonable value and let the timer shrink the\n\t * window */\n\ttau[cpu].low = 5;\n\ttau[cpu].high = 120;\n\n\tset_thresholds(cpu);\n}"
  },
  {
    "function_name": "tau_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "161-167",
    "snippet": "static void tau_work_func(struct work_struct *work)\n{\n\tmsleep(shrink_timer);\n\ton_each_cpu(tau_timeout, NULL, 0);\n\t/* schedule ourselves to be run again */\n\tqueue_work(tau_workq, work);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define shrink_timer\t2000\t/* period between shrinking the window */"
    ],
    "globals_used": [
      "static struct workqueue_struct *tau_workq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "tau_workq",
            "work"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "tau_timeout",
            "NULL",
            "0"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "shrink_timer"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define shrink_timer\t2000\t/* period between shrinking the window */\n\nstatic struct workqueue_struct *tau_workq;\n\nstatic void tau_work_func(struct work_struct *work)\n{\n\tmsleep(shrink_timer);\n\ton_each_cpu(tau_timeout, NULL, 0);\n\t/* schedule ourselves to be run again */\n\tqueue_work(tau_workq, work);\n}"
  },
  {
    "function_name": "tau_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "116-157",
    "snippet": "static void tau_timeout(void * info)\n{\n\tint cpu;\n\tint size;\n\tint shrink;\n\n\tcpu = smp_processor_id();\n\n\tif (!tau_int_enable)\n\t\tTAUupdate(cpu);\n\n\t/* Stop thermal sensor comparisons and interrupts */\n\tmtspr(SPRN_THRM3, 0);\n\n\tsize = tau[cpu].high - tau[cpu].low;\n\tif (size > min_window && ! tau[cpu].grew) {\n\t\t/* do an exponential shrink of half the amount currently over size */\n\t\tshrink = (2 + size - min_window) / 4;\n\t\tif (shrink) {\n\t\t\ttau[cpu].low += shrink;\n\t\t\ttau[cpu].high -= shrink;\n\t\t} else { /* size must have been min_window + 1 */\n\t\t\ttau[cpu].low += 1;\n#if 1 /* debug */\n\t\t\tif ((tau[cpu].high - tau[cpu].low) != min_window){\n\t\t\t\tprintk(KERN_ERR \"temp.c: line %d, logic error\\n\", __LINE__);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\ttau[cpu].grew = 0;\n\n\tset_thresholds(cpu);\n\n\t/* Restart thermal sensor comparisons and interrupts.\n\t * The \"PowerPC 740 and PowerPC 750 Microprocessor Datasheet\"\n\t * recommends that \"the maximum value be set in THRM3 under all\n\t * conditions.\"\n\t */\n\tmtspr(SPRN_THRM3, THRM3_SITV(0x1fff) | THRM3_E);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define min_window\t2\t/* minimum window size, degrees C */"
    ],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];",
      "static bool tau_int_enable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM3",
            "THRM3_SITV(0x1fff) | THRM3_E"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM3_SITV",
          "args": [
            "0x1fff"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thresholds",
          "args": [
            "cpu"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "set_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "55-64",
          "snippet": "static void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];",
            "static bool tau_int_enable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\nstatic bool tau_int_enable;\n\nstatic void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"temp.c: line %d, logic error\\n\"",
            "__LINE__"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM3",
            "0"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAUupdate",
          "args": [
            "cpu"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "TAUupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "66-95",
          "snippet": "static void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define window_expand\t\t1\t/* expand the window by this much */",
            "#define step_size\t\t2\t/* step size when temp goes out of range */"
          ],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nstatic void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define min_window\t2\t/* minimum window size, degrees C */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\nstatic bool tau_int_enable;\n\nstatic void tau_timeout(void * info)\n{\n\tint cpu;\n\tint size;\n\tint shrink;\n\n\tcpu = smp_processor_id();\n\n\tif (!tau_int_enable)\n\t\tTAUupdate(cpu);\n\n\t/* Stop thermal sensor comparisons and interrupts */\n\tmtspr(SPRN_THRM3, 0);\n\n\tsize = tau[cpu].high - tau[cpu].low;\n\tif (size > min_window && ! tau[cpu].grew) {\n\t\t/* do an exponential shrink of half the amount currently over size */\n\t\tshrink = (2 + size - min_window) / 4;\n\t\tif (shrink) {\n\t\t\ttau[cpu].low += shrink;\n\t\t\ttau[cpu].high -= shrink;\n\t\t} else { /* size must have been min_window + 1 */\n\t\t\ttau[cpu].low += 1;\n#if 1 /* debug */\n\t\t\tif ((tau[cpu].high - tau[cpu].low) != min_window){\n\t\t\t\tprintk(KERN_ERR \"temp.c: line %d, logic error\\n\", __LINE__);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\ttau[cpu].grew = 0;\n\n\tset_thresholds(cpu);\n\n\t/* Restart thermal sensor comparisons and interrupts.\n\t * The \"PowerPC 740 and PowerPC 750 Microprocessor Datasheet\"\n\t * recommends that \"the maximum value be set in THRM3 under all\n\t * conditions.\"\n\t */\n\tmtspr(SPRN_THRM3, THRM3_SITV(0x1fff) | THRM3_E);\n}"
  },
  {
    "function_name": "TAUException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "103-113",
    "snippet": "void TAUException(struct pt_regs * regs)\n{\n\tint cpu = smp_processor_id();\n\n\tirq_enter();\n\ttau[cpu].interrupts++;\n\n\tTAUupdate(cpu);\n\n\tirq_exit();\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAUupdate",
          "args": [
            "cpu"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "TAUupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
          "lines": "66-95",
          "snippet": "static void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/8xx_immap.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/reg.h>",
            "#include <asm/io.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define window_expand\t\t1\t/* expand the window by this much */",
            "#define step_size\t\t2\t/* step size when temp goes out of range */"
          ],
          "globals_used": [
            "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nstatic void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nvoid TAUException(struct pt_regs * regs)\n{\n\tint cpu = smp_processor_id();\n\n\tirq_enter();\n\ttau[cpu].interrupts++;\n\n\tTAUupdate(cpu);\n\n\tirq_exit();\n}"
  },
  {
    "function_name": "TAUupdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "66-95",
    "snippet": "static void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define window_expand\t\t1\t/* expand the window by this much */",
      "#define step_size\t\t2\t/* step size when temp goes out of range */"
    ],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: high threshold crossed\\n\"",
            "__func__"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM2",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_THRM2"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: low threshold crossed\\n\"",
            "__func__"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM1",
            "0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_THRM1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n#define window_expand\t\t1\t/* expand the window by this much */\n#define step_size\t\t2\t/* step size when temp goes out of range */\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\n\nstatic void TAUupdate(int cpu)\n{\n\tu32 thrm;\n\tu32 bits = THRM1_TIV | THRM1_TIN | THRM1_V;\n\n\t/* if both thresholds are crossed, the step_sizes cancel out\n\t * and the window winds up getting expanded twice. */\n\tthrm = mfspr(SPRN_THRM1);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM1, 0);\n\n\t\tif (tau[cpu].low >= step_size) {\n\t\t\ttau[cpu].low -= step_size;\n\t\t\ttau[cpu].high -= (step_size - window_expand);\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: low threshold crossed\\n\", __func__);\n\t}\n\tthrm = mfspr(SPRN_THRM2);\n\tif ((thrm & bits) == bits) {\n\t\tmtspr(SPRN_THRM2, 0);\n\n\t\tif (tau[cpu].high <= 127 - step_size) {\n\t\t\ttau[cpu].low += (step_size - window_expand);\n\t\t\ttau[cpu].high += step_size;\n\t\t}\n\t\ttau[cpu].grew = 1;\n\t\tpr_debug(\"%s: high threshold crossed\\n\", __func__);\n\t}\n}"
  },
  {
    "function_name": "set_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/tau_6xx.c",
    "lines": "55-64",
    "snippet": "static void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}",
    "includes": [
      "#include \"setup.h\"",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/machdep.h>",
      "#include <asm/8xx_immap.h>",
      "#include <asm/cache.h>",
      "#include <asm/nvram.h>",
      "#include <asm/reg.h>",
      "#include <asm/io.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/param.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];",
      "static bool tau_int_enable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM2",
            "THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].high"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_THRM1",
            "THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "THRM1_THRES",
          "args": [
            "tau[cpu].low"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"setup.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/8xx_immap.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/reg.h>\n#include <asm/io.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct tau_temp\n{\n\tint interrupts;\n\tunsigned char low;\n\tunsigned char high;\n\tunsigned char grew;\n} tau[NR_CPUS];\nstatic bool tau_int_enable;\n\nstatic void set_thresholds(unsigned long cpu)\n{\n\tu32 maybe_tie = tau_int_enable ? THRM1_TIE : 0;\n\n\t/* setup THRM1, threshold, valid bit, interrupt when below threshold */\n\tmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | maybe_tie | THRM1_TID);\n\n\t/* setup THRM2, threshold, valid bit, interrupt when above threshold */\n\tmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | maybe_tie);\n}"
  }
]