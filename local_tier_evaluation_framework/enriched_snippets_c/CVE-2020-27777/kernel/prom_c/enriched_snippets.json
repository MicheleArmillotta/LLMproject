[
  {
    "function_name": "arch_match_cpu_phys_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "928-941",
    "snippet": "bool arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Early firmware scanning must use this rather than\n\t * get_hard_smp_processor_id because we don't have pacas allocated\n\t * until memory topology is discovered.\n\t */\n\tif (cpu_to_phys_id != NULL)\n\t\treturn (int)phys_id == cpu_to_phys_id[cpu];\n#endif\n\n\treturn (int)phys_id == get_hard_smp_processor_id(cpu);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "cpu"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nbool arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Early firmware scanning must use this rather than\n\t * get_hard_smp_processor_id because we don't have pacas allocated\n\t * until memory topology is discovered.\n\t */\n\tif (cpu_to_phys_id != NULL)\n\t\treturn (int)phys_id == cpu_to_phys_id[cpu];\n#endif\n\n\treturn (int)phys_id == get_hard_smp_processor_id(cpu);\n}"
  },
  {
    "function_name": "cpu_to_chip_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "915-925",
    "snippet": "int cpu_to_chip_id(int cpu)\n{\n\tstruct device_node *np;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn -1;\n\n\tof_node_put(np);\n\treturn of_get_ibm_chip_id(np);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_ibm_chip_id",
          "args": [
            "np"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "of_get_ibm_chip_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "887-905",
          "snippet": "int of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "np"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_cpu_node",
          "args": [
            "cpu",
            "NULL"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint cpu_to_chip_id(int cpu)\n{\n\tstruct device_node *np;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn -1;\n\n\tof_node_put(np);\n\treturn of_get_ibm_chip_id(np);\n}"
  },
  {
    "function_name": "of_get_ibm_chip_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "887-905",
    "snippet": "int of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_next_parent",
          "args": [
            "np"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "np"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "np",
            "\"ibm,chip-id\"",
            "&chip_id"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "np"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "early_get_first_memblock_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "849-865",
    "snippet": "void __init early_get_first_memblock_info(void *params, phys_addr_t *size)\n{\n\t/* Setup flat device-tree pointer */\n\tinitial_boot_params = params;\n\n\t/*\n\t * Scan the memory nodes and set add_mem_to_memblock to 0 to avoid\n\t * mess the memblock.\n\t */\n\tadd_mem_to_memblock = 0;\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\tadd_mem_to_memblock = 1;\n\n\tif (size)\n\t\t*size = first_memblock_size;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define add_mem_to_memblock 1"
    ],
    "globals_used": [
      "static phys_addr_t first_memblock_size;",
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_memory_ppc",
            "NULL"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_root",
            "NULL"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\n#define add_mem_to_memblock 1\n\nstatic phys_addr_t first_memblock_size;\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nvoid __init early_get_first_memblock_info(void *params, phys_addr_t *size)\n{\n\t/* Setup flat device-tree pointer */\n\tinitial_boot_params = params;\n\n\t/*\n\t * Scan the memory nodes and set add_mem_to_memblock to 0 to avoid\n\t * mess the memblock.\n\t */\n\tadd_mem_to_memblock = 0;\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\tadd_mem_to_memblock = 1;\n\n\tif (size)\n\t\t*size = first_memblock_size;\n}"
  },
  {
    "function_name": "early_init_devtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "715-842",
    "snippet": "void __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%px)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n\n\t/* Scan tree for ultravisor feature */\n\tof_scan_flat_dt(early_init_dt_scan_ultravisor, NULL);\n#endif\n\n#if defined(CONFIG_FA_DUMP) || defined(CONFIG_PRESERVE_FA_DUMP)\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#if defined(CONFIG_FA_DUMP) || defined(CONFIG_PRESERVE_FA_DUMP)\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n#if defined(CONFIG_PPC_BOOK3S_64) && defined(CONFIG_PPC_4K_PAGES)\n\tif (!early_radix_enabled())\n\t\tmemblock_cap_memory_range(0, 1UL << (H_MAX_PHYSMEM_BITS));\n#endif\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", (unsigned long long)memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_paca_ptrs();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\tdt_cpu_ftrs_scan();\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n\tsave_fscr_to_task();\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n\tmmu_early_init_devtree();\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\tepapr_paravirt_early_init();\n\n\t/* Now try to figure out if we are running on LPAR and so on */\n\tpseries_probe_fw_features();\n\n\t/*\n\t * Initialize pkey features and default AMR/IAMR values\n\t */\n\tpkey_early_init_devtree();\n\n#ifdef CONFIG_PPC_PS3\n\t/* Identify PS3 firmware */\n\tif (of_flat_dt_is_compatible(of_get_flat_dt_root(), \"sony,ps3\"))\n\t\tpowerpc_firmware_features |= FW_FEATURE_PS3_POSSIBLE;\n#endif\n\n\ttm_init();\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t first_memblock_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" <- early_init_devtree()\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_init",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "tm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "695-695",
          "snippet": "static void tm_init(void) { }",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void tm_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "of_flat_dt_is_compatible",
          "args": [
            "of_get_flat_dt_root()",
            "\"sony,ps3\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_root",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pkey_early_init_devtree",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pseries_probe_fw_features",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epapr_paravirt_early_init",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "epapr_paravirt_early_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/epapr_paravirt.c",
          "lines": "57-62",
          "snippet": "int __init epapr_paravirt_early_init(void)\n{\n\tof_scan_flat_dt(early_init_dt_scan_epapr, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/machdep.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/machdep.h>\n#include <asm/code-patching.h>\n#include <asm/cacheflush.h>\n#include <asm/epapr_hcalls.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n\nint __init epapr_paravirt_early_init(void)\n{\n\tof_scan_flat_dt(early_init_dt_scan_epapr, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_recoverable_ranges",
            "NULL"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_early_init_devtree",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_fscr_to_task",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "save_fscr_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "711-711",
          "snippet": "static inline void save_fscr_to_task(void) {}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline void save_fscr_to_task(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Failed to identify boot CPU !\\n\""
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_cpus",
            "NULL"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_cpu_ftrs_scan",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cpu_ftrs_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dt_cpu_ftrs.c",
          "lines": "1131-1137",
          "snippet": "void __init dt_cpu_ftrs_scan(void)\n{\n\tif (!using_dt_cpu_ftrs)\n\t\treturn;\n\n\tof_scan_flat_dt(dt_cpu_ftrs_scan_callback, NULL);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/prom.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <asm/mmu.h>",
            "#include <asm/mce.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/cputable.h>",
            "#include <linux/threads.h>",
            "#include <linux/string.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/memblock.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/prom.h>\n#include <asm/oprofile_impl.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/cputable.h>\n#include <linux/threads.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/memblock.h>\n#include <linux/libfdt.h>\n#include <linux/jump_label.h>\n#include <linux/init.h>\n#include <linux/export.h>\n\nvoid __init dt_cpu_ftrs_scan(void)\n{\n\tif (!using_dt_cpu_ftrs)\n\t\treturn;\n\n\tof_scan_flat_dt(dt_cpu_ftrs_scan_callback, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Scanning CPUs ...\\n\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_paca_ptrs",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_paca_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "272-283",
          "snippet": "void __init allocate_paca_ptrs(void)\n{\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\n\tpaca_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tpaca_ptrs = memblock_alloc_raw(paca_ptrs_size, SMP_CACHE_BYTES);\n\tif (!paca_ptrs)\n\t\tpanic(\"Failed to allocate %d bytes for paca pointers\\n\",\n\t\t      paca_ptrs_size);\n\n\tmemset(paca_ptrs, 0x88, paca_ptrs_size);\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nvoid __init allocate_paca_ptrs(void)\n{\n\tpaca_nr_cpu_ids = nr_cpu_ids;\n\n\tpaca_ptrs_size = sizeof(struct paca_struct *) * nr_cpu_ids;\n\tpaca_ptrs = memblock_alloc_raw(paca_ptrs_size, SMP_CACHE_BYTES);\n\tif (!paca_ptrs)\n\t\tpanic(\"Failed to allocate %d bytes for paca pointers\\n\",\n\t\t      paca_ptrs_size);\n\n\tmemset(paca_ptrs, 0x88, paca_ptrs_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_device_tree",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "move_device_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "113-136",
          "snippet": "static void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t    !memblock_is_memory(start + size - 1) ||\n\t    overlaps_crashkernel(start, size) || overlaps_initrd(start, size)) {\n\t\tp = memblock_alloc_raw(size, PAGE_SIZE);\n\t\tif (!p)\n\t\t\tpanic(\"Failed to allocate %lu bytes to move device tree\\n\",\n\t\t\t      size);\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%px\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t    !memblock_is_memory(start + size - 1) ||\n\t    overlaps_crashkernel(start, size) || overlaps_initrd(start, size)) {\n\t\tp = memblock_alloc_raw(size, PAGE_SIZE);\n\t\tif (!p)\n\t\t\tpanic(\"Failed to allocate %lu bytes to move device tree\\n\",\n\t\t\t      size);\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%px\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Phys. mem: %llx\\n\"",
            "(unsigned long long)memblock_phys_mem_size()"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_dump_all",
          "args": [],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_allow_resize",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_cap_memory_range",
          "args": [
            "0",
            "1UL << (H_MAX_PHYSMEM_BITS)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_radix_enabled",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_enforce_memory_limit",
          "args": [
            "limit"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "memory_limit ?: memblock_phys_mem_size()",
            "PAGE_SIZE"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_reserve_mem",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "early_reserve_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "623-664",
          "snippet": "static void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\tALIGN(initrd_end, PAGE_SIZE) -\n\t\t\tALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\tALIGN(initrd_end, PAGE_SIZE) -\n\t\t\tALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_crashkernel",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fadump_reserve_mem",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_reserve_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/fadump.c",
          "lines": "1666-1679",
          "snippet": "int __init fadump_reserve_mem(void)\n{\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory to preserve crash data.\n\t\t */\n\t\tpr_info(\"Preserving crash data for processing in next boot.\\n\");\n\t\tfadump_reserve_crash_area(fw_dump.boot_mem_top);\n\t} else\n\t\tpr_debug(\"FADump-aware kernel..\\n\");\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/fadump-internal.h>",
            "#include <asm/fadump.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cma.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/fadump-internal.h>\n#include <asm/fadump.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/debugfs.h>\n#include <linux/hugetlb.h>\n#include <linux/cma.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\n\nint __init fadump_reserve_mem(void)\n{\n\tif (fw_dump.dump_active) {\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot memory to preserve crash data.\n\t\t */\n\t\tpr_info(\"Preserving crash data for processing in next boot.\\n\");\n\t\tfadump_reserve_crash_area(fw_dump.boot_mem_top);\n\t} else\n\t\tpr_debug(\"FADump-aware kernel..\\n\");\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_kdump_trampoline",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_kdump_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/crash_dump.c",
          "lines": "31-34",
          "snippet": "void __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/inst.h>",
            "#include <asm/rtas.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/memblock.h>",
            "#include <linux/io.h>",
            "#include <linux/crash_dump.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/inst.h>\n#include <asm/rtas.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "MEMORY_START",
            "0x8000"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "PHYSICAL_START",
            "__pa(klimit) - PHYSICAL_START"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "klimit"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_initial_memory_limit",
          "args": [
            "memstart_addr",
            "first_memblock_size"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "first_memblock_size",
            "memory_limit"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_early_param",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_memory_ppc",
            "NULL"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_root",
            "NULL"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_chosen_ppc",
            "boot_command_line"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_fw_dump",
            "NULL"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_ultravisor",
            "NULL"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_opal",
            "NULL"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_rtas",
            "NULL"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"BUG: Failed verifying flat device tree, bad version?\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_dt_verify",
          "args": [
            "params"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> early_init_devtree(%px)\\n\"",
            "params"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic phys_addr_t first_memblock_size;\n\nvoid __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%px)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n\n\t/* Scan tree for ultravisor feature */\n\tof_scan_flat_dt(early_init_dt_scan_ultravisor, NULL);\n#endif\n\n#if defined(CONFIG_FA_DUMP) || defined(CONFIG_PRESERVE_FA_DUMP)\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#if defined(CONFIG_FA_DUMP) || defined(CONFIG_PRESERVE_FA_DUMP)\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n#if defined(CONFIG_PPC_BOOK3S_64) && defined(CONFIG_PPC_4K_PAGES)\n\tif (!early_radix_enabled())\n\t\tmemblock_cap_memory_range(0, 1UL << (H_MAX_PHYSMEM_BITS));\n#endif\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", (unsigned long long)memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_paca_ptrs();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\tdt_cpu_ftrs_scan();\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n\tsave_fscr_to_task();\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n\tmmu_early_init_devtree();\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\tepapr_paravirt_early_init();\n\n\t/* Now try to figure out if we are running on LPAR and so on */\n\tpseries_probe_fw_features();\n\n\t/*\n\t * Initialize pkey features and default AMR/IAMR values\n\t */\n\tpkey_early_init_devtree();\n\n#ifdef CONFIG_PPC_PS3\n\t/* Identify PS3 firmware */\n\tif (of_flat_dt_is_compatible(of_get_flat_dt_root(), \"sony,ps3\"))\n\t\tpowerpc_firmware_features |= FW_FEATURE_PS3_POSSIBLE;\n#endif\n\n\ttm_init();\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}"
  },
  {
    "function_name": "save_fscr_to_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "711-711",
    "snippet": "static inline void save_fscr_to_task(void) {}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline void save_fscr_to_task(void) {}"
  },
  {
    "function_name": "save_fscr_to_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "699-709",
    "snippet": "static void __init save_fscr_to_task(void)\n{\n\t/*\n\t * Ensure the init_task (pid 0, aka swapper) uses the value of FSCR we\n\t * have configured via the device tree features or via __init_FSCR().\n\t * That value will then be propagated to pid 1 (init) and all future\n\t * processes.\n\t */\n\tif (early_cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\tinit_task.thread.fscr = mfspr(SPRN_FSCR);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_FSCR"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init save_fscr_to_task(void)\n{\n\t/*\n\t * Ensure the init_task (pid 0, aka swapper) uses the value of FSCR we\n\t * have configured via the device tree features or via __init_FSCR().\n\t * That value will then be propagated to pid 1 (init) and all future\n\t * processes.\n\t */\n\tif (early_cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\tinit_task.thread.fscr = mfspr(SPRN_FSCR);\n}"
  },
  {
    "function_name": "tm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "695-695",
    "snippet": "static void tm_init(void) { }",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void tm_init(void) { }"
  },
  {
    "function_name": "tm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "682-693",
    "snippet": "static void __init tm_init(void)\n{\n\tif (tm_disabled) {\n\t\tpr_info(\"Disabling hardware transactional memory (HTM)\\n\");\n\t\tcur_cpu_spec->cpu_user_features2 &=\n\t\t\t~(PPC_FEATURE2_HTM_NOSC | PPC_FEATURE2_HTM);\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_TM;\n\t\treturn;\n\t}\n\n\tpnv_tm_init();\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnv_tm_init",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling hardware transactional memory (HTM)\\n\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init tm_init(void)\n{\n\tif (tm_disabled) {\n\t\tpr_info(\"Disabling hardware transactional memory (HTM)\\n\");\n\t\tcur_cpu_spec->cpu_user_features2 &=\n\t\t\t~(PPC_FEATURE2_HTM_NOSC | PPC_FEATURE2_HTM);\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_TM;\n\t\treturn;\n\t}\n\n\tpnv_tm_init();\n}"
  },
  {
    "function_name": "parse_ppc_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "669-679",
    "snippet": "static int __init parse_ppc_tm(char *str)\n{\n\tbool res;\n\n\tif (kstrtobool(str, &res))\n\t\treturn -EINVAL;\n\n\ttm_disabled = !res;\n\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "str",
            "&res"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __init parse_ppc_tm(char *str)\n{\n\tbool res;\n\n\tif (kstrtobool(str, &res))\n\t\treturn -EINVAL;\n\n\ttm_disabled = !res;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "early_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "623-664",
    "snippet": "static void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\tALIGN(initrd_end, PAGE_SIZE) -\n\t\t\tALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base_32",
            "size_32"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"reserving: %x -> %x\\n\"",
            "base_32",
            "size_32"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reserve_map_32++"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reserve_map_32++"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Found old 32-bit reserve map\\n\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpup",
          "args": [
            "reserve_map"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE)",
            "ALIGN(initrd_end, PAGE_SIZE) -\n\t\t\tALIGN_DOWN(initrd_start, PAGE_SIZE)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "initrd_start",
            "PAGE_SIZE"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "initrd_end",
            "PAGE_SIZE"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "__pa(initrd_start)",
            "PAGE_SIZE"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "initrd_start"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_reserve_mem_dt",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "early_reserve_mem_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "590-621",
          "snippet": "static void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdt_off_mem_rsvmap",
          "args": [
            "initial_boot_params"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\tALIGN(initrd_end, PAGE_SIZE) -\n\t\t\tALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}"
  },
  {
    "function_name": "early_reserve_mem_dt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "590-621",
    "snippet": "static void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"reserving: %llx -> %llx\\n\"",
            "base",
            "size"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 2",
            "2"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 0",
            "2"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Found new-style reserved-ranges\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "dt_root",
            "\"reserved-ranges\"",
            "&len"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_root",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_fdt_scan_reserved_mem",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_fdt_reserve_self",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "early_init_dt_add_memory_arch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "564-588",
    "snippet": "void __init early_init_dt_add_memory_arch(u64 base, u64 size)\n{\n#ifdef CONFIG_PPC64\n\tif (iommu_is_off) {\n\t\tif (base >= 0x80000000ul)\n\t\t\treturn;\n\t\tif ((base + size) > 0x80000000ul)\n\t\t\tsize = 0x80000000ul - base;\n\t}\n#endif\n\t/* Keep track of the beginning of memory -and- the size of\n\t * the very first block in the device-tree as it represents\n\t * the RMA on ppc64 server\n\t */\n\tif (base < memstart_addr) {\n\t\tmemstart_addr = base;\n\t\tfirst_memblock_size = size;\n\t}\n\n\t/* Add the chunk to the MEMBLOCK list */\n\tif (add_mem_to_memblock) {\n\t\tif (validate_mem_limit(base, &size))\n\t\t\tmemblock_add(base, size);\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define add_mem_to_memblock 1"
    ],
    "globals_used": [
      "static phys_addr_t first_memblock_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_add",
          "args": [
            "base",
            "size"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_mem_limit",
          "args": [
            "base",
            "&size"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mem_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "461-464",
          "snippet": "static bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\n#define add_mem_to_memblock 1\n\nstatic phys_addr_t first_memblock_size;\n\nvoid __init early_init_dt_add_memory_arch(u64 base, u64 size)\n{\n#ifdef CONFIG_PPC64\n\tif (iommu_is_off) {\n\t\tif (base >= 0x80000000ul)\n\t\t\treturn;\n\t\tif ((base + size) > 0x80000000ul)\n\t\t\tsize = 0x80000000ul - base;\n\t}\n#endif\n\t/* Keep track of the beginning of memory -and- the size of\n\t * the very first block in the device-tree as it represents\n\t * the RMA on ppc64 server\n\t */\n\tif (base < memstart_addr) {\n\t\tmemstart_addr = base;\n\t\tfirst_memblock_size = size;\n\t}\n\n\t/* Add the chunk to the MEMBLOCK list */\n\tif (add_mem_to_memblock) {\n\t\tif (validate_mem_limit(base, &size))\n\t\t\tmemblock_add(base, size);\n\t}\n}"
  },
  {
    "function_name": "early_init_dt_scan_memory_ppc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "535-548",
    "snippet": "static int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0) {\n\t\twalk_drmem_lmbs_early(node, NULL, early_init_drmem_lmb);\n\t\treturn 0;\n\t}\n#endif\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_init_dt_scan_memory",
          "args": [
            "node",
            "uname",
            "depth",
            "data"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_memory_ppc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "535-548",
          "snippet": "static int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0) {\n\t\twalk_drmem_lmbs_early(node, NULL, early_init_drmem_lmb);\n\t\treturn 0;\n\t}\n#endif\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "walk_drmem_lmbs_early",
          "args": [
            "node",
            "NULL",
            "early_init_drmem_lmb"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"ibm,dynamic-reconfiguration-memory\""
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n#ifdef CONFIG_PPC_PSERIES\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0) {\n\t\twalk_drmem_lmbs_early(node, NULL, early_init_drmem_lmb);\n\t\treturn 0;\n\t}\n#endif\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}"
  },
  {
    "function_name": "early_init_drmem_lmb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "473-532",
    "snippet": "static int  __init early_init_drmem_lmb(struct drmem_lmb *lmb,\n\t\t\t\t\tconst __be32 **usm,\n\t\t\t\t\tvoid *data)\n{\n\tu64 base, size;\n\tint is_kexec_kdump = 0, rngs;\n\n\tbase = lmb->base_addr;\n\tsize = drmem_lmb_size();\n\trngs = 1;\n\n\t/*\n\t * Skip this block if the reserved bit is set in flags\n\t * or if the block is not assigned to this partition.\n\t */\n\tif ((lmb->flags & DRCONF_MEM_RESERVED) ||\n\t    !(lmb->flags & DRCONF_MEM_ASSIGNED))\n\t\treturn 0;\n\n\tif (*usm)\n\t\tis_kexec_kdump = 1;\n\n\tif (is_kexec_kdump) {\n\t\t/*\n\t\t * For each memblock in ibm,dynamic-memory, a\n\t\t * corresponding entry in linux,drconf-usable-memory\n\t\t * property contains a counter 'p' followed by 'p'\n\t\t * (base, size) duple. Now read the counter from\n\t\t * linux,drconf-usable-memory property\n\t\t */\n\t\trngs = dt_mem_next_cell(dt_root_size_cells, usm);\n\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\treturn 0;\n\t}\n\n\tdo {\n\t\tif (is_kexec_kdump) {\n\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells, usm);\n\t\t\tsize = dt_mem_next_cell(dt_root_size_cells, usm);\n\t\t}\n\n\t\tif (iommu_is_off) {\n\t\t\tif (base >= 0x80000000ul)\n\t\t\t\tcontinue;\n\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\tsize = 0x80000000ul - base;\n\t\t}\n\n\t\tif (!validate_mem_limit(base, &size))\n\t\t\tcontinue;\n\n\t\tDBG(\"Adding: %llx -> %llx\\n\", base, size);\n\t\tmemblock_add(base, size);\n\n\t\tif (lmb->flags & DRCONF_MEM_HOTREMOVABLE)\n\t\t\tmemblock_mark_hotplug(base, size);\n\t} while (--rngs);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_mark_hotplug",
          "args": [
            "base",
            "size"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_add",
          "args": [
            "base",
            "size"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Adding: %llx -> %llx\\n\"",
            "base",
            "size"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_mem_limit",
          "args": [
            "base",
            "&size"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "validate_mem_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "461-464",
          "snippet": "static bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_size_cells",
            "usm"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_addr_cells",
            "usm"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_size_cells",
            "usm"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drmem_lmb_size",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nstatic int  __init early_init_drmem_lmb(struct drmem_lmb *lmb,\n\t\t\t\t\tconst __be32 **usm,\n\t\t\t\t\tvoid *data)\n{\n\tu64 base, size;\n\tint is_kexec_kdump = 0, rngs;\n\n\tbase = lmb->base_addr;\n\tsize = drmem_lmb_size();\n\trngs = 1;\n\n\t/*\n\t * Skip this block if the reserved bit is set in flags\n\t * or if the block is not assigned to this partition.\n\t */\n\tif ((lmb->flags & DRCONF_MEM_RESERVED) ||\n\t    !(lmb->flags & DRCONF_MEM_ASSIGNED))\n\t\treturn 0;\n\n\tif (*usm)\n\t\tis_kexec_kdump = 1;\n\n\tif (is_kexec_kdump) {\n\t\t/*\n\t\t * For each memblock in ibm,dynamic-memory, a\n\t\t * corresponding entry in linux,drconf-usable-memory\n\t\t * property contains a counter 'p' followed by 'p'\n\t\t * (base, size) duple. Now read the counter from\n\t\t * linux,drconf-usable-memory property\n\t\t */\n\t\trngs = dt_mem_next_cell(dt_root_size_cells, usm);\n\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\treturn 0;\n\t}\n\n\tdo {\n\t\tif (is_kexec_kdump) {\n\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells, usm);\n\t\t\tsize = dt_mem_next_cell(dt_root_size_cells, usm);\n\t\t}\n\n\t\tif (iommu_is_off) {\n\t\t\tif (base >= 0x80000000ul)\n\t\t\t\tcontinue;\n\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\tsize = 0x80000000ul - base;\n\t\t}\n\n\t\tif (!validate_mem_limit(base, &size))\n\t\t\tcontinue;\n\n\t\tDBG(\"Adding: %llx -> %llx\\n\", base, size);\n\t\tmemblock_add(base, size);\n\n\t\tif (lmb->flags & DRCONF_MEM_HOTREMOVABLE)\n\t\t\tmemblock_mark_hotplug(base, size);\n\t} while (--rngs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "validate_mem_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "461-464",
    "snippet": "static bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic bool validate_mem_limit(u64 base, u64 *size)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "validate_mem_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "450-459",
    "snippet": "static bool validate_mem_limit(u64 base, u64 *size)\n{\n\tu64 max_mem = 1UL << (MAX_PHYSMEM_BITS);\n\n\tif (base >= max_mem)\n\t\treturn false;\n\tif ((base + *size) > max_mem)\n\t\t*size = max_mem - base;\n\treturn true;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic bool validate_mem_limit(u64 base, u64 *size)\n{\n\tu64 max_mem = 1UL << (MAX_PHYSMEM_BITS);\n\n\tif (base >= max_mem)\n\t\treturn false;\n\tif ((base + *size) > max_mem)\n\t\t*size = max_mem - base;\n\treturn true;\n}"
  },
  {
    "function_name": "early_init_dt_scan_chosen_ppc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "398-442",
    "snippet": "static int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC_CORE\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,crashkernel-size\"",
            "NULL"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,crashkernel-base\"",
            "NULL"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,tce-alloc-end\"",
            "NULL"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,tce-alloc-start\"",
            "NULL"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,memory-limit\"",
            "NULL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,iommu-force-on\"",
            "NULL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,iommu-off\"",
            "NULL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_dt_scan_chosen",
          "args": [
            "node",
            "uname",
            "depth",
            "data"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_chosen_ppc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "398-442",
          "snippet": "static int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC_CORE\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nstatic int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC_CORE\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}"
  },
  {
    "function_name": "early_init_dt_scan_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "308-396",
    "snippet": "static int __init early_init_dt_scan_cpus(unsigned long node,\n\t\t\t\t\t  const char *uname, int depth,\n\t\t\t\t\t  void *data)\n{\n\tconst char *type = of_get_flat_dt_prop(node, \"device_type\", NULL);\n\tconst __be32 *prop;\n\tconst __be32 *intserv;\n\tint i, nthreads;\n\tint len;\n\tint found = -1;\n\tint found_thread = 0;\n\n\t/* We are scanning \"cpu\" nodes only */\n\tif (type == NULL || strcmp(type, \"cpu\") != 0)\n\t\treturn 0;\n\n\t/* Get physical cpuid */\n\tintserv = of_get_flat_dt_prop(node, \"ibm,ppc-interrupt-server#s\", &len);\n\tif (!intserv)\n\t\tintserv = of_get_flat_dt_prop(node, \"reg\", &len);\n\n\tnthreads = len / sizeof(int);\n\n\t/*\n\t * Now see if any of these threads match our boot cpu.\n\t * NOTE: This must match the parsing done in smp_setup_cpu_maps.\n\t */\n\tfor (i = 0; i < nthreads; i++) {\n\t\tif (be32_to_cpu(intserv[i]) ==\n\t\t\tfdt_boot_cpuid_phys(initial_boot_params)) {\n\t\t\tfound = boot_cpu_count;\n\t\t\tfound_thread = i;\n\t\t}\n#ifdef CONFIG_SMP\n\t\t/* logical cpu id is always 0 on UP kernels */\n\t\tboot_cpu_count++;\n#endif\n\t}\n\n\t/* Not the boot CPU */\n\tif (found < 0)\n\t\treturn 0;\n\n\tDBG(\"boot cpu: logical %d physical %d\\n\", found,\n\t    be32_to_cpu(intserv[found_thread]));\n\tboot_cpuid = found;\n\n\t/*\n\t * PAPR defines \"logical\" PVR values for cpus that\n\t * meet various levels of the architecture:\n\t * 0x0f000001\tArchitecture version 2.04\n\t * 0x0f000002\tArchitecture version 2.05\n\t * If the cpu-version property in the cpu node contains\n\t * such a value, we call identify_cpu again with the\n\t * logical PVR value in order to use the cpu feature\n\t * bits appropriate for the architecture level.\n\t *\n\t * A POWER6 partition in \"POWER6 architected\" mode\n\t * uses the 0x0f000002 PVR value; in POWER5+ mode\n\t * it uses 0x0f000001.\n\t *\n\t * If we're using device tree CPU feature discovery then we don't\n\t * support the cpu-version property, and it's the responsibility of the\n\t * firmware/hypervisor to provide the correct feature set for the\n\t * architecture level via the ibm,powerpc-cpu-features binding.\n\t */\n\tif (!dt_cpu_ftrs_in_use()) {\n\t\tprop = of_get_flat_dt_prop(node, \"cpu-version\", NULL);\n\t\tif (prop && (be32_to_cpup(prop) & 0xff000000) == 0x0f000000)\n\t\t\tidentify_cpu(0, be32_to_cpup(prop));\n\n\t\tcheck_cpu_feature_properties(node);\n\t\tcheck_cpu_pa_features(node);\n\t}\n\n\tidentical_pvr_fixup(node);\n\tinit_mmu_slb_size(node);\n\n#ifdef CONFIG_PPC64\n\tif (nthreads == 1)\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_SMT;\n\telse if (!dt_cpu_ftrs_in_use())\n\t\tcur_cpu_spec->cpu_features |= CPU_FTR_SMT;\n\tallocate_paca(boot_cpuid);\n#endif\n\tset_hard_smp_processor_id(found, be32_to_cpu(intserv[found_thread]));\n\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_hard_smp_processor_id",
          "args": [
            "found",
            "be32_to_cpu(intserv[found_thread])"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[found_thread]"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_paca",
          "args": [
            "boot_cpuid"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_paca",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/paca.c",
          "lines": "285-317",
          "snippet": "void __init allocate_paca(int cpu)\n{\n\tu64 limit;\n\tstruct paca_struct *paca;\n\n\tBUG_ON(cpu >= paca_nr_cpu_ids);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We access pacas in real mode, and cannot take SLB faults\n\t * on them when in virtual mode, so allocate them accordingly.\n\t */\n\tlimit = min(ppc64_bolted_size(), ppc64_rma_size);\n#else\n\tlimit = ppc64_rma_size;\n#endif\n\n\tpaca = alloc_paca_data(sizeof(struct paca_struct), L1_CACHE_BYTES,\n\t\t\t\tlimit, cpu);\n\tpaca_ptrs[cpu] = paca;\n\n\tinitialise_paca(paca, cpu);\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->lppaca_ptr = new_lppaca(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tpaca->slb_shadow_ptr = new_slb_shadow(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->rtas_args_reentrant = new_rtas_args(cpu, limit);\n#endif\n\tpaca_struct_size += sizeof(struct paca_struct);\n}",
          "includes": [
            "#include \"setup.h\"",
            "#include <asm/rtas.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/svm.h>",
            "#include <asm/kexec.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/numa.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"setup.h\"\n#include <asm/rtas.h>\n#include <asm/ultravisor.h>\n#include <asm/svm.h>\n#include <asm/kexec.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/pgtable.h>\n#include <linux/numa.h>\n#include <linux/sched/task.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nvoid __init;\n\nvoid __init allocate_paca(int cpu)\n{\n\tu64 limit;\n\tstruct paca_struct *paca;\n\n\tBUG_ON(cpu >= paca_nr_cpu_ids);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We access pacas in real mode, and cannot take SLB faults\n\t * on them when in virtual mode, so allocate them accordingly.\n\t */\n\tlimit = min(ppc64_bolted_size(), ppc64_rma_size);\n#else\n\tlimit = ppc64_rma_size;\n#endif\n\n\tpaca = alloc_paca_data(sizeof(struct paca_struct), L1_CACHE_BYTES,\n\t\t\t\tlimit, cpu);\n\tpaca_ptrs[cpu] = paca;\n\n\tinitialise_paca(paca, cpu);\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->lppaca_ptr = new_lppaca(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tpaca->slb_shadow_ptr = new_slb_shadow(cpu, limit);\n#endif\n#ifdef CONFIG_PPC_PSERIES\n\tpaca->rtas_args_reentrant = new_rtas_args(cpu, limit);\n#endif\n\tpaca_struct_size += sizeof(struct paca_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dt_cpu_ftrs_in_use",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "dt_cpu_ftrs_in_use",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dt_cpu_ftrs.c",
          "lines": "867-870",
          "snippet": "bool __init dt_cpu_ftrs_in_use(void)\n{\n\treturn using_dt_cpu_ftrs;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/prom.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <asm/mmu.h>",
            "#include <asm/mce.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/cputable.h>",
            "#include <linux/threads.h>",
            "#include <linux/string.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/memblock.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/prom.h>\n#include <asm/oprofile_impl.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/cputable.h>\n#include <linux/threads.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/memblock.h>\n#include <linux/libfdt.h>\n#include <linux/jump_label.h>\n#include <linux/init.h>\n#include <linux/export.h>\n\nbool __init dt_cpu_ftrs_in_use(void)\n{\n\treturn using_dt_cpu_ftrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_mmu_slb_size",
          "args": [
            "node"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "init_mmu_slb_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "235-244",
          "snippet": "static void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "identical_pvr_fixup",
          "args": [
            "node"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "identical_pvr_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "271-288",
          "snippet": "static inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nstatic inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_pa_features",
          "args": [
            "node"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_pa_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "221-232",
          "snippet": "static void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_feature_properties",
          "args": [
            "node"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_feature_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "293-306",
          "snippet": "static void __init check_cpu_feature_properties(unsigned long node)\n{\n\tint i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};\n\nstatic void __init check_cpu_feature_properties(unsigned long node)\n{\n\tint i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "identify_cpu",
          "args": [
            "0",
            "be32_to_cpup(prop)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "identify_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2167-2182",
          "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/mce.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"cpu-version\"",
            "NULL"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"boot cpu: logical %d physical %d\\n\"",
            "found",
            "be32_to_cpu(intserv[found_thread])"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[found_thread]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdt_boot_cpuid_phys",
          "args": [
            "initial_boot_params"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[i]"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"reg\"",
            "&len"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,ppc-interrupt-server#s\"",
            "&len"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"cpu\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "230-243",
          "snippet": "static int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"device_type\"",
            "NULL"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nstatic int __init early_init_dt_scan_cpus(unsigned long node,\n\t\t\t\t\t  const char *uname, int depth,\n\t\t\t\t\t  void *data)\n{\n\tconst char *type = of_get_flat_dt_prop(node, \"device_type\", NULL);\n\tconst __be32 *prop;\n\tconst __be32 *intserv;\n\tint i, nthreads;\n\tint len;\n\tint found = -1;\n\tint found_thread = 0;\n\n\t/* We are scanning \"cpu\" nodes only */\n\tif (type == NULL || strcmp(type, \"cpu\") != 0)\n\t\treturn 0;\n\n\t/* Get physical cpuid */\n\tintserv = of_get_flat_dt_prop(node, \"ibm,ppc-interrupt-server#s\", &len);\n\tif (!intserv)\n\t\tintserv = of_get_flat_dt_prop(node, \"reg\", &len);\n\n\tnthreads = len / sizeof(int);\n\n\t/*\n\t * Now see if any of these threads match our boot cpu.\n\t * NOTE: This must match the parsing done in smp_setup_cpu_maps.\n\t */\n\tfor (i = 0; i < nthreads; i++) {\n\t\tif (be32_to_cpu(intserv[i]) ==\n\t\t\tfdt_boot_cpuid_phys(initial_boot_params)) {\n\t\t\tfound = boot_cpu_count;\n\t\t\tfound_thread = i;\n\t\t}\n#ifdef CONFIG_SMP\n\t\t/* logical cpu id is always 0 on UP kernels */\n\t\tboot_cpu_count++;\n#endif\n\t}\n\n\t/* Not the boot CPU */\n\tif (found < 0)\n\t\treturn 0;\n\n\tDBG(\"boot cpu: logical %d physical %d\\n\", found,\n\t    be32_to_cpu(intserv[found_thread]));\n\tboot_cpuid = found;\n\n\t/*\n\t * PAPR defines \"logical\" PVR values for cpus that\n\t * meet various levels of the architecture:\n\t * 0x0f000001\tArchitecture version 2.04\n\t * 0x0f000002\tArchitecture version 2.05\n\t * If the cpu-version property in the cpu node contains\n\t * such a value, we call identify_cpu again with the\n\t * logical PVR value in order to use the cpu feature\n\t * bits appropriate for the architecture level.\n\t *\n\t * A POWER6 partition in \"POWER6 architected\" mode\n\t * uses the 0x0f000002 PVR value; in POWER5+ mode\n\t * it uses 0x0f000001.\n\t *\n\t * If we're using device tree CPU feature discovery then we don't\n\t * support the cpu-version property, and it's the responsibility of the\n\t * firmware/hypervisor to provide the correct feature set for the\n\t * architecture level via the ibm,powerpc-cpu-features binding.\n\t */\n\tif (!dt_cpu_ftrs_in_use()) {\n\t\tprop = of_get_flat_dt_prop(node, \"cpu-version\", NULL);\n\t\tif (prop && (be32_to_cpup(prop) & 0xff000000) == 0x0f000000)\n\t\t\tidentify_cpu(0, be32_to_cpup(prop));\n\n\t\tcheck_cpu_feature_properties(node);\n\t\tcheck_cpu_pa_features(node);\n\t}\n\n\tidentical_pvr_fixup(node);\n\tinit_mmu_slb_size(node);\n\n#ifdef CONFIG_PPC64\n\tif (nthreads == 1)\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_SMT;\n\telse if (!dt_cpu_ftrs_in_use())\n\t\tcur_cpu_spec->cpu_features |= CPU_FTR_SMT;\n\tallocate_paca(boot_cpuid);\n#endif\n\tset_hard_smp_processor_id(found, be32_to_cpu(intserv[found_thread]));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_cpu_feature_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "293-306",
    "snippet": "static void __init check_cpu_feature_properties(unsigned long node)\n{\n\tint i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "fp->name",
            "NULL"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "feature_properties"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};\n\nstatic void __init check_cpu_feature_properties(unsigned long node)\n{\n\tint i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < (int)ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "identical_pvr_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "271-288",
    "snippet": "static inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Using logical pvr %x for %s\\n\"",
            "pvr",
            "model"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identify_cpu",
          "args": [
            "0",
            "pvr"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "identify_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2167-2182",
          "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/mce.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/mce.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/jump_label.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "model",
            "\"440EP\""
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "290-305",
          "snippet": "static char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic char __init *prom_strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = prom_strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = prom_strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!prom_memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"model\"",
            "NULL"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned int\tcpu_user_ftrs2;\t/* PPC_FEATURE2_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{ .pabyte = 0,  .pabit = 0, .cpu_user_ftrs = PPC_FEATURE_HAS_MMU },\n\t{ .pabyte = 0,  .pabit = 1, .cpu_user_ftrs = PPC_FEATURE_HAS_FPU },\n\t{ .pabyte = 0,  .pabit = 3, .cpu_features  = CPU_FTR_CTRL },\n\t{ .pabyte = 0,  .pabit = 6, .cpu_features  = CPU_FTR_NOEXECUTE },\n\t{ .pabyte = 1,  .pabit = 2, .mmu_features  = MMU_FTR_CI_LARGE_PAGE },\n#ifdef CONFIG_PPC_RADIX_MMU\n\t{ .pabyte = 40, .pabit = 0, .mmu_features  = MMU_FTR_TYPE_RADIX | MMU_FTR_GTSE },\n#endif\n\t{ .pabyte = 1,  .pabit = 1, .invert = 1, .cpu_features = CPU_FTR_NODSISRALIGN },\n\t{ .pabyte = 5,  .pabit = 0, .cpu_features  = CPU_FTR_REAL_LE,\n\t\t\t\t    .cpu_user_ftrs = PPC_FEATURE_TRUE_LE },\n\t/*\n\t * If the kernel doesn't support TM (ie CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on TM here, so we use the *_COMP versions\n\t * which are 0 if the kernel doesn't support TM.\n\t */\n\t{ .pabyte = 22, .pabit = 0, .cpu_features = CPU_FTR_TM_COMP,\n\t  .cpu_user_ftrs2 = PPC_FEATURE2_HTM_COMP | PPC_FEATURE2_HTM_NOSC_COMP },\n\n\t{ .pabyte = 64, .pabit = 0, .cpu_features = CPU_FTR_DAWR1 },\n};\n\nstatic inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}"
  },
  {
    "function_name": "init_mmu_slb_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "235-244",
    "snippet": "static void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "slb_size_ptr"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,slb-size\"",
            "NULL"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"slb-size\"",
            "NULL"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}"
  },
  {
    "function_name": "check_cpu_pa_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "221-232",
    "snippet": "static void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scan_features",
          "args": [
            "node",
            "pa_ftrs",
            "tablelen",
            "ibm_pa_features",
            "ARRAY_SIZE(ibm_pa_features)"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "scan_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "182-219",
          "snippet": "static void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 |= fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 &= ~fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 |= fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 &= ~fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ibm_pa_features"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,pa-features\"",
            "&tablelen"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}"
  },
  {
    "function_name": "scan_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "182-219",
    "snippet": "static void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 |= fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 &= ~fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 |= fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->cpu_user_features2 &= ~fp->cpu_user_ftrs2;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "move_device_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "113-136",
    "snippet": "static void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t    !memblock_is_memory(start + size - 1) ||\n\t    overlaps_crashkernel(start, size) || overlaps_initrd(start, size)) {\n\t\tp = memblock_alloc_raw(size, PAGE_SIZE);\n\t\tif (!p)\n\t\t\tpanic(\"Failed to allocate %lu bytes to move device tree\\n\",\n\t\t\t      size);\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%px\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"<- move_device_tree\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Moved device tree to 0x%px\\n\"",
            "p"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "initial_boot_params",
            "size"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/io.c",
          "lines": "181-205",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to allocate %lu bytes to move device tree\\n\"",
            "size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_smp_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "147-199",
          "snippet": "static void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static cpumask_t wd_smp_cpus_pending;",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic cpumask_t wd_smp_cpus_pending;\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_smp_panic(int cpu, u64 tb)\n{\n\tunsigned long flags;\n\tint c;\n\n\twd_smp_lock(&flags);\n\t/* Double check some things under lock */\n\tif ((s64)(tb - wd_smp_last_reset_tb) < (s64)wd_smp_panic_timeout_tb)\n\t\tgoto out;\n\tif (cpumask_test_cpu(cpu, &wd_smp_cpus_pending))\n\t\tgoto out;\n\tif (cpumask_weight(&wd_smp_cpus_pending) == 0)\n\t\tgoto out;\n\n\tpr_emerg(\"CPU %d detected hard LOCKUP on other CPUs %*pbl\\n\",\n\t\t cpu, cpumask_pr_args(&wd_smp_cpus_pending));\n\tpr_emerg(\"CPU %d TB:%lld, last SMP heartbeat TB:%lld (%lldms ago)\\n\",\n\t\t cpu, tb, wd_smp_last_reset_tb,\n\t\t tb_to_ns(tb - wd_smp_last_reset_tb) / 1000000);\n\n\tif (!sysctl_hardlockup_all_cpu_backtrace) {\n\t\t/*\n\t\t * Try to trigger the stuck CPUs, unless we are going to\n\t\t * get a backtrace on all of them anyway.\n\t\t */\n\t\tfor_each_cpu(c, &wd_smp_cpus_pending) {\n\t\t\tif (c == cpu)\n\t\t\t\tcontinue;\n\t\t\tsmp_send_nmi_ipi(c, wd_lockup_ipi, 1000000);\n\t\t}\n\t}\n\n\t/* Take the stuck CPUs out of the watch group */\n\tset_cpumask_stuck(&wd_smp_cpus_pending, tb);\n\n\twd_smp_unlock(&flags);\n\n\tprintk_safe_flush();\n\t/*\n\t * printk_safe_flush() seems to require another print\n\t * before anything actually goes out to console.\n\t */\n\tif (sysctl_hardlockup_all_cpu_backtrace)\n\t\ttrigger_allbutself_cpu_backtrace();\n\n\tif (hardlockup_panic)\n\t\tnmi_panic(NULL, \"Hard LOCKUP\");\n\n\treturn;\n\nout:\n\twd_smp_unlock(&flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_raw",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overlaps_initrd",
          "args": [
            "start",
            "size"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps_initrd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
          "lines": "93-104",
          "snippet": "static inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= ALIGN(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/ultravisor.h>",
            "#include <asm/drmem.h>",
            "#include <asm/dt_cpu_ftrs.h>",
            "#include <asm/firmware.h>",
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/powernv.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/cpu.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= ALIGN(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "overlaps_crashkernel",
          "args": [
            "start",
            "size"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_memory",
          "args": [
            "start + size - 1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdt_totalsize",
          "args": [
            "initial_boot_params"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "initial_boot_params"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1164-1189",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = FPE_FLTUNK;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"-> move_device_tree\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t    !memblock_is_memory(start + size - 1) ||\n\t    overlaps_crashkernel(start, size) || overlaps_initrd(start, size)) {\n\t\tp = memblock_alloc_raw(size, PAGE_SIZE);\n\t\tif (!p)\n\t\t\tpanic(\"Failed to allocate %lu bytes to move device tree\\n\",\n\t\t\t      size);\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%px\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}"
  },
  {
    "function_name": "overlaps_initrd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "93-104",
    "snippet": "static inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= ALIGN(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "initrd_end",
            "PAGE_SIZE"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "initrd_start",
            "PAGE_SIZE"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= ALIGN(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "early_parse_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom.c",
    "lines": "77-86",
    "snippet": "static int __init early_parse_mem(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tmemory_limit = PAGE_ALIGN(memparse(p, &p));\n\tDBG(\"memory limit = 0x%llx\\n\", memory_limit);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/ultravisor.h>",
      "#include <asm/drmem.h>",
      "#include <asm/dt_cpu_ftrs.h>",
      "#include <asm/firmware.h>",
      "#include <asm/epapr_hcalls.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/powernv.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/cpu.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"memory limit = 0x%llx\\n\"",
            "memory_limit"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "memparse(p, &p)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "prom_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "736-761",
          "snippet": "static unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/ultravisor.h>\n#include <asm/drmem.h>\n#include <asm/dt_cpu_ftrs.h>\n#include <asm/firmware.h>\n#include <asm/epapr_hcalls.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/powernv.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/cpu.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __init early_parse_mem(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tmemory_limit = PAGE_ALIGN(memparse(p, &p));\n\tDBG(\"memory limit = 0x%llx\\n\", memory_limit);\n\n\treturn 0;\n}"
  }
]