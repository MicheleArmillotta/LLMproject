[
  {
    "function_name": "count_cache_flush_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "560-566",
    "snippet": "static __init int count_cache_flush_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"count_cache_flush\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_count_cache_flush);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"count_cache_flush\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&fops_count_cache_flush"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int count_cache_flush_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"count_cache_flush\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_count_cache_flush);\n\treturn 0;\n}"
  },
  {
    "function_name": "count_cache_flush_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "547-555",
    "snippet": "static int count_cache_flush_get(void *data, u64 *val)\n{\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE)\n\t\t*val = 0;\n\telse\n\t\t*val = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic int count_cache_flush_get(void *data, u64 *val)\n{\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE)\n\t\t*val = 0;\n\telse\n\t\t*val = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "count_cache_flush_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "531-545",
    "snippet": "static int count_cache_flush_set(void *data, u64 val)\n{\n\tbool enable;\n\n\tif (val == 1)\n\t\tenable = true;\n\telse if (val == 0)\n\t\tenable = false;\n\telse\n\t\treturn -EINVAL;\n\n\ttoggle_branch_cache_flush(enable);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_branch_cache_flush",
          "args": [
            "enable"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_branch_cache_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "471-504",
          "snippet": "static void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
            "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int count_cache_flush_set(void *data, u64 val)\n{\n\tbool enable;\n\n\tif (val == 1)\n\t\tenable = true;\n\telse if (val == 0)\n\t\tenable = false;\n\telse\n\t\treturn -EINVAL;\n\n\ttoggle_branch_cache_flush(enable);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_count_cache_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "506-528",
    "snippet": "void setup_count_cache_flush(void)\n{\n\tbool enable = true;\n\n\tif (no_spectrev2 || cpu_mitigations_off()) {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTRL_SERIALISED) ||\n\t\t    security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED))\n\t\t\tpr_warn(\"Spectre v2 mitigations not fully under software control, can't disable\\n\");\n\n\t\tenable = false;\n\t}\n\n\t/*\n\t * There's no firmware feature flag/hypervisor bit to tell us we need to\n\t * flush the link stack on context switch. So we set it here if we see\n\t * either of the Spectre v2 mitigations that aim to protect userspace.\n\t */\n\tif (security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED) ||\n\t    security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE))\n\t\tsecurity_ftr_set(SEC_FTR_FLUSH_LINK_STACK);\n\n\ttoggle_branch_cache_flush(enable);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toggle_branch_cache_flush",
          "args": [
            "enable"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "toggle_branch_cache_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "471-504",
          "snippet": "static void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
            "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_ftr_set",
          "args": [
            "SEC_FTR_FLUSH_LINK_STACK"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_FLUSH_COUNT_CACHE"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_COUNT_CACHE_DISABLED"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Spectre v2 mitigations not fully under software control, can't disable\\n\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_COUNT_CACHE_DISABLED"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BCCTRL_SERIALISED"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_mitigations_off",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nvoid setup_count_cache_flush(void)\n{\n\tbool enable = true;\n\n\tif (no_spectrev2 || cpu_mitigations_off()) {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTRL_SERIALISED) ||\n\t\t    security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED))\n\t\t\tpr_warn(\"Spectre v2 mitigations not fully under software control, can't disable\\n\");\n\n\t\tenable = false;\n\t}\n\n\t/*\n\t * There's no firmware feature flag/hypervisor bit to tell us we need to\n\t * flush the link stack on context switch. So we set it here if we see\n\t * either of the Spectre v2 mitigations that aim to protect userspace.\n\t */\n\tif (security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED) ||\n\t    security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE))\n\t\tsecurity_ftr_set(SEC_FTR_FLUSH_LINK_STACK);\n\n\ttoggle_branch_cache_flush(enable);\n}"
  },
  {
    "function_name": "toggle_branch_cache_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "471-504",
    "snippet": "static void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
      "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_branch_cache_flush",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "update_branch_cache_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "431-469",
          "snippet": "static void update_branch_cache_flush(void)\n{\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t// This controls the branch from guest_exit_cont to kvm_flush_link_stack\n\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else {\n\t\t// Could use HW flush, but that could also flush count cache\n\t\tpatch_branch_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);\n\t}\n#endif\n\n\t// This controls the branch from _switch to flush_branch_caches\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE &&\n\t    link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW &&\n\t\t   link_stack_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_BCCTR_FLUSH));\n\t} else {\n\t\tpatch_branch_site(&patch__call_flush_branch_caches,\n\t\t\t\t  (u64)&flush_branch_caches, BRANCH_SET_LINK);\n\n\t\t// If we just need to flush the link stack, early return\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\t\tpatch_instruction_site(&patch__flush_link_stack_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\n\t\t// If we have flush instruction, early return\n\t\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\t\tpatch_instruction_site(&patch__flush_count_cache_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
            "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic void update_branch_cache_flush(void)\n{\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t// This controls the branch from guest_exit_cont to kvm_flush_link_stack\n\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else {\n\t\t// Could use HW flush, but that could also flush count cache\n\t\tpatch_branch_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);\n\t}\n#endif\n\n\t// This controls the branch from _switch to flush_branch_caches\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE &&\n\t    link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW &&\n\t\t   link_stack_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_BCCTR_FLUSH));\n\t} else {\n\t\tpatch_branch_site(&patch__call_flush_branch_caches,\n\t\t\t\t  (u64)&flush_branch_caches, BRANCH_SET_LINK);\n\n\t\t// If we just need to flush the link stack, early return\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\t\tpatch_instruction_site(&patch__flush_link_stack_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\n\t\t// If we have flush instruction, early return\n\t\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\t\tpatch_instruction_site(&patch__flush_count_cache_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"link-stack-flush: software flush enabled.\\n\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"link-stack-flush: hardware flush enabled.\\n\""
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BCCTR_LINK_FLUSH_ASSIST"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"link-stack-flush: flush disabled.\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_FLUSH_LINK_STACK"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"count-cache-flush: software flush enabled.\\n\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"count-cache-flush: hardware flush enabled.\\n\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BCCTR_FLUSH_ASSIST"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"count-cache-flush: flush disabled.\\n\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_FLUSH_COUNT_CACHE"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic void toggle_branch_cache_flush(bool enable)\n{\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) {\n\t\tif (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"count-cache-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"count-cache-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tcount_cache_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"count-cache-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tif (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_LINK_STACK)) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\n\t\tpr_info(\"link-stack-flush: flush disabled.\\n\");\n\t} else {\n\t\tif (security_ftr_enabled(SEC_FTR_BCCTR_LINK_FLUSH_ASSIST)) {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_HW;\n\t\t\tpr_info(\"link-stack-flush: hardware flush enabled.\\n\");\n\t\t} else {\n\t\t\tlink_stack_flush_type = BRANCH_CACHE_FLUSH_SW;\n\t\t\tpr_info(\"link-stack-flush: software flush enabled.\\n\");\n\t\t}\n\t}\n\n\tupdate_branch_cache_flush();\n}"
  },
  {
    "function_name": "update_branch_cache_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "431-469",
    "snippet": "static void update_branch_cache_flush(void)\n{\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t// This controls the branch from guest_exit_cont to kvm_flush_link_stack\n\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else {\n\t\t// Could use HW flush, but that could also flush count cache\n\t\tpatch_branch_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);\n\t}\n#endif\n\n\t// This controls the branch from _switch to flush_branch_caches\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE &&\n\t    link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW &&\n\t\t   link_stack_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_BCCTR_FLUSH));\n\t} else {\n\t\tpatch_branch_site(&patch__call_flush_branch_caches,\n\t\t\t\t  (u64)&flush_branch_caches, BRANCH_SET_LINK);\n\n\t\t// If we just need to flush the link stack, early return\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\t\tpatch_instruction_site(&patch__flush_link_stack_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\n\t\t// If we have flush instruction, early return\n\t\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\t\tpatch_instruction_site(&patch__flush_count_cache_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
      "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "patch_instruction_site",
          "args": [
            "&patch__flush_count_cache_return",
            "ppc_inst(PPC_INST_BLR)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_BLR"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction_site",
          "args": [
            "&patch__flush_link_stack_return",
            "ppc_inst(PPC_INST_BLR)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_BLR"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch_site",
          "args": [
            "&patch__call_flush_branch_caches",
            "(u64)&flush_branch_caches",
            "BRANCH_SET_LINK"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction_site",
          "args": [
            "&patch__call_flush_branch_caches",
            "ppc_inst(PPC_INST_BCCTR_FLUSH)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_BCCTR_FLUSH"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction_site",
          "args": [
            "&patch__call_flush_branch_caches",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_branch_site",
          "args": [
            "&patch__call_kvm_flush_link_stack",
            "(u64)&kvm_flush_link_stack",
            "BRANCH_SET_LINK"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patch_instruction_site",
          "args": [
            "&patch__call_kvm_flush_link_stack",
            "ppc_inst(PPC_INST_NOP)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "PPC_INST_NOP"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\n\nstatic void update_branch_cache_flush(void)\n{\n#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE\n\t// This controls the branch from guest_exit_cont to kvm_flush_link_stack\n\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else {\n\t\t// Could use HW flush, but that could also flush count cache\n\t\tpatch_branch_site(&patch__call_kvm_flush_link_stack,\n\t\t\t\t  (u64)&kvm_flush_link_stack, BRANCH_SET_LINK);\n\t}\n#endif\n\n\t// This controls the branch from _switch to flush_branch_caches\n\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE &&\n\t    link_stack_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_NOP));\n\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW &&\n\t\t   link_stack_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\tpatch_instruction_site(&patch__call_flush_branch_caches,\n\t\t\t\t       ppc_inst(PPC_INST_BCCTR_FLUSH));\n\t} else {\n\t\tpatch_branch_site(&patch__call_flush_branch_caches,\n\t\t\t\t  (u64)&flush_branch_caches, BRANCH_SET_LINK);\n\n\t\t// If we just need to flush the link stack, early return\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_NONE) {\n\t\t\tpatch_instruction_site(&patch__flush_link_stack_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\n\t\t// If we have flush instruction, early return\n\t\t} else if (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW) {\n\t\t\tpatch_instruction_site(&patch__flush_count_cache_return,\n\t\t\t\t\t       ppc_inst(PPC_INST_BLR));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "stf_barrier_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "422-427",
    "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"stf_barrier\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&fops_stf_barrier"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
  },
  {
    "function_name": "stf_barrier_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "413-417",
    "snippet": "static int stf_barrier_get(void *data, u64 *val)\n{\n\t*val = stf_barrier ? 1 : 0;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int stf_barrier_get(void *data, u64 *val)\n{\n\t*val = stf_barrier ? 1 : 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "stf_barrier_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "395-411",
    "snippet": "static int stf_barrier_set(void *data, u64 val)\n{\n\tbool enable;\n\n\tif (val == 1)\n\t\tenable = true;\n\telse if (val == 0)\n\t\tenable = false;\n\telse\n\t\treturn -EINVAL;\n\n\t/* Only do anything if we're changing state */\n\tif (enable != stf_barrier)\n\t\tstf_barrier_enable(enable);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stf_barrier_enable",
          "args": [
            "enable"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "288-296",
          "snippet": "static void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int stf_barrier_set(void *data, u64 val)\n{\n\tbool enable;\n\n\tif (val == 1)\n\t\tenable = true;\n\telse if (val == 0)\n\t\tenable = false;\n\telse\n\t\treturn -EINVAL;\n\n\t/* Only do anything if we're changing state */\n\tif (enable != stf_barrier)\n\t\tstf_barrier_enable(enable);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_prctl_spec_ctrl_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "384-392",
    "snippet": "int arch_prctl_spec_ctrl_get(struct task_struct *task, unsigned long which)\n{\n\tswitch (which) {\n\tcase PR_SPEC_STORE_BYPASS:\n\t\treturn ssb_prctl_get(task);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssb_prctl_get",
          "args": [
            "task"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ssb_prctl_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "360-382",
          "snippet": "static int ssb_prctl_get(struct task_struct *task)\n{\n\tif (stf_enabled_flush_types == STF_BARRIER_NONE)\n\t\t/*\n\t\t * We don't have an explicit signal from firmware that we're\n\t\t * vulnerable or not, we only have certain CPU revisions that\n\t\t * are known to be vulnerable.\n\t\t *\n\t\t * We assume that if we're on another CPU, where the barrier is\n\t\t * NONE, then we are not vulnerable.\n\t\t */\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\telse\n\t\t/*\n\t\t * If we do have a barrier type then we are vulnerable. The\n\t\t * barrier is not a global or per-process mitigation, so the\n\t\t * only value we can report here is PR_SPEC_ENABLE, which\n\t\t * appears as \"vulnerable\" in /proc.\n\t\t */\n\t\treturn PR_SPEC_ENABLE;\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int ssb_prctl_get(struct task_struct *task)\n{\n\tif (stf_enabled_flush_types == STF_BARRIER_NONE)\n\t\t/*\n\t\t * We don't have an explicit signal from firmware that we're\n\t\t * vulnerable or not, we only have certain CPU revisions that\n\t\t * are known to be vulnerable.\n\t\t *\n\t\t * We assume that if we're on another CPU, where the barrier is\n\t\t * NONE, then we are not vulnerable.\n\t\t */\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\telse\n\t\t/*\n\t\t * If we do have a barrier type then we are vulnerable. The\n\t\t * barrier is not a global or per-process mitigation, so the\n\t\t * only value we can report here is PR_SPEC_ENABLE, which\n\t\t * appears as \"vulnerable\" in /proc.\n\t\t */\n\t\treturn PR_SPEC_ENABLE;\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nint arch_prctl_spec_ctrl_get(struct task_struct *task, unsigned long which)\n{\n\tswitch (which) {\n\tcase PR_SPEC_STORE_BYPASS:\n\t\treturn ssb_prctl_get(task);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}"
  },
  {
    "function_name": "ssb_prctl_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "360-382",
    "snippet": "static int ssb_prctl_get(struct task_struct *task)\n{\n\tif (stf_enabled_flush_types == STF_BARRIER_NONE)\n\t\t/*\n\t\t * We don't have an explicit signal from firmware that we're\n\t\t * vulnerable or not, we only have certain CPU revisions that\n\t\t * are known to be vulnerable.\n\t\t *\n\t\t * We assume that if we're on another CPU, where the barrier is\n\t\t * NONE, then we are not vulnerable.\n\t\t */\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\telse\n\t\t/*\n\t\t * If we do have a barrier type then we are vulnerable. The\n\t\t * barrier is not a global or per-process mitigation, so the\n\t\t * only value we can report here is PR_SPEC_ENABLE, which\n\t\t * appears as \"vulnerable\" in /proc.\n\t\t */\n\t\treturn PR_SPEC_ENABLE;\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int ssb_prctl_get(struct task_struct *task)\n{\n\tif (stf_enabled_flush_types == STF_BARRIER_NONE)\n\t\t/*\n\t\t * We don't have an explicit signal from firmware that we're\n\t\t * vulnerable or not, we only have certain CPU revisions that\n\t\t * are known to be vulnerable.\n\t\t *\n\t\t * We assume that if we're on another CPU, where the barrier is\n\t\t * NONE, then we are not vulnerable.\n\t\t */\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\telse\n\t\t/*\n\t\t * If we do have a barrier type then we are vulnerable. The\n\t\t * barrier is not a global or per-process mitigation, so the\n\t\t * only value we can report here is PR_SPEC_ENABLE, which\n\t\t * appears as \"vulnerable\" in /proc.\n\t\t */\n\t\treturn PR_SPEC_ENABLE;\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cpu_show_spec_store_bypass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "333-358",
    "snippet": "ssize_t cpu_show_spec_store_bypass(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tif (stf_barrier && stf_enabled_flush_types != STF_BARRIER_NONE) {\n\t\tconst char *type;\n\t\tswitch (stf_enabled_flush_types) {\n\t\tcase STF_BARRIER_EIEIO:\n\t\t\ttype = \"eieio\";\n\t\t\tbreak;\n\t\tcase STF_BARRIER_SYNC_ORI:\n\t\t\ttype = \"hwsync\";\n\t\t\tbreak;\n\t\tcase STF_BARRIER_FALLBACK:\n\t\t\ttype = \"fallback\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\treturn sprintf(buf, \"Mitigation: Kernel entry/exit barrier (%s)\\n\", type);\n\t}\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Vulnerable\\n\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Not affected\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_PR"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_HV"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Mitigation: Kernel entry/exit barrier (%s)\\n\"",
            "type"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nssize_t cpu_show_spec_store_bypass(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tif (stf_barrier && stf_enabled_flush_types != STF_BARRIER_NONE) {\n\t\tconst char *type;\n\t\tswitch (stf_enabled_flush_types) {\n\t\tcase STF_BARRIER_EIEIO:\n\t\t\ttype = \"eieio\";\n\t\t\tbreak;\n\t\tcase STF_BARRIER_SYNC_ORI:\n\t\t\ttype = \"hwsync\";\n\t\t\tbreak;\n\t\tcase STF_BARRIER_FALLBACK:\n\t\t\ttype = \"fallback\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = \"unknown\";\n\t\t}\n\t\treturn sprintf(buf, \"Mitigation: Kernel entry/exit barrier (%s)\\n\", type);\n\t}\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}"
  },
  {
    "function_name": "setup_stf_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "298-331",
    "snippet": "void setup_stf_barrier(void)\n{\n\tenum stf_barrier_type type;\n\tbool enable, hv;\n\n\thv = cpu_has_feature(CPU_FTR_HVMODE);\n\n\t/* Default to fallback in case fw-features are not available */\n\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\ttype = STF_BARRIER_EIEIO;\n\telse if (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\ttype = STF_BARRIER_SYNC_ORI;\n\telse if (cpu_has_feature(CPU_FTR_ARCH_206))\n\t\ttype = STF_BARRIER_FALLBACK;\n\telse\n\t\ttype = STF_BARRIER_NONE;\n\n\tenable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) &&\n\t\t(security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR) ||\n\t\t (security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) && hv));\n\n\tif (type == STF_BARRIER_FALLBACK) {\n\t\tpr_info(\"stf-barrier: fallback barrier available\\n\");\n\t} else if (type == STF_BARRIER_SYNC_ORI) {\n\t\tpr_info(\"stf-barrier: hwsync barrier available\\n\");\n\t} else if (type == STF_BARRIER_EIEIO) {\n\t\tpr_info(\"stf-barrier: eieio barrier available\\n\");\n\t}\n\n\tstf_enabled_flush_types = type;\n\n\tif (!no_stf_barrier && !cpu_mitigations_off())\n\t\tstf_barrier_enable(enable);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stf_barrier_enable",
          "args": [
            "enable"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "288-296",
          "snippet": "static void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_mitigations_off",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"stf-barrier: eieio barrier available\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"stf-barrier: hwsync barrier available\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"stf-barrier: fallback barrier available\\n\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_HV"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_PR"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_FAVOUR_SECURITY"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_206"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_207S"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_300"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nvoid setup_stf_barrier(void)\n{\n\tenum stf_barrier_type type;\n\tbool enable, hv;\n\n\thv = cpu_has_feature(CPU_FTR_HVMODE);\n\n\t/* Default to fallback in case fw-features are not available */\n\tif (cpu_has_feature(CPU_FTR_ARCH_300))\n\t\ttype = STF_BARRIER_EIEIO;\n\telse if (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\ttype = STF_BARRIER_SYNC_ORI;\n\telse if (cpu_has_feature(CPU_FTR_ARCH_206))\n\t\ttype = STF_BARRIER_FALLBACK;\n\telse\n\t\ttype = STF_BARRIER_NONE;\n\n\tenable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) &&\n\t\t(security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR) ||\n\t\t (security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) && hv));\n\n\tif (type == STF_BARRIER_FALLBACK) {\n\t\tpr_info(\"stf-barrier: fallback barrier available\\n\");\n\t} else if (type == STF_BARRIER_SYNC_ORI) {\n\t\tpr_info(\"stf-barrier: hwsync barrier available\\n\");\n\t} else if (type == STF_BARRIER_EIEIO) {\n\t\tpr_info(\"stf-barrier: eieio barrier available\\n\");\n\t}\n\n\tstf_enabled_flush_types = type;\n\n\tif (!no_stf_barrier && !cpu_mitigations_off())\n\t\tstf_barrier_enable(enable);\n}"
  },
  {
    "function_name": "stf_barrier_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "288-296",
    "snippet": "static void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_stf_barrier_fixups",
          "args": [
            "STF_BARRIER_NONE"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_stf_barrier_fixups",
          "args": [
            "stf_enabled_flush_types"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic void stf_barrier_enable(bool enable)\n{\n\tif (enable)\n\t\tdo_stf_barrier_fixups(stf_enabled_flush_types);\n\telse\n\t\tdo_stf_barrier_fixups(STF_BARRIER_NONE);\n\n\tstf_barrier = enable;\n}"
  },
  {
    "function_name": "handle_no_ssbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "281-285",
    "snippet": "static int __init handle_no_ssbd(char *p)\n{\n\thandle_no_stf_barrier(NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_no_stf_barrier",
          "args": [
            "NULL"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "handle_no_stf_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "255-260",
          "snippet": "static int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_no_ssbd(char *p)\n{\n\thandle_no_stf_barrier(NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_ssbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "265-277",
    "snippet": "static int __init handle_ssbd(char *p)\n{\n\tif (!p || strncmp(p, \"auto\", 5) == 0 || strncmp(p, \"on\", 2) == 0 ) {\n\t\t/* Until firmware tells us, we have the barrier with auto */\n\t\treturn 0;\n\t} else if (strncmp(p, \"off\", 3) == 0) {\n\t\thandle_no_stf_barrier(NULL);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_no_stf_barrier",
          "args": [
            "NULL"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "handle_no_stf_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "255-260",
          "snippet": "static int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"off\"",
            "3"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "prom_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "254-268",
          "snippet": "static int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/ultravisor-api.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/ultravisor-api.h>\n#include <asm/asm-prototypes.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/pgtable.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init;\n\nstatic int __init prom_strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_ssbd(char *p)\n{\n\tif (!p || strncmp(p, \"auto\", 5) == 0 || strncmp(p, \"on\", 2) == 0 ) {\n\t\t/* Until firmware tells us, we have the barrier with auto */\n\t\treturn 0;\n\t} else if (strncmp(p, \"off\", 3) == 0) {\n\t\thandle_no_stf_barrier(NULL);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_no_stf_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "255-260",
    "snippet": "static int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"stf-barrier: disabled on command line.\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_no_stf_barrier(char *p)\n{\n\tpr_info(\"stf-barrier: disabled on command line.\");\n\tno_stf_barrier = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_show_spectre_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "200-244",
    "snippet": "ssize_t cpu_show_spectre_v2(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct seq_buf s;\n\tbool bcs, ccd;\n\n\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\tbcs = security_ftr_enabled(SEC_FTR_BCCTRL_SERIALISED);\n\tccd = security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED);\n\n\tif (bcs || ccd) {\n\t\tseq_buf_printf(&s, \"Mitigation: \");\n\n\t\tif (bcs)\n\t\t\tseq_buf_printf(&s, \"Indirect branch serialisation (kernel only)\");\n\n\t\tif (bcs && ccd)\n\t\t\tseq_buf_printf(&s, \", \");\n\n\t\tif (ccd)\n\t\t\tseq_buf_printf(&s, \"Indirect branch cache disabled\");\n\n\t} else if (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE) {\n\t\tseq_buf_printf(&s, \"Mitigation: Software count cache flush\");\n\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW)\n\t\t\tseq_buf_printf(&s, \" (hardware accelerated)\");\n\n\t} else if (btb_flush_enabled) {\n\t\tseq_buf_printf(&s, \"Mitigation: Branch predictor state flush\");\n\t} else {\n\t\tseq_buf_printf(&s, \"Vulnerable\");\n\t}\n\n\tif (bcs || ccd || count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tseq_buf_printf(&s, \", Software link stack flush\");\n\t\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_HW)\n\t\t\tseq_buf_printf(&s, \" (hardware accelerated)\");\n\t}\n\n\tseq_buf_printf(&s, \"\\n\");\n\n\treturn s.len;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;",
      "static enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;",
      "static bool btb_flush_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"\\n\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\" (hardware accelerated)\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\", Software link stack flush\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Vulnerable\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Mitigation: Branch predictor state flush\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\" (hardware accelerated)\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Mitigation: Software count cache flush\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Indirect branch cache disabled\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\", \""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Indirect branch serialisation (kernel only)\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Mitigation: \""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_COUNT_CACHE_DISABLED"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BCCTRL_SERIALISED"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&s",
            "buf",
            "PAGE_SIZE - 1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic enum branch_cache_flush_type count_cache_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic enum branch_cache_flush_type link_stack_flush_type = BRANCH_CACHE_FLUSH_NONE;\nstatic bool btb_flush_enabled;\n\nssize_t cpu_show_spectre_v2(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct seq_buf s;\n\tbool bcs, ccd;\n\n\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\tbcs = security_ftr_enabled(SEC_FTR_BCCTRL_SERIALISED);\n\tccd = security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED);\n\n\tif (bcs || ccd) {\n\t\tseq_buf_printf(&s, \"Mitigation: \");\n\n\t\tif (bcs)\n\t\t\tseq_buf_printf(&s, \"Indirect branch serialisation (kernel only)\");\n\n\t\tif (bcs && ccd)\n\t\t\tseq_buf_printf(&s, \", \");\n\n\t\tif (ccd)\n\t\t\tseq_buf_printf(&s, \"Indirect branch cache disabled\");\n\n\t} else if (count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE) {\n\t\tseq_buf_printf(&s, \"Mitigation: Software count cache flush\");\n\n\t\tif (count_cache_flush_type == BRANCH_CACHE_FLUSH_HW)\n\t\t\tseq_buf_printf(&s, \" (hardware accelerated)\");\n\n\t} else if (btb_flush_enabled) {\n\t\tseq_buf_printf(&s, \"Mitigation: Branch predictor state flush\");\n\t} else {\n\t\tseq_buf_printf(&s, \"Vulnerable\");\n\t}\n\n\tif (bcs || ccd || count_cache_flush_type != BRANCH_CACHE_FLUSH_NONE) {\n\t\tif (link_stack_flush_type != BRANCH_CACHE_FLUSH_NONE)\n\t\t\tseq_buf_printf(&s, \", Software link stack flush\");\n\t\tif (link_stack_flush_type == BRANCH_CACHE_FLUSH_HW)\n\t\t\tseq_buf_printf(&s, \" (hardware accelerated)\");\n\t}\n\n\tseq_buf_printf(&s, \"\\n\");\n\n\treturn s.len;\n}"
  },
  {
    "function_name": "cpu_show_spectre_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "178-198",
    "snippet": "ssize_t cpu_show_spectre_v1(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct seq_buf s;\n\n\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\tif (security_ftr_enabled(SEC_FTR_BNDS_CHK_SPEC_BAR)) {\n\t\tif (barrier_nospec_enabled)\n\t\t\tseq_buf_printf(&s, \"Mitigation: __user pointer sanitization\");\n\t\telse\n\t\t\tseq_buf_printf(&s, \"Vulnerable\");\n\n\t\tif (security_ftr_enabled(SEC_FTR_SPEC_BAR_ORI31))\n\t\t\tseq_buf_printf(&s, \", ori31 speculation barrier enabled\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\t} else\n\t\tseq_buf_printf(&s, \"Not affected\\n\");\n\n\treturn s.len;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool barrier_nospec_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Not affected\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\", ori31 speculation barrier enabled\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_SPEC_BAR_ORI31"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Vulnerable\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Mitigation: __user pointer sanitization\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BNDS_CHK_SPEC_BAR"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&s",
            "buf",
            "PAGE_SIZE - 1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nssize_t cpu_show_spectre_v1(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct seq_buf s;\n\n\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\tif (security_ftr_enabled(SEC_FTR_BNDS_CHK_SPEC_BAR)) {\n\t\tif (barrier_nospec_enabled)\n\t\t\tseq_buf_printf(&s, \"Mitigation: __user pointer sanitization\");\n\t\telse\n\t\t\tseq_buf_printf(&s, \"Vulnerable\");\n\n\t\tif (security_ftr_enabled(SEC_FTR_SPEC_BAR_ORI31))\n\t\t\tseq_buf_printf(&s, \", ori31 speculation barrier enabled\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\t} else\n\t\tseq_buf_printf(&s, \"Not affected\\n\");\n\n\treturn s.len;\n}"
  },
  {
    "function_name": "cpu_show_l1tf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "172-175",
    "snippet": "ssize_t cpu_show_l1tf(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn cpu_show_meltdown(dev, attr, buf);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_show_meltdown",
          "args": [
            "dev",
            "attr",
            "buf"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_show_meltdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "143-170",
          "snippet": "ssize_t cpu_show_meltdown(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool thread_priv;\n\n\tthread_priv = security_ftr_enabled(SEC_FTR_L1D_THREAD_PRIV);\n\n\tif (rfi_flush) {\n\t\tstruct seq_buf s;\n\t\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\t\tseq_buf_printf(&s, \"Mitigation: RFI Flush\");\n\t\tif (thread_priv)\n\t\t\tseq_buf_printf(&s, \", L1D private per thread\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\n\t\treturn s.len;\n\t}\n\n\tif (thread_priv)\n\t\treturn sprintf(buf, \"Vulnerable: L1D private per thread\\n\");\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nssize_t cpu_show_meltdown(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool thread_priv;\n\n\tthread_priv = security_ftr_enabled(SEC_FTR_L1D_THREAD_PRIV);\n\n\tif (rfi_flush) {\n\t\tstruct seq_buf s;\n\t\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\t\tseq_buf_printf(&s, \"Mitigation: RFI Flush\");\n\t\tif (thread_priv)\n\t\t\tseq_buf_printf(&s, \", L1D private per thread\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\n\t\treturn s.len;\n\t}\n\n\tif (thread_priv)\n\t\treturn sprintf(buf, \"Vulnerable: L1D private per thread\\n\");\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nssize_t cpu_show_l1tf(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn cpu_show_meltdown(dev, attr, buf);\n}"
  },
  {
    "function_name": "cpu_show_meltdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "143-170",
    "snippet": "ssize_t cpu_show_meltdown(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool thread_priv;\n\n\tthread_priv = security_ftr_enabled(SEC_FTR_L1D_THREAD_PRIV);\n\n\tif (rfi_flush) {\n\t\tstruct seq_buf s;\n\t\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\t\tseq_buf_printf(&s, \"Mitigation: RFI Flush\");\n\t\tif (thread_priv)\n\t\t\tseq_buf_printf(&s, \", L1D private per thread\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\n\t\treturn s.len;\n\t}\n\n\tif (thread_priv)\n\t\treturn sprintf(buf, \"Vulnerable: L1D private per thread\\n\");\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Vulnerable\\n\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Not affected\\n\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_PR"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_FLUSH_HV"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Vulnerable: L1D private per thread\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\", L1D private per thread\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&s",
            "\"Mitigation: RFI Flush\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&s",
            "buf",
            "PAGE_SIZE - 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_L1D_THREAD_PRIV"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nssize_t cpu_show_meltdown(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tbool thread_priv;\n\n\tthread_priv = security_ftr_enabled(SEC_FTR_L1D_THREAD_PRIV);\n\n\tif (rfi_flush) {\n\t\tstruct seq_buf s;\n\t\tseq_buf_init(&s, buf, PAGE_SIZE - 1);\n\n\t\tseq_buf_printf(&s, \"Mitigation: RFI Flush\");\n\t\tif (thread_priv)\n\t\t\tseq_buf_printf(&s, \", L1D private per thread\");\n\n\t\tseq_buf_printf(&s, \"\\n\");\n\n\t\treturn s.len;\n\t}\n\n\tif (thread_priv)\n\t\treturn sprintf(buf, \"Vulnerable: L1D private per thread\\n\");\n\n\tif (!security_ftr_enabled(SEC_FTR_L1D_FLUSH_HV) &&\n\t    !security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR))\n\t\treturn sprintf(buf, \"Not affected\\n\");\n\n\treturn sprintf(buf, \"Vulnerable\\n\");\n}"
  },
  {
    "function_name": "setup_spectre_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "133-139",
    "snippet": "void setup_spectre_v2(void)\n{\n\tif (no_spectrev2 || cpu_mitigations_off())\n\t\tdo_btb_flush_fixups();\n\telse\n\t\tbtb_flush_enabled = true;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool btb_flush_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_btb_flush_fixups",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_mitigations_off",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic bool btb_flush_enabled;\n\nvoid setup_spectre_v2(void)\n{\n\tif (no_spectrev2 || cpu_mitigations_off())\n\t\tdo_btb_flush_fixups();\n\telse\n\t\tbtb_flush_enabled = true;\n}"
  },
  {
    "function_name": "handle_nospectre_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "123-128",
    "snippet": "static int __init handle_nospectre_v2(char *p)\n{\n\tno_spectrev2 = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic int __init handle_nospectre_v2(char *p)\n{\n\tno_spectrev2 = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "security_feature_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "113-118",
    "snippet": "static __init int security_feature_debugfs_init(void)\n{\n\tdebugfs_create_x64(\"security_features\", 0400, powerpc_debugfs_root,\n\t\t\t   &powerpc_security_features);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u64 powerpc_security_features"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_x64",
          "args": [
            "\"security_features\"",
            "0400",
            "powerpc_debugfs_root",
            "&powerpc_security_features"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nu64 powerpc_security_features;\n\nstatic __init int security_feature_debugfs_init(void)\n{\n\tdebugfs_create_x64(\"security_features\", 0400, powerpc_debugfs_root,\n\t\t\t   &powerpc_security_features);\n\treturn 0;\n}"
  },
  {
    "function_name": "barrier_nospec_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "104-110",
    "snippet": "static __init int barrier_nospec_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"barrier_nospec\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_barrier_nospec);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file_unsafe",
          "args": [
            "\"barrier_nospec\"",
            "0600",
            "powerpc_debugfs_root",
            "NULL",
            "&fops_barrier_nospec"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int barrier_nospec_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"barrier_nospec\", 0600,\n\t\t\t\t   powerpc_debugfs_root, NULL,\n\t\t\t\t   &fops_barrier_nospec);\n\treturn 0;\n}"
  },
  {
    "function_name": "barrier_nospec_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "95-99",
    "snippet": "static int barrier_nospec_get(void *data, u64 *val)\n{\n\t*val = barrier_nospec_enabled ? 1 : 0;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool barrier_nospec_enabled;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nstatic int barrier_nospec_get(void *data, u64 *val)\n{\n\t*val = barrier_nospec_enabled ? 1 : 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "barrier_nospec_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "77-93",
    "snippet": "static int barrier_nospec_set(void *data, u64 val)\n{\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!!val == !!barrier_nospec_enabled)\n\t\treturn 0;\n\n\tenable_barrier_nospec(!!val);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool barrier_nospec_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_barrier_nospec",
          "args": [
            "!!val"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "enable_barrier_nospec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "39-43",
          "snippet": "static void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool barrier_nospec_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nstatic void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nstatic int barrier_nospec_set(void *data, u64 val)\n{\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!!val == !!barrier_nospec_enabled)\n\t\treturn 0;\n\n\tenable_barrier_nospec(!!val);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_nospectre_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "68-73",
    "snippet": "static int __init handle_nospectre_v1(char *p)\n{\n\tno_nospec = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool no_nospec;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic bool no_nospec;\n\nstatic int __init handle_nospectre_v1(char *p)\n{\n\tno_nospec = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_barrier_nospec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "45-66",
    "snippet": "void setup_barrier_nospec(void)\n{\n\tbool enable;\n\n\t/*\n\t * It would make sense to check SEC_FTR_SPEC_BAR_ORI31 below as well.\n\t * But there's a good reason not to. The two flags we check below are\n\t * both are enabled by default in the kernel, so if the hcall is not\n\t * functional they will be enabled.\n\t * On a system where the host firmware has been updated (so the ori\n\t * functions as a barrier), but on which the hypervisor (KVM/Qemu) has\n\t * not been updated, we would like to enable the barrier. Dropping the\n\t * check for SEC_FTR_SPEC_BAR_ORI31 achieves that. The only downside is\n\t * we potentially enable the barrier on systems where the host firmware\n\t * is not updated, but that's harmless as it's a no-op.\n\t */\n\tenable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) &&\n\t\t security_ftr_enabled(SEC_FTR_BNDS_CHK_SPEC_BAR);\n\n\tif (!no_nospec && !cpu_mitigations_off())\n\t\tenable_barrier_nospec(enable);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool no_nospec;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_barrier_nospec",
          "args": [
            "enable"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "enable_barrier_nospec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "39-43",
          "snippet": "static void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool barrier_nospec_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nstatic void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_mitigations_off",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_BNDS_CHK_SPEC_BAR"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ftr_enabled",
          "args": [
            "SEC_FTR_FAVOUR_SECURITY"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic bool no_nospec;\n\nvoid setup_barrier_nospec(void)\n{\n\tbool enable;\n\n\t/*\n\t * It would make sense to check SEC_FTR_SPEC_BAR_ORI31 below as well.\n\t * But there's a good reason not to. The two flags we check below are\n\t * both are enabled by default in the kernel, so if the hcall is not\n\t * functional they will be enabled.\n\t * On a system where the host firmware has been updated (so the ori\n\t * functions as a barrier), but on which the hypervisor (KVM/Qemu) has\n\t * not been updated, we would like to enable the barrier. Dropping the\n\t * check for SEC_FTR_SPEC_BAR_ORI31 achieves that. The only downside is\n\t * we potentially enable the barrier on systems where the host firmware\n\t * is not updated, but that's harmless as it's a no-op.\n\t */\n\tenable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) &&\n\t\t security_ftr_enabled(SEC_FTR_BNDS_CHK_SPEC_BAR);\n\n\tif (!no_nospec && !cpu_mitigations_off())\n\t\tenable_barrier_nospec(enable);\n}"
  },
  {
    "function_name": "enable_barrier_nospec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
    "lines": "39-43",
    "snippet": "static void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}",
    "includes": [
      "#include <asm/inst.h>",
      "#include <asm/setup.h>",
      "#include <asm/security_features.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <linux/seq_buf.h>",
      "#include <linux/prctl.h>",
      "#include <linux/nospec.h>",
      "#include <linux/device.h>",
      "#include <linux/kernel.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool barrier_nospec_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_barrier_nospec_fixups",
          "args": [
            "enable"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nbool barrier_nospec_enabled;\n\nstatic void enable_barrier_nospec(bool enable)\n{\n\tbarrier_nospec_enabled = enable;\n\tdo_barrier_nospec_fixups(enable);\n}"
  }
]