[
  {
    "function_name": "of_pci_phb_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/of_platform.c",
    "lines": "35-83",
    "snippet": "static int of_pci_phb_probe(struct platform_device *dev)\n{\n\tstruct pci_controller *phb;\n\n\t/* Check if we can do that ... */\n\tif (ppc_md.pci_setup_phb == NULL)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Setting up PCI bus %pOF\\n\", dev->dev.of_node);\n\n\t/* Alloc and setup PHB data structure */\n\tphb = pcibios_alloc_controller(dev->dev.of_node);\n\tif (!phb)\n\t\treturn -ENODEV;\n\n\t/* Setup parent in sysfs */\n\tphb->parent = &dev->dev;\n\n\t/* Setup the PHB using arch provided callback */\n\tif (ppc_md.pci_setup_phb(phb)) {\n\t\tpcibios_free_controller(phb);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Process \"ranges\" property */\n\tpci_process_bridge_OF_ranges(phb, dev->dev.of_node, 0);\n\n\t/* Init pci_dn data structures */\n\tpci_devs_phb_init_dynamic(phb);\n\n\t/* Create EEH PE for the PHB */\n\teeh_phb_pe_create(phb);\n\n\t/* Scan the bus */\n\tpcibios_scan_phb(phb);\n\tif (phb->bus == NULL)\n\t\treturn -ENXIO;\n\n\t/* Claim resources. This might need some rework as well depending\n\t * whether we are doing probe-only or not, like assigning unassigned\n\t * resources etc...\n\t */\n\tpcibios_claim_one_bus(phb->bus);\n\n\t/* Add probed PCI devices to the device model */\n\tpci_bus_add_devices(phb->bus);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/topology.h>",
      "#include <asm/errno.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of_platform.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of.h>",
      "#include <linux/pci.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "phb->bus"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "phb->bus"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1462-1488",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_scan_phb",
          "args": [
            "phb"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_scan_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1659-1719",
          "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_create",
          "args": [
            "phb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "79-96",
          "snippet": "int eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nint eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%x\\n\", phb->global_number);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_devs_phb_init_dynamic",
          "args": [
            "phb"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devs_phb_init_dynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "506-522",
          "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_process_bridge_OF_ranges",
          "args": [
            "phb",
            "dev->dev.of_node",
            "0"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_bridge_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "773-873",
          "snippet": "void pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %pOF %s ranges:\\n\",\n\t       dev, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.flags & IORESOURCE_PREFETCH) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "resource_size_t isa_mem_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t isa_mem_base;\n\nvoid pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %pOF %s ranges:\\n\",\n\t       dev, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.flags & IORESOURCE_PREFETCH) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_free_controller",
          "args": [
            "phb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_free_controller_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "176-184",
          "snippet": "void pcibios_free_controller_deferred(struct pci_host_bridge *bridge)\n{\n\tstruct pci_controller *phb = (struct pci_controller *)\n\t\t\t\t\t bridge->release_data;\n\n\tpr_debug(\"domain %d, dynamic %d\\n\", phb->global_number, phb->is_dynamic);\n\n\tpcibios_free_controller(phb);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_free_controller_deferred(struct pci_host_bridge *bridge)\n{\n\tstruct pci_controller *phb = (struct pci_controller *)\n\t\t\t\t\t bridge->release_data;\n\n\tpr_debug(\"domain %d, dynamic %d\\n\", phb->global_number, phb->is_dynamic);\n\n\tpcibios_free_controller(phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.pci_setup_phb",
          "args": [
            "phb"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_alloc_controller",
          "args": [
            "dev->dev.of_node"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_alloc_controller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "108-132",
          "snippet": "struct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = get_phb_number(dev);\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = NUMA_NO_NODE;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hose_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nstruct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = get_phb_number(dev);\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = NUMA_NO_NODE;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting up PCI bus %pOF\\n\"",
            "dev->dev.of_node"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/topology.h>\n#include <asm/errno.h>\n#include <linux/atomic.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/mod_devicetable.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int of_pci_phb_probe(struct platform_device *dev)\n{\n\tstruct pci_controller *phb;\n\n\t/* Check if we can do that ... */\n\tif (ppc_md.pci_setup_phb == NULL)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Setting up PCI bus %pOF\\n\", dev->dev.of_node);\n\n\t/* Alloc and setup PHB data structure */\n\tphb = pcibios_alloc_controller(dev->dev.of_node);\n\tif (!phb)\n\t\treturn -ENODEV;\n\n\t/* Setup parent in sysfs */\n\tphb->parent = &dev->dev;\n\n\t/* Setup the PHB using arch provided callback */\n\tif (ppc_md.pci_setup_phb(phb)) {\n\t\tpcibios_free_controller(phb);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Process \"ranges\" property */\n\tpci_process_bridge_OF_ranges(phb, dev->dev.of_node, 0);\n\n\t/* Init pci_dn data structures */\n\tpci_devs_phb_init_dynamic(phb);\n\n\t/* Create EEH PE for the PHB */\n\teeh_phb_pe_create(phb);\n\n\t/* Scan the bus */\n\tpcibios_scan_phb(phb);\n\tif (phb->bus == NULL)\n\t\treturn -ENXIO;\n\n\t/* Claim resources. This might need some rework as well depending\n\t * whether we are doing probe-only or not, like assigning unassigned\n\t * resources etc...\n\t */\n\tpcibios_claim_one_bus(phb->bus);\n\n\t/* Add probed PCI devices to the device model */\n\tpci_bus_add_devices(phb->bus);\n\n\treturn 0;\n}"
  }
]