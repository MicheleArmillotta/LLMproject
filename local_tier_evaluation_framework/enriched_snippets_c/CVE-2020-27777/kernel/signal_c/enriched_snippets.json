[
  {
    "function_name": "get_tm_stackpointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "338-385",
    "snippet": "unsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_TRANSACTIONAL",
          "args": [
            "tsk->thread.regs->msr"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_reclaim_current",
          "args": [
            "TM_CAUSE_SIGNAL"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "959-963",
          "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, cause);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "tsk->thread.regs->msr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct task_struct *tsk)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted because of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n\tunsigned long ret = tsk->thread.regs->gpr[1];\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tBUG_ON(tsk != current);\n\n\tif (MSR_TM_ACTIVE(tsk->thread.regs->msr)) {\n\t\tpreempt_disable();\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(tsk->thread.regs->msr))\n\t\t\tret = tsk->thread.ckpt_regs.gpr[1];\n\n\t\t/*\n\t\t * If we treclaim, we must clear the current thread's TM bits\n\t\t * before re-enabling preemption. Otherwise we might be\n\t\t * preempted and have the live MSR[TS] changed behind our back\n\t\t * (tm_recheckpoint_new_task() would recheckpoint). Besides, we\n\t\t * enter the signal handler in non-transactional state.\n\t\t */\n\t\ttsk->thread.regs->msr &= ~MSR_TS_MASK;\n\t\tpreempt_enable();\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_notify_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "311-336",
    "snippet": "void do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_handle_notify_resume",
          "args": [
            "NULL",
            "regs"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_notify_resume",
          "args": [
            "regs"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_NOTIFY_RESUME"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_signal",
          "args": [
            "current"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "do_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "259-309",
          "snippet": "static void do_signal(struct task_struct *tsk)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig = { .sig = 0 };\n\tint ret;\n\n\tBUG_ON(tsk != current);\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(tsk->thread.regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tset_trap_norestart(tsk->thread.regs);\n\t\treturn;               /* no signals delivered */\n\t}\n\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (!IS_ENABLED(CONFIG_PPC_ADV_DEBUG_REGS)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (tsk->thread.hw_brk[i].address && tsk->thread.hw_brk[i].type)\n\t\t\t\t__set_breakpoint(i, &tsk->thread.hw_brk[i]);\n\t\t}\n\t}\n\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(tsk, tsk->thread.regs);\n\n\trseq_signal_deliver(&ksig, tsk->thread.regs);\n\n\tif (is_32bit_task()) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, tsk);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, tsk);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, tsk);\n\t}\n\n\tset_trap_norestart(tsk->thread.regs);\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void do_signal(struct task_struct *tsk)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig = { .sig = 0 };\n\tint ret;\n\n\tBUG_ON(tsk != current);\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(tsk->thread.regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tset_trap_norestart(tsk->thread.regs);\n\t\treturn;               /* no signals delivered */\n\t}\n\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (!IS_ENABLED(CONFIG_PPC_ADV_DEBUG_REGS)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (tsk->thread.hw_brk[i].address && tsk->thread.hw_brk[i].type)\n\t\t\t\t__set_breakpoint(i, &tsk->thread.hw_brk[i]);\n\t\t}\n\t}\n\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(tsk, tsk->thread.regs);\n\n\trseq_signal_deliver(&ksig, tsk->thread.regs);\n\n\tif (is_32bit_task()) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, tsk);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, tsk);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, tsk);\n\t}\n\n\tset_trap_norestart(tsk->thread.regs);\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "regs != current->thread.regs"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "current"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_notify_resume",
          "args": [
            "regs"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_limit_user_check",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid do_notify_resume(struct pt_regs *regs, unsigned long thread_info_flags)\n{\n\tuser_exit();\n\n\t/* Check valid addr_limit, TIF check is done there */\n\taddr_limit_user_check();\n\n\tif (thread_info_flags & _TIF_UPROBE)\n\t\tuprobe_notify_resume(regs);\n\n\tif (thread_info_flags & _TIF_PATCH_PENDING)\n\t\tklp_update_patch_state(current);\n\n\tif (thread_info_flags & _TIF_SIGPENDING) {\n\t\tBUG_ON(regs != current->thread.regs);\n\t\tdo_signal(current);\n\t}\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(regs);\n\t\trseq_handle_notify_resume(NULL, regs);\n\t}\n\n\tuser_enter();\n}"
  },
  {
    "function_name": "do_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "259-309",
    "snippet": "static void do_signal(struct task_struct *tsk)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig = { .sig = 0 };\n\tint ret;\n\n\tBUG_ON(tsk != current);\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(tsk->thread.regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tset_trap_norestart(tsk->thread.regs);\n\t\treturn;               /* no signals delivered */\n\t}\n\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (!IS_ENABLED(CONFIG_PPC_ADV_DEBUG_REGS)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (tsk->thread.hw_brk[i].address && tsk->thread.hw_brk[i].type)\n\t\t\t\t__set_breakpoint(i, &tsk->thread.hw_brk[i]);\n\t\t}\n\t}\n\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(tsk, tsk->thread.regs);\n\n\trseq_signal_deliver(&ksig, tsk->thread.regs);\n\n\tif (is_32bit_task()) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, tsk);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, tsk);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, tsk);\n\t}\n\n\tset_trap_norestart(tsk->thread.regs);\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_setup_done",
          "args": [
            "ret",
            "&ksig",
            "test_thread_flag(TIF_SINGLESTEP)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trap_norestart",
          "args": [
            "tsk->thread.regs"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_rt_signal64",
          "args": [
            "&ksig",
            "oldset",
            "tsk"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rt_signal64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.h",
          "lines": "53-57",
          "snippet": "static inline int handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\t\t\t     struct task_struct *tsk)\n{\n\treturn -EFAULT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int handle_rt_signal64(struct ksignal *ksig, sigset_t *set,\n\t\t\t\t     struct task_struct *tsk)\n{\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_signal32",
          "args": [
            "&ksig",
            "oldset",
            "tsk"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "handle_signal32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "1213-1298",
          "snippet": "int handle_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\tstruct task_struct *tsk)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
            "#define mcontext\tmcontext32",
            "#define sigcontext\tsigcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nint handle_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\tstruct task_struct *tsk)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_rt_signal32",
          "args": [
            "&ksig",
            "oldset",
            "tsk"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rt_signal32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "751-846",
          "snippet": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define copy_siginfo_to_user\tcopy_siginfo_to_user32",
            "#define tramp\tmc_pad",
            "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
            "#define __save_altstack __compat_save_altstack",
            "#define ucontext\tucontext32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/asm-prototypes.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define copy_siginfo_to_user\tcopy_siginfo_to_user32\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define __save_altstack __compat_save_altstack\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nint handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct task_struct *tsk)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\tstruct pt_regs *regs = tsk->thread.regs;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t/* Save the thread's msr before get_tm_stackpointer() changes it */\n\tunsigned long msr = regs->msr;\n#endif\n\n\tBUG_ON(tsk != current);\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(tsk), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && tsk->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = tsk->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret, msr))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\ttsk->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   tsk->comm, tsk->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_signal_deliver",
          "args": [
            "&ksig",
            "tsk->thread.regs"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_change_pc",
          "args": [
            "tsk",
            "tsk->thread.regs"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "thread_change_pc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "477-495",
          "snippet": "void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (unlikely(tsk->thread.last_hit_ubp[i]))\n\t\t\tgoto reset;\n\t}\n\treturn;\n\nreset:\n\tregs->msr &= ~MSR_SE;\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tinfo = counter_arch_bp(__this_cpu_read(bp_per_reg[i]));\n\t\t__set_breakpoint(i, info);\n\t\ttsk->thread.last_hit_ubp[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nvoid thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (unlikely(tsk->thread.last_hit_ubp[i]))\n\t\t\tgoto reset;\n\t}\n\treturn;\n\nreset:\n\tregs->msr &= ~MSR_SE;\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tinfo = counter_arch_bp(__this_cpu_read(bp_per_reg[i]));\n\t\t__set_breakpoint(i, info);\n\t\ttsk->thread.last_hit_ubp[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "&tsk->thread.hw_brk[i]"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_ADV_DEBUG_REGS"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_trap_norestart",
          "args": [
            "tsk->thread.regs"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_saved_sigmask",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_syscall_restart",
          "args": [
            "tsk->thread.regs",
            "&ksig.ka",
            "ksig.sig > 0"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "check_syscall_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
          "lines": "194-257",
          "snippet": "static void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (!trap_is_syscall(regs))\n\t\treturn;\n\n\tif (trap_norestart(regs))\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (trap_is_scv(regs)) {\n\t\t/* 32-bit compat mode sign extend? */\n\t\tif (!IS_ERR_VALUE(ret))\n\t\t\treturn;\n\t\tret = -ret;\n\t} else if (!(regs->ccr & 0x10000000)) {\n\t\treturn;\n\t}\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tif (trap_is_scv(regs)) {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = -EINTR;\n\t\t} else {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = EINTR;\n\t\t\tregs->ccr |= 0x10000000;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (!trap_is_syscall(regs))\n\t\treturn;\n\n\tif (trap_norestart(regs))\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (trap_is_scv(regs)) {\n\t\t/* 32-bit compat mode sign extend? */\n\t\tif (!IS_ERR_VALUE(ret))\n\t\t\treturn;\n\t\tret = -ret;\n\t} else if (!(regs->ccr & 0x10000000)) {\n\t\treturn;\n\t}\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tif (trap_is_scv(regs)) {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = -EINTR;\n\t\t} else {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = EINTR;\n\t\t\tregs->ccr |= 0x10000000;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_signal",
          "args": [
            "&ksig"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask_to_save",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void do_signal(struct task_struct *tsk)\n{\n\tsigset_t *oldset = sigmask_to_save();\n\tstruct ksignal ksig = { .sig = 0 };\n\tint ret;\n\n\tBUG_ON(tsk != current);\n\n\tget_signal(&ksig);\n\n\t/* Is there any syscall restart business here ? */\n\tcheck_syscall_restart(tsk->thread.regs, &ksig.ka, ksig.sig > 0);\n\n\tif (ksig.sig <= 0) {\n\t\t/* No signal to deliver -- put the saved sigmask back */\n\t\trestore_saved_sigmask();\n\t\tset_trap_norestart(tsk->thread.regs);\n\t\treturn;               /* no signals delivered */\n\t}\n\n        /*\n\t * Reenable the DABR before delivering the signal to\n\t * user space. The DABR will have been cleared if it\n\t * triggered inside the kernel.\n\t */\n\tif (!IS_ENABLED(CONFIG_PPC_ADV_DEBUG_REGS)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (tsk->thread.hw_brk[i].address && tsk->thread.hw_brk[i].type)\n\t\t\t\t__set_breakpoint(i, &tsk->thread.hw_brk[i]);\n\t\t}\n\t}\n\n\t/* Re-enable the breakpoints for the signal stack */\n\tthread_change_pc(tsk, tsk->thread.regs);\n\n\trseq_signal_deliver(&ksig, tsk->thread.regs);\n\n\tif (is_32bit_task()) {\n        \tif (ksig.ka.sa.sa_flags & SA_SIGINFO)\n\t\t\tret = handle_rt_signal32(&ksig, oldset, tsk);\n\t\telse\n\t\t\tret = handle_signal32(&ksig, oldset, tsk);\n\t} else {\n\t\tret = handle_rt_signal64(&ksig, oldset, tsk);\n\t}\n\n\tset_trap_norestart(tsk->thread.regs);\n\tsignal_setup_done(ret, &ksig, test_thread_flag(TIF_SINGLESTEP));\n}"
  },
  {
    "function_name": "check_syscall_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "194-257",
    "snippet": "static void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (!trap_is_syscall(regs))\n\t\treturn;\n\n\tif (trap_norestart(regs))\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (trap_is_scv(regs)) {\n\t\t/* 32-bit compat mode sign extend? */\n\t\tif (!IS_ERR_VALUE(ret))\n\t\t\treturn;\n\t\tret = -ret;\n\t} else if (!(regs->ccr & 0x10000000)) {\n\t\treturn;\n\t}\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tif (trap_is_scv(regs)) {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = -EINTR;\n\t\t} else {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = EINTR;\n\t\t\tregs->ccr |= 0x10000000;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trap_is_scv",
          "args": [
            "regs"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "ret"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trap_is_scv",
          "args": [
            "regs"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trap_norestart",
          "args": [
            "regs"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trap_is_syscall",
          "args": [
            "regs"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nstatic void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,\n\t\t\t\t  int has_handler)\n{\n\tunsigned long ret = regs->gpr[3];\n\tint restart = 1;\n\n\t/* syscall ? */\n\tif (!trap_is_syscall(regs))\n\t\treturn;\n\n\tif (trap_norestart(regs))\n\t\treturn;\n\n\t/* error signalled ? */\n\tif (trap_is_scv(regs)) {\n\t\t/* 32-bit compat mode sign extend? */\n\t\tif (!IS_ERR_VALUE(ret))\n\t\t\treturn;\n\t\tret = -ret;\n\t} else if (!(regs->ccr & 0x10000000)) {\n\t\treturn;\n\t}\n\n\tswitch (ret) {\n\tcase ERESTART_RESTARTBLOCK:\n\tcase ERESTARTNOHAND:\n\t\t/* ERESTARTNOHAND means that the syscall should only be\n\t\t * restarted if there was no handler for the signal, and since\n\t\t * we only get here if there is a handler, we dont restart.\n\t\t */\n\t\trestart = !has_handler;\n\t\tbreak;\n\tcase ERESTARTSYS:\n\t\t/* ERESTARTSYS means to restart the syscall if there is no\n\t\t * handler or the handler was registered with SA_RESTART\n\t\t */\n\t\trestart = !has_handler || (ka->sa.sa_flags & SA_RESTART) != 0;\n\t\tbreak;\n\tcase ERESTARTNOINTR:\n\t\t/* ERESTARTNOINTR means that the syscall should be\n\t\t * called again after the signal handler returns.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (restart) {\n\t\tif (ret == ERESTART_RESTARTBLOCK)\n\t\t\tregs->gpr[0] = __NR_restart_syscall;\n\t\telse\n\t\t\tregs->gpr[3] = regs->orig_gpr3;\n\t\tregs->nip -= 4;\n\t\tregs->result = 0;\n\t} else {\n\t\tif (trap_is_scv(regs)) {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = -EINTR;\n\t\t} else {\n\t\t\tregs->result = -EINTR;\n\t\t\tregs->gpr[3] = EINTR;\n\t\t\tregs->ccr |= 0x10000000;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_sigframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "177-192",
    "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "(void __user *)newsp",
            "oldsp - newsp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigsp",
          "args": [
            "oldsp",
            "ksig"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clean_sp",
          "args": [
            "sp",
            "is_32"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok((void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
  },
  {
    "function_name": "copy_ckfpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "159-164",
    "snippet": "inline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "task->thread.ckfp_state.fpr",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.ckfp_state.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_ckfpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "152-157",
    "snippet": "inline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "task->thread.ckfp_state.fpr",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.ckfp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "144-149",
    "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "task->thread.fp_state.fpr",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "137-142",
    "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "task->thread.fp_state.fpr",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_ckvsx_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "123-134",
    "snippet": "unsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_ckvsx_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "111-121",
    "snippet": "unsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckvsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_ckfpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "96-109",
    "snippet": "unsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_CKFPR(i) = buf[i];\n\ttask->thread.ckfp_state.fpscr = buf[i];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task->thread.TS_CKFPR",
          "args": [
            "i"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckfpr_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_CKFPR(i) = buf[i];\n\ttask->thread.ckfp_state.fpscr = buf[i];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_ckfpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "83-94",
    "snippet": "unsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_CKFPR(i);\n\tbuf[i] = task->thread.ckfp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task->thread.TS_CKFPR",
          "args": [
            "i"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_ckfpr_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_CKFPR(i);\n\tbuf[i] = task->thread.ckfp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_vsx_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "69-80",
    "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_vsx_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "57-67",
    "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "42-55",
    "snippet": "unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_FPR(i) = buf[i];\n\ttask->thread.fp_state.fpscr = buf[i];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_FPR(i) = buf[i];\n\ttask->thread.fp_state.fpscr = buf[i];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/signal.c",
    "lines": "29-40",
    "snippet": "unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_FPR(i);\n\tbuf[i] = task->thread.fp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/debug.h>",
      "#include <asm/unistd.h>",
      "#include <asm/switch_to.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/key.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/signal.h>",
      "#include <linux/tracehook.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/switch_to.h>\n#include <linux/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/syscalls.h>\n#include <linux/livepatch.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long copy_fpr_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_FPR(i);\n\tbuf[i] = task->thread.fp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}"
  }
]