[
  {
    "function_name": "pci_dev_pdn_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "546-556",
    "snippet": "static void pci_dev_pdn_setup(struct pci_dev *pdev)\n{\n\tstruct pci_dn *pdn;\n\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn;\n\n\t/* Setup the fast path */\n\tpdn = pci_get_pdn(pdev);\n\tpdev->dev.archdata.pci_data = pdn;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "95-125",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_dev_pdn_setup(struct pci_dev *pdev)\n{\n\tstruct pci_dn *pdn;\n\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn;\n\n\t/* Setup the fast path */\n\tpdn = pci_get_pdn(pdev);\n\tpdev->dev.archdata.pci_data = pdn;\n}"
  },
  {
    "function_name": "pci_devs_phb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "533-542",
    "snippet": "static int __init pci_devs_phb_init(void)\n{\n\tstruct pci_controller *phb, *tmp;\n\n\t/* This must be done first so the device nodes have valid pci info! */\n\tlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\n\t\tpci_devs_phb_init_dynamic(phb);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_devs_phb_init_dynamic",
          "args": [
            "phb"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devs_phb_init_dynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "506-522",
          "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "phb",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int __init pci_devs_phb_init(void)\n{\n\tstruct pci_controller *phb, *tmp;\n\n\t/* This must be done first so the device nodes have valid pci info! */\n\tlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\n\t\tpci_devs_phb_init_dynamic(phb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_devs_phb_init_dynamic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "506-522",
    "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_traverse_device_nodes",
          "args": [
            "dn",
            "add_pdn",
            "phb"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "pci_traverse_device_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "401-443",
          "snippet": "void *pci_traverse_device_nodes(struct device_node *start,\n\t\t\t\tvoid *(*fn)(struct device_node *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (fn) {\n\t\t\tret = fn(dn, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *pci_traverse_device_nodes(struct device_node *start,\n\t\t\t\tvoid *(*fn)(struct device_node *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (fn) {\n\t\t\tret = fn(dn, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_add_device_node_info",
          "args": [
            "phb",
            "dn"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "pci_add_device_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "282-337",
          "snippet": "struct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tpdn = pci_add_device_node_info(phb, dn);\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\tpci_traverse_device_nodes(dn, add_pdn, phb);\n}"
  },
  {
    "function_name": "add_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "486-496",
    "snippet": "static void *add_pdn(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *hose = data;\n\tstruct pci_dn *pdn;\n\n\tpdn = pci_add_device_node_info(hose, dn);\n\tif (!pdn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_device_node_info",
          "args": [
            "hose",
            "dn"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "pci_add_device_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "282-337",
          "snippet": "struct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void *add_pdn(struct device_node *dn, void *data)\n{\n\tstruct pci_controller *hose = data;\n\tstruct pci_dn *pdn;\n\n\tpdn = pci_add_device_node_info(hose, dn);\n\tif (!pdn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "traverse_pci_dn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "468-484",
    "snippet": "void *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pdn",
            "data"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "58-93",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_dn_next_one",
          "args": [
            "root",
            "pdn"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "pci_dn_next_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "446-466",
          "snippet": "static struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *traverse_pci_dn(struct pci_dn *root,\n\t\t      void *(*fn)(struct pci_dn *, void *),\n\t\t      void *data)\n{\n\tstruct pci_dn *pdn = root;\n\tvoid *ret;\n\n\t/* Only scan the child nodes */\n\tfor (pdn = pci_dn_next_one(root, pdn); pdn;\n\t     pdn = pci_dn_next_one(root, pdn)) {\n\t\tret = fn(pdn, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_dn_next_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "446-466",
    "snippet": "static struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structpci_dn",
            "list"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structpci_dn",
            "list"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_dn_next_one(struct pci_dn *root,\n\t\t\t\t      struct pci_dn *pdn)\n{\n\tstruct list_head *next = pdn->child_list.next;\n\n\tif (next != &pdn->child_list)\n\t\treturn list_entry(next, struct pci_dn, list);\n\n\twhile (1) {\n\t\tif (pdn == root)\n\t\t\treturn NULL;\n\n\t\tnext = pdn->list.next;\n\t\tif (next != &pdn->parent->child_list)\n\t\t\tbreak;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn list_entry(next, struct pci_dn, list);\n}"
  },
  {
    "function_name": "pci_traverse_device_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "401-443",
    "snippet": "void *pci_traverse_device_nodes(struct device_node *start,\n\t\t\t\tvoid *(*fn)(struct device_node *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (fn) {\n\t\t\tret = fn(dn, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "dn",
            "data"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "58-93",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "classp",
            "1"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"class-code\"",
            "NULL"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid *pci_traverse_device_nodes(struct device_node *start,\n\t\t\t\tvoid *(*fn)(struct device_node *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct device_node *dn, *nextdn;\n\tvoid *ret;\n\n\t/* We started with a phb, iterate all childs */\n\tfor (dn = start->child; dn; dn = nextdn) {\n\t\tconst __be32 *classp;\n\t\tu32 class = 0;\n\n\t\tnextdn = NULL;\n\t\tclassp = of_get_property(dn, \"class-code\", NULL);\n\t\tif (classp)\n\t\t\tclass = of_read_number(classp, 1);\n\n\t\tif (fn) {\n\t\t\tret = fn(dn, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t/* If we are a PCI bridge, go down */\n\t\tif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\n\t\t\t\t  (class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\t/* Depth first...do children */\n\t\t\tnextdn = dn->child;\n\t\telse if (dn->sibling)\n\t\t\t/* ok, try next sibling instead. */\n\t\t\tnextdn = dn->sibling;\n\t\tif (!nextdn) {\n\t\t\t/* Walk up to next valid sibling. */\n\t\t\tdo {\n\t\t\t\tdn = dn->parent;\n\t\t\t\tif (dn == start)\n\t\t\t\t\treturn NULL;\n\t\t\t} while (dn->sibling == NULL);\n\t\t\tnextdn = dn->sibling;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_remove_device_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "340-380",
    "snippet": "void pci_remove_device_node_info(struct device_node *dn)\n{\n\tstruct pci_dn *pdn = dn ? PCI_DN(dn) : NULL;\n\tstruct device_node *parent;\n\tstruct pci_dev *pdev;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (edev)\n\t\tedev->pdn = NULL;\n#endif\n\n\tif (!pdn)\n\t\treturn;\n\n\tWARN_ON(!list_empty(&pdn->child_list));\n\tlist_del(&pdn->list);\n\n\t/* Drop the parent pci_dn's ref to our backing dt node */\n\tparent = of_get_parent(dn);\n\tif (parent)\n\t\tof_node_put(parent);\n\n\t/*\n\t * At this point we *might* still have a pci_dev that was\n\t * instantiated from this pci_dn. So defer free()ing it until\n\t * the pci_dev's release function is called.\n\t */\n\tpdev = pci_get_domain_bus_and_slot(pdn->phb->global_number,\n\t\t\tpdn->busno, pdn->devfn);\n\tif (pdev) {\n\t\t/* NB: pdev has a ref to dn */\n\t\tpci_dbg(pdev, \"marked pdn (from %pOF) as dead\\n\", dn);\n\t\tpdn->flags |= PCI_DN_FLAG_DEAD;\n\t} else {\n\t\tdn->data = NULL;\n\t\tkfree(pdn);\n\t}\n\n\tpci_dev_put(pdev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdn"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dbg",
          "args": [
            "pdev",
            "\"marked pdn (from %pOF) as dead\\n\"",
            "dn"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_domain_bus_and_slot",
          "args": [
            "pdn->phb->global_number",
            "pdn->busno",
            "pdn->devfn"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "parent"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "dn"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pdn->list"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pdn->child_list)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pdn->child_list"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_remove_device_node_info(struct device_node *dn)\n{\n\tstruct pci_dn *pdn = dn ? PCI_DN(dn) : NULL;\n\tstruct device_node *parent;\n\tstruct pci_dev *pdev;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\n\n\tif (edev)\n\t\tedev->pdn = NULL;\n#endif\n\n\tif (!pdn)\n\t\treturn;\n\n\tWARN_ON(!list_empty(&pdn->child_list));\n\tlist_del(&pdn->list);\n\n\t/* Drop the parent pci_dn's ref to our backing dt node */\n\tparent = of_get_parent(dn);\n\tif (parent)\n\t\tof_node_put(parent);\n\n\t/*\n\t * At this point we *might* still have a pci_dev that was\n\t * instantiated from this pci_dn. So defer free()ing it until\n\t * the pci_dev's release function is called.\n\t */\n\tpdev = pci_get_domain_bus_and_slot(pdn->phb->global_number,\n\t\t\tpdn->busno, pdn->devfn);\n\tif (pdev) {\n\t\t/* NB: pdev has a ref to dn */\n\t\tpci_dbg(pdev, \"marked pdn (from %pOF) as dead\\n\", dn);\n\t\tpdn->flags |= PCI_DN_FLAG_DEAD;\n\t} else {\n\t\tdn->data = NULL;\n\t\tkfree(pdn);\n\t}\n\n\tpci_dev_put(pdev);\n}"
  },
  {
    "function_name": "pci_add_device_node_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "282-337",
    "snippet": "struct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pdn->list",
            "&pdn->parent->child_list"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "parent"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_parent",
          "args": [
            "dn"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->list"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->child_list"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdn"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_init",
          "args": [
            "pdn"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "128-144",
          "snippet": "static struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "type",
            "1"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"class-code\"",
            "NULL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"device-id\"",
            "NULL"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"vendor-id\"",
            "NULL"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "regs",
            "1"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"reg\"",
            "NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pdn)",
            "GFP_KERNEL"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,pci-config-space-type\"",
            "NULL"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_add_device_node_info(struct pci_controller *hose,\n\t\t\t\t\tstruct device_node *dn)\n{\n\tconst __be32 *type = of_get_property(dn, \"ibm,pci-config-space-type\", NULL);\n\tconst __be32 *regs;\n\tstruct device_node *parent;\n\tstruct pci_dn *pdn;\n#ifdef CONFIG_EEH\n\tstruct eeh_dev *edev;\n#endif\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (pdn == NULL)\n\t\treturn NULL;\n\tdn->data = pdn;\n\tpdn->phb = hose;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tregs = of_get_property(dn, \"reg\", NULL);\n\tif (regs) {\n\t\tu32 addr = of_read_number(regs, 1);\n\n\t\t/* First register entry is addr (00BBSS00)  */\n\t\tpdn->busno = (addr >> 16) & 0xff;\n\t\tpdn->devfn = (addr >> 8) & 0xff;\n\t}\n\n\t/* vendor/device IDs and class code */\n\tregs = of_get_property(dn, \"vendor-id\", NULL);\n\tpdn->vendor_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"device-id\", NULL);\n\tpdn->device_id = regs ? of_read_number(regs, 1) : 0;\n\tregs = of_get_property(dn, \"class-code\", NULL);\n\tpdn->class_code = regs ? of_read_number(regs, 1) : 0;\n\n\t/* Extended config space */\n\tpdn->pci_ext_config_space = (type && of_read_number(type, 1) == 1);\n\n\t/* Create EEH device */\n#ifdef CONFIG_EEH\n\tedev = eeh_dev_init(pdn);\n\tif (!edev) {\n\t\tkfree(pdn);\n\t\treturn NULL;\n\t}\n#endif\n\n\t/* Attach to parent node */\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tparent = of_get_parent(dn);\n\tpdn->parent = parent ? PCI_DN(parent) : NULL;\n\tif (pdn->parent)\n\t\tlist_add_tail(&pdn->list, &pdn->parent->child_list);\n\n\treturn pdn;\n}"
  },
  {
    "function_name": "remove_sriov_vf_pdns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "217-279",
    "snippet": "void remove_sriov_vf_pdns(struct pci_dev *pdev)\n{\n\tstruct pci_dn *parent;\n\tstruct pci_dn *pdn, *tmp;\n\tint i;\n\n\t/* Only support IOV PF for now */\n\tif (WARN_ON(!pdev->is_physfn))\n\t\treturn;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || !(pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn;\n\n\tpdn->flags &= ~PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn;\n\n\t/*\n\t * We might introduce flag to pci_dn in future\n\t * so that we can release VF's firmware data in\n\t * a batch mode.\n\t */\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tstruct eeh_dev *edev __maybe_unused;\n\n\t\tlist_for_each_entry_safe(pdn, tmp,\n\t\t\t&parent->child_list, list) {\n\t\t\tif (pdn->busno != pci_iov_virtfn_bus(pdev, i) ||\n\t\t\t    pdn->devfn != pci_iov_virtfn_devfn(pdev, i))\n\t\t\t\tcontinue;\n\n#ifdef CONFIG_EEH\n\t\t\t/*\n\t\t\t * Release EEH state for this VF. The PCI core\n\t\t\t * has already torn down the pci_dev for this VF, but\n\t\t\t * we're responsible to removing the eeh_dev since it\n\t\t\t * has the same lifetime as the pci_dn that spawned it.\n\t\t\t */\n\t\t\tedev = pdn_to_eeh_dev(pdn);\n\t\t\tif (edev) {\n\t\t\t\t/*\n\t\t\t\t * We allocate pci_dn's for the totalvfs count,\n\t\t\t\t * but only only the vfs that were activated\n\t\t\t\t * have a configured PE.\n\t\t\t\t */\n\t\t\t\tif (edev->pe)\n\t\t\t\t\teeh_pe_tree_remove(edev);\n\n\t\t\t\tpdn->edev = NULL;\n\t\t\t\tkfree(edev);\n\t\t\t}\n#endif /* CONFIG_EEH */\n\n\t\t\tif (!list_empty(&pdn->list))\n\t\t\t\tlist_del(&pdn->list);\n\n\t\t\tkfree(pdn);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdn"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pdn->list"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pdn->list"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "edev"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_tree_remove",
          "args": [
            "edev"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "402-478",
          "snippet": "int eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_devfn",
          "args": [
            "pdev",
            "i"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_bus",
          "args": [
            "pdev",
            "i"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pdn",
            "tmp",
            "&parent->child_list",
            "list"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sriov_get_totalvfs",
          "args": [
            "pdev"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "30-56",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "95-125",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pdev->is_physfn"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid remove_sriov_vf_pdns(struct pci_dev *pdev)\n{\n\tstruct pci_dn *parent;\n\tstruct pci_dn *pdn, *tmp;\n\tint i;\n\n\t/* Only support IOV PF for now */\n\tif (WARN_ON(!pdev->is_physfn))\n\t\treturn;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || !(pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn;\n\n\tpdn->flags &= ~PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn;\n\n\t/*\n\t * We might introduce flag to pci_dn in future\n\t * so that we can release VF's firmware data in\n\t * a batch mode.\n\t */\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tstruct eeh_dev *edev __maybe_unused;\n\n\t\tlist_for_each_entry_safe(pdn, tmp,\n\t\t\t&parent->child_list, list) {\n\t\t\tif (pdn->busno != pci_iov_virtfn_bus(pdev, i) ||\n\t\t\t    pdn->devfn != pci_iov_virtfn_devfn(pdev, i))\n\t\t\t\tcontinue;\n\n#ifdef CONFIG_EEH\n\t\t\t/*\n\t\t\t * Release EEH state for this VF. The PCI core\n\t\t\t * has already torn down the pci_dev for this VF, but\n\t\t\t * we're responsible to removing the eeh_dev since it\n\t\t\t * has the same lifetime as the pci_dn that spawned it.\n\t\t\t */\n\t\t\tedev = pdn_to_eeh_dev(pdn);\n\t\t\tif (edev) {\n\t\t\t\t/*\n\t\t\t\t * We allocate pci_dn's for the totalvfs count,\n\t\t\t\t * but only only the vfs that were activated\n\t\t\t\t * have a configured PE.\n\t\t\t\t */\n\t\t\t\tif (edev->pe)\n\t\t\t\t\teeh_pe_tree_remove(edev);\n\n\t\t\t\tpdn->edev = NULL;\n\t\t\t\tkfree(edev);\n\t\t\t}\n#endif /* CONFIG_EEH */\n\n\t\t\tif (!list_empty(&pdn->list))\n\t\t\t\tlist_del(&pdn->list);\n\n\t\t\tkfree(pdn);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_sriov_vf_pdns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "173-215",
    "snippet": "struct pci_dn *add_sriov_vf_pdns(struct pci_dev *pdev)\n{\n\tstruct pci_dn *parent, *pdn;\n\tint i;\n\n\t/* Only support IOV for now */\n\tif (WARN_ON(!pdev->is_physfn))\n\t\treturn NULL;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || (pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn NULL;\n\n\tpdn->flags |= PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tstruct eeh_dev *edev __maybe_unused;\n\n\t\tpdn = add_one_sriov_vf_pdn(parent,\n\t\t\t\t\t   pci_iov_virtfn_bus(pdev, i),\n\t\t\t\t\t   pci_iov_virtfn_devfn(pdev, i));\n\t\tif (!pdn) {\n\t\t\tdev_warn(&pdev->dev, \"%s: Cannot create firmware data for VF#%d\\n\",\n\t\t\t\t __func__, i);\n\t\t\treturn NULL;\n\t\t}\n\n#ifdef CONFIG_EEH\n\t\t/* Create the EEH device for the VF */\n\t\tedev = eeh_dev_init(pdn);\n\t\tBUG_ON(!edev);\n\n\t\t/* FIXME: these should probably be populated by the EEH probe */\n\t\tedev->physfn = pdev;\n\t\tedev->vf_index = i;\n#endif /* CONFIG_EEH */\n\t}\n\treturn pci_get_pdn(pdev);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_get_pdn",
          "args": [
            "pdev"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "95-125",
          "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!edev"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_init",
          "args": [
            "pdn"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "128-144",
          "snippet": "static struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_warn",
          "args": [
            "&pdev->dev",
            "\"%s: Cannot create firmware data for VF#%d\\n\"",
            "__func__",
            "i"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_one_sriov_vf_pdn",
          "args": [
            "parent",
            "pci_iov_virtfn_bus(pdev, i)",
            "pci_iov_virtfn_devfn(pdev, i)"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "add_one_sriov_vf_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "148-171",
          "snippet": "static struct pci_dn *add_one_sriov_vf_pdn(struct pci_dn *parent,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn)\n\t\treturn NULL;\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *add_one_sriov_vf_pdn(struct pci_dn *parent,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn)\n\t\treturn NULL;\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_devfn",
          "args": [
            "pdev",
            "i"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_virtfn_bus",
          "args": [
            "pdev",
            "i"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sriov_get_totalvfs",
          "args": [
            "pdev"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "30-56",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pdev->is_physfn"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *add_sriov_vf_pdns(struct pci_dev *pdev)\n{\n\tstruct pci_dn *parent, *pdn;\n\tint i;\n\n\t/* Only support IOV for now */\n\tif (WARN_ON(!pdev->is_physfn))\n\t\treturn NULL;\n\n\t/* Check if VFs have been populated */\n\tpdn = pci_get_pdn(pdev);\n\tif (!pdn || (pdn->flags & PCI_DN_FLAG_IOV_VF))\n\t\treturn NULL;\n\n\tpdn->flags |= PCI_DN_FLAG_IOV_VF;\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pci_sriov_get_totalvfs(pdev); i++) {\n\t\tstruct eeh_dev *edev __maybe_unused;\n\n\t\tpdn = add_one_sriov_vf_pdn(parent,\n\t\t\t\t\t   pci_iov_virtfn_bus(pdev, i),\n\t\t\t\t\t   pci_iov_virtfn_devfn(pdev, i));\n\t\tif (!pdn) {\n\t\t\tdev_warn(&pdev->dev, \"%s: Cannot create firmware data for VF#%d\\n\",\n\t\t\t\t __func__, i);\n\t\t\treturn NULL;\n\t\t}\n\n#ifdef CONFIG_EEH\n\t\t/* Create the EEH device for the VF */\n\t\tedev = eeh_dev_init(pdn);\n\t\tBUG_ON(!edev);\n\n\t\t/* FIXME: these should probably be populated by the EEH probe */\n\t\tedev->physfn = pdev;\n\t\tedev->vf_index = i;\n#endif /* CONFIG_EEH */\n\t}\n\treturn pci_get_pdn(pdev);\n}"
  },
  {
    "function_name": "add_one_sriov_vf_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "148-171",
    "snippet": "static struct pci_dn *add_one_sriov_vf_pdn(struct pci_dn *parent,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn)\n\t\treturn NULL;\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\treturn pdn;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pdn->list",
            "&parent->child_list"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->list"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pdn->child_list"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pdn)",
            "GFP_KERNEL"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *add_one_sriov_vf_pdn(struct pci_dn *parent,\n\t\t\t\t\t   int busno, int devfn)\n{\n\tstruct pci_dn *pdn;\n\n\t/* Except PHB, we always have the parent */\n\tif (!parent)\n\t\treturn NULL;\n\n\tpdn = kzalloc(sizeof(*pdn), GFP_KERNEL);\n\tif (!pdn)\n\t\treturn NULL;\n\n\tpdn->phb = parent->phb;\n\tpdn->parent = parent;\n\tpdn->busno = busno;\n\tpdn->devfn = devfn;\n\tpdn->pe_number = IODA_INVALID_PE;\n\tINIT_LIST_HEAD(&pdn->child_list);\n\tINIT_LIST_HEAD(&pdn->list);\n\tlist_add_tail(&pdn->list, &parent->child_list);\n\n\treturn pdn;\n}"
  },
  {
    "function_name": "eeh_dev_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "128-144",
    "snippet": "static struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*edev)",
            "GFP_KERNEL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct eeh_dev *eeh_dev_init(struct pci_dn *pdn)\n{\n\tstruct eeh_dev *edev;\n\n\t/* Allocate EEH device */\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn NULL;\n\n\t/* Associate EEH device with OF node */\n\tpdn->edev = edev;\n\tedev->pdn = pdn;\n\tedev->bdfn = (pdn->busno << 8) | pdn->devfn;\n\tedev->controller = pdn->phb;\n\n\treturn edev;\n}"
  },
  {
    "function_name": "pci_get_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "95-125",
    "snippet": "struct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdn",
            "&parent->child_list",
            "list"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "pdev->bus"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "30-56",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn(struct pci_dev *pdev)\n{\n\tstruct device_node *dn;\n\tstruct pci_dn *parent, *pdn;\n\n\t/* Search device directly */\n\tif (pdev->dev.archdata.pci_data)\n\t\treturn pdev->dev.archdata.pci_data;\n\n\t/* Check device node */\n\tdn = pci_device_to_OF_node(pdev);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/*\n\t * VFs don't have device nodes. We hook their\n\t * firmware data to PF's bridge.\n\t */\n\tparent = pci_bus_to_pdn(pdev->bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == pdev->bus->number &&\n\t\t    pdn->devfn == pdev->devfn)\n\t\t\treturn pdn;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_get_pdn_by_devfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "58-93",
    "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdn",
            "&parent->child_list",
            "list"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_pdn",
          "args": [
            "bus"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_pdn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "30-56",
          "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_device_to_OF_node",
          "args": [
            "pdev"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pdev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_bus_to_pdn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_dn.c",
    "lines": "30-56",
    "snippet": "static struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/firmware.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <linux/gfp.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dn"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "pbus"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_is_root_bus",
          "args": [
            "pbus"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_dn *pci_bus_to_pdn(struct pci_bus *bus)\n{\n\tstruct pci_bus *pbus;\n\tstruct device_node *dn;\n\tstruct pci_dn *pdn;\n\n\t/*\n\t * We probably have virtual bus which doesn't\n\t * have associated bridge.\n\t */\n\tpbus = bus;\n\twhile (pbus) {\n\t\tif (pci_is_root_bus(pbus) || pbus->self)\n\t\t\tbreak;\n\n\t\tpbus = pbus->parent;\n\t}\n\n\t/*\n\t * Except virtual bus, all PCI buses should\n\t * have device nodes.\n\t */\n\tdn = pci_bus_to_OF_node(pbus);\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\n\treturn pdn;\n}"
  }
]