[
  {
    "function_name": "fixup_hide_host_resource_fsl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1722-1739",
    "snippet": "static void fixup_hide_host_resource_fsl(struct pci_dev *dev)\n{\n\tint i, class = dev->class >> 8;\n\t/* When configured as agent, programing interface = 1 */\n\tint prog_if = dev->class & 0xf;\n\n\tif ((class == PCI_CLASS_PROCESSOR_POWERPC ||\n\t     class == PCI_CLASS_BRIDGE_OTHER) &&\n\t\t(dev->hdr_type == PCI_HEADER_TYPE_NORMAL) &&\n\t\t(prog_if == 0) &&\n\t\t(dev->bus->parent == NULL)) {\n\t\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\t\tdev->resource[i].start = 0;\n\t\t\tdev->resource[i].end = 0;\n\t\t\tdev->resource[i].flags = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_hide_host_resource_fsl(struct pci_dev *dev)\n{\n\tint i, class = dev->class >> 8;\n\t/* When configured as agent, programing interface = 1 */\n\tint prog_if = dev->class & 0xf;\n\n\tif ((class == PCI_CLASS_PROCESSOR_POWERPC ||\n\t     class == PCI_CLASS_BRIDGE_OTHER) &&\n\t\t(dev->hdr_type == PCI_HEADER_TYPE_NORMAL) &&\n\t\t(prog_if == 0) &&\n\t\t(dev->bus->parent == NULL)) {\n\t\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\t\tdev->resource[i].start = 0;\n\t\t\tdev->resource[i].end = 0;\n\t\t\tdev->resource[i].flags = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcibios_scan_phb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1659-1719",
    "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcie_bus_configure_settings",
          "args": [
            "child"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&bus->children",
            "node"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_phb",
          "args": [
            "hose"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_update_busn_res_end",
          "args": [
            "bus",
            "hose->last_busno"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_scan_child_bus",
          "args": [
            "bus"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_update_busn_res_end",
          "args": [
            "bus",
            "255"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_bus",
          "args": [
            "node",
            "bus"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "of_scan_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_of_scan.c",
          "lines": "428-431",
          "snippet": "void of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}",
          "includes": [
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid of_scan_bus(struct device_node *node, struct pci_bus *bus)\n{\n\t__of_scan_bus(node, bus, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"    probe mode: %d\\n\"",
            "mode"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hose->controller_ops.probe_mode",
          "args": [
            "bus"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_free_resource_list",
          "args": [
            "&resources"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to create bus for PCI domain %04x\\n\"",
            "hose->global_number"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_create_root_bus",
          "args": [
            "hose->parent",
            "hose->first_busno",
            "hose->ops",
            "hose",
            "&resources"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_resource",
          "args": [
            "&resources",
            "&hose->busn"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_setup_phb_resources",
          "args": [
            "hose",
            "&resources"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_phb_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1542-1576",
          "snippet": "static void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_debug(\"PCI: I/O resource not set for host\"\n\t\t\t \" bridge %pOF (domain %d)\\n\",\n\t\t\t hose->dn, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\toffset = hose->mem_offset[i];\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_debug(\"PCI: I/O resource not set for host\"\n\t\t\t \" bridge %pOF (domain %d)\\n\",\n\t\t\t hose->dn, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\toffset = hose->mem_offset[i];\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_setup_phb_io_space",
          "args": [
            "hose"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_phb_io_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "223-232",
          "snippet": "void pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_irq_map_init",
          "args": [
            "hose"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_irq_map_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "401-411",
          "snippet": "static void pcibios_irq_map_init(struct pci_controller *phb)\n{\n\tphb->irq_count = pcibios_irq_map_count(phb);\n\tif (phb->irq_count < PCI_NUM_INTX)\n\t\tphb->irq_count = PCI_NUM_INTX;\n\n\tpr_debug(\"%pOF : interrupt map #%d\\n\", phb->dn, phb->irq_count);\n\n\tphb->irq_map = kcalloc(phb->irq_count, sizeof(unsigned int),\n\t\t\t       GFP_KERNEL);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_irq_map_init(struct pci_controller *phb)\n{\n\tphb->irq_count = pcibios_irq_map_count(phb);\n\tif (phb->irq_count < PCI_NUM_INTX)\n\t\tphb->irq_count = PCI_NUM_INTX;\n\n\tpr_debug(\"%pOF : interrupt map #%d\\n\", phb->dn, phb->irq_count);\n\n\tphb->irq_map = kcalloc(phb->irq_count, sizeof(unsigned int),\n\t\t\t       GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Scanning PHB %pOF\\n\"",
            "node"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "resources"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %pOF\\n\", node);\n\n\t/* Allocate interrupt mappings array */\n\tpcibios_irq_map_init(hose);\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
  },
  {
    "function_name": "fake_pci_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1613-1625",
    "snippet": "static struct pci_bus *\nfake_pci_bus(struct pci_controller *hose, int busnr)\n{\n\tstatic struct pci_bus bus;\n\n\tif (hose == NULL) {\n\t\tprintk(KERN_ERR \"Can't find hose for PCI bus %d!\\n\", busnr);\n\t}\n\tbus.number = busnr;\n\tbus.sysdata = hose;\n\tbus.ops = hose? hose->ops: &null_pci_ops;\n\treturn &bus;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pci_ops null_pci_ops =\n{\n\t.read = null_read_config,\n\t.write = null_write_config,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't find hose for PCI bus %d!\\n\"",
            "busnr"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_ops null_pci_ops =\n{\n\t.read = null_read_config,\n\t.write = null_write_config,\n};\n\nstatic struct pci_bus *\nfake_pci_bus(struct pci_controller *hose, int busnr)\n{\n\tstatic struct pci_bus bus;\n\n\tif (hose == NULL) {\n\t\tprintk(KERN_ERR \"Can't find hose for PCI bus %d!\\n\", busnr);\n\t}\n\tbus.number = busnr;\n\tbus.sysdata = hose;\n\tbus.ops = hose? hose->ops: &null_pci_ops;\n\treturn &bus;\n}"
  },
  {
    "function_name": "null_write_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1596-1601",
    "snippet": "static int\nnull_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t  int len, u32 val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int\nnull_write_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t  int len, u32 val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}"
  },
  {
    "function_name": "null_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1589-1594",
    "snippet": "static int\nnull_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t int len, u32 *val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int\nnull_read_config(struct pci_bus *bus, unsigned int devfn, int offset,\n\t\t int len, u32 *val)\n{\n\treturn PCIBIOS_DEVICE_NOT_FOUND;\n}"
  },
  {
    "function_name": "pcibios_setup_phb_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1542-1576",
    "snippet": "static void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_debug(\"PCI: I/O resource not set for host\"\n\t\t\t \" bridge %pOF (domain %d)\\n\",\n\t\t\t hose->dn, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\toffset = hose->mem_offset[i];\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_add_resource_offset",
          "args": [
            "resources",
            "res",
            "offset"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\"",
            "i",
            "res",
            "(unsigned long long)offset"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_add_resource_offset",
          "args": [
            "resources",
            "res",
            "offset"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\"",
            "res",
            "(unsigned long long)offset"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_space_offset",
          "args": [
            "hose"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_space_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1537-1540",
          "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: I/O resource not set for host\"\n\t\t\t \" bridge %pOF (domain %d)\\n\"",
            "hose->dn",
            "hose->global_number"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_setup_phb_resources(struct pci_controller *hose,\n\t\t\t\t\tstruct list_head *resources)\n{\n\tstruct resource *res;\n\tresource_size_t offset;\n\tint i;\n\n\t/* Hookup PHB IO resource */\n\tres = &hose->io_resource;\n\n\tif (!res->flags) {\n\t\tpr_debug(\"PCI: I/O resource not set for host\"\n\t\t\t \" bridge %pOF (domain %d)\\n\",\n\t\t\t hose->dn, hose->global_number);\n\t} else {\n\t\toffset = pcibios_io_space_offset(hose);\n\n\t\tpr_debug(\"PCI: PHB IO resource    = %pR off 0x%08llx\\n\",\n\t\t\t res, (unsigned long long)offset);\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n\n\t/* Hookup PHB Memory resources */\n\tfor (i = 0; i < 3; ++i) {\n\t\tres = &hose->mem_resources[i];\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\toffset = hose->mem_offset[i];\n\t\tpr_debug(\"PCI: PHB MEM resource %d = %pR off 0x%08llx\\n\", i,\n\t\t\t res, (unsigned long long)offset);\n\n\t\tpci_add_resource_offset(resources, res, offset);\n\t}\n}"
  },
  {
    "function_name": "pcibios_io_space_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1537-1540",
    "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
  },
  {
    "function_name": "pcibios_disable_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1529-1535",
    "snippet": "void pcibios_disable_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.disable_device)\n\t\tphb->controller_ops.disable_device(dev);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.disable_device",
          "args": [
            "dev"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_disable_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.disable_device)\n\t\tphb->controller_ops.disable_device(dev);\n}"
  },
  {
    "function_name": "pcibios_enable_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1518-1527",
    "snippet": "int pcibios_enable_device(struct pci_dev *dev, int mask)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.enable_device_hook)\n\t\tif (!phb->controller_ops.enable_device_hook(dev))\n\t\t\treturn -EINVAL;\n\n\treturn pci_enable_resources(dev, mask);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_enable_resources",
          "args": [
            "dev",
            "mask"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.enable_device_hook",
          "args": [
            "dev"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_enable_device(struct pci_dev *dev, int mask)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.enable_device_hook)\n\t\tif (!phb->controller_ops.enable_device_hook(dev))\n\t\t\treturn -EINVAL;\n\n\treturn pci_enable_resources(dev, mask);\n}"
  },
  {
    "function_name": "pcibios_finish_adding_to_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1498-1515",
    "snippet": "void pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tif (bus->self)\n\t\t\tpci_assign_unassigned_bridge_resources(bus->self);\n\t\telse\n\t\t\tpci_assign_unassigned_bus_resources(bus);\n\t}\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "bus"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_assign_unassigned_bus_resources",
          "args": [
            "bus"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_assign_unassigned_bridge_resources",
          "args": [
            "bus->self"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "bus"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1462-1488",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "bus"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1232-1301",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_finish_adding_to_bus(struct pci_bus *bus)\n{\n\tpr_debug(\"PCI: Finishing adding to hotplug bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\t/* Allocate bus and devices resources */\n\tpcibios_allocate_bus_resources(bus);\n\tpcibios_claim_one_bus(bus);\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tif (bus->self)\n\t\t\tpci_assign_unassigned_bridge_resources(bus->self);\n\t\telse\n\t\t\tpci_assign_unassigned_bus_resources(bus);\n\t}\n\n\t/* Add new devices to global lists.  Register in proc, sysfs. */\n\tpci_bus_add_devices(bus);\n}"
  },
  {
    "function_name": "pcibios_claim_one_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1462-1488",
    "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "child_bus"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1462-1488",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child_bus",
            "&bus->children",
            "node"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_bridge_resource",
          "args": [
            "dev",
            "i"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_resource",
          "args": [
            "dev",
            "i"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Claiming %s: Resource %d: %pR\\n\"",
            "pci_name(dev)",
            "i",
            "r"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&bus->devices",
            "bus_list"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
  },
  {
    "function_name": "pcibios_resource_survey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1427-1455",
    "snippet": "void __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_assign_unassigned_resources",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Assigning unassigned resources...\\n\""
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_reserve_legacy_regions",
          "args": [
            "b"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_reserve_legacy_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1371-1425",
          "snippet": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&pci_root_buses",
            "node"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_resources",
          "args": [
            "1"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1324-1369",
          "snippet": "static void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "b"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1232-1301",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&pci_root_buses",
            "node"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\tpcibios_allocate_resources(0);\n\t\tpcibios_allocate_resources(1);\n\t}\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n}"
  },
  {
    "function_name": "pcibios_reserve_legacy_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1371-1425",
    "snippet": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "res"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pres",
            "res"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Candidate VGA memory: %pR\\n\"",
            "res"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res == NULL"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "GFP_KERNEL"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"hose mem res: %pR\\n\"",
            "pres"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "res"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "res"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "&hose->io_resource",
            "res"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Candidate legacy IO: %pR\\n\"",
            "res"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res == NULL"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct resource)",
            "GFP_KERNEL"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Reserving legacy ranges for domain %04x\\n\"",
            "pci_domain_nr(bus)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}"
  },
  {
    "function_name": "pcibios_allocate_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1324-1369",
    "snippet": "static void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config_dword",
          "args": [
            "dev",
            "dev->rom_base_reg",
            "reg & ~PCI_ROM_ADDRESS_ENABLE"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Switching off ROM of %s\\n\"",
            "pci_name(dev)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_dword",
          "args": [
            "dev",
            "dev->rom_base_reg",
            "&reg"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_resource",
          "args": [
            "dev",
            "idx"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1303-1322",
          "snippet": "static inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void __init pcibios_allocate_resources(int pass)\n{\n\tstruct pci_dev *dev = NULL;\n\tint idx, disabled;\n\tu16 command;\n\tstruct resource *r;\n\n\tfor_each_pci_dev(dev) {\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tfor (idx = 0; idx <= PCI_ROM_RESOURCE; idx++) {\n\t\t\tr = &dev->resource[idx];\n\t\t\tif (r->parent)\t\t/* Already allocated */\n\t\t\t\tcontinue;\n\t\t\tif (!r->flags || (r->flags & IORESOURCE_UNSET))\n\t\t\t\tcontinue;\t/* Not assigned at all */\n\t\t\t/* We only allocate ROMs on pass 1 just in case they\n\t\t\t * have been screwed up by firmware\n\t\t\t */\n\t\t\tif (idx == PCI_ROM_RESOURCE )\n\t\t\t\tdisabled = 1;\n\t\t\tif (r->flags & IORESOURCE_IO)\n\t\t\t\tdisabled = !(command & PCI_COMMAND_IO);\n\t\t\telse\n\t\t\t\tdisabled = !(command & PCI_COMMAND_MEMORY);\n\t\t\tif (pass == disabled)\n\t\t\t\talloc_resource(dev, idx);\n\t\t}\n\t\tif (pass)\n\t\t\tcontinue;\n\t\tr = &dev->resource[PCI_ROM_RESOURCE];\n\t\tif (r->flags) {\n\t\t\t/* Turn the ROM off, leave the resource region,\n\t\t\t * but keep it unregistered.\n\t\t\t */\n\t\t\tu32 reg;\n\t\t\tpci_read_config_dword(dev, dev->rom_base_reg, &reg);\n\t\t\tif (reg & PCI_ROM_ADDRESS_ENABLE) {\n\t\t\t\tpr_debug(\"PCI: Switching off ROM of %s\\n\",\n\t\t\t\t\t pci_name(dev));\n\t\t\t\tr->flags &= ~IORESOURCE_ROM_ENABLE;\n\t\t\t\tpci_write_config_dword(dev, dev->rom_base_reg,\n\t\t\t\t\t\t       reg & ~PCI_ROM_ADDRESS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "alloc_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1303-1322",
    "snippet": "static inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:  parent is %p: %pR\\n\"",
            "pr",
            "pr"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\"",
            "idx",
            "pci_name(dev)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pr",
            "r"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_parent_resource",
          "args": [
            "dev",
            "r"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Allocating %s: Resource %d: %pR\\n\"",
            "pci_name(dev)",
            "idx",
            "r"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic inline void alloc_resource(struct pci_dev *dev, int idx)\n{\n\tstruct resource *pr, *r = &dev->resource[idx];\n\n\tpr_debug(\"PCI: Allocating %s: Resource %d: %pR\\n\",\n\t\t pci_name(dev), idx, r);\n\n\tpr = pci_find_parent_resource(dev, r);\n\tif (!pr || (pr->flags & IORESOURCE_UNSET) ||\n\t    request_resource(pr, r) < 0) {\n\t\tprintk(KERN_WARNING \"PCI: Cannot allocate resource region %d\"\n\t\t       \" of device %s, will remap\\n\", idx, pci_name(dev));\n\t\tif (pr)\n\t\t\tpr_debug(\"PCI:  parent is %p: %pR\\n\", pr, pr);\n\t\t/* We'll assign a new address later */\n\t\tr->flags |= IORESOURCE_UNSET;\n\t\tr->end -= r->start;\n\t\tr->start = 0;\n\t}\n}"
  },
  {
    "function_name": "pcibios_allocate_bus_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1232-1301",
    "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_allocate_bus_resources",
          "args": [
            "b"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_allocate_bus_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1232-1301",
          "snippet": "static void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "b",
            "&bus->children",
            "node"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\"",
            "i",
            "bus->number"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_claim_bridge_resource",
          "args": [
            "dev",
            "i + PCI_BRIDGE_RESOURCES"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reparent_resources",
          "args": [
            "pr",
            "res"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "reparent_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1168-1197",
          "snippet": "static int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_resource",
          "args": [
            "pr",
            "res"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\"",
            "bus->self ? pci_name(bus->self) : \"PHB\"",
            "bus->number",
            "i",
            "res",
            "pr",
            "(pr && pr->name) ? pr->name : \"nil\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "bus->self"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_parent_resource",
          "args": [
            "bus->self",
            "res"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_for_each_resource",
          "args": [
            "bus",
            "res",
            "i"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Allocating bus resources for %04x:%02x...\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_allocate_bus_resources(struct pci_bus *bus)\n{\n\tstruct pci_bus *b;\n\tint i;\n\tstruct resource *res, *pr;\n\n\tpr_debug(\"PCI: Allocating bus resources for %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags || res->start > res->end || res->parent)\n\t\t\tcontinue;\n\n\t\t/* If the resource was left unset at this point, we clear it */\n\t\tif (res->flags & IORESOURCE_UNSET)\n\t\t\tgoto clear_resource;\n\n\t\tif (bus->parent == NULL)\n\t\t\tpr = (res->flags & IORESOURCE_IO) ?\n\t\t\t\t&ioport_resource : &iomem_resource;\n\t\telse {\n\t\t\tpr = pci_find_parent_resource(bus->self, res);\n\t\t\tif (pr == res) {\n\t\t\t\t/* this happens when the generic PCI\n\t\t\t\t * code (wrongly) decides that this\n\t\t\t\t * bridge is transparent  -- paulus\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"PCI: %s (bus %d) bridge rsrc %d: %pR, parent %p (%s)\\n\",\n\t\t\t bus->self ? pci_name(bus->self) : \"PHB\", bus->number,\n\t\t\t i, res, pr, (pr && pr->name) ? pr->name : \"nil\");\n\n\t\tif (pr && !(pr->flags & IORESOURCE_UNSET)) {\n\t\t\tstruct pci_dev *dev = bus->self;\n\n\t\t\tif (request_resource(pr, res) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Must be a conflict with an existing entry.\n\t\t\t * Move that entry (or entries) under the\n\t\t\t * bridge resource and try again.\n\t\t\t */\n\t\t\tif (reparent_resources(pr, res) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (dev && i < PCI_BRIDGE_RESOURCE_NUM &&\n\t\t\t    pci_claim_bridge_resource(dev,\n\t\t\t\t\t\ti + PCI_BRIDGE_RESOURCES) == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tpr_warn(\"PCI: Cannot allocate resource region %d of PCI bridge %d, will remap\\n\",\n\t\t\ti, bus->number);\n\tclear_resource:\n\t\t/* The resource might be figured out when doing\n\t\t * reassignment based on the resources required\n\t\t * by the downstream PCI devices. Here we set\n\t\t * the size of the resource to be 0 in order to\n\t\t * save more space.\n\t\t */\n\t\tres->start = 0;\n\t\tres->end = -1;\n\t\tres->flags = 0;\n\t}\n\n\tlist_for_each_entry(b, &bus->children, node)\n\t\tpcibios_allocate_bus_resources(b);\n}"
  },
  {
    "function_name": "reparent_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1168-1197",
    "snippet": "static int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Reparented %s %pR under %s\\n\"",
            "p->name",
            "p",
            "res->name"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int reparent_resources(struct resource *parent,\n\t\t\t\t     struct resource *res)\n{\n\tstruct resource *p, **pp;\n\tstruct resource **firstpp = NULL;\n\n\tfor (pp = &parent->child; (p = *pp) != NULL; pp = &p->sibling) {\n\t\tif (p->end < res->start)\n\t\t\tcontinue;\n\t\tif (res->end < p->start)\n\t\t\tbreak;\n\t\tif (p->start < res->start || p->end > res->end)\n\t\t\treturn -1;\t/* not completely contained */\n\t\tif (firstpp == NULL)\n\t\t\tfirstpp = pp;\n\t}\n\tif (firstpp == NULL)\n\t\treturn -1;\t/* didn't find any conflicting entries? */\n\tres->parent = parent;\n\tres->child = *firstpp;\n\tres->sibling = *pp;\n\t*firstpp = res;\n\t*pp = NULL;\n\tfor (p = res->child; p != NULL; p = p->sibling) {\n\t\tp->parent = res;\n\t\tpr_debug(\"PCI: Reparented %s %pR under %s\\n\",\n\t\t\t p->name, p, res->name);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_align_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1147-1161",
    "snippet": "resource_size_t pcibios_align_resource(void *data, const struct resource *res,\n\t\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pci_dev *dev = data;\n\tresource_size_t start = res->start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (skip_isa_ioresource_align(dev))\n\t\t\treturn start;\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t}\n\n\treturn start;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_isa_ioresource_align",
          "args": [
            "dev"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "skip_isa_ioresource_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1126-1132",
          "snippet": "static int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\n\t\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pci_dev *dev = data;\n\tresource_size_t start = res->start;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (skip_isa_ioresource_align(dev))\n\t\t\treturn start;\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t}\n\n\treturn start;\n}"
  },
  {
    "function_name": "skip_isa_ioresource_align",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1126-1132",
    "snippet": "static int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_CAN_SKIP_ISA_ALIGN"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int skip_isa_ioresource_align(struct pci_dev *dev)\n{\n\tif (pci_has_flag(PCI_CAN_SKIP_ISA_ALIGN) &&\n\t    !(dev->bus->bridge_ctl & PCI_BRIDGE_CTL_ISA))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_fixup_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1113-1123",
    "snippet": "void pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_setup_bus_self",
          "args": [
            "bus"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_setup_bus_self",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1052-1070",
          "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_read_bridge_bases",
          "args": [
            "bus"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n}"
  },
  {
    "function_name": "pcibios_set_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1108-1111",
    "snippet": "void pcibios_set_master(struct pci_dev *dev)\n{\n\t/* No special bus mastering setup handling */\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_set_master(struct pci_dev *dev)\n{\n\t/* No special bus mastering setup handling */\n}"
  },
  {
    "function_name": "pcibios_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1098-1106",
    "snippet": "int pcibios_add_device(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_IOV\n\tif (ppc_md.pcibios_fixup_sriov)\n\t\tppc_md.pcibios_fixup_sriov(dev);\n#endif /* CONFIG_PCI_IOV */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_sriov",
          "args": [
            "dev"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_add_device(struct pci_dev *dev)\n{\n#ifdef CONFIG_PCI_IOV\n\tif (ppc_md.pcibios_fixup_sriov)\n\t\tppc_md.pcibios_fixup_sriov(dev);\n#endif /* CONFIG_PCI_IOV */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_bus_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1072-1096",
    "snippet": "void pcibios_bus_add_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tdev->dev.archdata.dma_offset = PCI_DRAM_OFFSET;\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n\n\tif (ppc_md.pcibios_bus_add_device)\n\t\tppc_md.pcibios_bus_add_device(dev);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dma_map_ops *pci_dma_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_bus_add_device",
          "args": [
            "dev"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_bus_add_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1072-1096",
          "snippet": "void pcibios_bus_add_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tdev->dev.archdata.dma_offset = PCI_DRAM_OFFSET;\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n\n\tif (ppc_md.pcibios_bus_add_device)\n\t\tppc_md.pcibios_bus_add_device(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.pci_irq_fixup",
          "args": [
            "dev"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_irq_line",
          "args": [
            "dev"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "pci_read_irq_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "470-516",
          "snippet": "static int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tint virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n\t/* Try to get a mapping from the device-tree */\n\tvirq = of_irq_parse_and_map_pci(pci_dev, 0, 0);\n\tif (virq <= 0) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t}\n\n\tif (!virq) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\t/* Record all interrut mappings for later removal of a PHB */\n\tpci_irq_map_register(pci_dev, virq);\n\treturn 0;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tint virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n\t/* Try to get a mapping from the device-tree */\n\tvirq = of_irq_parse_and_map_pci(pci_dev, 0, 0);\n\tif (virq <= 0) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t}\n\n\tif (!virq) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\t/* Record all interrut mappings for later removal of a PHB */\n\tpci_irq_map_register(pci_dev, virq);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_dev_setup",
          "args": [
            "dev"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dma_ops",
          "args": [
            "&dev->dev",
            "pci_dma_ops"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dev_node",
          "args": [
            "&dev->dev",
            "pcibus_to_node(dev->bus)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibus_to_node",
          "args": [
            "dev->bus"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "pcibus_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "281-285",
          "snippet": "int pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibus_to_node(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\treturn phb->node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic const struct dma_map_ops *pci_dma_ops;\n\nvoid pcibios_bus_add_device(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb;\n\t/* Fixup NUMA node as it may not be setup yet by the generic\n\t * code and is needed by the DMA init\n\t */\n\tset_dev_node(&dev->dev, pcibus_to_node(dev->bus));\n\n\t/* Hook up default DMA ops */\n\tset_dma_ops(&dev->dev, pci_dma_ops);\n\tdev->dev.archdata.dma_offset = PCI_DRAM_OFFSET;\n\n\t/* Additional platform DMA/iommu setup */\n\tphb = pci_bus_to_host(dev->bus);\n\tif (phb->controller_ops.dma_dev_setup)\n\t\tphb->controller_ops.dma_dev_setup(dev);\n\n\t/* Read default IRQs and fixup if necessary */\n\tpci_read_irq_line(dev);\n\tif (ppc_md.pci_irq_fixup)\n\t\tppc_md.pci_irq_fixup(dev);\n\n\tif (ppc_md.pcibios_bus_add_device)\n\t\tppc_md.pcibios_bus_add_device(dev);\n}"
  },
  {
    "function_name": "pcibios_setup_bus_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1052-1070",
    "snippet": "void pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.dma_bus_setup",
          "args": [
            "bus"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_bus",
          "args": [
            "bus"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1113-1123",
          "snippet": "void pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_fixup_bus(struct pci_bus *bus)\n{\n\t/* When called from the generic PCI probe, read PCI<->PCI bridge\n\t * bases. This is -not- called when generating the PCI tree from\n\t * the OF device-tree.\n\t */\n\tpci_read_bridge_bases(bus);\n\n\t/* Now fixup the bus bus */\n\tpcibios_setup_bus_self(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_fixup_bridge",
          "args": [
            "bus"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1016-1050",
          "snippet": "static void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bus_self(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb;\n\n\t/* Fix up the bus resources for P2P bridges */\n\tif (bus->self != NULL)\n\t\tpcibios_fixup_bridge(bus);\n\n\t/* Platform specific bus fixups. This is currently only used\n\t * by fsl_pci and I'm hoping to get rid of it at some point\n\t */\n\tif (ppc_md.pcibios_fixup_bus)\n\t\tppc_md.pcibios_fixup_bus(bus);\n\n\t/* Setup bus DMA mappings */\n\tphb = pci_bus_to_host(bus);\n\tif (phb->controller_ops.dma_bus_setup)\n\t\tphb->controller_ops.dma_bus_setup(bus);\n}"
  },
  {
    "function_name": "pcibios_fixup_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "1016-1050",
    "snippet": "static void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s            (unassigned)\\n\"",
            "pci_name(dev)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_uninitialized_bridge_resource",
          "args": [
            "bus",
            "res"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_uninitialized_bridge_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "950-1013",
          "snippet": "static int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Bus rsrc %d %pR\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_for_each_resource",
          "args": [
            "bus",
            "res",
            "i"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_bridge(struct pci_bus *bus)\n{\n\tstruct resource *res;\n\tint i;\n\n\tstruct pci_dev *dev = bus->self;\n\n\tpci_bus_for_each_resource(bus, res, i) {\n\t\tif (!res || !res->flags)\n\t\t\tcontinue;\n\t\tif (i >= 3 && bus->self->transparent)\n\t\t\tcontinue;\n\n\t\t/* If we're going to reassign everything, we can\n\t\t * shrink the P2P resource to have size as being\n\t\t * of 0 in order to save space.\n\t\t */\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC)) {\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tres->start = 0;\n\t\t\tres->end = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Bus rsrc %d %pR\\n\", pci_name(dev), i, res);\n\n\t\t/* Try to detect uninitialized P2P bridge resources,\n\t\t * and clear them out so they get re-assigned later\n\t\t */\n\t\tif (pcibios_uninitialized_bridge_resource(bus, res)) {\n\t\t\tres->flags = 0;\n\t\t\tpr_debug(\"PCI:%s            (unassigned)\\n\", pci_name(dev));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcibios_uninitialized_bridge_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "950-1013",
    "snippet": "static int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_word",
          "args": [
            "dev",
            "PCI_COMMAND",
            "&command"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_to_bus",
          "args": [
            "dev->bus",
            "&region",
            "res"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_uninitialized_bridge_resource(struct pci_bus *bus,\n\t\t\t\t\t\t struct resource *res)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pci_dev *dev = bus->self;\n\tresource_size_t offset;\n\tstruct pci_bus_region region;\n\tu16 command;\n\tint i;\n\n\t/* We don't do anything if PCI_PROBE_ONLY is set */\n\tif (pci_has_flag(PCI_PROBE_ONLY))\n\t\treturn 0;\n\n\t/* Job is a bit different between memory and IO */\n\tif (res->flags & IORESOURCE_MEM) {\n\t\tpcibios_resource_to_bus(dev->bus, &region, res);\n\n\t\t/* If the BAR is non-0 then it's probably been initialized */\n\t\tif (region.start != 0)\n\t\t\treturn 0;\n\n\t\t/* The BAR is 0, let's check if memory decoding is enabled on\n\t\t * the bridge. If not, we consider it unassigned\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif ((command & PCI_COMMAND_MEMORY) == 0)\n\t\t\treturn 1;\n\n\t\t/* Memory decoding is enabled and the BAR is 0. If any of the bridge\n\t\t * resources covers that starting address (0 then it's good enough for\n\t\t * us for memory space)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif ((hose->mem_resources[i].flags & IORESOURCE_MEM) &&\n\t\t\t    hose->mem_resources[i].start == hose->mem_offset[i])\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/* Well, it starts at 0 and we know it will collide so we may as\n\t\t * well consider it as unassigned. That covers the Apple case.\n\t\t */\n\t\treturn 1;\n\t} else {\n\t\t/* If the BAR is non-0, then we consider it assigned */\n\t\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tif (((res->start - offset) & 0xfffffffful) != 0)\n\t\t\treturn 0;\n\n\t\t/* Here, we are a bit different than memory as typically IO space\n\t\t * starting at low addresses -is- valid. What we do instead if that\n\t\t * we consider as unassigned anything that doesn't have IO enabled\n\t\t * in the PCI command register, and that's it.\n\t\t */\n\t\tpci_read_config_word(dev, PCI_COMMAND, &command);\n\t\tif (command & PCI_COMMAND_IO)\n\t\t\treturn 0;\n\n\t\t/* It's starting at 0 and IO is disabled in the bridge, consider\n\t\t * it unassigned\n\t\t */\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "pcibios_fixup_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "898-942",
    "snippet": "static void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_fixup_resources",
          "args": [
            "dev"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_fixup_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "898-942",
          "snippet": "static void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Resource %d %pR\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI:%s Resource %d %pR is unassigned\\n\"",
            "pci_name(dev)",
            "i",
            "res"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_PROBE_ONLY"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_RSRC"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_to_bus",
          "args": [
            "dev->bus",
            "&reg",
            "res"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"No host bridge for PCI dev %s !\\n\"",
            "pci_name(dev)"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "110-157",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/topology.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool full_rtas_msgs;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/topology.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic bool full_rtas_msgs;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s (%d), Severity: %d\\n\",\n\t\t       error_log_cnt,\n\t\t       rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_type(errlog),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_fixup_resources(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tint i;\n\n\tif (!hose) {\n\t\tprintk(KERN_ERR \"No host bridge for PCI dev %s !\\n\",\n\t\t       pci_name(dev));\n\t\treturn;\n\t}\n\n\tif (dev->is_virtfn)\n\t\treturn;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tstruct resource *res = dev->resource + i;\n\t\tstruct pci_bus_region reg;\n\t\tif (!res->flags)\n\t\t\tcontinue;\n\n\t\t/* If we're going to re-assign everything, we mark all resources\n\t\t * as unset (and 0-base them). In addition, we mark BARs starting\n\t\t * at 0 as unset as well, except if PCI_PROBE_ONLY is also set\n\t\t * since in that case, we don't want to re-assign anything\n\t\t */\n\t\tpcibios_resource_to_bus(dev->bus, &reg, res);\n\t\tif (pci_has_flag(PCI_REASSIGN_ALL_RSRC) ||\n\t\t    (reg.start == 0 && !pci_has_flag(PCI_PROBE_ONLY))) {\n\t\t\t/* Only print message if not re-assigning */\n\t\t\tif (!pci_has_flag(PCI_REASSIGN_ALL_RSRC))\n\t\t\t\tpr_debug(\"PCI:%s Resource %d %pR is unassigned\\n\",\n\t\t\t\t\t pci_name(dev), i, res);\n\t\t\tres->end -= res->start;\n\t\t\tres->start = 0;\n\t\t\tres->flags |= IORESOURCE_UNSET;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"PCI:%s Resource %d %pR\\n\", pci_name(dev), i, res);\n\t}\n\n\t/* Call machine specific resource fixup */\n\tif (ppc_md.pcibios_fixup_resources)\n\t\tppc_md.pcibios_fixup_resources(dev);\n}"
  },
  {
    "function_name": "pcibios_root_bridge_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "887-893",
    "snippet": "int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_root_bridge_prepare",
          "args": [
            "bridge"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_root_bridge_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "887-893",
          "snippet": "int pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)\n{\n\tif (ppc_md.pcibios_root_bridge_prepare)\n\t\treturn ppc_md.pcibios_root_bridge_prepare(bridge);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_proc_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "876-885",
    "snippet": "int pci_proc_domain(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (!pci_has_flag(PCI_ENABLE_PROC_DOMAINS))\n\t\treturn 0;\n\tif (pci_has_flag(PCI_COMPAT_DOMAIN_0))\n\t\treturn hose->global_number != 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_COMPAT_DOMAIN_0"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_ENABLE_PROC_DOMAINS"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_proc_domain(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (!pci_has_flag(PCI_ENABLE_PROC_DOMAINS))\n\t\treturn 0;\n\tif (pci_has_flag(PCI_COMPAT_DOMAIN_0))\n\t\treturn hose->global_number != 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "pci_process_bridge_OF_ranges",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "773-873",
    "snippet": "void pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %pOF %s ranges:\\n\",\n\t       dev, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.flags & IORESOURCE_PREFETCH) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "resource_size_t isa_mem_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\"",
            "range.cpu_addr",
            "range.cpu_addr + range.size - 1",
            "range.pci_addr",
            "(range.flags & IORESOURCE_PREFETCH) ?\n\t\t\t       \"Prefetch\" : \"\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "range.cpu_addr",
            "range.size"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci_64.c",
          "lines": "120-148",
          "snippet": "void __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __iomem *ioremap_phb(phys_addr_t paddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\tunsigned long addr;\n\n\tWARN_ON_ONCE(paddr & ~PAGE_MASK);\n\tWARN_ON_ONCE(size & ~PAGE_MASK);\n\n\t/*\n\t * Let's allocate some IO space for that guy. We don't pass VM_IOREMAP\n\t * because we don't care about alignment tricks that the core does in\n\t * that case.  Maybe we should due to stupid card with incomplete\n\t * address decoding but I'd rather not deal with those outside of the\n\t * reserved 64K legacy region.\n\t */\n\tarea = __get_vm_area_caller(size, 0, PHB_IO_BASE, PHB_IO_END,\n\t\t\t\t    __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\taddr = (unsigned long)area->addr;\n\tif (ioremap_page_range(addr, addr + size, paddr,\n\t\t\tpgprot_noncached(PAGE_KERNEL))) {\n\t\tunmap_kernel_range(addr, size);\n\t\treturn NULL;\n\t}\n\n\treturn (void __iomem *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\"",
            "range.cpu_addr",
            "range.cpu_addr + range.size - 1",
            "range.pci_addr"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_of_pci_range",
          "args": [
            "&parser",
            "&range"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_pci_range_parser_init",
          "args": [
            "&parser",
            "dev"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"PCI host bridge %pOF %s ranges:\\n\"",
            "dev",
            "primary ? \"(primary)\" : \"\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t isa_mem_base;\n\nvoid pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %pOF %s ranges:\\n\",\n\t       dev, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.flags & IORESOURCE_PREFETCH) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pci_resource_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "724-747",
    "snippet": "void pci_resource_to_user(const struct pci_dev *dev, int bar,\n\t\t\t  const struct resource *rsrc,\n\t\t\t  resource_size_t *start, resource_size_t *end)\n{\n\tstruct pci_bus_region region;\n\n\tif (rsrc->flags & IORESOURCE_IO) {\n\t\tpcibios_resource_to_bus(dev->bus, &region,\n\t\t\t\t\t(struct resource *) rsrc);\n\t\t*start = region.start;\n\t\t*end = region.end;\n\t\treturn;\n\t}\n\n\t/* We pass a CPU physical address to userland for MMIO instead of a\n\t * BAR value because X is lame and expects to be able to use that\n\t * to pass to /dev/mem!\n\t *\n\t * That means we may have 64-bit values where some apps only expect\n\t * 32 (like X itself since it thinks only Sparc has 64-bit MMIO).\n\t */\n\t*start = rsrc->start;\n\t*end = rsrc->end;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_resource_to_bus",
          "args": [
            "dev->bus",
            "&region",
            "(struct resource *) rsrc"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_resource_to_user(const struct pci_dev *dev, int bar,\n\t\t\t  const struct resource *rsrc,\n\t\t\t  resource_size_t *start, resource_size_t *end)\n{\n\tstruct pci_bus_region region;\n\n\tif (rsrc->flags & IORESOURCE_IO) {\n\t\tpcibios_resource_to_bus(dev->bus, &region,\n\t\t\t\t\t(struct resource *) rsrc);\n\t\t*start = region.start;\n\t\t*end = region.end;\n\t\treturn;\n\t}\n\n\t/* We pass a CPU physical address to userland for MMIO instead of a\n\t * BAR value because X is lame and expects to be able to use that\n\t * to pass to /dev/mem!\n\t *\n\t * That means we may have 64-bit values where some apps only expect\n\t * 32 (like X itself since it thinks only Sparc has 64-bit MMIO).\n\t */\n\t*start = rsrc->start;\n\t*end = rsrc->end;\n}"
  },
  {
    "function_name": "pci_mmap_legacy_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "672-722",
    "snippet": "int pci_mmap_legacy_page_range(struct pci_bus *bus,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tresource_size_t size = vma->vm_end - vma->vm_start;\n\tstruct resource *rp;\n\n\tpr_debug(\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\",\n\t\t pci_domain_nr(bus), bus->number,\n\t\t mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\",\n\t\t (unsigned long long)offset,\n\t\t (unsigned long long)(offset + size - 1));\n\n\tif (mmap_state == pci_mmap_mem) {\n\t\t/* Hack alert !\n\t\t *\n\t\t * Because X is lame and can fail starting if it gets an error trying\n\t\t * to mmap legacy_mem (instead of just moving on without legacy memory\n\t\t * access) we fake it here by giving it anonymous memory, effectively\n\t\t * behaving just like /dev/zero\n\t\t */\n\t\tif ((offset + size) > hose->isa_mem_size) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\",\n\t\t\t       current->comm, current->pid, pci_domain_nr(bus), bus->number);\n\t\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\t\treturn shmem_zero_setup(vma);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += hose->isa_mem_phys;\n\t} else {\n\t\tunsigned long io_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tunsigned long roffset = offset + io_offset;\n\t\trp = &hose->io_resource;\n\t\tif (!(rp->flags & IORESOURCE_IO))\n\t\t\treturn -ENXIO;\n\t\tif (roffset < rp->start || (roffset + size) > rp->end)\n\t\t\treturn -ENXIO;\n\t\toffset += hose->io_base_phys;\n\t}\n\tpr_debug(\" -> mapping phys %llx\\n\", (unsigned long long)offset);\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "vma->vm_pgoff",
            "vma->vm_end - vma->vm_start",
            "vma->vm_page_prot"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" -> mapping phys %llx\\n\"",
            "(unsigned long long)offset"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_zero_setup",
          "args": [
            "vma"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\"",
            "current->comm",
            "current->pid",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\"",
            "pci_domain_nr(bus)",
            "bus->number",
            "mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\"",
            "(unsigned long long)offset",
            "(unsigned long long)(offset + size - 1)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_mmap_legacy_page_range(struct pci_bus *bus,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       enum pci_mmap_state mmap_state)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t offset =\n\t\t((resource_size_t)vma->vm_pgoff) << PAGE_SHIFT;\n\tresource_size_t size = vma->vm_end - vma->vm_start;\n\tstruct resource *rp;\n\n\tpr_debug(\"pci_mmap_legacy_page_range(%04x:%02x, %s @%llx..%llx)\\n\",\n\t\t pci_domain_nr(bus), bus->number,\n\t\t mmap_state == pci_mmap_mem ? \"MEM\" : \"IO\",\n\t\t (unsigned long long)offset,\n\t\t (unsigned long long)(offset + size - 1));\n\n\tif (mmap_state == pci_mmap_mem) {\n\t\t/* Hack alert !\n\t\t *\n\t\t * Because X is lame and can fail starting if it gets an error trying\n\t\t * to mmap legacy_mem (instead of just moving on without legacy memory\n\t\t * access) we fake it here by giving it anonymous memory, effectively\n\t\t * behaving just like /dev/zero\n\t\t */\n\t\tif ((offset + size) > hose->isa_mem_size) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"Process %s (pid:%d) mapped non-existing PCI legacy memory for 0%04x:%02x\\n\",\n\t\t\t       current->comm, current->pid, pci_domain_nr(bus), bus->number);\n\t\t\tif (vma->vm_flags & VM_SHARED)\n\t\t\t\treturn shmem_zero_setup(vma);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += hose->isa_mem_phys;\n\t} else {\n\t\tunsigned long io_offset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\t\tunsigned long roffset = offset + io_offset;\n\t\trp = &hose->io_resource;\n\t\tif (!(rp->flags & IORESOURCE_IO))\n\t\t\treturn -ENXIO;\n\t\tif (roffset < rp->start || (roffset + size) > rp->end)\n\t\t\treturn -ENXIO;\n\t\toffset += hose->io_base_phys;\n\t}\n\tpr_debug(\" -> mapping phys %llx\\n\", (unsigned long long)offset);\n\n\tvma->vm_pgoff = offset >> PAGE_SHIFT;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}"
  },
  {
    "function_name": "pci_legacy_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "627-669",
    "snippet": "int pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\t/* WARNING: The generic code is idiotic. It gets passed a pointer\n\t * to what can be a 1, 2 or 4 byte quantity and always reads that\n\t * as a u32, which means that we have to correct the location of\n\t * the data read within those 32 bits for size 1 and 2\n\t */\n\tswitch(size) {\n\tcase 1:\n\t\tout_8(addr, val >> 24);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\tout_le16(addr, val >> 16);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\tout_le32(addr, val);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out_le32",
          "args": [
            "addr",
            "val"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_le16",
          "args": [
            "addr",
            "val >> 16"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_8",
          "args": [
            "addr",
            "val >> 24"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\t/* WARNING: The generic code is idiotic. It gets passed a pointer\n\t * to what can be a 1, 2 or 4 byte quantity and always reads that\n\t * as a u32, which means that we have to correct the location of\n\t * the data read within those 32 bits for size 1 and 2\n\t */\n\tswitch(size) {\n\tcase 1:\n\t\tout_8(addr, val >> 24);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\tout_le16(addr, val >> 16);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\tout_le32(addr, val);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pci_legacy_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "587-624",
    "snippet": "int pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\tswitch(size) {\n\tcase 1:\n\t\t*((u8 *)val) = in_8(addr);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\t*((u16 *)val) = in_le16(addr);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\t*((u32 *)val) = in_le32(addr);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_le32",
          "args": [
            "addr"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_le16",
          "args": [
            "addr"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_8",
          "args": [
            "addr"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\n{\n\tunsigned long offset;\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct resource *rp = &hose->io_resource;\n\tvoid __iomem *addr;\n\n\t/* Check if port can be supported by that bus. We only check\n\t * the ranges of the PHB though, not the bus itself as the rules\n\t * for forwarding legacy cycles down bridges are not our problem\n\t * here. So if the host bridge supports it, we do it.\n\t */\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\toffset += port;\n\n\tif (!(rp->flags & IORESOURCE_IO))\n\t\treturn -ENXIO;\n\tif (offset < rp->start || (offset + size) > rp->end)\n\t\treturn -ENXIO;\n\taddr = hose->io_base_virt + port;\n\n\tswitch(size) {\n\tcase 1:\n\t\t*((u8 *)val) = in_8(addr);\n\t\treturn 1;\n\tcase 2:\n\t\tif (port & 1)\n\t\t\treturn -EINVAL;\n\t\t*((u16 *)val) = in_le16(addr);\n\t\treturn 2;\n\tcase 4:\n\t\tif (port & 3)\n\t\t\treturn -EINVAL;\n\t\t*((u32 *)val) = in_le32(addr);\n\t\treturn 4;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pci_phys_mem_access_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "542-584",
    "snippet": "pgprot_t pci_phys_mem_access_prot(struct file *file,\n\t\t\t\t  unsigned long pfn,\n\t\t\t\t  unsigned long size,\n\t\t\t\t  pgprot_t prot)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct resource *found = NULL;\n\tresource_size_t offset = ((resource_size_t)pfn) << PAGE_SHIFT;\n\tint i;\n\n\tif (page_is_ram(pfn))\n\t\treturn prot;\n\n\tprot = pgprot_noncached(prot);\n\tfor_each_pci_dev(pdev) {\n\t\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\t\tstruct resource *rp = &pdev->resource[i];\n\t\t\tint flags = rp->flags;\n\n\t\t\t/* Active and same type? */\n\t\t\tif ((flags & IORESOURCE_MEM) == 0)\n\t\t\t\tcontinue;\n\t\t\t/* In the range of this resource? */\n\t\t\tif (offset < (rp->start & PAGE_MASK) ||\n\t\t\t    offset > rp->end)\n\t\t\t\tcontinue;\n\t\t\tfound = rp;\n\t\t\tbreak;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (found) {\n\t\tif (found->flags & IORESOURCE_PREFETCH)\n\t\t\tprot = pgprot_noncached_wc(prot);\n\t\tpci_dev_put(pdev);\n\t}\n\n\tpr_debug(\"PCI: Non-PCI map for %llx, prot: %lx\\n\",\n\t\t (unsigned long long)offset, pgprot_val(prot));\n\n\treturn prot;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Non-PCI map for %llx, prot: %lx\\n\"",
            "(unsigned long long)offset",
            "pgprot_val(prot)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_val",
          "args": [
            "prot"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "pdev"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached_wc",
          "args": [
            "prot"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprot_noncached",
          "args": [
            "prot"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_ram",
          "args": [
            "pfn"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\npgprot_t pci_phys_mem_access_prot(struct file *file,\n\t\t\t\t  unsigned long pfn,\n\t\t\t\t  unsigned long size,\n\t\t\t\t  pgprot_t prot)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct resource *found = NULL;\n\tresource_size_t offset = ((resource_size_t)pfn) << PAGE_SHIFT;\n\tint i;\n\n\tif (page_is_ram(pfn))\n\t\treturn prot;\n\n\tprot = pgprot_noncached(prot);\n\tfor_each_pci_dev(pdev) {\n\t\tfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\n\t\t\tstruct resource *rp = &pdev->resource[i];\n\t\t\tint flags = rp->flags;\n\n\t\t\t/* Active and same type? */\n\t\t\tif ((flags & IORESOURCE_MEM) == 0)\n\t\t\t\tcontinue;\n\t\t\t/* In the range of this resource? */\n\t\t\tif (offset < (rp->start & PAGE_MASK) ||\n\t\t\t    offset > rp->end)\n\t\t\t\tcontinue;\n\t\t\tfound = rp;\n\t\t\tbreak;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (found) {\n\t\tif (found->flags & IORESOURCE_PREFETCH)\n\t\t\tprot = pgprot_noncached_wc(prot);\n\t\tpci_dev_put(pdev);\n\t}\n\n\tpr_debug(\"PCI: Non-PCI map for %llx, prot: %lx\\n\",\n\t\t (unsigned long long)offset, pgprot_val(prot));\n\n\treturn prot;\n}"
  },
  {
    "function_name": "pci_iobar_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "522-535",
    "snippet": "int pci_iobar_pfn(struct pci_dev *pdev, int bar, struct vm_area_struct *vma)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\tresource_size_t ioaddr = pci_resource_start(pdev, bar);\n\n\tif (!hose)\n\t\treturn -EINVAL;\n\n\t/* Convert to an offset within this PCI controller */\n\tioaddr -= (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\tvma->vm_pgoff += (ioaddr + hose->io_base_phys) >> PAGE_SHIFT;\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_resource_start",
          "args": [
            "pdev",
            "bar"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_iobar_pfn(struct pci_dev *pdev, int bar, struct vm_area_struct *vma)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\tresource_size_t ioaddr = pci_resource_start(pdev, bar);\n\n\tif (!hose)\n\t\treturn -EINVAL;\n\n\t/* Convert to an offset within this PCI controller */\n\tioaddr -= (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\tvma->vm_pgoff += (ioaddr + hose->io_base_phys) >> PAGE_SHIFT;\n\treturn 0;\n}"
  },
  {
    "function_name": "pci_read_irq_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "470-516",
    "snippet": "static int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tint virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n\t/* Try to get a mapping from the device-tree */\n\tvirq = of_irq_parse_and_map_pci(pci_dev, 0, 0);\n\tif (virq <= 0) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t}\n\n\tif (!virq) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\t/* Record all interrut mappings for later removal of a PHB */\n\tpci_irq_map_register(pci_dev, virq);\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_irq_map_register",
          "args": [
            "pci_dev",
            "virq"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "pci_irq_map_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "413-435",
          "snippet": "static void pci_irq_map_register(struct pci_dev *pdev, unsigned int virq)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tfor (i = 0; i < phb->irq_count; i++) {\n\t\t/*\n\t\t * Look for an empty or an equivalent slot, as INTx\n\t\t * interrupts can be shared between adapters.\n\t\t */\n\t\tif (phb->irq_map[i] == virq || !phb->irq_map[i]) {\n\t\t\tphb->irq_map[i] = virq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == phb->irq_count)\n\t\tpr_err(\"PCI:%s all platform interrupts mapped\\n\",\n\t\t       pci_name(pdev));\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_irq_map_register(struct pci_dev *pdev, unsigned int virq)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tfor (i = 0; i < phb->irq_count; i++) {\n\t\t/*\n\t\t * Look for an empty or an equivalent slot, as INTx\n\t\t * interrupts can be shared between adapters.\n\t\t */\n\t\tif (phb->irq_map[i] == virq || !phb->irq_map[i]) {\n\t\t\tphb->irq_map[i] = virq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == phb->irq_count)\n\t\tpr_err(\"PCI:%s all platform interrupts mapped\\n\",\n\t\t       pci_name(pdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" Mapped to linux irq %d\\n\"",
            "virq"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" Failed to map !\\n\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_irq_type",
          "args": [
            "virq",
            "IRQ_TYPE_LEVEL_LOW"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_create_mapping",
          "args": [
            "NULL",
            "line"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" No map ! Using line %d (pin %d) from PCI config\\n\"",
            "line",
            "pin"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_byte",
          "args": [
            "pci_dev",
            "PCI_INTERRUPT_LINE",
            "&line"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config_byte",
          "args": [
            "pci_dev",
            "PCI_INTERRUPT_PIN",
            "&pin"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_irq_parse_and_map_pci",
          "args": [
            "pci_dev",
            "0",
            "0"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Try to map irq for %s...\\n\"",
            "pci_name(pci_dev)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pci_dev"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pci_read_irq_line(struct pci_dev *pci_dev)\n{\n\tint virq;\n\n\tpr_debug(\"PCI: Try to map irq for %s...\\n\", pci_name(pci_dev));\n\n\t/* Try to get a mapping from the device-tree */\n\tvirq = of_irq_parse_and_map_pci(pci_dev, 0, 0);\n\tif (virq <= 0) {\n\t\tu8 line, pin;\n\n\t\t/* If that fails, lets fallback to what is in the config\n\t\t * space and map that through the default controller. We\n\t\t * also set the type to level low since that's what PCI\n\t\t * interrupts are. If your platform does differently, then\n\t\t * either provide a proper interrupt tree or don't use this\n\t\t * function.\n\t\t */\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_PIN, &pin))\n\t\t\treturn -1;\n\t\tif (pin == 0)\n\t\t\treturn -1;\n\t\tif (pci_read_config_byte(pci_dev, PCI_INTERRUPT_LINE, &line) ||\n\t\t    line == 0xff || line == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\" No map ! Using line %d (pin %d) from PCI config\\n\",\n\t\t\t line, pin);\n\n\t\tvirq = irq_create_mapping(NULL, line);\n\t\tif (virq)\n\t\t\tirq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);\n\t}\n\n\tif (!virq) {\n\t\tpr_debug(\" Failed to map !\\n\");\n\t\treturn -1;\n\t}\n\n\tpr_debug(\" Mapped to linux irq %d\\n\", virq);\n\n\tpci_dev->irq = virq;\n\n\t/* Record all interrut mappings for later removal of a PHB */\n\tpci_irq_map_register(pci_dev, virq);\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_remove_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "459-462",
    "snippet": "void pcibios_remove_bus(struct pci_bus *bus)\n{\n\tpci_irq_map_dispose(bus);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_irq_map_dispose",
          "args": [
            "bus"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "pci_irq_map_dispose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "443-457",
          "snippet": "static void pci_irq_map_dispose(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tpr_debug(\"PCI: Clearing interrupt mappings for PHB %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\tfor (i = 0; i < phb->irq_count; i++)\n\t\tirq_dispose_mapping(phb->irq_map[i]);\n\n\tkfree(phb->irq_map);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_irq_map_dispose(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tpr_debug(\"PCI: Clearing interrupt mappings for PHB %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\tfor (i = 0; i < phb->irq_count; i++)\n\t\tirq_dispose_mapping(phb->irq_map[i]);\n\n\tkfree(phb->irq_map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_remove_bus(struct pci_bus *bus)\n{\n\tpci_irq_map_dispose(bus);\n}"
  },
  {
    "function_name": "pci_irq_map_dispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "443-457",
    "snippet": "static void pci_irq_map_dispose(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tpr_debug(\"PCI: Clearing interrupt mappings for PHB %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\tfor (i = 0; i < phb->irq_count; i++)\n\t\tirq_dispose_mapping(phb->irq_map[i]);\n\n\tkfree(phb->irq_map);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "phb->irq_map"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_dispose_mapping",
          "args": [
            "phb->irq_map[i]"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"PCI: Clearing interrupt mappings for PHB %04x:%02x...\\n\"",
            "pci_domain_nr(bus)",
            "bus->number"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_domain_nr",
          "args": [
            "bus"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "pci_domain_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "318-323",
          "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_irq_map_dispose(struct pci_bus *bus)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tpr_debug(\"PCI: Clearing interrupt mappings for PHB %04x:%02x...\\n\",\n\t\t pci_domain_nr(bus), bus->number);\n\tfor (i = 0; i < phb->irq_count; i++)\n\t\tirq_dispose_mapping(phb->irq_map[i]);\n\n\tkfree(phb->irq_map);\n}"
  },
  {
    "function_name": "pci_irq_map_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "413-435",
    "snippet": "static void pci_irq_map_register(struct pci_dev *pdev, unsigned int virq)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tfor (i = 0; i < phb->irq_count; i++) {\n\t\t/*\n\t\t * Look for an empty or an equivalent slot, as INTx\n\t\t * interrupts can be shared between adapters.\n\t\t */\n\t\tif (phb->irq_map[i] == virq || !phb->irq_map[i]) {\n\t\t\tphb->irq_map[i] = virq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == phb->irq_count)\n\t\tpr_err(\"PCI:%s all platform interrupts mapped\\n\",\n\t\t       pci_name(pdev));\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PCI:%s all platform interrupts mapped\\n\"",
            "pci_name(pdev)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "pdev"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "pdev->bus"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pci_irq_map_register(struct pci_dev *pdev, unsigned int virq)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(pdev->bus);\n\tint i;\n\n\tif (!phb->irq_map)\n\t\treturn;\n\n\tfor (i = 0; i < phb->irq_count; i++) {\n\t\t/*\n\t\t * Look for an empty or an equivalent slot, as INTx\n\t\t * interrupts can be shared between adapters.\n\t\t */\n\t\tif (phb->irq_map[i] == virq || !phb->irq_map[i]) {\n\t\t\tphb->irq_map[i] = virq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == phb->irq_count)\n\t\tpr_err(\"PCI:%s all platform interrupts mapped\\n\",\n\t\t       pci_name(pdev));\n}"
  },
  {
    "function_name": "pcibios_irq_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "401-411",
    "snippet": "static void pcibios_irq_map_init(struct pci_controller *phb)\n{\n\tphb->irq_count = pcibios_irq_map_count(phb);\n\tif (phb->irq_count < PCI_NUM_INTX)\n\t\tphb->irq_count = PCI_NUM_INTX;\n\n\tpr_debug(\"%pOF : interrupt map #%d\\n\", phb->dn, phb->irq_count);\n\n\tphb->irq_map = kcalloc(phb->irq_count, sizeof(unsigned int),\n\t\t\t       GFP_KERNEL);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "phb->irq_count",
            "sizeof(unsigned int)",
            "GFP_KERNEL"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%pOF : interrupt map #%d\\n\"",
            "phb->dn",
            "phb->irq_count"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_irq_map_count",
          "args": [
            "phb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_irq_map_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "360-399",
          "snippet": "static int pcibios_irq_map_count(struct pci_controller *phb)\n{\n\tconst __be32 *imap;\n\tint imaplen;\n\tstruct device_node *parent;\n\tu32 intsize, addrsize, parintsize, paraddrsize;\n\n\tif (of_property_read_u32(phb->dn, \"#interrupt-cells\", &intsize))\n\t\treturn 0;\n\tif (of_property_read_u32(phb->dn, \"#address-cells\", &addrsize))\n\t\treturn 0;\n\n\timap = of_get_property(phb->dn, \"interrupt-map\", &imaplen);\n\tif (!imap) {\n\t\tpr_debug(\"%pOF : no interrupt-map\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\timaplen /= sizeof(u32);\n\tpr_debug(\"%pOF : imaplen=%d\\n\", phb->dn, imaplen);\n\n\tif (imaplen < (addrsize + intsize + 1))\n\t\treturn 0;\n\n\timap += intsize + addrsize;\n\tparent = of_find_node_by_phandle(be32_to_cpup(imap));\n\tif (!parent) {\n\t\tpr_debug(\"%pOF : no imap parent found !\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#interrupt-cells\", &parintsize)) {\n\t\tpr_debug(\"%pOF : parent lacks #interrupt-cells!\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#address-cells\", &paraddrsize))\n\t\tparaddrsize = 0;\n\n\treturn imaplen / (addrsize + intsize + 1 + paraddrsize + parintsize);\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_irq_map_count(struct pci_controller *phb)\n{\n\tconst __be32 *imap;\n\tint imaplen;\n\tstruct device_node *parent;\n\tu32 intsize, addrsize, parintsize, paraddrsize;\n\n\tif (of_property_read_u32(phb->dn, \"#interrupt-cells\", &intsize))\n\t\treturn 0;\n\tif (of_property_read_u32(phb->dn, \"#address-cells\", &addrsize))\n\t\treturn 0;\n\n\timap = of_get_property(phb->dn, \"interrupt-map\", &imaplen);\n\tif (!imap) {\n\t\tpr_debug(\"%pOF : no interrupt-map\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\timaplen /= sizeof(u32);\n\tpr_debug(\"%pOF : imaplen=%d\\n\", phb->dn, imaplen);\n\n\tif (imaplen < (addrsize + intsize + 1))\n\t\treturn 0;\n\n\timap += intsize + addrsize;\n\tparent = of_find_node_by_phandle(be32_to_cpup(imap));\n\tif (!parent) {\n\t\tpr_debug(\"%pOF : no imap parent found !\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#interrupt-cells\", &parintsize)) {\n\t\tpr_debug(\"%pOF : parent lacks #interrupt-cells!\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#address-cells\", &paraddrsize))\n\t\tparaddrsize = 0;\n\n\treturn imaplen / (addrsize + intsize + 1 + paraddrsize + parintsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void pcibios_irq_map_init(struct pci_controller *phb)\n{\n\tphb->irq_count = pcibios_irq_map_count(phb);\n\tif (phb->irq_count < PCI_NUM_INTX)\n\t\tphb->irq_count = PCI_NUM_INTX;\n\n\tpr_debug(\"%pOF : interrupt map #%d\\n\", phb->dn, phb->irq_count);\n\n\tphb->irq_map = kcalloc(phb->irq_count, sizeof(unsigned int),\n\t\t\t       GFP_KERNEL);\n}"
  },
  {
    "function_name": "pcibios_irq_map_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "360-399",
    "snippet": "static int pcibios_irq_map_count(struct pci_controller *phb)\n{\n\tconst __be32 *imap;\n\tint imaplen;\n\tstruct device_node *parent;\n\tu32 intsize, addrsize, parintsize, paraddrsize;\n\n\tif (of_property_read_u32(phb->dn, \"#interrupt-cells\", &intsize))\n\t\treturn 0;\n\tif (of_property_read_u32(phb->dn, \"#address-cells\", &addrsize))\n\t\treturn 0;\n\n\timap = of_get_property(phb->dn, \"interrupt-map\", &imaplen);\n\tif (!imap) {\n\t\tpr_debug(\"%pOF : no interrupt-map\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\timaplen /= sizeof(u32);\n\tpr_debug(\"%pOF : imaplen=%d\\n\", phb->dn, imaplen);\n\n\tif (imaplen < (addrsize + intsize + 1))\n\t\treturn 0;\n\n\timap += intsize + addrsize;\n\tparent = of_find_node_by_phandle(be32_to_cpup(imap));\n\tif (!parent) {\n\t\tpr_debug(\"%pOF : no imap parent found !\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#interrupt-cells\", &parintsize)) {\n\t\tpr_debug(\"%pOF : parent lacks #interrupt-cells!\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#address-cells\", &paraddrsize))\n\t\tparaddrsize = 0;\n\n\treturn imaplen / (addrsize + intsize + 1 + paraddrsize + parintsize);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "parent",
            "\"#address-cells\"",
            "&paraddrsize"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%pOF : parent lacks #interrupt-cells!\\n\"",
            "phb->dn"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "parent",
            "\"#interrupt-cells\"",
            "&parintsize"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%pOF : no imap parent found !\\n\"",
            "phb->dn"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_phandle",
          "args": [
            "be32_to_cpup(imap)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "imap"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%pOF : imaplen=%d\\n\"",
            "phb->dn",
            "imaplen"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%pOF : no interrupt-map\\n\"",
            "phb->dn"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "phb->dn",
            "\"interrupt-map\"",
            "&imaplen"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "phb->dn",
            "\"#address-cells\"",
            "&addrsize"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "phb->dn",
            "\"#interrupt-cells\"",
            "&intsize"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic int pcibios_irq_map_count(struct pci_controller *phb)\n{\n\tconst __be32 *imap;\n\tint imaplen;\n\tstruct device_node *parent;\n\tu32 intsize, addrsize, parintsize, paraddrsize;\n\n\tif (of_property_read_u32(phb->dn, \"#interrupt-cells\", &intsize))\n\t\treturn 0;\n\tif (of_property_read_u32(phb->dn, \"#address-cells\", &addrsize))\n\t\treturn 0;\n\n\timap = of_get_property(phb->dn, \"interrupt-map\", &imaplen);\n\tif (!imap) {\n\t\tpr_debug(\"%pOF : no interrupt-map\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\timaplen /= sizeof(u32);\n\tpr_debug(\"%pOF : imaplen=%d\\n\", phb->dn, imaplen);\n\n\tif (imaplen < (addrsize + intsize + 1))\n\t\treturn 0;\n\n\timap += intsize + addrsize;\n\tparent = of_find_node_by_phandle(be32_to_cpup(imap));\n\tif (!parent) {\n\t\tpr_debug(\"%pOF : no imap parent found !\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#interrupt-cells\", &parintsize)) {\n\t\tpr_debug(\"%pOF : parent lacks #interrupt-cells!\\n\", phb->dn);\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_u32(parent, \"#address-cells\", &paraddrsize))\n\t\tparaddrsize = 0;\n\n\treturn imaplen / (addrsize + intsize + 1 + paraddrsize + parintsize);\n}"
  },
  {
    "function_name": "pci_find_controller_for_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "345-354",
    "snippet": "struct pci_controller *pci_find_controller_for_domain(int domain_nr)\n{\n\tstruct pci_controller *hose;\n\n\tlist_for_each_entry(hose, &hose_list, list_node)\n\t\tif (hose->global_number == domain_nr)\n\t\t\treturn hose;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller *pci_find_controller_for_domain(int domain_nr)\n{\n\tstruct pci_controller *hose;\n\n\tlist_for_each_entry(hose, &hose_list, list_node)\n\t\tif (hose->global_number == domain_nr)\n\t\t\treturn hose;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_find_hose_for_OF_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "333-343",
    "snippet": "struct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "pci_domain_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "318-323",
    "snippet": "int pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_domain_nr(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\treturn hose->global_number;\n}"
  },
  {
    "function_name": "pci_address_to_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "292-312",
    "snippet": "unsigned long pci_address_to_pio(phys_addr_t address)\n{\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\tunsigned long ret = ~0;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_phys &&\n\t\t    address < (hose->io_base_phys + size)) {\n\t\t\tunsigned long base =\n\t\t\t\t(unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t\tret = base + (address - hose->io_base_phys);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_size",
          "args": [
            "hose"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "264-271",
          "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nunsigned long pci_address_to_pio(phys_addr_t address)\n{\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\tunsigned long ret = ~0;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_phys &&\n\t\t    address < (hose->io_base_phys + size)) {\n\t\t\tunsigned long base =\n\t\t\t\t(unsigned long)hose->io_base_virt - _IO_BASE;\n\t\t\tret = base + (address - hose->io_base_phys);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pcibios_vaddr_is_ioport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "273-290",
    "snippet": "int pcibios_vaddr_is_ioport(void __iomem *address)\n{\n\tint ret = 0;\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_virt &&\n\t\t    address < (hose->io_base_virt + size)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\treturn ret;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_io_size",
          "args": [
            "hose"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "264-271",
          "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nint pcibios_vaddr_is_ioport(void __iomem *address)\n{\n\tint ret = 0;\n\tstruct pci_controller *hose;\n\tresource_size_t size;\n\n\tspin_lock(&hose_spinlock);\n\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\tsize = pcibios_io_size(hose);\n\t\tif (address >= hose->io_base_virt &&\n\t\t    address < (hose->io_base_virt + size)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&hose_spinlock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pcibios_io_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "264-271",
    "snippet": "static resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "&hose->io_resource"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic resource_size_t pcibios_io_size(const struct pci_controller *hose)\n{\n#ifdef CONFIG_PPC64\n\treturn hose->pci_io_size;\n#else\n\treturn resource_size(&hose->io_resource);\n#endif\n}"
  },
  {
    "function_name": "pcibios_sriov_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "254-260",
    "snippet": "int pcibios_sriov_disable(struct pci_dev *pdev)\n{\n\tif (ppc_md.pcibios_sriov_disable)\n\t\treturn ppc_md.pcibios_sriov_disable(pdev);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_sriov_disable",
          "args": [
            "pdev"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_sriov_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "254-260",
          "snippet": "int pcibios_sriov_disable(struct pci_dev *pdev)\n{\n\tif (ppc_md.pcibios_sriov_disable)\n\t\treturn ppc_md.pcibios_sriov_disable(pdev);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_sriov_disable(struct pci_dev *pdev)\n{\n\tif (ppc_md.pcibios_sriov_disable)\n\t\treturn ppc_md.pcibios_sriov_disable(pdev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_sriov_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "246-252",
    "snippet": "int pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\n{\n\tif (ppc_md.pcibios_sriov_enable)\n\t\treturn ppc_md.pcibios_sriov_enable(pdev, num_vfs);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_sriov_enable",
          "args": [
            "pdev",
            "num_vfs"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_sriov_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "246-252",
          "snippet": "int pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\n{\n\tif (ppc_md.pcibios_sriov_enable)\n\t\treturn ppc_md.pcibios_sriov_enable(pdev, num_vfs);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)\n{\n\tif (ppc_md.pcibios_sriov_enable)\n\t\treturn ppc_md.pcibios_sriov_enable(pdev, num_vfs);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_iov_resource_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "238-244",
    "snippet": "resource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_iov_resource_size",
          "args": [
            "pdev",
            "resno"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.pcibios_iov_resource_alignment",
          "args": [
            "pdev",
            "resno"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_iov_resource_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "238-244",
          "snippet": "resource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_iov_resource_alignment(struct pci_dev *pdev, int resno)\n{\n\tif (ppc_md.pcibios_iov_resource_alignment)\n\t\treturn ppc_md.pcibios_iov_resource_alignment(pdev, resno);\n\n\treturn pci_iov_resource_size(pdev, resno);\n}"
  },
  {
    "function_name": "pcibios_default_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "229-235",
    "snippet": "resource_size_t pcibios_default_alignment(void)\n{\n\tif (ppc_md.pcibios_default_alignment)\n\t\treturn ppc_md.pcibios_default_alignment();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_default_alignment",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_default_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "229-235",
          "snippet": "resource_size_t pcibios_default_alignment(void)\n{\n\tif (ppc_md.pcibios_default_alignment)\n\t\treturn ppc_md.pcibios_default_alignment();\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_default_alignment(void)\n{\n\tif (ppc_md.pcibios_default_alignment)\n\t\treturn ppc_md.pcibios_default_alignment();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_reset_secondary_bus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "217-227",
    "snippet": "void pcibios_reset_secondary_bus(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.reset_secondary_bus) {\n\t\tphb->controller_ops.reset_secondary_bus(dev);\n\t\treturn;\n\t}\n\n\tpci_reset_secondary_bus(dev);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_reset_secondary_bus",
          "args": [
            "dev"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phb->controller_ops.reset_secondary_bus",
          "args": [
            "dev"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "dev->bus"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_reset_secondary_bus(struct pci_dev *dev)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(dev->bus);\n\n\tif (phb->controller_ops.reset_secondary_bus) {\n\t\tphb->controller_ops.reset_secondary_bus(dev);\n\t\treturn;\n\t}\n\n\tpci_reset_secondary_bus(dev);\n}"
  },
  {
    "function_name": "pcibios_setup_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "209-215",
    "snippet": "void pcibios_setup_bridge(struct pci_bus *bus, unsigned long type)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (hose->controller_ops.setup_bridge)\n\t\those->controller_ops.setup_bridge(bus, type);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hose->controller_ops.setup_bridge",
          "args": [
            "bus",
            "type"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_bridge(struct pci_bus *bus, unsigned long type)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\n\tif (hose->controller_ops.setup_bridge)\n\t\those->controller_ops.setup_bridge(bus, type);\n}"
  },
  {
    "function_name": "pcibios_window_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "193-207",
    "snippet": "resource_size_t pcibios_window_alignment(struct pci_bus *bus,\n\t\t\t\t\t unsigned long type)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\n\tif (phb->controller_ops.window_alignment)\n\t\treturn phb->controller_ops.window_alignment(bus, type);\n\n\t/*\n\t * PCI core will figure out the default\n\t * alignment: 4KiB for I/O and 1MiB for\n\t * memory window.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "phb->controller_ops.window_alignment",
          "args": [
            "bus",
            "type"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_host",
          "args": [
            "bus"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_window_alignment(struct pci_bus *bus,\n\t\t\t\t\t unsigned long type)\n{\n\tstruct pci_controller *phb = pci_bus_to_host(bus);\n\n\tif (phb->controller_ops.window_alignment)\n\t\treturn phb->controller_ops.window_alignment(bus, type);\n\n\t/*\n\t * PCI core will figure out the default\n\t * alignment: 4KiB for I/O and 1MiB for\n\t * memory window.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "pcibios_free_controller_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "176-184",
    "snippet": "void pcibios_free_controller_deferred(struct pci_host_bridge *bridge)\n{\n\tstruct pci_controller *phb = (struct pci_controller *)\n\t\t\t\t\t bridge->release_data;\n\n\tpr_debug(\"domain %d, dynamic %d\\n\", phb->global_number, phb->is_dynamic);\n\n\tpcibios_free_controller(phb);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_free_controller",
          "args": [
            "phb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_free_controller_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "176-184",
          "snippet": "void pcibios_free_controller_deferred(struct pci_host_bridge *bridge)\n{\n\tstruct pci_controller *phb = (struct pci_controller *)\n\t\t\t\t\t bridge->release_data;\n\n\tpr_debug(\"domain %d, dynamic %d\\n\", phb->global_number, phb->is_dynamic);\n\n\tpcibios_free_controller(phb);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"domain %d, dynamic %d\\n\"",
            "phb->global_number",
            "phb->is_dynamic"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_free_controller_deferred(struct pci_host_bridge *bridge)\n{\n\tstruct pci_controller *phb = (struct pci_controller *)\n\t\t\t\t\t bridge->release_data;\n\n\tpr_debug(\"domain %d, dynamic %d\\n\", phb->global_number, phb->is_dynamic);\n\n\tpcibios_free_controller(phb);\n}"
  },
  {
    "function_name": "pcibios_free_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "135-148",
    "snippet": "void pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\n\t/* Clear bit of phb_bitmap to allow reuse of this PHB number. */\n\tif (phb->global_number < MAX_PHBS)\n\t\tclear_bit(phb->global_number, phb_bitmap);\n\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_PHBS 0x10000"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);",
      "static DECLARE_BITMAP(phb_bitmap, MAX_PHBS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "phb"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&phb->list_node"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "phb->global_number",
            "phb_bitmap"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define MAX_PHBS 0x10000\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\nstatic DECLARE_BITMAP(phb_bitmap, MAX_PHBS);\n\nvoid pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\n\t/* Clear bit of phb_bitmap to allow reuse of this PHB number. */\n\tif (phb->global_number < MAX_PHBS)\n\t\tclear_bit(phb->global_number, phb_bitmap);\n\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}"
  },
  {
    "function_name": "pcibios_alloc_controller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "108-132",
    "snippet": "struct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = get_phb_number(dev);\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = NUMA_NO_NODE;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(hose_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PHB_SET_NODE",
          "args": [
            "phb",
            "nid"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "nid"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "dev"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&phb->list_node",
            "&hose_list"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_phb_number",
          "args": [
            "dev"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "get_phb_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "73-106",
          "snippet": "static int get_phb_number(struct device_node *dn)\n{\n\tint ret, phb_id = -1;\n\tu32 prop_32;\n\tu64 prop;\n\n\t/*\n\t * Try fixed PHB numbering first, by checking archs and reading\n\t * the respective device-tree properties. Firstly, try powernv by\n\t * reading \"ibm,opal-phbid\", only present in OPAL environment.\n\t */\n\tret = of_property_read_u64(dn, \"ibm,opal-phbid\", &prop);\n\tif (ret) {\n\t\tret = of_property_read_u32_index(dn, \"reg\", 1, &prop_32);\n\t\tprop = prop_32;\n\t}\n\n\tif (!ret)\n\t\tphb_id = (int)(prop & (MAX_PHBS - 1));\n\n\t/* We need to be sure to not use the same PHB number twice. */\n\tif ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))\n\t\treturn phb_id;\n\n\t/*\n\t * If not pseries nor powernv, or if fixed PHB numbering tried to add\n\t * the same PHB number twice, then fallback to dynamic PHB numbering.\n\t */\n\tphb_id = find_first_zero_bit(phb_bitmap, MAX_PHBS);\n\tBUG_ON(phb_id >= MAX_PHBS);\n\tset_bit(phb_id, phb_bitmap);\n\n\treturn phb_id;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PHBS 0x10000"
          ],
          "globals_used": [
            "static DECLARE_BITMAP(phb_bitmap, MAX_PHBS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define MAX_PHBS 0x10000\n\nstatic DECLARE_BITMAP(phb_bitmap, MAX_PHBS);\n\nstatic int get_phb_number(struct device_node *dn)\n{\n\tint ret, phb_id = -1;\n\tu32 prop_32;\n\tu64 prop;\n\n\t/*\n\t * Try fixed PHB numbering first, by checking archs and reading\n\t * the respective device-tree properties. Firstly, try powernv by\n\t * reading \"ibm,opal-phbid\", only present in OPAL environment.\n\t */\n\tret = of_property_read_u64(dn, \"ibm,opal-phbid\", &prop);\n\tif (ret) {\n\t\tret = of_property_read_u32_index(dn, \"reg\", 1, &prop_32);\n\t\tprop = prop_32;\n\t}\n\n\tif (!ret)\n\t\tphb_id = (int)(prop & (MAX_PHBS - 1));\n\n\t/* We need to be sure to not use the same PHB number twice. */\n\tif ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))\n\t\treturn phb_id;\n\n\t/*\n\t * If not pseries nor powernv, or if fixed PHB numbering tried to add\n\t * the same PHB number twice, then fallback to dynamic PHB numbering.\n\t */\n\tphb_id = find_first_zero_bit(phb_bitmap, MAX_PHBS);\n\tBUG_ON(phb_id >= MAX_PHBS);\n\tset_bit(phb_id, phb_bitmap);\n\n\treturn phb_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hose_spinlock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_maybe_bootmem",
          "args": [
            "sizeof(struct pci_controller)",
            "GFP_KERNEL"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nstruct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = get_phb_number(dev);\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = NUMA_NO_NODE;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}"
  },
  {
    "function_name": "get_phb_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "73-106",
    "snippet": "static int get_phb_number(struct device_node *dn)\n{\n\tint ret, phb_id = -1;\n\tu32 prop_32;\n\tu64 prop;\n\n\t/*\n\t * Try fixed PHB numbering first, by checking archs and reading\n\t * the respective device-tree properties. Firstly, try powernv by\n\t * reading \"ibm,opal-phbid\", only present in OPAL environment.\n\t */\n\tret = of_property_read_u64(dn, \"ibm,opal-phbid\", &prop);\n\tif (ret) {\n\t\tret = of_property_read_u32_index(dn, \"reg\", 1, &prop_32);\n\t\tprop = prop_32;\n\t}\n\n\tif (!ret)\n\t\tphb_id = (int)(prop & (MAX_PHBS - 1));\n\n\t/* We need to be sure to not use the same PHB number twice. */\n\tif ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))\n\t\treturn phb_id;\n\n\t/*\n\t * If not pseries nor powernv, or if fixed PHB numbering tried to add\n\t * the same PHB number twice, then fallback to dynamic PHB numbering.\n\t */\n\tphb_id = find_first_zero_bit(phb_bitmap, MAX_PHBS);\n\tBUG_ON(phb_id >= MAX_PHBS);\n\tset_bit(phb_id, phb_bitmap);\n\n\treturn phb_id;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_PHBS 0x10000"
    ],
    "globals_used": [
      "static DECLARE_BITMAP(phb_bitmap, MAX_PHBS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "phb_id",
            "phb_bitmap"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "phb_id >= MAX_PHBS"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "phb_bitmap",
            "MAX_PHBS"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "phb_id",
            "phb_bitmap"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32_index",
          "args": [
            "dn",
            "\"reg\"",
            "1",
            "&prop_32"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u64",
          "args": [
            "dn",
            "\"ibm,opal-phbid\"",
            "&prop"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\n#define MAX_PHBS 0x10000\n\nstatic DECLARE_BITMAP(phb_bitmap, MAX_PHBS);\n\nstatic int get_phb_number(struct device_node *dn)\n{\n\tint ret, phb_id = -1;\n\tu32 prop_32;\n\tu64 prop;\n\n\t/*\n\t * Try fixed PHB numbering first, by checking archs and reading\n\t * the respective device-tree properties. Firstly, try powernv by\n\t * reading \"ibm,opal-phbid\", only present in OPAL environment.\n\t */\n\tret = of_property_read_u64(dn, \"ibm,opal-phbid\", &prop);\n\tif (ret) {\n\t\tret = of_property_read_u32_index(dn, \"reg\", 1, &prop_32);\n\t\tprop = prop_32;\n\t}\n\n\tif (!ret)\n\t\tphb_id = (int)(prop & (MAX_PHBS - 1));\n\n\t/* We need to be sure to not use the same PHB number twice. */\n\tif ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))\n\t\treturn phb_id;\n\n\t/*\n\t * If not pseries nor powernv, or if fixed PHB numbering tried to add\n\t * the same PHB number twice, then fallback to dynamic PHB numbering.\n\t */\n\tphb_id = find_first_zero_bit(phb_bitmap, MAX_PHBS);\n\tBUG_ON(phb_id >= MAX_PHBS);\n\tset_bit(phb_id, phb_bitmap);\n\n\treturn phb_id;\n}"
  },
  {
    "function_name": "set_pci_dma_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
    "lines": "64-67",
    "snippet": "void set_pci_dma_ops(const struct dma_map_ops *dma_ops)\n{\n\tpci_dma_ops = dma_ops;\n}",
    "includes": [
      "#include \"../../../drivers/pci/pci.h\"",
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/machdep.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/numa.h>",
      "#include <linux/vgaarb.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/irq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/list.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/of_pci.h>",
      "#include <linux/of_address.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dma_map_ops *pci_dma_ops;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic const struct dma_map_ops *pci_dma_ops;\n\nvoid set_pci_dma_ops(const struct dma_map_ops *dma_ops)\n{\n\tpci_dma_ops = dma_ops;\n}"
  }
]