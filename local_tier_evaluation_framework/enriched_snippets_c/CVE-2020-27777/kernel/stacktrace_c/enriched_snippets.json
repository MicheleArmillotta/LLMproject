[
  {
    "function_name": "arch_trigger_cpumask_backtrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "267-270",
    "snippet": "void arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)\n{\n\tnmi_trigger_cpumask_backtrace(mask, exclude_self, raise_backtrace_ipi);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nmi_trigger_cpumask_backtrace",
          "args": [
            "mask",
            "exclude_self",
            "raise_backtrace_ipi"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nvoid arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)\n{\n\tnmi_trigger_cpumask_backtrace(mask, exclude_self, raise_backtrace_ipi);\n}"
  },
  {
    "function_name": "raise_backtrace_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "231-265",
    "snippet": "static void raise_backtrace_ipi(cpumask_t *mask)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tif (cpu == smp_processor_id())\n\t\t\thandle_backtrace_ipi(NULL);\n\t\telse\n\t\t\tsmp_send_safe_nmi_ipi(cpu, handle_backtrace_ipi, 5 * USEC_PER_SEC);\n\t}\n\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct paca_struct *p = paca_ptrs[cpu];\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\n\t\tpr_warn(\"CPU %d didn't respond to backtrace IPI, inspecting paca.\\n\", cpu);\n\t\tif (!virt_addr_valid(p)) {\n\t\t\tpr_warn(\"paca pointer appears corrupt? (%px)\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_warn(\"irq_soft_mask: 0x%02x in_mce: %d in_nmi: %d\",\n\t\t\tp->irq_soft_mask, p->in_mce, p->in_nmi);\n\n\t\tif (virt_addr_valid(p->__current))\n\t\t\tpr_cont(\" current: %d (%s)\\n\", p->__current->pid,\n\t\t\t\tp->__current->comm);\n\t\telse\n\t\t\tpr_cont(\" current pointer corrupt? (%px)\\n\", p->__current);\n\n\t\tpr_warn(\"Back trace of paca->saved_r1 (0x%016llx) (possibly stale):\\n\", p->saved_r1);\n\t\tshow_stack(p->__current, (unsigned long *)p->saved_r1, KERN_WARNING);\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "p->__current",
            "(unsigned long *)p->saved_r1",
            "KERN_WARNING"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "2124-2188",
          "snippet": "void show_stack(struct task_struct *tsk, unsigned long *stack,\n\t\tconst char *loglvl)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n\tunsigned long ret_addr;\n\tint ftrace_idx = 0;\n\n\tif (tsk == NULL)\n\t\ttsk = current;\n\n\tif (!try_get_task_stack(tsk))\n\t\treturn;\n\n\tsp = (unsigned long) stack;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_frame();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"%sCall Trace:\\n\", loglvl);\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\tbreak;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"%s[\"REG\"] [\"REG\"] %pS\",\n\t\t\t\tloglvl, sp, ip, (void *)ip);\n\t\t\tret_addr = ftrace_graph_ret_addr(current,\n\t\t\t\t\t\t&ftrace_idx, ip, stack);\n\t\t\tif (ret_addr != ip)\n\t\t\t\tpr_cont(\" (%pS)\", (void *)ret_addr);\n\t\t\tif (firstframe)\n\t\t\t\tpr_cont(\" (unreliable)\");\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"%s--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       loglvl, regs->trap,\n\t\t\t       (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n\n\tput_task_stack(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define REG\t\t\"%08lx\"",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REG\t\t\"%08lx\"\n#define REG\t\t\"%016lx\"\n\nvoid show_stack(struct task_struct *tsk, unsigned long *stack,\n\t\tconst char *loglvl)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n\tunsigned long ret_addr;\n\tint ftrace_idx = 0;\n\n\tif (tsk == NULL)\n\t\ttsk = current;\n\n\tif (!try_get_task_stack(tsk))\n\t\treturn;\n\n\tsp = (unsigned long) stack;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_frame();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"%sCall Trace:\\n\", loglvl);\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\tbreak;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"%s[\"REG\"] [\"REG\"] %pS\",\n\t\t\t\tloglvl, sp, ip, (void *)ip);\n\t\t\tret_addr = ftrace_graph_ret_addr(current,\n\t\t\t\t\t\t&ftrace_idx, ip, stack);\n\t\t\tif (ret_addr != ip)\n\t\t\t\tpr_cont(\" (%pS)\", (void *)ret_addr);\n\t\t\tif (firstframe)\n\t\t\t\tpr_cont(\" (unreliable)\");\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"%s--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       loglvl, regs->trap,\n\t\t\t       (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n\n\tput_task_stack(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Back trace of paca->saved_r1 (0x%016llx) (possibly stale):\\n\"",
            "p->saved_r1"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" current pointer corrupt? (%px)\\n\"",
            "p->__current"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" current: %d (%s)\\n\"",
            "p->__current->pid",
            "p->__current->comm"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "p->__current"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"irq_soft_mask: 0x%02x in_mce: %d in_nmi: %d\"",
            "p->irq_soft_mask",
            "p->in_mce",
            "p->in_nmi"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"paca pointer appears corrupt? (%px)\\n\"",
            "p"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "p"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"CPU %d didn't respond to backtrace IPI, inspecting paca.\\n\"",
            "cpu"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_send_safe_nmi_ipi",
          "args": [
            "cpu",
            "handle_backtrace_ipi",
            "5 * USEC_PER_SEC"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "smp_send_safe_nmi_ipi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp.c",
          "lines": "544-547",
          "snippet": "int smp_send_safe_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us)\n{\n\treturn __smp_send_nmi_ipi(cpu, fn, delay_us, true);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kup.h>",
            "#include <asm/ftrace.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <asm/dbell.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/stackprotector.h>",
            "#include <linux/random.h>",
            "#include <linux/processor.h>",
            "#include <linux/profile.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kup.h>\n#include <asm/ftrace.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/asm-prototypes.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <asm/dbell.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/pgtable.h>\n#include <linux/stackprotector.h>\n#include <linux/random.h>\n#include <linux/processor.h>\n#include <linux/profile.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint smp_send_safe_nmi_ipi(int cpu, void (*fn)(struct pt_regs *), u64 delay_us)\n{\n\treturn __smp_send_nmi_ipi(cpu, fn, delay_us, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_backtrace_ipi",
          "args": [
            "NULL"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "handle_backtrace_ipi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
          "lines": "226-229",
          "snippet": "static void handle_backtrace_ipi(struct pt_regs *regs)\n{\n\tnmi_cpu_backtrace(regs);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void handle_backtrace_ipi(struct pt_regs *regs)\n{\n\tnmi_cpu_backtrace(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void raise_backtrace_ipi(cpumask_t *mask)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tif (cpu == smp_processor_id())\n\t\t\thandle_backtrace_ipi(NULL);\n\t\telse\n\t\t\tsmp_send_safe_nmi_ipi(cpu, handle_backtrace_ipi, 5 * USEC_PER_SEC);\n\t}\n\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct paca_struct *p = paca_ptrs[cpu];\n\n\t\tcpumask_clear_cpu(cpu, mask);\n\n\t\tpr_warn(\"CPU %d didn't respond to backtrace IPI, inspecting paca.\\n\", cpu);\n\t\tif (!virt_addr_valid(p)) {\n\t\t\tpr_warn(\"paca pointer appears corrupt? (%px)\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_warn(\"irq_soft_mask: 0x%02x in_mce: %d in_nmi: %d\",\n\t\t\tp->irq_soft_mask, p->in_mce, p->in_nmi);\n\n\t\tif (virt_addr_valid(p->__current))\n\t\t\tpr_cont(\" current: %d (%s)\\n\", p->__current->pid,\n\t\t\t\tp->__current->comm);\n\t\telse\n\t\t\tpr_cont(\" current pointer corrupt? (%px)\\n\", p->__current);\n\n\t\tpr_warn(\"Back trace of paca->saved_r1 (0x%016llx) (possibly stale):\\n\", p->saved_r1);\n\t\tshow_stack(p->__current, (unsigned long *)p->saved_r1, KERN_WARNING);\n\t}\n}"
  },
  {
    "function_name": "handle_backtrace_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "226-229",
    "snippet": "static void handle_backtrace_ipi(struct pt_regs *regs)\n{\n\tnmi_cpu_backtrace(regs);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nmi_cpu_backtrace",
          "args": [
            "regs"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void handle_backtrace_ipi(struct pt_regs *regs)\n{\n\tnmi_cpu_backtrace(regs);\n}"
  },
  {
    "function_name": "save_stack_trace_tsk_reliable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "205-222",
    "snippet": "int save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t  struct stack_trace *trace)\n{\n\tint ret;\n\n\t/*\n\t * If the task doesn't have a stack (e.g., a zombie), the stack is\n\t * \"reliably\" empty.\n\t */\n\tif (!try_get_task_stack(tsk))\n\t\treturn 0;\n\n\tret = __save_stack_trace_tsk_reliable(tsk, trace);\n\n\tput_task_stack(tsk);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_stack",
          "args": [
            "tsk"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_stack_trace_tsk_reliable",
          "args": [
            "tsk",
            "trace"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace_tsk_reliable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
          "lines": "98-203",
          "snippet": "static int __save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t\t   struct stack_trace *trace)\n{\n\tunsigned long sp;\n\tunsigned long newsp;\n\tunsigned long stack_page = (unsigned long)task_stack_page(tsk);\n\tunsigned long stack_end;\n\tint graph_idx = 0;\n\tbool firstframe;\n\n\tstack_end = stack_page + THREAD_SIZE;\n\tif (!is_idle_task(tsk)) {\n\t\t/*\n\t\t * For user tasks, this is the SP value loaded on\n\t\t * kernel entry, see \"PACAKSAVE(r13)\" in _switch() and\n\t\t * system_call_common()/EXCEPTION_PROLOG_COMMON().\n\t\t *\n\t\t * Likewise for non-swapper kernel threads,\n\t\t * this also happens to be the top of the stack\n\t\t * as setup by copy_thread().\n\t\t *\n\t\t * Note that stack backlinks are not properly setup by\n\t\t * copy_thread() and thus, a forked task() will have\n\t\t * an unreliable stack trace until it's been\n\t\t * _switch()'ed to for the first time.\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\n\t} else {\n\t\t/*\n\t\t * idle tasks have a custom stack layout,\n\t\t * c.f. cpu_idle_thread_init().\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD;\n\t}\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tif (sp < stack_page + sizeof(struct thread_struct) ||\n\t    sp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (firstframe = true; sp != stack_end;\n\t     firstframe = false, sp = newsp) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long ip;\n\n\t\t/* sanity check: ABI requires SP to be aligned 16 bytes. */\n\t\tif (sp & 0xF)\n\t\t\treturn -EINVAL;\n\n\t\tnewsp = stack[0];\n\t\t/* Stack grows downwards; unwinder may only go up. */\n\t\tif (newsp <= sp)\n\t\t\treturn -EINVAL;\n\n\t\tif (newsp != stack_end &&\n\t\t    newsp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\t\treturn -EINVAL; /* invalid backlink, too far up. */\n\t\t}\n\n\t\t/*\n\t\t * We can only trust the bottom frame's backlink, the\n\t\t * rest of the frame may be uninitialized, continue to\n\t\t * the next.\n\t\t */\n\t\tif (firstframe)\n\t\t\tcontinue;\n\n\t\t/* Mark stacktraces with exception frames as unreliable. */\n\t\tif (sp <= stack_end - STACK_INT_FRAME_SIZE &&\n\t\t    stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Examine the saved LR: it must point into kernel code. */\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!__kernel_text_address(ip))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * FIXME: IMHO these tests do not belong in\n\t\t * arch-dependent code, they are generic.\n\t\t */\n\t\tip = ftrace_graph_ret_addr(tsk, &graph_idx, ip, stack);\n#ifdef CONFIG_KPROBES\n\t\t/*\n\t\t * Mark stacktraces with kretprobed functions on them\n\t\t * as unreliable.\n\t\t */\n\t\tif (ip == (unsigned long)kretprobe_trampoline)\n\t\t\treturn -EINVAL;\n#endif\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn -E2BIG;\n\t\tif (!trace->skip)\n\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\telse\n\t\t\ttrace->skip--;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic int __save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t\t   struct stack_trace *trace)\n{\n\tunsigned long sp;\n\tunsigned long newsp;\n\tunsigned long stack_page = (unsigned long)task_stack_page(tsk);\n\tunsigned long stack_end;\n\tint graph_idx = 0;\n\tbool firstframe;\n\n\tstack_end = stack_page + THREAD_SIZE;\n\tif (!is_idle_task(tsk)) {\n\t\t/*\n\t\t * For user tasks, this is the SP value loaded on\n\t\t * kernel entry, see \"PACAKSAVE(r13)\" in _switch() and\n\t\t * system_call_common()/EXCEPTION_PROLOG_COMMON().\n\t\t *\n\t\t * Likewise for non-swapper kernel threads,\n\t\t * this also happens to be the top of the stack\n\t\t * as setup by copy_thread().\n\t\t *\n\t\t * Note that stack backlinks are not properly setup by\n\t\t * copy_thread() and thus, a forked task() will have\n\t\t * an unreliable stack trace until it's been\n\t\t * _switch()'ed to for the first time.\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\n\t} else {\n\t\t/*\n\t\t * idle tasks have a custom stack layout,\n\t\t * c.f. cpu_idle_thread_init().\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD;\n\t}\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tif (sp < stack_page + sizeof(struct thread_struct) ||\n\t    sp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (firstframe = true; sp != stack_end;\n\t     firstframe = false, sp = newsp) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long ip;\n\n\t\t/* sanity check: ABI requires SP to be aligned 16 bytes. */\n\t\tif (sp & 0xF)\n\t\t\treturn -EINVAL;\n\n\t\tnewsp = stack[0];\n\t\t/* Stack grows downwards; unwinder may only go up. */\n\t\tif (newsp <= sp)\n\t\t\treturn -EINVAL;\n\n\t\tif (newsp != stack_end &&\n\t\t    newsp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\t\treturn -EINVAL; /* invalid backlink, too far up. */\n\t\t}\n\n\t\t/*\n\t\t * We can only trust the bottom frame's backlink, the\n\t\t * rest of the frame may be uninitialized, continue to\n\t\t * the next.\n\t\t */\n\t\tif (firstframe)\n\t\t\tcontinue;\n\n\t\t/* Mark stacktraces with exception frames as unreliable. */\n\t\tif (sp <= stack_end - STACK_INT_FRAME_SIZE &&\n\t\t    stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Examine the saved LR: it must point into kernel code. */\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!__kernel_text_address(ip))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * FIXME: IMHO these tests do not belong in\n\t\t * arch-dependent code, they are generic.\n\t\t */\n\t\tip = ftrace_graph_ret_addr(tsk, &graph_idx, ip, stack);\n#ifdef CONFIG_KPROBES\n\t\t/*\n\t\t * Mark stacktraces with kretprobed functions on them\n\t\t * as unreliable.\n\t\t */\n\t\tif (ip == (unsigned long)kretprobe_trampoline)\n\t\t\treturn -EINVAL;\n#endif\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn -E2BIG;\n\t\tif (!trace->skip)\n\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\telse\n\t\t\ttrace->skip--;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_get_task_stack",
          "args": [
            "tsk"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nint save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t  struct stack_trace *trace)\n{\n\tint ret;\n\n\t/*\n\t * If the task doesn't have a stack (e.g., a zombie), the stack is\n\t * \"reliably\" empty.\n\t */\n\tif (!try_get_task_stack(tsk))\n\t\treturn 0;\n\n\tret = __save_stack_trace_tsk_reliable(tsk, trace);\n\n\tput_task_stack(tsk);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__save_stack_trace_tsk_reliable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "98-203",
    "snippet": "static int __save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t\t   struct stack_trace *trace)\n{\n\tunsigned long sp;\n\tunsigned long newsp;\n\tunsigned long stack_page = (unsigned long)task_stack_page(tsk);\n\tunsigned long stack_end;\n\tint graph_idx = 0;\n\tbool firstframe;\n\n\tstack_end = stack_page + THREAD_SIZE;\n\tif (!is_idle_task(tsk)) {\n\t\t/*\n\t\t * For user tasks, this is the SP value loaded on\n\t\t * kernel entry, see \"PACAKSAVE(r13)\" in _switch() and\n\t\t * system_call_common()/EXCEPTION_PROLOG_COMMON().\n\t\t *\n\t\t * Likewise for non-swapper kernel threads,\n\t\t * this also happens to be the top of the stack\n\t\t * as setup by copy_thread().\n\t\t *\n\t\t * Note that stack backlinks are not properly setup by\n\t\t * copy_thread() and thus, a forked task() will have\n\t\t * an unreliable stack trace until it's been\n\t\t * _switch()'ed to for the first time.\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\n\t} else {\n\t\t/*\n\t\t * idle tasks have a custom stack layout,\n\t\t * c.f. cpu_idle_thread_init().\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD;\n\t}\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tif (sp < stack_page + sizeof(struct thread_struct) ||\n\t    sp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (firstframe = true; sp != stack_end;\n\t     firstframe = false, sp = newsp) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long ip;\n\n\t\t/* sanity check: ABI requires SP to be aligned 16 bytes. */\n\t\tif (sp & 0xF)\n\t\t\treturn -EINVAL;\n\n\t\tnewsp = stack[0];\n\t\t/* Stack grows downwards; unwinder may only go up. */\n\t\tif (newsp <= sp)\n\t\t\treturn -EINVAL;\n\n\t\tif (newsp != stack_end &&\n\t\t    newsp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\t\treturn -EINVAL; /* invalid backlink, too far up. */\n\t\t}\n\n\t\t/*\n\t\t * We can only trust the bottom frame's backlink, the\n\t\t * rest of the frame may be uninitialized, continue to\n\t\t * the next.\n\t\t */\n\t\tif (firstframe)\n\t\t\tcontinue;\n\n\t\t/* Mark stacktraces with exception frames as unreliable. */\n\t\tif (sp <= stack_end - STACK_INT_FRAME_SIZE &&\n\t\t    stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Examine the saved LR: it must point into kernel code. */\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!__kernel_text_address(ip))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * FIXME: IMHO these tests do not belong in\n\t\t * arch-dependent code, they are generic.\n\t\t */\n\t\tip = ftrace_graph_ret_addr(tsk, &graph_idx, ip, stack);\n#ifdef CONFIG_KPROBES\n\t\t/*\n\t\t * Mark stacktraces with kretprobed functions on them\n\t\t * as unreliable.\n\t\t */\n\t\tif (ip == (unsigned long)kretprobe_trampoline)\n\t\t\treturn -EINVAL;\n#endif\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn -E2BIG;\n\t\tif (!trace->skip)\n\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\telse\n\t\t\ttrace->skip--;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_ret_addr",
          "args": [
            "tsk",
            "&graph_idx",
            "ip",
            "stack"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_text_address",
          "args": [
            "ip"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_stack_frame",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "tsk"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "tsk"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic int __save_stack_trace_tsk_reliable(struct task_struct *tsk,\n\t\t\t\t\t   struct stack_trace *trace)\n{\n\tunsigned long sp;\n\tunsigned long newsp;\n\tunsigned long stack_page = (unsigned long)task_stack_page(tsk);\n\tunsigned long stack_end;\n\tint graph_idx = 0;\n\tbool firstframe;\n\n\tstack_end = stack_page + THREAD_SIZE;\n\tif (!is_idle_task(tsk)) {\n\t\t/*\n\t\t * For user tasks, this is the SP value loaded on\n\t\t * kernel entry, see \"PACAKSAVE(r13)\" in _switch() and\n\t\t * system_call_common()/EXCEPTION_PROLOG_COMMON().\n\t\t *\n\t\t * Likewise for non-swapper kernel threads,\n\t\t * this also happens to be the top of the stack\n\t\t * as setup by copy_thread().\n\t\t *\n\t\t * Note that stack backlinks are not properly setup by\n\t\t * copy_thread() and thus, a forked task() will have\n\t\t * an unreliable stack trace until it's been\n\t\t * _switch()'ed to for the first time.\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\n\t} else {\n\t\t/*\n\t\t * idle tasks have a custom stack layout,\n\t\t * c.f. cpu_idle_thread_init().\n\t\t */\n\t\tstack_end -= STACK_FRAME_OVERHEAD;\n\t}\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tif (sp < stack_page + sizeof(struct thread_struct) ||\n\t    sp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (firstframe = true; sp != stack_end;\n\t     firstframe = false, sp = newsp) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long ip;\n\n\t\t/* sanity check: ABI requires SP to be aligned 16 bytes. */\n\t\tif (sp & 0xF)\n\t\t\treturn -EINVAL;\n\n\t\tnewsp = stack[0];\n\t\t/* Stack grows downwards; unwinder may only go up. */\n\t\tif (newsp <= sp)\n\t\t\treturn -EINVAL;\n\n\t\tif (newsp != stack_end &&\n\t\t    newsp > stack_end - STACK_FRAME_MIN_SIZE) {\n\t\t\treturn -EINVAL; /* invalid backlink, too far up. */\n\t\t}\n\n\t\t/*\n\t\t * We can only trust the bottom frame's backlink, the\n\t\t * rest of the frame may be uninitialized, continue to\n\t\t * the next.\n\t\t */\n\t\tif (firstframe)\n\t\t\tcontinue;\n\n\t\t/* Mark stacktraces with exception frames as unreliable. */\n\t\tif (sp <= stack_end - STACK_INT_FRAME_SIZE &&\n\t\t    stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Examine the saved LR: it must point into kernel code. */\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!__kernel_text_address(ip))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * FIXME: IMHO these tests do not belong in\n\t\t * arch-dependent code, they are generic.\n\t\t */\n\t\tip = ftrace_graph_ret_addr(tsk, &graph_idx, ip, stack);\n#ifdef CONFIG_KPROBES\n\t\t/*\n\t\t * Mark stacktraces with kretprobed functions on them\n\t\t * as unreliable.\n\t\t */\n\t\tif (ip == (unsigned long)kretprobe_trampoline)\n\t\t\treturn -EINVAL;\n#endif\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn -E2BIG;\n\t\tif (!trace->skip)\n\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\telse\n\t\t\ttrace->skip--;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "save_stack_trace_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "84-88",
    "snippet": "void\nsave_stack_trace_regs(struct pt_regs *regs, struct stack_trace *trace)\n{\n\tsave_context_stack(trace, regs->gpr[1], current, 0);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_context_stack",
          "args": [
            "trace",
            "regs->gpr[1]",
            "current",
            "0"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "save_context_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
          "lines": "29-54",
          "snippet": "static void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nvoid\nsave_stack_trace_regs(struct pt_regs *regs, struct stack_trace *trace)\n{\n\tsave_context_stack(trace, regs->gpr[1], current, 0);\n}"
  },
  {
    "function_name": "save_stack_trace_tsk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "66-81",
    "snippet": "void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)\n{\n\tunsigned long sp;\n\n\tif (!try_get_task_stack(tsk))\n\t\treturn;\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tsave_context_stack(trace, sp, tsk, 0);\n\n\tput_task_stack(tsk);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_stack",
          "args": [
            "tsk"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_context_stack",
          "args": [
            "trace",
            "sp",
            "tsk",
            "0"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "save_context_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
          "lines": "29-54",
          "snippet": "static void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_stack_frame",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_task_stack",
          "args": [
            "tsk"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nvoid save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)\n{\n\tunsigned long sp;\n\n\tif (!try_get_task_stack(tsk))\n\t\treturn;\n\n\tif (tsk == current)\n\t\tsp = current_stack_frame();\n\telse\n\t\tsp = tsk->thread.ksp;\n\n\tsave_context_stack(trace, sp, tsk, 0);\n\n\tput_task_stack(tsk);\n}"
  },
  {
    "function_name": "save_stack_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "56-63",
    "snippet": "void save_stack_trace(struct stack_trace *trace)\n{\n\tunsigned long sp;\n\n\tsp = current_stack_frame();\n\n\tsave_context_stack(trace, sp, current, 1);\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_context_stack",
          "args": [
            "trace",
            "sp",
            "current",
            "1"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "save_context_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
          "lines": "29-54",
          "snippet": "static void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <asm/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <asm/processor.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/module.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_stack_frame",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nvoid save_stack_trace(struct stack_trace *trace)\n{\n\tunsigned long sp;\n\n\tsp = current_stack_frame();\n\n\tsave_context_stack(trace, sp, current, 1);\n}"
  },
  {
    "function_name": "save_context_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/stacktrace.c",
    "lines": "29-54",
    "snippet": "static void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}",
    "includes": [
      "#include <asm/paca.h>",
      "#include <asm/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <asm/processor.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/module.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_sched_functions",
          "args": [
            "ip"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_sp",
          "args": [
            "sp",
            "tsk",
            "STACK_FRAME_OVERHEAD"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "validate_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "2063-2078",
          "snippet": "int validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp < THREAD_SIZE)\n\t\treturn 0;\n\n\tif (sp >= stack_page && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\tif (valid_irq_stack(sp, p, nbytes))\n\t\treturn 1;\n\n\treturn valid_emergency_stack(sp, p, nbytes);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp < THREAD_SIZE)\n\t\treturn 0;\n\n\tif (sp >= stack_page && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\tif (valid_irq_stack(sp, p, nbytes))\n\t\treturn 1;\n\n\treturn valid_emergency_stack(sp, p, nbytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/paca.h>\n#include <asm/kprobes.h>\n#include <linux/ftrace.h>\n#include <asm/processor.h>\n#include <asm/ptrace.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n\nstatic void save_context_stack(struct stack_trace *trace, unsigned long sp,\n\t\t\tstruct task_struct *tsk, int savesched)\n{\n\tfor (;;) {\n\t\tunsigned long *stack = (unsigned long *) sp;\n\t\tunsigned long newsp, ip;\n\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\n\t\tif (savesched || !in_sched_functions(ip)) {\n\t\t\tif (!trace->skip)\n\t\t\t\ttrace->entries[trace->nr_entries++] = ip;\n\t\t\telse\n\t\t\t\ttrace->skip--;\n\t\t}\n\n\t\tif (trace->nr_entries >= trace->max_entries)\n\t\t\treturn;\n\n\t\tsp = newsp;\n\t}\n}"
  }
]