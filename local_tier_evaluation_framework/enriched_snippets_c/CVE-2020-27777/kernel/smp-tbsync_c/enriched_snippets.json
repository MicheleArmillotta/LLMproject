[
  {
    "function_name": "smp_generic_give_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "113-171",
    "snippet": "void smp_generic_give_timebase(void)\n{\n\tint i, score, score2, old, min=0, max=5000, offset=1000;\n\n\tpr_debug(\"Software timebase sync\\n\");\n\n\t/* if this fails then this kernel won't work anyway... */\n\ttbsync = kzalloc( sizeof(*tbsync), GFP_KERNEL );\n\tmb();\n\trunning = 1;\n\n\twhile (!tbsync->ack)\n\t\tbarrier();\n\n\tpr_debug(\"Got ack\\n\");\n\n\t/* binary search */\n\tfor (old = -1; old != offset ; offset = (min+max) / 2) {\n\t\tscore = start_contest(kSetAndTest, offset, NUM_ITER);\n\n\t\tpr_debug(\"score %d, offset %d\\n\", score, offset );\n\n\t\tif( score > 0 )\n\t\t\tmax = offset;\n\t\telse\n\t\t\tmin = offset;\n\t\told = offset;\n\t}\n\tscore = start_contest(kSetAndTest, min, NUM_ITER);\n\tscore2 = start_contest(kSetAndTest, max, NUM_ITER);\n\n\tpr_debug(\"Min %d (score %d), Max %d (score %d)\\n\",\n\t\t min, score, max, score2);\n\tscore = abs(score);\n\tscore2 = abs(score2);\n\toffset = (score < score2) ? min : max;\n\n\t/* guard against inaccurate mttb */\n\tfor (i = 0; i < 10; i++) {\n\t\tstart_contest(kSetAndTest, offset, NUM_ITER/10);\n\n\t\tif ((score2 = start_contest(kTest, offset, NUM_ITER)) < 0)\n\t\t\tscore2 = -score2;\n\t\tif (score2 <= score || score2 < 20)\n\t\t\tbreak;\n\t}\n\tpr_debug(\"Final offset: %d (%d/%d)\\n\", offset, score2, NUM_ITER );\n\n\t/* exiting */\n\ttbsync->cmd = kExit;\n\twmb();\n\ttbsync->handshake = 1;\n\twhile (tbsync->ack)\n\t\tbarrier();\n\ttbsync->handshake = 0;\n\tkfree(tbsync);\n\ttbsync = NULL;\n\trunning = 0;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NUM_ITER\t\t300"
    ],
    "globals_used": [
      "static volatile int\t\trunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tbsync"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "422-427",
          "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Final offset: %d (%d/%d)\\n\"",
            "offset",
            "score2",
            "NUM_ITER"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_contest",
          "args": [
            "kTest",
            "offset",
            "NUM_ITER"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "start_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "78-111",
          "snippet": "static int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "score2"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "score"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Min %d (score %d), Max %d (score %d)\\n\"",
            "min",
            "score",
            "max",
            "score2"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"score %d, offset %d\\n\"",
            "score",
            "offset"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Got ack\\n\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tbsync)",
            "GFP_KERNEL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Software timebase sync\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define NUM_ITER\t\t300\n\nstatic volatile int\t\trunning;\n\nvoid smp_generic_give_timebase(void)\n{\n\tint i, score, score2, old, min=0, max=5000, offset=1000;\n\n\tpr_debug(\"Software timebase sync\\n\");\n\n\t/* if this fails then this kernel won't work anyway... */\n\ttbsync = kzalloc( sizeof(*tbsync), GFP_KERNEL );\n\tmb();\n\trunning = 1;\n\n\twhile (!tbsync->ack)\n\t\tbarrier();\n\n\tpr_debug(\"Got ack\\n\");\n\n\t/* binary search */\n\tfor (old = -1; old != offset ; offset = (min+max) / 2) {\n\t\tscore = start_contest(kSetAndTest, offset, NUM_ITER);\n\n\t\tpr_debug(\"score %d, offset %d\\n\", score, offset );\n\n\t\tif( score > 0 )\n\t\t\tmax = offset;\n\t\telse\n\t\t\tmin = offset;\n\t\told = offset;\n\t}\n\tscore = start_contest(kSetAndTest, min, NUM_ITER);\n\tscore2 = start_contest(kSetAndTest, max, NUM_ITER);\n\n\tpr_debug(\"Min %d (score %d), Max %d (score %d)\\n\",\n\t\t min, score, max, score2);\n\tscore = abs(score);\n\tscore2 = abs(score2);\n\toffset = (score < score2) ? min : max;\n\n\t/* guard against inaccurate mttb */\n\tfor (i = 0; i < 10; i++) {\n\t\tstart_contest(kSetAndTest, offset, NUM_ITER/10);\n\n\t\tif ((score2 = start_contest(kTest, offset, NUM_ITER)) < 0)\n\t\t\tscore2 = -score2;\n\t\tif (score2 <= score || score2 < 20)\n\t\t\tbreak;\n\t}\n\tpr_debug(\"Final offset: %d (%d/%d)\\n\", offset, score2, NUM_ITER );\n\n\t/* exiting */\n\ttbsync->cmd = kExit;\n\twmb();\n\ttbsync->handshake = 1;\n\twhile (tbsync->ack)\n\t\tbarrier();\n\ttbsync->handshake = 0;\n\tkfree(tbsync);\n\ttbsync = NULL;\n\trunning = 0;\n}"
  },
  {
    "function_name": "start_contest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "78-111",
    "snippet": "static int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "422-427",
          "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_contest",
          "args": [
            "mark",
            "1"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "enter_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "39-43",
          "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int start_contest(int cmd, long offset, int num)\n{\n\tint i, score=0;\n\tu64 tb;\n\tu64 mark;\n\n\ttbsync->cmd = cmd;\n\n\tlocal_irq_disable();\n\tfor (i = -3; i < num; ) {\n\t\ttb = get_tb() + 400;\n\t\ttbsync->tb = tb + offset;\n\t\ttbsync->mark = mark = tb + 400;\n\n\t\twmb();\n\n\t\ttbsync->handshake = 1;\n\t\twhile (tbsync->ack)\n\t\t\tbarrier();\n\n\t\twhile (get_tb() <= tb)\n\t\t\tbarrier();\n\t\ttbsync->handshake = 0;\n\t\tenter_contest(mark, 1);\n\n\t\twhile (!tbsync->ack)\n\t\t\tbarrier();\n\n\t\tif (i++ > 0)\n\t\t\tscore += tbsync->race_result;\n\t}\n\tlocal_irq_enable();\n\treturn score;\n}"
  },
  {
    "function_name": "smp_generic_take_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "45-76",
    "snippet": "void smp_generic_take_timebase(void)\n{\n\tint cmd;\n\tu64 tb;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twhile (!running)\n\t\tbarrier();\n\trmb();\n\n\tfor (;;) {\n\t\ttbsync->ack = 1;\n\t\twhile (!tbsync->handshake)\n\t\t\tbarrier();\n\t\trmb();\n\n\t\tcmd = tbsync->cmd;\n\t\ttb = tbsync->tb;\n\t\tmb();\n\t\ttbsync->ack = 0;\n\t\tif (cmd == kExit)\n\t\t\tbreak;\n\n\t\twhile (tbsync->handshake)\n\t\t\tbarrier();\n\t\tif (cmd == kSetAndTest)\n\t\t\tset_tb(tb >> 32, tb & 0xfffffffful);\n\t\tenter_contest(tbsync->mark, -1);\n\t}\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int\t\trunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "314-383",
          "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_contest",
          "args": [
            "tbsync->mark",
            "-1"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "enter_contest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
          "lines": "39-43",
          "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
          "includes": [
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/unistd.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tb",
          "args": [
            "tb >> 32",
            "tb & 0xfffffffful"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "stf_barrier_debugfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/security.c",
          "lines": "422-427",
          "snippet": "static __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/inst.h>",
            "#include <asm/setup.h>",
            "#include <asm/security_features.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/device.h>",
            "#include <linux/kernel.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/inst.h>\n#include <asm/setup.h>\n#include <asm/security_features.h>\n#include <asm/debugfs.h>\n#include <asm/code-patching.h>\n#include <asm/asm-prototypes.h>\n#include <linux/seq_buf.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/cpu.h>\n\nstatic __init int stf_barrier_debugfs_init(void)\n{\n\tdebugfs_create_file_unsafe(\"stf_barrier\", 0600, powerpc_debugfs_root,\n\t\t\t\t   NULL, &fops_stf_barrier);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic volatile int\t\trunning;\n\nvoid smp_generic_take_timebase(void)\n{\n\tint cmd;\n\tu64 tb;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\twhile (!running)\n\t\tbarrier();\n\trmb();\n\n\tfor (;;) {\n\t\ttbsync->ack = 1;\n\t\twhile (!tbsync->handshake)\n\t\t\tbarrier();\n\t\trmb();\n\n\t\tcmd = tbsync->cmd;\n\t\ttb = tbsync->tb;\n\t\tmb();\n\t\ttbsync->ack = 0;\n\t\tif (cmd == kExit)\n\t\t\tbreak;\n\n\t\twhile (tbsync->handshake)\n\t\t\tbarrier();\n\t\tif (cmd == kSetAndTest)\n\t\t\tset_tb(tb >> 32, tb & 0xfffffffful);\n\t\tenter_contest(tbsync->mark, -1);\n\t}\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "enter_contest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/smp-tbsync.c",
    "lines": "39-43",
    "snippet": "static void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}",
    "includes": [
      "#include <asm/time.h>",
      "#include <asm/smp.h>",
      "#include <linux/atomic.h>",
      "#include <linux/slab.h>",
      "#include <linux/unistd.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/time.h>\n#include <asm/smp.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void enter_contest(u64 mark, long add)\n{\n\twhile (get_tb() < mark)\n\t\ttbsync->race_result = add;\n}"
  }
]