[
  {
    "function_name": "eeh_handle_special_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "1120-1225",
    "snippet": "void eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe, *tmp_pe;\n\tstruct eeh_dev *edev, *tmp_edev;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_mark_isolated(phb_pe);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc != EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_pe_mark_isolated(pe);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_handle_normal_event(pe);\n\t\t} else {\n\t\t\teeh_for_each_pe(pe, tmp_pe)\n\t\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp_edev)\n\t\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t\t\t/* Notify all devices to be down */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\t\teeh_pe_report(\n\t\t\t\t\"error_detected(permanent failure)\", pe,\n\t\t\t\teeh_report_failure, NULL);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\tif (!bus) {\n\t\t\t\t\tpr_err(\"%s: Cannot find PCI bus for \"\n\t\t\t\t\t       \"PHB#%x-PE#%x\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       pe->phb->global_number,\n\t\t\t\t\t       pe->addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpci_hp_remove_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_hp_remove_devices",
          "args": [
            "bus"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "pci_hp_remove_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "77-92",
          "snippet": "void pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Cannot find PCI bus for \"\n\t\t\t\t\t       \"PHB#%x-PE#%x\\n\"",
            "__func__",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "phb_pe"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "848-867",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "hose"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "157-172",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_report",
          "args": [
            "\"error_detected(permanent failure)\"",
            "pe",
            "eeh_report_failure",
            "NULL"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "301-315",
          "snippet": "static void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_set_channel_state",
          "args": [
            "pe",
            "pci_channel_io_perm_failure"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_set_channel_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "217-226",
          "snippet": "static void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_PRI_BUS",
            "true"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "tmp_pe",
            "edev",
            "tmp_edev"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_handle_normal_event",
          "args": [
            "pe"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_normal_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "836-1111",
          "snippet": "void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define MAX_WAIT_FOR_RECOVERY 300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nvoid eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid value %d from next_error()\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_mark_isolated",
          "args": [
            "pe"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_mark_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "533-550",
          "snippet": "void eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_mark_isolated(struct eeh_pe *root)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\teeh_pe_state_mark(root, EEH_PE_ISOLATED);\n\teeh_for_each_pe(root, pe) {\n\t\tlist_for_each_entry(edev, &pe->edevs, entry) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (pdev)\n\t\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t\t}\n\t\t/* Block PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_remove_event",
          "args": [
            "pe",
            "true"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_remove_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_event.c",
          "lines": "167-201",
          "snippet": "void eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <linux/kthread.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
            "static LIST_HEAD(eeh_eventlist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic LIST_HEAD(eeh_eventlist);\n\nvoid eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_unlock",
          "args": [
            "flags"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "hose",
            "&hose_list",
            "list_node"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_serialize_lock",
          "args": [
            "&flags"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->next_error",
          "args": [
            "&pe"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nvoid eeh_handle_special_event(void)\n{\n\tstruct eeh_pe *pe, *phb_pe, *tmp_pe;\n\tstruct eeh_dev *edev, *tmp_edev;\n\tstruct pci_bus *bus;\n\tstruct pci_controller *hose;\n\tunsigned long flags;\n\tint rc;\n\n\n\tdo {\n\t\trc = eeh_ops->next_error(&pe);\n\n\t\tswitch (rc) {\n\t\tcase EEH_NEXT_ERR_DEAD_IOC:\n\t\t\t/* Mark all PHBs in dead state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events */\n\t\t\teeh_remove_event(NULL, true);\n\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe) continue;\n\n\t\t\t\teeh_pe_mark_isolated(phb_pe);\n\t\t\t}\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_FROZEN_PE:\n\t\tcase EEH_NEXT_ERR_FENCED_PHB:\n\t\tcase EEH_NEXT_ERR_DEAD_PHB:\n\t\t\t/* Mark the PE in fenced state */\n\t\t\teeh_serialize_lock(&flags);\n\n\t\t\t/* Purge all events of the PHB */\n\t\t\teeh_remove_event(pe, true);\n\n\t\t\tif (rc != EEH_NEXT_ERR_DEAD_PHB)\n\t\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_pe_mark_isolated(pe);\n\n\t\t\teeh_serialize_unlock(flags);\n\n\t\t\tbreak;\n\t\tcase EEH_NEXT_ERR_NONE:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Invalid value %d from next_error()\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * For fenced PHB and frozen PE, it's handled as normal\n\t\t * event. We have to remove the affected PHBs for dead\n\t\t * PHB and IOC\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_FROZEN_PE ||\n\t\t    rc == EEH_NEXT_ERR_FENCED_PHB) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\teeh_handle_normal_event(pe);\n\t\t} else {\n\t\t\teeh_for_each_pe(pe, tmp_pe)\n\t\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp_edev)\n\t\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t\t\t/* Notify all devices to be down */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\t\teeh_pe_report(\n\t\t\t\t\"error_detected(permanent failure)\", pe,\n\t\t\t\teeh_report_failure, NULL);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tlist_for_each_entry(hose, &hose_list, list_node) {\n\t\t\t\tphb_pe = eeh_phb_pe_get(hose);\n\t\t\t\tif (!phb_pe ||\n\t\t\t\t    !(phb_pe->state & EEH_PE_ISOLATED) ||\n\t\t\t\t    (phb_pe->state & EEH_PE_RECOVERING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbus = eeh_pe_bus_get(phb_pe);\n\t\t\t\tif (!bus) {\n\t\t\t\t\tpr_err(\"%s: Cannot find PCI bus for \"\n\t\t\t\t\t       \"PHB#%x-PE#%x\\n\",\n\t\t\t\t\t       __func__,\n\t\t\t\t\t       pe->phb->global_number,\n\t\t\t\t\t       pe->addr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpci_hp_remove_devices(bus);\n\t\t\t}\n\t\t\tpci_unlock_rescan_remove();\n\t\t}\n\n\t\t/*\n\t\t * If we have detected dead IOC, we needn't proceed\n\t\t * any more since all PHBs would have been removed\n\t\t */\n\t\tif (rc == EEH_NEXT_ERR_DEAD_IOC)\n\t\t\tbreak;\n\t} while (rc != EEH_NEXT_ERR_NONE);\n}"
  },
  {
    "function_name": "eeh_handle_normal_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "836-1111",
    "snippet": "void eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define MAX_WAIT_FOR_RECOVERY 300"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RECOVERING",
            "true"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_clear_slot_attention",
          "args": [
            "edev->pdev"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_clear_slot_attention",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "793-813",
          "snippet": "static void eeh_clear_slot_attention(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\n\tif (!pdev)\n\t\treturn;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->set_attention_status)\n\t\treturn;\n\n\tops->set_attention_status(slot->hotplug, 0);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_clear_slot_attention(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\n\tif (!pdev)\n\t\treturn;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->set_attention_status)\n\t\treturn;\n\n\tops->set_attention_status(slot->hotplug, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "tmp_pe",
            "edev",
            "tmp"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_cleanup",
          "args": [
            "pe"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "730-747",
          "snippet": "static void eeh_pe_cleanup(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *child_pe, *tmp;\n\n\tlist_for_each_entry_safe(child_pe, tmp, &pe->child_list, child)\n\t\teeh_pe_cleanup(child_pe);\n\n\tif (pe->state & EEH_PE_KEEP)\n\t\treturn;\n\n\tif (!(pe->state & EEH_PE_INVALID))\n\t\treturn;\n\n\tif (list_empty(&pe->edevs) && list_empty(&pe->child_list)) {\n\t\tlist_del(&pe->child);\n\t\tkfree(pe);\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_cleanup(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *child_pe, *tmp;\n\n\tlist_for_each_entry_safe(child_pe, tmp, &pe->child_list, child)\n\t\teeh_pe_cleanup(child_pe);\n\n\tif (pe->state & EEH_PE_KEEP)\n\t\treturn;\n\n\tif (!(pe->state & EEH_PE_INVALID))\n\t\treturn;\n\n\tif (list_empty(&pe->edevs) && list_empty(&pe->child_list)) {\n\t\tlist_del(&pe->child);\n\t\tkfree(pe);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_hp_remove_devices",
          "args": [
            "bus"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "pci_hp_remove_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "77-92",
          "snippet": "void pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_mode_mark",
          "args": [
            "pe",
            "EEH_DEV_REMOVED"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_mode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "566-569",
          "snippet": "void eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_rmv_device",
            "NULL"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_REMOVED"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_report",
          "args": [
            "\"error_detected(permanent failure)\"",
            "pe",
            "eeh_report_failure",
            "NULL"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "301-315",
          "snippet": "static void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_set_irq_state",
          "args": [
            "pe",
            "false"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_set_irq_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "228-249",
          "snippet": "static void eeh_set_irq_state(struct eeh_pe *root, bool enable)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tif (!eeh_edev_actionable(edev))\n\t\t\t\tcontinue;\n\n\t\t\tif (!eeh_pcid_get(edev->pdev))\n\t\t\t\tcontinue;\n\n\t\t\tif (enable)\n\t\t\t\teeh_enable_irq(edev);\n\t\t\telse\n\t\t\t\teeh_disable_irq(edev);\n\n\t\t\teeh_pcid_put(edev->pdev);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_irq_state(struct eeh_pe *root, bool enable)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tif (!eeh_edev_actionable(edev))\n\t\t\t\tcontinue;\n\n\t\t\tif (!eeh_pcid_get(edev->pdev))\n\t\t\t\tcontinue;\n\n\t\t\tif (enable)\n\t\t\t\teeh_enable_irq(edev);\n\t\t\telse\n\t\t\t\teeh_disable_irq(edev);\n\n\t\t\teeh_pcid_put(edev->pdev);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_set_channel_state",
          "args": [
            "pe",
            "pci_channel_io_perm_failure"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_set_channel_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "217-226",
          "snippet": "static void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_slot_error_detail",
          "args": [
            "pe",
            "EEH_LOG_PERM"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_slot_error_detail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "291-338",
          "snippet": "void eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t *\n\t * When the @severity is EEH_LOG_PERM, the PE is going to be\n\t * removed. Prior to that, the drivers for devices included in\n\t * the PE will be closed. The drivers rely on working IO path\n\t * to bring the devices to quiet state. Otherwise, PCI traffic\n\t * from those devices after they are removed is like to cause\n\t * another unexpected EEH error.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||\n\t\t    severity == EEH_LOG_PERM)\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;",
            "static unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nstruct eeh_ops *eeh_ops = NULL;\nstatic unsigned char pci_regs_buf[EEH_PCI_REGS_LOG_LEN];\n\nvoid eeh_slot_error_detail(struct eeh_pe *pe, int severity)\n{\n\tsize_t loglen = 0;\n\n\t/*\n\t * When the PHB is fenced or dead, it's pointless to collect\n\t * the data from PCI config space because it should return\n\t * 0xFF's. For ER, we still retrieve the data from the PCI\n\t * config space.\n\t *\n\t * For pHyp, we have to enable IO for log retrieval. Otherwise,\n\t * 0xFF's is always returned from PCI config space.\n\t *\n\t * When the @severity is EEH_LOG_PERM, the PE is going to be\n\t * removed. Prior to that, the drivers for devices included in\n\t * the PE will be closed. The drivers rely on working IO path\n\t * to bring the devices to quiet state. Otherwise, PCI traffic\n\t * from those devices after they are removed is like to cause\n\t * another unexpected EEH error.\n\t */\n\tif (!(pe->type & EEH_PE_PHB)) {\n\t\tif (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||\n\t\t    severity == EEH_LOG_PERM)\n\t\t\teeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\t/*\n\t\t * The config space of some PCI devices can't be accessed\n\t\t * when their PEs are in frozen state. Otherwise, fenced\n\t\t * PHB might be seen. Those PEs are identified with flag\n\t\t * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED\n\t\t * is set automatically when the PE is put to EEH_PE_ISOLATED.\n\t\t *\n\t\t * Restoring BARs possibly triggers PCI config access in\n\t\t * (OPAL) firmware and then causes fenced PHB. If the\n\t\t * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it's\n\t\t * pointless to restore BARs and dump config space.\n\t\t */\n\t\teeh_ops->configure_bridge(pe);\n\t\tif (!(pe->state & EEH_PE_CFG_BLOCKED)) {\n\t\t\teeh_pe_restore_bars(pe);\n\n\t\t\tpci_regs_buf[0] = 0;\n\t\t\teeh_pe_traverse(pe, eeh_dump_pe_log, &loglen);\n\t\t}\n\t}\n\n\teeh_ops->get_log(pe, severity, pci_regs_buf, loglen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Recovery successful.\\n\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "tmp_pe",
            "edev",
            "tmp"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device driver to resume\\n\""
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&edev->rmv_entry"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_virt_device",
          "args": [
            "edev"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_virt_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "460-483",
          "snippet": "static void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "edev",
            "tmp",
            "&rmv_data.removed_vf_list",
            "rmv_entry"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Cannot reset, err=%d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_reset_device",
          "args": [
            "pe",
            "bus",
            "&rmv_data",
            "true"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_reset_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "624-715",
          "snippet": "static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,\n\t\t\t    struct eeh_rmv_data *rmv_data,\n\t\t\t    bool driver_eeh_aware)\n{\n\ttime64_t tstamp;\n\tint cnt, rc;\n\tstruct eeh_dev *edev;\n\tstruct eeh_pe *tmp_pe;\n\tbool any_passed = false;\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\tany_passed |= eeh_pe_passed(tmp_pe);\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pci_hp_add_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (any_passed || driver_eeh_aware || (pe->type & EEH_PE_VF)) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, rmv_data);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_hp_remove_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_pe_reset_full(pe, false);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/* Clear frozen state */\n\trc = eeh_clear_pe_frozen_state(pe, false);\n\tif (rc) {\n\t\tpci_unlock_rescan_remove();\n\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (!driver_eeh_aware || rmv_data->removed_dev_count) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of %s hotplug\\n\",\n\t\t\t(driver_eeh_aware ? \"partial\" : \"complete\"));\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, entry);\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_add_virt_device(edev);\n\t\t} else {\n\t\t\tif (!driver_eeh_aware)\n\t\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\tpci_hp_add_devices(bus);\n\t\t}\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP, true);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,\n\t\t\t    struct eeh_rmv_data *rmv_data,\n\t\t\t    bool driver_eeh_aware)\n{\n\ttime64_t tstamp;\n\tint cnt, rc;\n\tstruct eeh_dev *edev;\n\tstruct eeh_pe *tmp_pe;\n\tbool any_passed = false;\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\tany_passed |= eeh_pe_passed(tmp_pe);\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pci_hp_add_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (any_passed || driver_eeh_aware || (pe->type & EEH_PE_VF)) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, rmv_data);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_hp_remove_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_pe_reset_full(pe, false);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/* Clear frozen state */\n\trc = eeh_clear_pe_frozen_state(pe, false);\n\tif (rc) {\n\t\tpci_unlock_rescan_remove();\n\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (!driver_eeh_aware || rmv_data->removed_dev_count) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of %s hotplug\\n\",\n\t\t\t(driver_eeh_aware ? \"partial\" : \"complete\"));\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, entry);\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_add_virt_device(edev);\n\t\t} else {\n\t\t\tif (!driver_eeh_aware)\n\t\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\tpci_hp_add_devices(bus);\n\t\t}\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP, true);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Reset without hotplug activity\\n\""
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pci_enable",
          "args": [
            "pe",
            "EEH_OPT_THAW_DMA"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pci_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "626-693",
          "snippet": "int eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [
            "struct eeh_ops *eeh_ops = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nstruct eeh_ops *eeh_ops = NULL;\n\nint eeh_pci_enable(struct eeh_pe *pe, int function)\n{\n\tint active_flag, rc;\n\n\t/*\n\t * pHyp doesn't allow to enable IO or DMA on unfrozen PE.\n\t * Also, it's pointless to enable them on unfrozen PE. So\n\t * we have to check before enabling IO or DMA.\n\t */\n\tswitch (function) {\n\tcase EEH_OPT_THAW_MMIO:\n\t\tactive_flag = EEH_STATE_MMIO_ACTIVE | EEH_STATE_MMIO_ENABLED;\n\t\tbreak;\n\tcase EEH_OPT_THAW_DMA:\n\t\tactive_flag = EEH_STATE_DMA_ACTIVE;\n\t\tbreak;\n\tcase EEH_OPT_DISABLE:\n\tcase EEH_OPT_ENABLE:\n\tcase EEH_OPT_FREEZE_PE:\n\t\tactive_flag = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Invalid function %d\\n\",\n\t\t\t__func__, function);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Check if IO or DMA has been enabled before\n\t * enabling them.\n\t */\n\tif (active_flag) {\n\t\trc = eeh_ops->get_state(pe, NULL);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t/* Needn't enable it at all */\n\t\tif (rc == EEH_STATE_NOT_SUPPORT)\n\t\t\treturn 0;\n\n\t\t/* It's already enabled */\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\t}\n\n\n\t/* Issue the request */\n\trc = eeh_ops->set_option(pe, function);\n\tif (rc)\n\t\tpr_warn(\"%s: Unexpected state change %d on \"\n\t\t\t\"PHB#%x-PE#%x, err=%d\\n\",\n\t\t\t__func__, function, pe->phb->global_number,\n\t\t\tpe->addr, rc);\n\n\t/* Check if the request is finished successfully */\n\tif (active_flag) {\n\t\trc = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (rc & active_flag)\n\t\t\treturn 0;\n\n\t\treturn -EIO;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Enabled DMA for affected devices\\n\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device drivers to resume I/O\\n\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Enable I/O for affected devices\\n\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Unable to reset, err=%d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Reset with hotplug activity\\n\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Collect temporary log\\n\""
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: Permanent failure\\n\""
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_wait_state",
          "args": [
            "pe",
            "MAX_WAIT_FOR_RECOVERY*1000"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_wait_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "106-147",
          "snippet": "int eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)",
            "#define EEH_STATE_MIN_WAIT_TIME\t(1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n\nint eeh_wait_state(struct eeh_pe *pe, int max_wait)\n{\n\tint ret;\n\tint mwait;\n\n\t/*\n\t * According to PAPR, the state of PE might be temporarily\n\t * unavailable. Under the circumstance, we have to wait\n\t * for indicated time determined by firmware. The maximal\n\t * wait time is 5 minutes, which is acquired from the original\n\t * EEH implementation. Also, the original implementation\n\t * also defined the minimal wait time as 1 second.\n\t */\n#define EEH_STATE_MIN_WAIT_TIME\t(1000)\n#define EEH_STATE_MAX_WAIT_TIME\t(300 * 1000)\n\n\twhile (1) {\n\t\tret = eeh_ops->get_state(pe, &mwait);\n\n\t\tif (ret != EEH_STATE_UNAVAILABLE)\n\t\t\treturn ret;\n\n\t\tif (max_wait <= 0) {\n\t\t\tpr_warn(\"%s: Timeout when getting PE's state (%d)\\n\",\n\t\t\t\t__func__, max_wait);\n\t\t\treturn EEH_STATE_NOT_SUPPORT;\n\t\t}\n\n\t\tif (mwait < EEH_STATE_MIN_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned bad wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MIN_WAIT_TIME;\n\t\t} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\n\t\t\tpr_warn(\"%s: Firmware returned too long wait value %d\\n\",\n\t\t\t\t__func__, mwait);\n\t\t\tmwait = EEH_STATE_MAX_WAIT_TIME;\n\t\t}\n\n\t\tmsleep(min(mwait, max_wait));\n\t\tmax_wait -= mwait;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Notify device drivers to shutdown\\n\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\"",
            "pe->freeze_count",
            "eeh_max_freezes"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "tmp_pe",
            "edev",
            "tmp"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\"",
            "pe->phb->global_number",
            "pe->addr",
            "pe->freeze_count"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_update_time_stamp",
          "args": [
            "pe"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_update_time_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "489-505",
          "snippet": "void eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\ttime64_t tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tpe->tstamp = ktime_get_seconds();\n\t} else {\n\t\ttstamp = ktime_get_seconds();\n\t\tif (tstamp - pe->tstamp > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\ttime64_t tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tpe->tstamp = ktime_get_seconds();\n\t} else {\n\t\ttstamp = ktime_get_seconds();\n\t\tif (tstamp - pe->tstamp > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: [%pK] %pS\\n\"",
            "ptrs[i]",
            "ptrs[i]"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Call Trace:\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Frozen PHB#%x-PE#%x detected\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: PE location: %s, PHB location: %s\\n\"",
            "eeh_pe_loc_get(pe)",
            "eeh_pe_loc_get(phb_pe)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_loc_get",
          "args": [
            "phb_pe"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_loc_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "810-836",
          "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn;\n\tconst char *loc = NULL;\n\n\twhile (bus) {\n\t\tdn = pci_bus_to_OF_node(bus);\n\t\tif (!dn) {\n\t\t\tbus = bus->parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pci_is_root_bus(bus))\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\telse\n\t\t\tloc = of_get_property(dn, \"ibm,slot-location-code\",\n\t\t\t\t\t      NULL);\n\n\t\tif (loc)\n\t\t\treturn loc;\n\n\t\tbus = bus->parent;\n\t}\n\n\treturn \"N/A\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Recovering PHB#%x-PE#%x\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "pe->phb"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "157-172",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: Recovering PHB#%x, location: %s\\n\"",
            "pe->phb->global_number",
            "eeh_pe_loc_get(pe)"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_slot_presence_check",
          "args": [
            "edev->pdev"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_slot_presence_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "761-791",
          "snippet": "static bool eeh_slot_presence_check(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\tu8 state;\n\tint rc;\n\n\tif (!pdev)\n\t\treturn false;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn true;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->get_adapter_status)\n\t\treturn true;\n\n\t/* set the attention indicator while we've got the slot ops */\n\tif (ops->set_attention_status)\n\t\tops->set_attention_status(slot->hotplug, 1);\n\n\trc = ops->get_adapter_status(slot->hotplug, &state);\n\tif (rc)\n\t\treturn true;\n\n\treturn !!state;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_slot_presence_check(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\tu8 state;\n\tint rc;\n\n\tif (!pdev)\n\t\treturn false;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn true;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->get_adapter_status)\n\t\treturn true;\n\n\t/* set the attention indicator while we've got the slot ops */\n\tif (ops->set_attention_status)\n\t\tops->set_attention_status(slot->hotplug, 1);\n\n\trc = ops->get_adapter_status(slot->hotplug, &state);\n\tif (rc)\n\t\treturn true;\n\n\treturn !!state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "tmp_pe",
            "edev",
            "tmp"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\"",
            "__func__",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "pe"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "848-867",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn pe->phb->bus;\n\n\t/* The primary bus might be cached during probe time */\n\tif (pe->state & EEH_PE_PRI_BUS)\n\t\treturn pe->bus;\n\n\t/* Retrieve the parent PCI bus of first (top) PCI device */\n\tedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, entry);\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (pdev)\n\t\treturn pdev->bus;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "rmv_data.removed_vf_list"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#define MAX_WAIT_FOR_RECOVERY 300\n\nvoid eeh_handle_normal_event(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct eeh_pe *tmp_pe;\n\tint rc = 0;\n\tenum pci_ers_result result = PCI_ERS_RESULT_NONE;\n\tstruct eeh_rmv_data rmv_data =\n\t\t{LIST_HEAD_INIT(rmv_data.removed_vf_list), 0};\n\tint devices = 0;\n\n\tbus = eeh_pe_bus_get(pe);\n\tif (!bus) {\n\t\tpr_err(\"%s: Cannot find PCI bus for PHB#%x-PE#%x\\n\",\n\t\t\t__func__, pe->phb->global_number, pe->addr);\n\t\treturn;\n\t}\n\n\t/*\n\t * When devices are hot-removed we might get an EEH due to\n\t * a driver attempting to touch the MMIO space of a removed\n\t * device. In this case we don't have a device to recover\n\t * so suppress the event if we can't find any present devices.\n\t *\n\t * The hotplug driver should take care of tearing down the\n\t * device itself.\n\t */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tif (eeh_slot_presence_check(edev->pdev))\n\t\t\t\tdevices++;\n\n\tif (!devices) {\n\t\tpr_debug(\"EEH: Frozen PHB#%x-PE#%x is empty!\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\t\tgoto out; /* nothing to recover */\n\t}\n\n\t/* Log the event */\n\tif (pe->type & EEH_PE_PHB) {\n\t\tpr_err(\"EEH: Recovering PHB#%x, location: %s\\n\",\n\t\t\tpe->phb->global_number, eeh_pe_loc_get(pe));\n\t} else {\n\t\tstruct eeh_pe *phb_pe = eeh_phb_pe_get(pe->phb);\n\n\t\tpr_err(\"EEH: Recovering PHB#%x-PE#%x\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\t\tpr_err(\"EEH: PE location: %s, PHB location: %s\\n\",\n\t\t       eeh_pe_loc_get(pe), eeh_pe_loc_get(phb_pe));\n\t}\n\n#ifdef CONFIG_STACKTRACE\n\t/*\n\t * Print the saved stack trace now that we've verified there's\n\t * something to recover.\n\t */\n\tif (pe->trace_entries) {\n\t\tvoid **ptrs = (void **) pe->stack_trace;\n\t\tint i;\n\n\t\tpr_err(\"EEH: Frozen PHB#%x-PE#%x detected\\n\",\n\t\t       pe->phb->global_number, pe->addr);\n\n\t\t/* FIXME: Use the same format as dump_stack() */\n\t\tpr_err(\"EEH: Call Trace:\\n\");\n\t\tfor (i = 0; i < pe->trace_entries; i++)\n\t\t\tpr_err(\"EEH: [%pK] %pS\\n\", ptrs[i], ptrs[i]);\n\n\t\tpe->trace_entries = 0;\n\t}\n#endif /* CONFIG_STACKTRACE */\n\n\teeh_pe_update_time_stamp(pe);\n\tpe->freeze_count++;\n\tif (pe->freeze_count > eeh_max_freezes) {\n\t\tpr_err(\"EEH: PHB#%x-PE#%x has failed %d times in the last hour and has been permanently disabled.\\n\",\n\t\t       pe->phb->global_number, pe->addr,\n\t\t       pe->freeze_count);\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\n\t/* Walk the various device drivers attached to this slot through\n\t * a reset sequence, giving each an opportunity to do what it needs\n\t * to accomplish the reset.  Each child gets a report of the\n\t * status ... if any child can't handle the reset, then the entire\n\t * slot is dlpar removed and added.\n\t *\n\t * When the PHB is fenced, we have to issue a reset to recover from\n\t * the error. Override the result if necessary to have partially\n\t * hotplug for this case.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_warn(\"EEH: This PCI device has failed %d times in the last hour and will be permanently disabled after %d failures.\\n\",\n\t\t\tpe->freeze_count, eeh_max_freezes);\n\t\tpr_info(\"EEH: Notify device drivers to shutdown\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_frozen);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(IO frozen)\", pe,\n\t\t\t      eeh_report_error, &result);\n\t\tif ((pe->type & EEH_PE_PHB) &&\n\t\t    result != PCI_ERS_RESULT_NONE &&\n\t\t    result != PCI_ERS_RESULT_NEED_RESET)\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\n\t/* Get the current PCI slot state. This can take a long time,\n\t * sometimes over 300 seconds for certain systems.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\trc = eeh_wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\n\t\tif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\n\t\t\tpr_warn(\"EEH: Permanent failure\\n\");\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* Since rtas may enable MMIO when posting the error log,\n\t * don't post the error log until after all dev drivers\n\t * have been informed.\n\t */\n\tif (result != PCI_ERS_RESULT_DISCONNECT) {\n\t\tpr_info(\"EEH: Collect temporary log\\n\");\n\t\teeh_slot_error_detail(pe, EEH_LOG_TEMP);\n\t}\n\n\t/* If all device drivers were EEH-unaware, then shut\n\t * down all of the device drivers, and hope they\n\t * go down willingly, without panicing the system.\n\t */\n\tif (result == PCI_ERS_RESULT_NONE) {\n\t\tpr_info(\"EEH: Reset with hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, NULL, false);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Unable to reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable MMIO */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enable I/O for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\tpr_info(\"EEH: Notify device drivers to resume I/O\\n\");\n\t\t\teeh_pe_report(\"mmio_enabled\", pe,\n\t\t\t\t      eeh_report_mmio_enabled, &result);\n\t\t}\n\t}\n\n\t/* If all devices reported they can proceed, then re-enable DMA */\n\tif (result == PCI_ERS_RESULT_CAN_RECOVER) {\n\t\tpr_info(\"EEH: Enabled DMA for affected devices\\n\");\n\t\trc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\n\t\tif (rc < 0) {\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else if (rc) {\n\t\t\tresult = PCI_ERS_RESULT_NEED_RESET;\n\t\t} else {\n\t\t\t/*\n\t\t\t * We didn't do PE reset for the case. The PE\n\t\t\t * is still in frozen state. Clear it before\n\t\t\t * resuming the PE.\n\t\t\t */\n\t\t\teeh_pe_state_clear(pe, EEH_PE_ISOLATED, true);\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\t}\n\t}\n\n\t/* If any device called out for a reset, then reset the slot */\n\tif (result == PCI_ERS_RESULT_NEED_RESET) {\n\t\tpr_info(\"EEH: Reset without hotplug activity\\n\");\n\t\trc = eeh_reset_device(pe, bus, &rmv_data, true);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: Cannot reset, err=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t\t} else {\n\t\t\tresult = PCI_ERS_RESULT_NONE;\n\t\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\t\teeh_set_irq_state(pe, true);\n\t\t\teeh_pe_report(\"slot_reset\", pe, eeh_report_reset,\n\t\t\t\t      &result);\n\t\t}\n\t}\n\n\tif ((result == PCI_ERS_RESULT_RECOVERED) ||\n\t    (result == PCI_ERS_RESULT_NONE)) {\n\t\t/*\n\t\t * For those hot removed VFs, we should add back them after PF\n\t\t * get recovered properly.\n\t\t */\n\t\tlist_for_each_entry_safe(edev, tmp, &rmv_data.removed_vf_list,\n\t\t\t\t\t rmv_entry) {\n\t\t\teeh_add_virt_device(edev);\n\t\t\tlist_del(&edev->rmv_entry);\n\t\t}\n\n\t\t/* Tell all device drivers that they can resume operations */\n\t\tpr_info(\"EEH: Notify device driver to resume\\n\");\n\t\teeh_set_channel_state(pe, pci_channel_io_normal);\n\t\teeh_set_irq_state(pe, true);\n\t\teeh_pe_report(\"resume\", pe, eeh_report_resume, NULL);\n\t\teeh_for_each_pe(pe, tmp_pe) {\n\t\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp) {\n\t\t\t\tedev->mode &= ~EEH_DEV_NO_HANDLER;\n\t\t\t\tedev->in_error = false;\n\t\t\t}\n\t\t}\n\n\t\tpr_info(\"EEH: Recovery successful.\\n\");\n\t} else  {\n\t\t/*\n\t\t * About 90% of all real-life EEH failures in the field\n\t\t * are due to poorly seated PCI cards. Only 10% or so are\n\t\t * due to actual, failed cards.\n\t\t */\n\t\tpr_err(\"EEH: Unable to recover from failure from PHB#%x-PE#%x.\\n\"\n\t\t       \"Please try reseating or replacing it\\n\",\n\t\t\tpe->phb->global_number, pe->addr);\n\n\t\teeh_slot_error_detail(pe, EEH_LOG_PERM);\n\n\t\t/* Notify all devices that they're about to go down. */\n\t\teeh_set_channel_state(pe, pci_channel_io_perm_failure);\n\t\teeh_set_irq_state(pe, false);\n\t\teeh_pe_report(\"error_detected(permanent failure)\", pe,\n\t\t\t      eeh_report_failure, NULL);\n\n\t\t/* Mark the PE to be removed permanently */\n\t\teeh_pe_state_mark(pe, EEH_PE_REMOVED);\n\n\t\t/*\n\t\t * Shut down the device drivers for good. We mark\n\t\t * all removed devices correctly to avoid access\n\t\t * the their PCI config any more.\n\t\t */\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\t\t} else {\n\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\teeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\n\n\t\t\tpci_lock_rescan_remove();\n\t\t\tpci_hp_remove_devices(bus);\n\t\t\tpci_unlock_rescan_remove();\n\t\t\t/* The passed PE should no longer be used */\n\t\t\treturn;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Clean up any PEs without devices. While marked as EEH_PE_RECOVERYING\n\t * we don't want to modify the PE tree structure so we do it here.\n\t */\n\teeh_pe_cleanup(pe);\n\n\t/* clear the slot attention LED for all recovered devices */\n\teeh_for_each_pe(pe, tmp_pe)\n\t\teeh_pe_for_each_dev(tmp_pe, edev, tmp)\n\t\t\teeh_clear_slot_attention(edev->pdev);\n\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n}"
  },
  {
    "function_name": "eeh_clear_slot_attention",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "793-813",
    "snippet": "static void eeh_clear_slot_attention(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\n\tif (!pdev)\n\t\treturn;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->set_attention_status)\n\t\treturn;\n\n\tops->set_attention_status(slot->hotplug, 0);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->set_attention_status",
          "args": [
            "slot->hotplug",
            "0"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_clear_slot_attention(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\n\tif (!pdev)\n\t\treturn;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->set_attention_status)\n\t\treturn;\n\n\tops->set_attention_status(slot->hotplug, 0);\n}"
  },
  {
    "function_name": "eeh_slot_presence_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "761-791",
    "snippet": "static bool eeh_slot_presence_check(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\tu8 state;\n\tint rc;\n\n\tif (!pdev)\n\t\treturn false;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn true;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->get_adapter_status)\n\t\treturn true;\n\n\t/* set the attention indicator while we've got the slot ops */\n\tif (ops->set_attention_status)\n\t\tops->set_attention_status(slot->hotplug, 1);\n\n\trc = ops->get_adapter_status(slot->hotplug, &state);\n\tif (rc)\n\t\treturn true;\n\n\treturn !!state;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->get_adapter_status",
          "args": [
            "slot->hotplug",
            "&state"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->set_attention_status",
          "args": [
            "slot->hotplug",
            "1"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_slot_presence_check(struct pci_dev *pdev)\n{\n\tconst struct hotplug_slot_ops *ops;\n\tstruct pci_slot *slot;\n\tu8 state;\n\tint rc;\n\n\tif (!pdev)\n\t\treturn false;\n\n\tif (pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\n\tslot = pdev->slot;\n\tif (!slot || !slot->hotplug)\n\t\treturn true;\n\n\tops = slot->hotplug->ops;\n\tif (!ops || !ops->get_adapter_status)\n\t\treturn true;\n\n\t/* set the attention indicator while we've got the slot ops */\n\tif (ops->set_attention_status)\n\t\tops->set_attention_status(slot->hotplug, 1);\n\n\trc = ops->get_adapter_status(slot->hotplug, &state);\n\tif (rc)\n\t\treturn true;\n\n\treturn !!state;\n}"
  },
  {
    "function_name": "eeh_pe_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "730-747",
    "snippet": "static void eeh_pe_cleanup(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *child_pe, *tmp;\n\n\tlist_for_each_entry_safe(child_pe, tmp, &pe->child_list, child)\n\t\teeh_pe_cleanup(child_pe);\n\n\tif (pe->state & EEH_PE_KEEP)\n\t\treturn;\n\n\tif (!(pe->state & EEH_PE_INVALID))\n\t\treturn;\n\n\tif (list_empty(&pe->edevs) && list_empty(&pe->child_list)) {\n\t\tlist_del(&pe->child);\n\t\tkfree(pe);\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pe->child"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->child_list"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->edevs"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_cleanup",
          "args": [
            "child_pe"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "730-747",
          "snippet": "static void eeh_pe_cleanup(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *child_pe, *tmp;\n\n\tlist_for_each_entry_safe(child_pe, tmp, &pe->child_list, child)\n\t\teeh_pe_cleanup(child_pe);\n\n\tif (pe->state & EEH_PE_KEEP)\n\t\treturn;\n\n\tif (!(pe->state & EEH_PE_INVALID))\n\t\treturn;\n\n\tif (list_empty(&pe->edevs) && list_empty(&pe->child_list)) {\n\t\tlist_del(&pe->child);\n\t\tkfree(pe);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "child_pe",
            "tmp",
            "&pe->child_list",
            "child"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_cleanup(struct eeh_pe *pe)\n{\n\tstruct eeh_pe *child_pe, *tmp;\n\n\tlist_for_each_entry_safe(child_pe, tmp, &pe->child_list, child)\n\t\teeh_pe_cleanup(child_pe);\n\n\tif (pe->state & EEH_PE_KEEP)\n\t\treturn;\n\n\tif (!(pe->state & EEH_PE_INVALID))\n\t\treturn;\n\n\tif (list_empty(&pe->edevs) && list_empty(&pe->child_list)) {\n\t\tlist_del(&pe->child);\n\t\tkfree(pe);\n\t}\n}"
  },
  {
    "function_name": "eeh_reset_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "624-715",
    "snippet": "static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,\n\t\t\t    struct eeh_rmv_data *rmv_data,\n\t\t\t    bool driver_eeh_aware)\n{\n\ttime64_t tstamp;\n\tint cnt, rc;\n\tstruct eeh_dev *edev;\n\tstruct eeh_pe *tmp_pe;\n\tbool any_passed = false;\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\tany_passed |= eeh_pe_passed(tmp_pe);\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pci_hp_add_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (any_passed || driver_eeh_aware || (pe->type & EEH_PE_VF)) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, rmv_data);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_hp_remove_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_pe_reset_full(pe, false);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/* Clear frozen state */\n\trc = eeh_clear_pe_frozen_state(pe, false);\n\tif (rc) {\n\t\tpci_unlock_rescan_remove();\n\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (!driver_eeh_aware || rmv_data->removed_dev_count) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of %s hotplug\\n\",\n\t\t\t(driver_eeh_aware ? \"partial\" : \"complete\"));\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, entry);\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_add_virt_device(edev);\n\t\t} else {\n\t\t\tif (!driver_eeh_aware)\n\t\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\tpci_hp_add_devices(bus);\n\t\t}\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP, true);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_KEEP",
            "true"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_hp_add_devices",
          "args": [
            "bus"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "pci_hp_add_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "106-147",
          "snippet": "void pci_hp_add_devices(struct pci_bus *bus)\n{\n\tint slotno, mode, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL &&\n\t\t   dn->child && PCI_DN(dn->child)) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tmax = bus->busn_res.start;\n\t\t/*\n\t\t * Scan bridges that are already configured. We don't touch\n\t\t * them unless they are misconfigured (which will be done in\n\t\t * the second scan below).\n\t\t */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 0);\n\n\t\t/* Scan bridges that need to be reconfigured */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 1);\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_add_devices(struct pci_bus *bus)\n{\n\tint slotno, mode, max;\n\tstruct pci_dev *dev;\n\tstruct pci_controller *phb;\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\n\tphb = pci_bus_to_host(bus);\n\n\tmode = PCI_PROBE_NORMAL;\n\tif (phb->controller_ops.probe_mode)\n\t\tmode = phb->controller_ops.probe_mode(bus);\n\n\tif (mode == PCI_PROBE_DEVTREE) {\n\t\t/* use ofdt-based probe */\n\t\tof_rescan_bus(dn, bus);\n\t} else if (mode == PCI_PROBE_NORMAL &&\n\t\t   dn->child && PCI_DN(dn->child)) {\n\t\t/*\n\t\t * Use legacy probe. In the partial hotplug case, we\n\t\t * probably have grandchildren devices unplugged. So\n\t\t * we don't check the return value from pci_scan_slot() in\n\t\t * order for fully rescan all the way down to pick them up.\n\t\t * They can have been removed during partial hotplug.\n\t\t */\n\t\tslotno = PCI_SLOT(PCI_DN(dn->child)->devfn);\n\t\tpci_scan_slot(bus, PCI_DEVFN(slotno, 0));\n\t\tmax = bus->busn_res.start;\n\t\t/*\n\t\t * Scan bridges that are already configured. We don't touch\n\t\t * them unless they are misconfigured (which will be done in\n\t\t * the second scan below).\n\t\t */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 0);\n\n\t\t/* Scan bridges that need to be reconfigured */\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, 1);\n\t}\n\tpcibios_finish_adding_to_bus(bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_add_virt_device",
          "args": [
            "edev"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_virt_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "460-483",
          "snippet": "static void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "eeh_pe_detach_dev",
            "NULL"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "211-223",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_pe_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\teeh_for_each_pe(root, pe) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pe->edevs",
            "structeeh_dev",
            "entry"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssleep",
          "args": [
            "5"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Sleep 5s ahead of %s hotplug\\n\"",
            "(driver_eeh_aware ? \"partial\" : \"complete\")"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_clear_pe_frozen_state",
          "args": [
            "pe",
            "false"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_clear_pe_frozen_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "558-574",
          "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "pe"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "792-799",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->configure_bridge",
          "args": [
            "pe"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_reset_full",
          "args": [
            "pe",
            "false"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reset_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "842-901",
          "snippet": "int eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nint eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_hp_remove_devices",
          "args": [
            "bus"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "pci_hp_remove_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-hotplug.c",
          "lines": "77-92",
          "snippet": "void pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/export.h>",
            "#include <linux/pci.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n\nvoid pci_hp_remove_devices(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev, *tmp;\n\tstruct pci_bus *child_bus;\n\n\t/* First go down child busses */\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpci_hp_remove_devices(child_bus);\n\n\tpr_debug(\"PCI: Removing devices on bus %04x:%02x\\n\",\n\t\t pci_domain_nr(bus),  bus->number);\n\tlist_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list) {\n\t\tpr_debug(\"   Removing %s...\\n\", pci_name(dev));\n\t\tpci_stop_and_remove_bus_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_rmv_device",
            "rmv_data"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_KEEP"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "tmp_pe"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "pe",
            "tmp_pe"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,\n\t\t\t    struct eeh_rmv_data *rmv_data,\n\t\t\t    bool driver_eeh_aware)\n{\n\ttime64_t tstamp;\n\tint cnt, rc;\n\tstruct eeh_dev *edev;\n\tstruct eeh_pe *tmp_pe;\n\tbool any_passed = false;\n\n\teeh_for_each_pe(pe, tmp_pe)\n\t\tany_passed |= eeh_pe_passed(tmp_pe);\n\n\t/* pcibios will clear the counter; save the value */\n\tcnt = pe->freeze_count;\n\ttstamp = pe->tstamp;\n\n\t/*\n\t * We don't remove the corresponding PE instances because\n\t * we need the information afterwords. The attached EEH\n\t * devices are expected to be attached soon when calling\n\t * into pci_hp_add_devices().\n\t */\n\teeh_pe_state_mark(pe, EEH_PE_KEEP);\n\tif (any_passed || driver_eeh_aware || (pe->type & EEH_PE_VF)) {\n\t\teeh_pe_dev_traverse(pe, eeh_rmv_device, rmv_data);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_hp_remove_devices(bus);\n\t\tpci_unlock_rescan_remove();\n\t}\n\n\t/*\n\t * Reset the pci controller. (Asserts RST#; resets config space).\n\t * Reconfigure bridges and devices. Don't try to bring the system\n\t * up if the reset failed for some reason.\n\t *\n\t * During the reset, it's very dangerous to have uncontrolled PCI\n\t * config accesses. So we prefer to block them. However, controlled\n\t * PCI config accesses initiated from EEH itself are allowed.\n\t */\n\trc = eeh_pe_reset_full(pe, false);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_lock_rescan_remove();\n\n\t/* Restore PE */\n\teeh_ops->configure_bridge(pe);\n\teeh_pe_restore_bars(pe);\n\n\t/* Clear frozen state */\n\trc = eeh_clear_pe_frozen_state(pe, false);\n\tif (rc) {\n\t\tpci_unlock_rescan_remove();\n\t\treturn rc;\n\t}\n\n\t/* Give the system 5 seconds to finish running the user-space\n\t * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,\n\t * this is a hack, but if we don't do this, and try to bring\n\t * the device up before the scripts have taken it down,\n\t * potentially weird things happen.\n\t */\n\tif (!driver_eeh_aware || rmv_data->removed_dev_count) {\n\t\tpr_info(\"EEH: Sleep 5s ahead of %s hotplug\\n\",\n\t\t\t(driver_eeh_aware ? \"partial\" : \"complete\"));\n\t\tssleep(5);\n\n\t\t/*\n\t\t * The EEH device is still connected with its parent\n\t\t * PE. We should disconnect it so the binding can be\n\t\t * rebuilt when adding PCI devices.\n\t\t */\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, entry);\n\t\teeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\n\t\tif (pe->type & EEH_PE_VF) {\n\t\t\teeh_add_virt_device(edev);\n\t\t} else {\n\t\t\tif (!driver_eeh_aware)\n\t\t\t\teeh_pe_state_clear(pe, EEH_PE_PRI_BUS, true);\n\t\t\tpci_hp_add_devices(bus);\n\t\t}\n\t}\n\teeh_pe_state_clear(pe, EEH_PE_KEEP, true);\n\n\tpe->tstamp = tstamp;\n\tpe->freeze_count = cnt;\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_reset_and_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "576-611",
    "snippet": "int eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Issue reset */\n\tret = eeh_pe_reset_full(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RECOVERING",
            "true"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_dev_restore_state",
            "NULL"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "234-250",
          "snippet": "void eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\t\t  eeh_edev_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn;\n\t}\n\n\t/* Traverse root PE */\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tfn(edev, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_clear_pe_frozen_state",
          "args": [
            "pe",
            "true"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_clear_pe_frozen_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "558-574",
          "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_reset_full",
          "args": [
            "pe",
            "true"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_reset_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "842-901",
          "snippet": "int eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [
            "#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\n#define PCI_BUS_RESET_WAIT_MSEC (5*60*1000)\n\nint eeh_pe_reset_full(struct eeh_pe *pe, bool include_passed)\n{\n\tint reset_state = (EEH_PE_RESET | EEH_PE_CFG_BLOCKED);\n\tint type = EEH_RESET_HOT;\n\tunsigned int freset = 0;\n\tint i, state = 0, ret;\n\n\t/*\n\t * Determine the type of reset to perform - hot or fundamental.\n\t * Hot reset is the default operation, unless any device under the\n\t * PE requires a fundamental reset.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_set_dev_freset, &freset);\n\n\tif (freset)\n\t\ttype = EEH_RESET_FUNDAMENTAL;\n\n\t/* Mark the PE as in reset state and block config space accesses */\n\teeh_pe_state_mark(pe, reset_state);\n\n\t/* Make three attempts at resetting the bus */\n\tfor (i = 0; i < 3; i++) {\n\t\tret = eeh_pe_reset(pe, type, include_passed);\n\t\tif (!ret)\n\t\t\tret = eeh_pe_reset(pe, EEH_RESET_DEACTIVATE,\n\t\t\t\t\t   include_passed);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tpr_warn(\"EEH: Failure %d resetting PHB#%x-PE#%x (attempt %d)\\n\\n\",\n\t\t\t\tstate, pe->phb->global_number, pe->addr, i + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i)\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Successful reset (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, i + 1);\n\n\t\t/* Wait until the PE is in a functioning state */\n\t\tstate = eeh_wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);\n\t\tif (state < 0) {\n\t\t\tpr_warn(\"EEH: Unrecoverable slot failure on PHB#%x-PE#%x\",\n\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\tret = -ENOTRECOVERABLE;\n\t\t\tbreak;\n\t\t}\n\t\tif (eeh_state_active(state))\n\t\t\tbreak;\n\t\telse\n\t\t\tpr_warn(\"EEH: PHB#%x-PE#%x: Slot inactive after reset: 0x%x (attempt %d)\\n\",\n\t\t\t\tpe->phb->global_number, pe->addr, state, i + 1);\n\t}\n\n\t/* Resetting the PE may have unfrozen child PEs. If those PEs have been\n\t * (potentially) passed through to a guest, re-freeze them:\n\t */\n\tif (!include_passed)\n\t\teeh_pe_refreeze_passed(pe);\n\n\teeh_pe_state_clear(pe, reset_state, true);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "515-522",
          "snippet": "void eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *root, int state)\n{\n\tstruct eeh_pe *pe;\n\n\teeh_for_each_pe(root, pe)\n\t\tif (!(pe->state & EEH_PE_REMOVED))\n\t\t\tpe->state |= state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nint eeh_pe_reset_and_recover(struct eeh_pe *pe)\n{\n\tint ret;\n\n\t/* Bail if the PE is being recovered */\n\tif (pe->state & EEH_PE_RECOVERING)\n\t\treturn 0;\n\n\t/* Put the PE into recovery mode */\n\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\n\t/* Save states */\n\teeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\n\n\t/* Issue reset */\n\tret = eeh_pe_reset_full(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Unfreeze the PE */\n\tret = eeh_clear_pe_frozen_state(pe, true);\n\tif (ret) {\n\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\t\treturn ret;\n\t}\n\n\t/* Restore device state */\n\teeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\n\n\t/* Clear recovery mode */\n\teeh_pe_state_clear(pe, EEH_PE_RECOVERING, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_clear_pe_frozen_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "558-574",
    "snippet": "static int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "root",
            "EEH_PE_ISOLATED",
            "include_passed"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "581-618",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *root, int state, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\teeh_for_each_pe(root, pe) {\n\t\t/* Keep the state of permanently removed PE intact */\n\t\tif (pe->state & EEH_PE_REMOVED)\n\t\t\tcontinue;\n\n\t\tif (!include_passed && eeh_pe_passed(pe))\n\t\t\tcontinue;\n\n\t\tpe->state &= ~state;\n\n\t\t/*\n\t\t * Special treatment on clearing isolated state. Clear\n\t\t * check count since last isolation and put all affected\n\t\t * devices to normal state.\n\t\t */\n\t\tif (!(state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tpe->check_count = 0;\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\t\tif (!pdev)\n\t\t\t\tcontinue;\n\n\t\t\tpdev->error_state = pci_channel_io_normal;\n\t\t}\n\n\t\t/* Unblock PCI config access if required */\n\t\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_unfreeze_pe",
          "args": [
            "pe"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_unfreeze_pe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1131-1150",
          "snippet": "int eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pte-walk.h>",
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pte-walk.h>\n#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n\nint eeh_unfreeze_pe(struct eeh_pe *pe)\n{\n\tint ret;\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling IO on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\tret = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\n\tif (ret) {\n\t\tpr_warn(\"%s: Failure %d enabling DMA on PHB#%x-PE#%x\\n\",\n\t\t\t__func__, ret, pe->phb->global_number, pe->addr);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "pe"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *root, bool include_passed)\n{\n\tstruct eeh_pe *pe;\n\tint i;\n\n\teeh_for_each_pe(root, pe) {\n\t\tif (include_passed || !eeh_pe_passed(pe)) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tif (!eeh_unfreeze_pe(pe))\n\t\t\t\t\tbreak;\n\t\t\tif (i >= 3)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\teeh_pe_state_clear(root, EEH_PE_ISOLATED, include_passed);\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_detach_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "536-549",
    "snippet": "static void *eeh_pe_detach_dev(struct eeh_pe *pe, void *userdata)\n{\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tif (!(edev->mode & EEH_DEV_DISCONNECTED))\n\t\t\tcontinue;\n\n\t\tedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\n\t\teeh_pe_tree_remove(edev);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_tree_remove",
          "args": [
            "edev"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "402-478",
          "snippet": "int eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_pe_tree_remove(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tbool keep, recover;\n\tint cnt;\n\n\tpe = eeh_dev_to_pe(edev);\n\tif (!pe) {\n\t\teeh_edev_dbg(edev, \"No PE found for device.\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tedev->pe = NULL;\n\tlist_del(&edev->entry);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\n\t\t/* PHB PEs should never be removed */\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * XXX: KEEP is set while resetting a PE. I don't think it's\n\t\t * ever set without RECOVERING also being set. I could\n\t\t * be wrong though so catch that with a WARN.\n\t\t */\n\t\tkeep = !!(pe->state & EEH_PE_KEEP);\n\t\trecover = !!(pe->state & EEH_PE_RECOVERING);\n\t\tWARN_ON(keep && !recover);\n\n\t\tif (!keep && !recover) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Mark the PE as invalid. At the end of the recovery\n\t\t\t * process any invalid PEs will be garbage collected.\n\t\t\t *\n\t\t\t * We need to delay the free()ing of them since we can\n\t\t\t * remove edev's while traversing the PE tree which\n\t\t\t * might trigger the removal of a PE and we can't\n\t\t\t * deal with that (yet).\n\t\t\t */\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_pe_detach_dev(struct eeh_pe *pe, void *userdata)\n{\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tif (!(edev->mode & EEH_DEV_DISCONNECTED))\n\t\t\tcontinue;\n\n\t\tedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\n\t\teeh_pe_tree_remove(edev);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_rmv_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "485-534",
    "snippet": "static void eeh_rmv_device(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct eeh_rmv_data *rmv_data = (struct eeh_rmv_data *)userdata;\n\n\t/*\n\t * Actually, we should remove the PCI bridges as well.\n\t * However, that's lots of complexity to do that,\n\t * particularly some of devices under the bridge might\n\t * support EEH. So we just care about PCI devices for\n\t * simplicity here.\n\t */\n\tif (!eeh_edev_actionable(edev) ||\n\t    (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE))\n\t\treturn;\n\n\tif (rmv_data) {\n\t\tdriver = eeh_pcid_get(dev);\n\t\tif (driver) {\n\t\t\tif (driver->err_handler &&\n\t\t\t    driver->err_handler->error_detected &&\n\t\t\t    driver->err_handler->slot_reset) {\n\t\t\t\teeh_pcid_put(dev);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\teeh_pcid_put(dev);\n\t\t}\n\t}\n\n\t/* Remove it from PCI subsystem */\n\tpr_info(\"EEH: Removing %s without EEH sensitive driver\\n\",\n\t\tpci_name(dev));\n\tedev->mode |= EEH_DEV_DISCONNECTED;\n\tif (rmv_data)\n\t\trmv_data->removed_dev_count++;\n\n\tif (edev->physfn) {\n#ifdef CONFIG_PCI_IOV\n\t\tpci_iov_remove_virtfn(edev->physfn, edev->vf_index);\n\t\tedev->pdev = NULL;\n#endif\n\t\tif (rmv_data)\n\t\t\tlist_add(&edev->rmv_entry, &rmv_data->removed_vf_list);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_stop_and_remove_bus_device(dev);\n\t\tpci_unlock_rescan_remove();\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_stop_and_remove_bus_device",
          "args": [
            "dev"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&edev->rmv_entry",
            "&rmv_data->removed_vf_list"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_iov_remove_virtfn",
          "args": [
            "edev->physfn",
            "edev->vf_index"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Removing %s without EEH sensitive driver\\n\"",
            "pci_name(dev)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_name",
          "args": [
            "dev"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "123-129",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "105-114",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_actionable",
          "args": [
            "edev"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_edev_actionable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "82-94",
          "snippet": "static bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_rmv_device(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\tstruct eeh_rmv_data *rmv_data = (struct eeh_rmv_data *)userdata;\n\n\t/*\n\t * Actually, we should remove the PCI bridges as well.\n\t * However, that's lots of complexity to do that,\n\t * particularly some of devices under the bridge might\n\t * support EEH. So we just care about PCI devices for\n\t * simplicity here.\n\t */\n\tif (!eeh_edev_actionable(edev) ||\n\t    (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE))\n\t\treturn;\n\n\tif (rmv_data) {\n\t\tdriver = eeh_pcid_get(dev);\n\t\tif (driver) {\n\t\t\tif (driver->err_handler &&\n\t\t\t    driver->err_handler->error_detected &&\n\t\t\t    driver->err_handler->slot_reset) {\n\t\t\t\teeh_pcid_put(dev);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\teeh_pcid_put(dev);\n\t\t}\n\t}\n\n\t/* Remove it from PCI subsystem */\n\tpr_info(\"EEH: Removing %s without EEH sensitive driver\\n\",\n\t\tpci_name(dev));\n\tedev->mode |= EEH_DEV_DISCONNECTED;\n\tif (rmv_data)\n\t\trmv_data->removed_dev_count++;\n\n\tif (edev->physfn) {\n#ifdef CONFIG_PCI_IOV\n\t\tpci_iov_remove_virtfn(edev->physfn, edev->vf_index);\n\t\tedev->pdev = NULL;\n#endif\n\t\tif (rmv_data)\n\t\t\tlist_add(&edev->rmv_entry, &rmv_data->removed_vf_list);\n\t} else {\n\t\tpci_lock_rescan_remove();\n\t\tpci_stop_and_remove_bus_device(dev);\n\t\tpci_unlock_rescan_remove();\n\t}\n}"
  },
  {
    "function_name": "eeh_add_virt_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "460-483",
    "snippet": "static void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_iov_add_virtfn",
          "args": [
            "edev->physfn",
            "edev->vf_index"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "dev"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "123-129",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "dev"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "105-114",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_warn",
          "args": [
            "edev",
            "\"Not for VF\\n\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void *eeh_add_virt_device(struct eeh_dev *edev)\n{\n\tstruct pci_driver *driver;\n\tstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\n\n\tif (!(edev->physfn)) {\n\t\teeh_edev_warn(edev, \"Not for VF\\n\");\n\t\treturn NULL;\n\t}\n\n\tdriver = eeh_pcid_get(dev);\n\tif (driver) {\n\t\tif (driver->err_handler) {\n\t\t\teeh_pcid_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\teeh_pcid_put(dev);\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\tpci_iov_add_virtfn(edev->physfn, edev->vf_index);\n#endif\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_report_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "442-458",
    "snippet": "static enum pci_ers_result eeh_report_failure(struct eeh_dev *edev,\n\t\t\t\t\t      struct pci_dev *pdev,\n\t\t\t\t\t      struct pci_driver *driver)\n{\n\tenum pci_ers_result rc;\n\n\tif (!driver->err_handler->error_detected)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->error_detected(permanent failure)\",\n\t\t      driver->name);\n\trc = driver->err_handler->error_detected(pdev,\n\t\t\t\t\t\t pci_channel_io_perm_failure);\n\n\tpci_uevent_ers(pdev, PCI_ERS_RESULT_DISCONNECT);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_uevent_ers",
          "args": [
            "pdev",
            "PCI_ERS_RESULT_DISCONNECT"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->err_handler->error_detected",
          "args": [
            "pdev",
            "pci_channel_io_perm_failure"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"Invoking %s->error_detected(permanent failure)\"",
            "driver->name"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result eeh_report_failure(struct eeh_dev *edev,\n\t\t\t\t\t      struct pci_dev *pdev,\n\t\t\t\t\t      struct pci_driver *driver)\n{\n\tenum pci_ers_result rc;\n\n\tif (!driver->err_handler->error_detected)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->error_detected(permanent failure)\",\n\t\t      driver->name);\n\trc = driver->err_handler->error_detected(pdev,\n\t\t\t\t\t\t pci_channel_io_perm_failure);\n\n\tpci_uevent_ers(pdev, PCI_ERS_RESULT_DISCONNECT);\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_report_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "416-432",
    "snippet": "static enum pci_ers_result eeh_report_resume(struct eeh_dev *edev,\n\t\t\t\t\t     struct pci_dev *pdev,\n\t\t\t\t\t     struct pci_driver *driver)\n{\n\tif (!driver->err_handler->resume || !edev->in_error)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->resume()\", driver->name);\n\tdriver->err_handler->resume(pdev);\n\n\tpci_uevent_ers(edev->pdev, PCI_ERS_RESULT_RECOVERED);\n#ifdef CONFIG_PCI_IOV\n\tif (eeh_ops->notify_resume)\n\t\teeh_ops->notify_resume(edev);\n#endif\n\treturn PCI_ERS_RESULT_NONE;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->notify_resume",
          "args": [
            "edev"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_uevent_ers",
          "args": [
            "edev->pdev",
            "PCI_ERS_RESULT_RECOVERED"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->err_handler->resume",
          "args": [
            "pdev"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"Invoking %s->resume()\"",
            "driver->name"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result eeh_report_resume(struct eeh_dev *edev,\n\t\t\t\t\t     struct pci_dev *pdev,\n\t\t\t\t\t     struct pci_driver *driver)\n{\n\tif (!driver->err_handler->resume || !edev->in_error)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->resume()\", driver->name);\n\tdriver->err_handler->resume(pdev);\n\n\tpci_uevent_ers(edev->pdev, PCI_ERS_RESULT_RECOVERED);\n#ifdef CONFIG_PCI_IOV\n\tif (eeh_ops->notify_resume)\n\t\teeh_ops->notify_resume(edev);\n#endif\n\treturn PCI_ERS_RESULT_NONE;\n}"
  },
  {
    "function_name": "eeh_dev_restore_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "380-405",
    "snippet": "static void eeh_dev_restore_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn;\n\n\t/*\n\t * The content in the config space isn't saved because\n\t * the blocked config space on some adapters. We have\n\t * to restore the initial saved config space when the\n\t * EEH device is created.\n\t */\n\tif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED)) {\n\t\tif (list_is_last(&edev->entry, &edev->pe->edevs))\n\t\t\teeh_pe_restore_bars(edev->pe);\n\n\t\treturn;\n\t}\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn;\n\n\tpci_restore_state(pdev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_restore_state",
          "args": [
            "pdev"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_restore_bars",
          "args": [
            "edev->pe"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_restore_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "792-799",
          "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&edev->entry",
            "&edev->pe->edevs"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_dev_restore_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn;\n\n\t/*\n\t * The content in the config space isn't saved because\n\t * the blocked config space on some adapters. We have\n\t * to restore the initial saved config space when the\n\t * EEH device is created.\n\t */\n\tif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED)) {\n\t\tif (list_is_last(&edev->entry, &edev->pe->edevs))\n\t\t\teeh_pe_restore_bars(edev->pe);\n\n\t\treturn;\n\t}\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn;\n\n\tpci_restore_state(pdev);\n}"
  },
  {
    "function_name": "eeh_report_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "370-378",
    "snippet": "static enum pci_ers_result eeh_report_reset(struct eeh_dev *edev,\n\t\t\t\t\t    struct pci_dev *pdev,\n\t\t\t\t\t    struct pci_driver *driver)\n{\n\tif (!driver->err_handler->slot_reset || !edev->in_error)\n\t\treturn PCI_ERS_RESULT_NONE;\n\teeh_edev_info(edev, \"Invoking %s->slot_reset()\", driver->name);\n\treturn driver->err_handler->slot_reset(pdev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->err_handler->slot_reset",
          "args": [
            "pdev"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"Invoking %s->slot_reset()\"",
            "driver->name"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result eeh_report_reset(struct eeh_dev *edev,\n\t\t\t\t\t    struct pci_dev *pdev,\n\t\t\t\t\t    struct pci_driver *driver)\n{\n\tif (!driver->err_handler->slot_reset || !edev->in_error)\n\t\treturn PCI_ERS_RESULT_NONE;\n\teeh_edev_info(edev, \"Invoking %s->slot_reset()\", driver->name);\n\treturn driver->err_handler->slot_reset(pdev);\n}"
  },
  {
    "function_name": "eeh_report_mmio_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "350-358",
    "snippet": "static enum pci_ers_result eeh_report_mmio_enabled(struct eeh_dev *edev,\n\t\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t\t   struct pci_driver *driver)\n{\n\tif (!driver->err_handler->mmio_enabled)\n\t\treturn PCI_ERS_RESULT_NONE;\n\teeh_edev_info(edev, \"Invoking %s->mmio_enabled()\", driver->name);\n\treturn driver->err_handler->mmio_enabled(pdev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->err_handler->mmio_enabled",
          "args": [
            "pdev"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"Invoking %s->mmio_enabled()\"",
            "driver->name"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result eeh_report_mmio_enabled(struct eeh_dev *edev,\n\t\t\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t\t\t   struct pci_driver *driver)\n{\n\tif (!driver->err_handler->mmio_enabled)\n\t\treturn PCI_ERS_RESULT_NONE;\n\teeh_edev_info(edev, \"Invoking %s->mmio_enabled()\", driver->name);\n\treturn driver->err_handler->mmio_enabled(pdev);\n}"
  },
  {
    "function_name": "eeh_report_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "324-340",
    "snippet": "static enum pci_ers_result eeh_report_error(struct eeh_dev *edev,\n\t\t\t\t\t    struct pci_dev *pdev,\n\t\t\t\t\t    struct pci_driver *driver)\n{\n\tenum pci_ers_result rc;\n\n\tif (!driver->err_handler->error_detected)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->error_detected(IO frozen)\",\n\t\t      driver->name);\n\trc = driver->err_handler->error_detected(pdev, pci_channel_io_frozen);\n\n\tedev->in_error = true;\n\tpci_uevent_ers(pdev, PCI_ERS_RESULT_NONE);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_uevent_ers",
          "args": [
            "pdev",
            "PCI_ERS_RESULT_NONE"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->err_handler->error_detected",
          "args": [
            "pdev",
            "pci_channel_io_frozen"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"Invoking %s->error_detected(IO frozen)\"",
            "driver->name"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result eeh_report_error(struct eeh_dev *edev,\n\t\t\t\t\t    struct pci_dev *pdev,\n\t\t\t\t\t    struct pci_driver *driver)\n{\n\tenum pci_ers_result rc;\n\n\tif (!driver->err_handler->error_detected)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\teeh_edev_info(edev, \"Invoking %s->error_detected(IO frozen)\",\n\t\t      driver->name);\n\trc = driver->err_handler->error_detected(pdev, pci_channel_io_frozen);\n\n\tedev->in_error = true;\n\tpci_uevent_ers(pdev, PCI_ERS_RESULT_NONE);\n\treturn rc;\n}"
  },
  {
    "function_name": "eeh_pe_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "301-315",
    "snippet": "static void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Finished:'%s'\"",
            "name"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\"",
            "name",
            "pci_ers_result_name(*result)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_ers_result_name",
          "args": [
            "*result"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "pci_ers_result_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "48-67",
          "snippet": "static const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_report_edev",
          "args": [
            "edev",
            "fn",
            "result"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_report_edev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "254-299",
          "snippet": "static void eeh_pe_report_edev(struct eeh_dev *edev, eeh_report_fn fn,\n\t\t\t       enum pci_ers_result *result)\n{\n\tstruct pci_dev *pdev;\n\tstruct pci_driver *driver;\n\tenum pci_ers_result new_result;\n\n\tpci_lock_rescan_remove();\n\tpdev = edev->pdev;\n\tif (pdev)\n\t\tget_device(&pdev->dev);\n\tpci_unlock_rescan_remove();\n\tif (!pdev) {\n\t\teeh_edev_info(edev, \"no device\");\n\t\treturn;\n\t}\n\tdevice_lock(&pdev->dev);\n\tif (eeh_edev_actionable(edev)) {\n\t\tdriver = eeh_pcid_get(pdev);\n\n\t\tif (!driver)\n\t\t\teeh_edev_info(edev, \"no driver\");\n\t\telse if (!driver->err_handler)\n\t\t\teeh_edev_info(edev, \"driver not EEH aware\");\n\t\telse if (edev->mode & EEH_DEV_NO_HANDLER)\n\t\t\teeh_edev_info(edev, \"driver bound too late\");\n\t\telse {\n\t\t\tnew_result = fn(edev, pdev, driver);\n\t\t\teeh_edev_info(edev, \"%s driver reports: '%s'\",\n\t\t\t\t      driver->name,\n\t\t\t\t      pci_ers_result_name(new_result));\n\t\t\tif (result)\n\t\t\t\t*result = pci_ers_merge_result(*result,\n\t\t\t\t\t\t\t       new_result);\n\t\t}\n\t\tif (driver)\n\t\t\teeh_pcid_put(pdev);\n\t} else {\n\t\teeh_edev_info(edev, \"not actionable (%d,%d,%d)\", !!pdev,\n\t\t\t      !eeh_dev_removed(edev), !eeh_pe_passed(edev->pe));\n\t}\n\tdevice_unlock(&pdev->dev);\n\tif (edev->pdev != pdev)\n\t\teeh_edev_warn(edev, \"Device changed during processing!\\n\");\n\tput_device(&pdev->dev);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_report_edev(struct eeh_dev *edev, eeh_report_fn fn,\n\t\t\t       enum pci_ers_result *result)\n{\n\tstruct pci_dev *pdev;\n\tstruct pci_driver *driver;\n\tenum pci_ers_result new_result;\n\n\tpci_lock_rescan_remove();\n\tpdev = edev->pdev;\n\tif (pdev)\n\t\tget_device(&pdev->dev);\n\tpci_unlock_rescan_remove();\n\tif (!pdev) {\n\t\teeh_edev_info(edev, \"no device\");\n\t\treturn;\n\t}\n\tdevice_lock(&pdev->dev);\n\tif (eeh_edev_actionable(edev)) {\n\t\tdriver = eeh_pcid_get(pdev);\n\n\t\tif (!driver)\n\t\t\teeh_edev_info(edev, \"no driver\");\n\t\telse if (!driver->err_handler)\n\t\t\teeh_edev_info(edev, \"driver not EEH aware\");\n\t\telse if (edev->mode & EEH_DEV_NO_HANDLER)\n\t\t\teeh_edev_info(edev, \"driver bound too late\");\n\t\telse {\n\t\t\tnew_result = fn(edev, pdev, driver);\n\t\t\teeh_edev_info(edev, \"%s driver reports: '%s'\",\n\t\t\t\t      driver->name,\n\t\t\t\t      pci_ers_result_name(new_result));\n\t\t\tif (result)\n\t\t\t\t*result = pci_ers_merge_result(*result,\n\t\t\t\t\t\t\t       new_result);\n\t\t}\n\t\tif (driver)\n\t\t\teeh_pcid_put(pdev);\n\t} else {\n\t\teeh_edev_info(edev, \"not actionable (%d,%d,%d)\", !!pdev,\n\t\t\t      !eeh_dev_removed(edev), !eeh_pe_passed(edev->pe));\n\t}\n\tdevice_unlock(&pdev->dev);\n\tif (edev->pdev != pdev)\n\t\teeh_edev_warn(edev, \"Device changed during processing!\\n\");\n\tput_device(&pdev->dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Beginning: '%s'\\n\"",
            "name"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_report(const char *name, struct eeh_pe *root,\n\t\t\t  eeh_report_fn fn, enum pci_ers_result *result)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\tpr_info(\"EEH: Beginning: '%s'\\n\", name);\n\teeh_for_each_pe(root, pe) eeh_pe_for_each_dev(pe, edev, tmp)\n\t\teeh_pe_report_edev(edev, fn, result);\n\tif (result)\n\t\tpr_info(\"EEH: Finished:'%s' with aggregate recovery state:'%s'\\n\",\n\t\t\tname, pci_ers_result_name(*result));\n\telse\n\t\tpr_info(\"EEH: Finished:'%s'\", name);\n}"
  },
  {
    "function_name": "eeh_pe_report_edev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "254-299",
    "snippet": "static void eeh_pe_report_edev(struct eeh_dev *edev, eeh_report_fn fn,\n\t\t\t       enum pci_ers_result *result)\n{\n\tstruct pci_dev *pdev;\n\tstruct pci_driver *driver;\n\tenum pci_ers_result new_result;\n\n\tpci_lock_rescan_remove();\n\tpdev = edev->pdev;\n\tif (pdev)\n\t\tget_device(&pdev->dev);\n\tpci_unlock_rescan_remove();\n\tif (!pdev) {\n\t\teeh_edev_info(edev, \"no device\");\n\t\treturn;\n\t}\n\tdevice_lock(&pdev->dev);\n\tif (eeh_edev_actionable(edev)) {\n\t\tdriver = eeh_pcid_get(pdev);\n\n\t\tif (!driver)\n\t\t\teeh_edev_info(edev, \"no driver\");\n\t\telse if (!driver->err_handler)\n\t\t\teeh_edev_info(edev, \"driver not EEH aware\");\n\t\telse if (edev->mode & EEH_DEV_NO_HANDLER)\n\t\t\teeh_edev_info(edev, \"driver bound too late\");\n\t\telse {\n\t\t\tnew_result = fn(edev, pdev, driver);\n\t\t\teeh_edev_info(edev, \"%s driver reports: '%s'\",\n\t\t\t\t      driver->name,\n\t\t\t\t      pci_ers_result_name(new_result));\n\t\t\tif (result)\n\t\t\t\t*result = pci_ers_merge_result(*result,\n\t\t\t\t\t\t\t       new_result);\n\t\t}\n\t\tif (driver)\n\t\t\teeh_pcid_put(pdev);\n\t} else {\n\t\teeh_edev_info(edev, \"not actionable (%d,%d,%d)\", !!pdev,\n\t\t\t      !eeh_dev_removed(edev), !eeh_pe_passed(edev->pe));\n\t}\n\tdevice_unlock(&pdev->dev);\n\tif (edev->pdev != pdev)\n\t\teeh_edev_warn(edev, \"Device changed during processing!\\n\");\n\tput_device(&pdev->dev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "&pdev->dev"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_warn",
          "args": [
            "edev",
            "\"Device changed during processing!\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_unlock",
          "args": [
            "&pdev->dev"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"not actionable (%d,%d,%d)\"",
            "!!pdev",
            "!eeh_dev_removed(edev)",
            "!eeh_pe_passed(edev->pe)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "edev->pe"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "77-80",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "pdev"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "123-129",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_ers_merge_result",
          "args": [
            "*result",
            "new_result"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "pci_ers_merge_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "69-75",
          "snippet": "static enum pci_ers_result pci_ers_merge_result(enum pci_ers_result old,\n\t\t\t\t\t\tenum pci_ers_result new)\n{\n\tif (eeh_result_priority(new) > eeh_result_priority(old))\n\t\treturn new;\n\treturn old;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result pci_ers_merge_result(enum pci_ers_result old,\n\t\t\t\t\t\tenum pci_ers_result new)\n{\n\tif (eeh_result_priority(new) > eeh_result_priority(old))\n\t\treturn new;\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"%s driver reports: '%s'\"",
            "driver->name",
            "pci_ers_result_name(new_result)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_ers_result_name",
          "args": [
            "new_result"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "pci_ers_result_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "48-67",
          "snippet": "static const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "edev",
            "pdev",
            "driver"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "pci_iobar_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "522-535",
          "snippet": "int pci_iobar_pfn(struct pci_dev *pdev, int bar, struct vm_area_struct *vma)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\tresource_size_t ioaddr = pci_resource_start(pdev, bar);\n\n\tif (!hose)\n\t\treturn -EINVAL;\n\n\t/* Convert to an offset within this PCI controller */\n\tioaddr -= (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\tvma->vm_pgoff += (ioaddr + hose->io_base_phys) >> PAGE_SHIFT;\n\treturn 0;\n}",
          "includes": [
            "#include \"../../../drivers/pci/pci.h\"",
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/numa.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../../drivers/pci/pci.h\"\n#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/numa.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/shmem_fs.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pci_iobar_pfn(struct pci_dev *pdev, int bar, struct vm_area_struct *vma)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\n\tresource_size_t ioaddr = pci_resource_start(pdev, bar);\n\n\tif (!hose)\n\t\treturn -EINVAL;\n\n\t/* Convert to an offset within this PCI controller */\n\tioaddr -= (unsigned long)hose->io_base_virt - _IO_BASE;\n\n\tvma->vm_pgoff += (ioaddr + hose->io_base_phys) >> PAGE_SHIFT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"driver bound too late\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"driver not EEH aware\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"no driver\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "pdev"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "105-114",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_actionable",
          "args": [
            "edev"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_edev_actionable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "82-94",
          "snippet": "static bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_lock",
          "args": [
            "&pdev->dev"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_edev_info",
          "args": [
            "edev",
            "\"no device\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_unlock_rescan_remove",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "&pdev->dev"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__eeh_addr_cache_get_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_cache.c",
          "lines": "54-71",
          "snippet": "static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/debugfs.h>\n#include <asm/pci-bridge.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n\nstatic struct pci_io_addr_cache {\n\tstruct rb_root rb_root;\n\tspinlock_t piar_lock;\n} pci_io_addr_cache_root;\n\nstatic inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\n{\n\tstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\n\n\twhile (n) {\n\t\tstruct pci_io_addr_range *piar;\n\t\tpiar = rb_entry(n, struct pci_io_addr_range, rb_node);\n\n\t\tif (addr < piar->addr_lo)\n\t\t\tn = n->rb_left;\n\t\telse if (addr > piar->addr_hi)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn piar->edev;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_lock_rescan_remove",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_pe_report_edev(struct eeh_dev *edev, eeh_report_fn fn,\n\t\t\t       enum pci_ers_result *result)\n{\n\tstruct pci_dev *pdev;\n\tstruct pci_driver *driver;\n\tenum pci_ers_result new_result;\n\n\tpci_lock_rescan_remove();\n\tpdev = edev->pdev;\n\tif (pdev)\n\t\tget_device(&pdev->dev);\n\tpci_unlock_rescan_remove();\n\tif (!pdev) {\n\t\teeh_edev_info(edev, \"no device\");\n\t\treturn;\n\t}\n\tdevice_lock(&pdev->dev);\n\tif (eeh_edev_actionable(edev)) {\n\t\tdriver = eeh_pcid_get(pdev);\n\n\t\tif (!driver)\n\t\t\teeh_edev_info(edev, \"no driver\");\n\t\telse if (!driver->err_handler)\n\t\t\teeh_edev_info(edev, \"driver not EEH aware\");\n\t\telse if (edev->mode & EEH_DEV_NO_HANDLER)\n\t\t\teeh_edev_info(edev, \"driver bound too late\");\n\t\telse {\n\t\t\tnew_result = fn(edev, pdev, driver);\n\t\t\teeh_edev_info(edev, \"%s driver reports: '%s'\",\n\t\t\t\t      driver->name,\n\t\t\t\t      pci_ers_result_name(new_result));\n\t\t\tif (result)\n\t\t\t\t*result = pci_ers_merge_result(*result,\n\t\t\t\t\t\t\t       new_result);\n\t\t}\n\t\tif (driver)\n\t\t\teeh_pcid_put(pdev);\n\t} else {\n\t\teeh_edev_info(edev, \"not actionable (%d,%d,%d)\", !!pdev,\n\t\t\t      !eeh_dev_removed(edev), !eeh_pe_passed(edev->pe));\n\t}\n\tdevice_unlock(&pdev->dev);\n\tif (edev->pdev != pdev)\n\t\teeh_edev_warn(edev, \"Device changed during processing!\\n\");\n\tput_device(&pdev->dev);\n}"
  },
  {
    "function_name": "eeh_set_irq_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "228-249",
    "snippet": "static void eeh_set_irq_state(struct eeh_pe *root, bool enable)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tif (!eeh_edev_actionable(edev))\n\t\t\t\tcontinue;\n\n\t\t\tif (!eeh_pcid_get(edev->pdev))\n\t\t\t\tcontinue;\n\n\t\t\tif (enable)\n\t\t\t\teeh_enable_irq(edev);\n\t\t\telse\n\t\t\t\teeh_disable_irq(edev);\n\n\t\t\teeh_pcid_put(edev->pdev);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pcid_put",
          "args": [
            "edev->pdev"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "123-129",
          "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_disable_irq",
          "args": [
            "edev"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_disable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "141-155",
          "snippet": "static void eeh_disable_irq(struct eeh_dev *edev)\n{\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (edev->pdev->msi_enabled || edev->pdev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(edev->pdev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(edev->pdev->irq);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_irq(struct eeh_dev *edev)\n{\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (edev->pdev->msi_enabled || edev->pdev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(edev->pdev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(edev->pdev->irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_enable_irq",
          "args": [
            "edev"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_enable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "164-191",
          "snippet": "static void eeh_enable_irq(struct eeh_dev *edev)\n{\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their asymmetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(edev->pdev->irq)))\n\t\t\tenable_irq(edev->pdev->irq);\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_enable_irq(struct eeh_dev *edev)\n{\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their asymmetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(edev->pdev->irq)))\n\t\t\tenable_irq(edev->pdev->irq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pcid_get",
          "args": [
            "edev->pdev"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pcid_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "105-114",
          "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_edev_actionable",
          "args": [
            "edev"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_edev_actionable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "82-94",
          "snippet": "static bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_irq_state(struct eeh_pe *root, bool enable)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tif (!eeh_edev_actionable(edev))\n\t\t\t\tcontinue;\n\n\t\t\tif (!eeh_pcid_get(edev->pdev))\n\t\t\t\tcontinue;\n\n\t\t\tif (enable)\n\t\t\t\teeh_enable_irq(edev);\n\t\t\telse\n\t\t\t\teeh_disable_irq(edev);\n\n\t\t\teeh_pcid_put(edev->pdev);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_set_channel_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "217-226",
    "snippet": "static void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_edev_actionable",
          "args": [
            "edev"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_edev_actionable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "82-94",
          "snippet": "static bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_for_each_pe",
          "args": [
            "root",
            "pe"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_set_channel_state(struct eeh_pe *root, pci_channel_state_t s)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\n\teeh_for_each_pe(root, pe)\n\t\teeh_pe_for_each_dev(pe, edev, tmp)\n\t\t\tif (eeh_edev_actionable(edev))\n\t\t\t\tedev->pdev->error_state = s;\n}"
  },
  {
    "function_name": "eeh_dev_save_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "193-215",
    "snippet": "static void eeh_dev_save_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn;\n\n\t/*\n\t * We cannot access the config space on some adapters.\n\t * Otherwise, it will cause fenced PHB. We don't save\n\t * the content in their config space and will restore\n\t * from the initial config space saved when the EEH\n\t * device is created.\n\t */\n\tif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED))\n\t\treturn;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn;\n\n\tpci_save_state(pdev);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_save_state",
          "args": [
            "pdev"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_dev_save_state(struct eeh_dev *edev, void *userdata)\n{\n\tstruct pci_dev *pdev;\n\n\tif (!edev)\n\t\treturn;\n\n\t/*\n\t * We cannot access the config space on some adapters.\n\t * Otherwise, it will cause fenced PHB. We don't save\n\t * the content in their config space and will restore\n\t * from the initial config space saved when the EEH\n\t * device is created.\n\t */\n\tif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED))\n\t\treturn;\n\n\tpdev = eeh_dev_to_pci_dev(edev);\n\tif (!pdev)\n\t\treturn;\n\n\tpci_save_state(pdev);\n}"
  },
  {
    "function_name": "eeh_enable_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "164-191",
    "snippet": "static void eeh_enable_irq(struct eeh_dev *edev)\n{\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their asymmetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(edev->pdev->irq)))\n\t\t\tenable_irq(edev->pdev->irq);\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_irq",
          "args": [
            "edev->pdev->irq"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_enable_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "164-191",
          "snippet": "static void eeh_enable_irq(struct eeh_dev *edev)\n{\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their asymmetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(edev->pdev->irq)))\n\t\t\tenable_irq(edev->pdev->irq);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "irq_get_irq_data(edev->pdev->irq)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "edev->pdev->irq"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_enable_irq(struct eeh_dev *edev)\n{\n\tif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\n\t\tedev->mode &= ~EEH_DEV_IRQ_DISABLED;\n\t\t/*\n\t\t * FIXME !!!!!\n\t\t *\n\t\t * This is just ass backwards. This maze has\n\t\t * unbalanced irq_enable/disable calls. So instead of\n\t\t * finding the root cause it works around the warning\n\t\t * in the irq_enable code by conditionally calling\n\t\t * into it.\n\t\t *\n\t\t * That's just wrong.The warning in the core code is\n\t\t * there to tell people to fix their asymmetries in\n\t\t * their own code, not by abusing the core information\n\t\t * to avoid it.\n\t\t *\n\t\t * I so wish that the assymetry would be the other way\n\t\t * round and a few more irq_disable calls render that\n\t\t * shit unusable forever.\n\t\t *\n\t\t *\ttglx\n\t\t */\n\t\tif (irqd_irq_disabled(irq_get_irq_data(edev->pdev->irq)))\n\t\t\tenable_irq(edev->pdev->irq);\n\t}\n}"
  },
  {
    "function_name": "eeh_disable_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "141-155",
    "snippet": "static void eeh_disable_irq(struct eeh_dev *edev)\n{\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (edev->pdev->msi_enabled || edev->pdev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(edev->pdev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(edev->pdev->irq);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_irq_nosync",
          "args": [
            "edev->pdev->irq"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_has_action",
          "args": [
            "edev->pdev->irq"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic void eeh_disable_irq(struct eeh_dev *edev)\n{\n\t/* Don't disable MSI and MSI-X interrupts. They are\n\t * effectively disabled by the DMA Stopped state\n\t * when an EEH error occurs.\n\t */\n\tif (edev->pdev->msi_enabled || edev->pdev->msix_enabled)\n\t\treturn;\n\n\tif (!irq_has_action(edev->pdev->irq))\n\t\treturn;\n\n\tedev->mode |= EEH_DEV_IRQ_DISABLED;\n\tdisable_irq_nosync(edev->pdev->irq);\n}"
  },
  {
    "function_name": "eeh_pcid_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "123-129",
    "snippet": "static inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "pdev->driver->driver.owner"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn;\n\n\tmodule_put(pdev->driver->driver.owner);\n}"
  },
  {
    "function_name": "eeh_pcid_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "105-114",
    "snippet": "static inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "pdev->driver->driver.owner"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\n{\n\tif (!pdev || !pdev->driver)\n\t\treturn NULL;\n\n\tif (!try_module_get(pdev->driver->driver.owner))\n\t\treturn NULL;\n\n\treturn pdev->driver;\n}"
  },
  {
    "function_name": "eeh_edev_actionable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "82-94",
    "snippet": "static bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_passed",
          "args": [
            "edev->pe"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_removed",
          "args": [
            "edev"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "77-80",
          "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_edev_actionable(struct eeh_dev *edev)\n{\n\tif (!edev->pdev)\n\t\treturn false;\n\tif (edev->pdev->error_state == pci_channel_io_perm_failure)\n\t\treturn false;\n\tif (eeh_dev_removed(edev))\n\t\treturn false;\n\tif (eeh_pe_passed(edev->pe))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "eeh_dev_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "77-80",
    "snippet": "static bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\n{\n\treturn !edev || (edev->mode & EEH_DEV_REMOVED);\n}"
  },
  {
    "function_name": "pci_ers_merge_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "69-75",
    "snippet": "static enum pci_ers_result pci_ers_merge_result(enum pci_ers_result old,\n\t\t\t\t\t\tenum pci_ers_result new)\n{\n\tif (eeh_result_priority(new) > eeh_result_priority(old))\n\t\treturn new;\n\treturn old;\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_result_priority",
          "args": [
            "old"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_result_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "27-46",
          "snippet": "static int eeh_result_priority(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn 1;\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn 2;\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn 3;\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn 4;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn 5;\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn 6;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown pci_ers_result value: %d\\n\", (int)result);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci_hotplug.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_result_priority(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn 1;\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn 2;\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn 3;\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn 4;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn 5;\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn 6;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown pci_ers_result value: %d\\n\", (int)result);\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic enum pci_ers_result pci_ers_merge_result(enum pci_ers_result old,\n\t\t\t\t\t\tenum pci_ers_result new)\n{\n\tif (eeh_result_priority(new) > eeh_result_priority(old))\n\t\treturn new;\n\treturn old;\n}"
  },
  {
    "function_name": "pci_ers_result_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "48-67",
    "snippet": "static const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Unknown result type: %d\\n\"",
            "(int)result"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic const char *pci_ers_result_name(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn \"none\";\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn \"can recover\";\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn \"need reset\";\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn \"disconnect\";\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn \"recovered\";\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn \"no AER driver\";\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown result type: %d\\n\", (int)result);\n\t\treturn \"unknown\";\n\t}\n}"
  },
  {
    "function_name": "eeh_result_priority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/eeh_driver.c",
    "lines": "27-46",
    "snippet": "static int eeh_result_priority(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn 1;\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn 2;\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn 3;\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn 4;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn 5;\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn 6;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown pci_ers_result value: %d\\n\", (int)result);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <asm/eeh.h>",
      "#include <linux/pci_hotplug.h>",
      "#include <linux/pci.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Unknown pci_ers_result value: %d\\n\"",
            "(int)result"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci_hotplug.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nstatic int eeh_result_priority(enum pci_ers_result result)\n{\n\tswitch (result) {\n\tcase PCI_ERS_RESULT_NONE:\n\t\treturn 1;\n\tcase PCI_ERS_RESULT_NO_AER_DRIVER:\n\t\treturn 2;\n\tcase PCI_ERS_RESULT_RECOVERED:\n\t\treturn 3;\n\tcase PCI_ERS_RESULT_CAN_RECOVER:\n\t\treturn 4;\n\tcase PCI_ERS_RESULT_DISCONNECT:\n\t\treturn 5;\n\tcase PCI_ERS_RESULT_NEED_RESET:\n\t\treturn 6;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unknown pci_ers_result value: %d\\n\", (int)result);\n\t\treturn 0;\n\t}\n}"
  }
]