[
  {
    "function_name": "ptrace_triggered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "767-781",
    "snippet": "void ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint",
          "args": [
            "bp",
            "&attr"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}"
  },
  {
    "function_name": "hw_breakpoint_pmu_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "762-765",
    "snippet": "void hw_breakpoint_pmu_read(struct perf_event *bp)\n{\n\t/* TODO */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid hw_breakpoint_pmu_read(struct perf_event *bp)\n{\n\t/* TODO */\n}"
  },
  {
    "function_name": "flush_ptrace_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "751-760",
    "snippet": "void flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tint i;\n\tstruct thread_struct *t = &tsk->thread;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tunregister_hw_breakpoint(t->ptrace_bps[i]);\n\t\tt->ptrace_bps[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "t->ptrace_bps[i]"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "352-368",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tint i;\n\tstruct thread_struct *t = &tsk->thread;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tunregister_hw_breakpoint(t->ptrace_bps[i]);\n\t\tt->ptrace_bps[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "hw_breakpoint_exceptions_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "730-745",
    "snippet": "int hw_breakpoint_exceptions_notify(\n\t\tstruct notifier_block *unused, unsigned long val, void *data)\n{\n\tint ret = NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_DABR_MATCH:\n\t\tret = hw_breakpoint_handler(data);\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tret = single_step_dabr_instruction(data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_step_dabr_instruction",
          "args": [
            "data"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "single_step_dabr_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "673-724",
          "snippet": "static int single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\tbool found = false;\n\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = current->thread.last_hit_ubp[i];\n\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tinfo = counter_arch_bp(bp);\n\n\t\t/*\n\t\t * We shall invoke the user-defined callback function in the\n\t\t * single stepping handler to confirm to 'trigger-after-execute'\n\t\t * semantics\n\t\t */\n\t\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp, regs);\n\t\tcurrent->thread.last_hit_ubp[i] = NULL;\n\t}\n\n\tif (!found)\n\t\treturn NOTIFY_DONE;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tinfo = counter_arch_bp(bp);\n\t\t__set_breakpoint(i, info);\n\t}\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nstatic int single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\tbool found = false;\n\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = current->thread.last_hit_ubp[i];\n\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tinfo = counter_arch_bp(bp);\n\n\t\t/*\n\t\t * We shall invoke the user-defined callback function in the\n\t\t * single stepping handler to confirm to 'trigger-after-execute'\n\t\t * semantics\n\t\t */\n\t\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp, regs);\n\t\tcurrent->thread.last_hit_ubp[i] = NULL;\n\t}\n\n\tif (!found)\n\t\treturn NOTIFY_DONE;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tinfo = counter_arch_bp(bp);\n\t\t__set_breakpoint(i, info);\n\t}\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_handler",
          "args": [
            "data"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "552-667",
          "snippet": "int hw_breakpoint_handler(struct die_args *args)\n{\n\tbool err = false;\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp[HBP_NUM_MAX] = { NULL };\n\tstruct pt_regs *regs = args->regs;\n\tstruct arch_hw_breakpoint *info[HBP_NUM_MAX] = { NULL };\n\tint i;\n\tint hit[HBP_NUM_MAX] = {0};\n\tint nr_hit = 0;\n\tbool ptrace_bp = false;\n\tstruct ppc_inst instr = ppc_inst(0);\n\tint type = 0;\n\tint size = 0;\n\tunsigned long ea;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx))\n\t\twp_get_instr_detail(regs, &instr, &type, &size, &ea);\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp[i] = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp[i])\n\t\t\tcontinue;\n\n\t\tinfo[i] = counter_arch_bp(bp[i]);\n\t\tinfo[i]->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t\tif (wp_check_constraints(regs, instr, ea, type, size, info[i])) {\n\t\t\tif (!IS_ENABLED(CONFIG_PPC_8xx) &&\n\t\t\t    ppc_inst_equal(instr, ppc_inst(0))) {\n\t\t\t\thandler_error(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t\terr = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ptrace_bp(bp[i]))\n\t\t\t\tptrace_bp = true;\n\t\t\thit[i] = 1;\n\t\t\tnr_hit++;\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto reset;\n\n\tif (!nr_hit) {\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (ptrace_bp) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tperf_bp_event(bp[i], regs);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\trc = NOTIFY_DONE;\n\t\tgoto reset;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (is_larx_stcx_instr(type)) {\n\t\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\t\tif (!hit[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tlarx_stcx_err(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t}\n\t\t\tgoto reset;\n\t\t}\n\n\t\tif (!stepping_handler(regs, bp, info, hit, instr))\n\t\t\tgoto reset;\n\t}\n\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!hit[i])\n\t\t\tcontinue;\n\t\tif (!(info[i]->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp[i], regs);\n\t}\n\nreset:\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!info[i])\n\t\t\tcontinue;\n\t\t__set_breakpoint(i, info[i]);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nint hw_breakpoint_handler(struct die_args *args)\n{\n\tbool err = false;\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp[HBP_NUM_MAX] = { NULL };\n\tstruct pt_regs *regs = args->regs;\n\tstruct arch_hw_breakpoint *info[HBP_NUM_MAX] = { NULL };\n\tint i;\n\tint hit[HBP_NUM_MAX] = {0};\n\tint nr_hit = 0;\n\tbool ptrace_bp = false;\n\tstruct ppc_inst instr = ppc_inst(0);\n\tint type = 0;\n\tint size = 0;\n\tunsigned long ea;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx))\n\t\twp_get_instr_detail(regs, &instr, &type, &size, &ea);\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp[i] = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp[i])\n\t\t\tcontinue;\n\n\t\tinfo[i] = counter_arch_bp(bp[i]);\n\t\tinfo[i]->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t\tif (wp_check_constraints(regs, instr, ea, type, size, info[i])) {\n\t\t\tif (!IS_ENABLED(CONFIG_PPC_8xx) &&\n\t\t\t    ppc_inst_equal(instr, ppc_inst(0))) {\n\t\t\t\thandler_error(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t\terr = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ptrace_bp(bp[i]))\n\t\t\t\tptrace_bp = true;\n\t\t\thit[i] = 1;\n\t\t\tnr_hit++;\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto reset;\n\n\tif (!nr_hit) {\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (ptrace_bp) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tperf_bp_event(bp[i], regs);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\trc = NOTIFY_DONE;\n\t\tgoto reset;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (is_larx_stcx_instr(type)) {\n\t\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\t\tif (!hit[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tlarx_stcx_err(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t}\n\t\t\tgoto reset;\n\t\t}\n\n\t\tif (!stepping_handler(regs, bp, info, hit, instr))\n\t\t\tgoto reset;\n\t}\n\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!hit[i])\n\t\t\tcontinue;\n\t\tif (!(info[i]->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp[i], regs);\n\t}\n\nreset:\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!info[i])\n\t\t\tcontinue;\n\t\t__set_breakpoint(i, info[i]);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint hw_breakpoint_exceptions_notify(\n\t\tstruct notifier_block *unused, unsigned long val, void *data)\n{\n\tint ret = NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_DABR_MATCH:\n\t\tret = hw_breakpoint_handler(data);\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tret = single_step_dabr_instruction(data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "single_step_dabr_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "673-724",
    "snippet": "static int single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\tbool found = false;\n\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = current->thread.last_hit_ubp[i];\n\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tinfo = counter_arch_bp(bp);\n\n\t\t/*\n\t\t * We shall invoke the user-defined callback function in the\n\t\t * single stepping handler to confirm to 'trigger-after-execute'\n\t\t * semantics\n\t\t */\n\t\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp, regs);\n\t\tcurrent->thread.last_hit_ubp[i] = NULL;\n\t}\n\n\tif (!found)\n\t\treturn NOTIFY_DONE;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tinfo = counter_arch_bp(bp);\n\t\t__set_breakpoint(i, info);\n\t}\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "info"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bp_per_reg[i]"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp",
            "regs"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nstatic int single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\tbool found = false;\n\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = current->thread.last_hit_ubp[i];\n\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tfound = true;\n\t\tinfo = counter_arch_bp(bp);\n\n\t\t/*\n\t\t * We shall invoke the user-defined callback function in the\n\t\t * single stepping handler to confirm to 'trigger-after-execute'\n\t\t * semantics\n\t\t */\n\t\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp, regs);\n\t\tcurrent->thread.last_hit_ubp[i] = NULL;\n\t}\n\n\tif (!found)\n\t\treturn NOTIFY_DONE;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp)\n\t\t\tcontinue;\n\n\t\tinfo = counter_arch_bp(bp);\n\t\t__set_breakpoint(i, info);\n\t}\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}"
  },
  {
    "function_name": "hw_breakpoint_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "552-667",
    "snippet": "int hw_breakpoint_handler(struct die_args *args)\n{\n\tbool err = false;\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp[HBP_NUM_MAX] = { NULL };\n\tstruct pt_regs *regs = args->regs;\n\tstruct arch_hw_breakpoint *info[HBP_NUM_MAX] = { NULL };\n\tint i;\n\tint hit[HBP_NUM_MAX] = {0};\n\tint nr_hit = 0;\n\tbool ptrace_bp = false;\n\tstruct ppc_inst instr = ppc_inst(0);\n\tint type = 0;\n\tint size = 0;\n\tunsigned long ea;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx))\n\t\twp_get_instr_detail(regs, &instr, &type, &size, &ea);\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp[i] = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp[i])\n\t\t\tcontinue;\n\n\t\tinfo[i] = counter_arch_bp(bp[i]);\n\t\tinfo[i]->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t\tif (wp_check_constraints(regs, instr, ea, type, size, info[i])) {\n\t\t\tif (!IS_ENABLED(CONFIG_PPC_8xx) &&\n\t\t\t    ppc_inst_equal(instr, ppc_inst(0))) {\n\t\t\t\thandler_error(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t\terr = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ptrace_bp(bp[i]))\n\t\t\t\tptrace_bp = true;\n\t\t\thit[i] = 1;\n\t\t\tnr_hit++;\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto reset;\n\n\tif (!nr_hit) {\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (ptrace_bp) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tperf_bp_event(bp[i], regs);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\trc = NOTIFY_DONE;\n\t\tgoto reset;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (is_larx_stcx_instr(type)) {\n\t\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\t\tif (!hit[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tlarx_stcx_err(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t}\n\t\t\tgoto reset;\n\t\t}\n\n\t\tif (!stepping_handler(regs, bp, info, hit, instr))\n\t\t\tgoto reset;\n\t}\n\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!hit[i])\n\t\t\tcontinue;\n\t\tif (!(info[i]->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp[i], regs);\n\t}\n\nreset:\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!info[i])\n\t\t\tcontinue;\n\t\t__set_breakpoint(i, info[i]);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "info[i]"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp[i]",
            "regs"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stepping_handler",
          "args": [
            "regs",
            "bp",
            "info",
            "hit",
            "instr"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "stepping_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "520-550",
          "snippet": "static bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,\n\t\t\t     struct arch_hw_breakpoint **info, int *hit,\n\t\t\t     struct ppc_inst instr)\n{\n\tint i;\n\tint stepped;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tcurrent->thread.last_hit_ubp[i] = bp[i];\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\tregs->msr |= MSR_SE;\n\t\treturn false;\n\t}\n\n\tstepped = emulate_step(regs, instr);\n\tif (!stepped) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\thandler_error(bp[i], info[i]);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,\n\t\t\t     struct arch_hw_breakpoint **info, int *hit,\n\t\t\t     struct ppc_inst instr)\n{\n\tint i;\n\tint stepped;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tcurrent->thread.last_hit_ubp[i] = bp[i];\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\tregs->msr |= MSR_SE;\n\t\treturn false;\n\t}\n\n\tstepped = emulate_step(regs, instr);\n\tif (!stepped) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\thandler_error(bp[i], info[i]);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "larx_stcx_err",
          "args": [
            "bp[i]",
            "info[i]"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "larx_stcx_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "513-518",
          "snippet": "static void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tprintk_ratelimited(\"Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\\n\",\n\t\t\t   info->address);\n\tperf_event_disable_inatomic(bp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tprintk_ratelimited(\"Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\\n\",\n\t\t\t   info->address);\n\tperf_event_disable_inatomic(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_larx_stcx_instr",
          "args": [
            "type"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "is_larx_stcx_instr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "497-500",
          "snippet": "static bool is_larx_stcx_instr(int type)\n{\n\treturn type == LARX || type == STCX;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_larx_stcx_instr(int type)\n{\n\treturn type == LARX || type == STCX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_8xx"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp[i]",
            "regs"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ptrace_bp",
          "args": [
            "bp[i]"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "is_ptrace_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "122-125",
          "snippet": "static bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler_error",
          "args": [
            "bp[i]",
            "info[i]"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "handler_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "506-511",
          "snippet": "static void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "instr",
            "ppc_inst(0)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "0"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_8xx"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wp_check_constraints",
          "args": [
            "regs",
            "instr",
            "ea",
            "type",
            "size",
            "info[i]"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "wp_check_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "83-128",
          "snippet": "bool wp_check_constraints(struct pt_regs *regs, struct ppc_inst instr,\n\t\t\t  unsigned long ea, int type, int size,\n\t\t\t  struct arch_hw_breakpoint *info)\n{\n\tbool in_user_range = dar_in_user_range(regs->dar, info);\n\tbool dawrx_constraints;\n\n\t/*\n\t * 8xx supports only one breakpoint and thus we can\n\t * unconditionally return true.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (!in_user_range)\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\treturn true;\n\t}\n\n\tif (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tdawrx_constraints = check_dawrx_constraints(regs, type, info);\n\n\tif (type == UNKNOWN) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn dawrx_constraints;\n\t}\n\n\tif (ea_user_range_overlaps(ea, size, info))\n\t\treturn dawrx_constraints;\n\n\tif (ea_hw_range_overlaps(ea, size, info)) {\n\t\tif (dawrx_constraints) {\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nbool wp_check_constraints(struct pt_regs *regs, struct ppc_inst instr,\n\t\t\t  unsigned long ea, int type, int size,\n\t\t\t  struct arch_hw_breakpoint *info)\n{\n\tbool in_user_range = dar_in_user_range(regs->dar, info);\n\tbool dawrx_constraints;\n\n\t/*\n\t * 8xx supports only one breakpoint and thus we can\n\t * unconditionally return true.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (!in_user_range)\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\treturn true;\n\t}\n\n\tif (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tdawrx_constraints = check_dawrx_constraints(regs, type, info);\n\n\tif (type == UNKNOWN) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn dawrx_constraints;\n\t}\n\n\tif (ea_user_range_overlaps(ea, size, info))\n\t\treturn dawrx_constraints;\n\n\tif (ea_hw_range_overlaps(ea, size, info)) {\n\t\tif (dawrx_constraints) {\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp[i]"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bp_per_reg[i]"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wp_get_instr_detail",
          "args": [
            "regs",
            "&instr",
            "&type",
            "&size",
            "&ea"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "wp_get_instr_detail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "139-162",
          "snippet": "void wp_get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,\n\t\t\t int *type, int *size, unsigned long *ea)\n{\n\tstruct instruction_op op;\n\n\tif (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))\n\t\treturn;\n\n\tanalyse_instr(&op, regs, *instr);\n\t*type = GETTYPE(op.type);\n\t*ea = op.ea;\n#ifdef __powerpc64__\n\tif (!(regs->msr & MSR_64BIT))\n\t\t*ea &= 0xffffffffUL;\n#endif\n\n\t*size = GETSIZE(op.type);\n\tif (*type == CACHEOP) {\n\t\t*size = cache_op_size();\n\t\t*ea &= ~(*size - 1);\n\t} else if (*type == LOAD_VMX || *type == STORE_VMX) {\n\t\t*ea &= ~(*size - 1);\n\t}\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nvoid wp_get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,\n\t\t\t int *type, int *size, unsigned long *ea)\n{\n\tstruct instruction_op op;\n\n\tif (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))\n\t\treturn;\n\n\tanalyse_instr(&op, regs, *instr);\n\t*type = GETTYPE(op.type);\n\t*ea = op.ea;\n#ifdef __powerpc64__\n\tif (!(regs->msr & MSR_64BIT))\n\t\t*ea &= 0xffffffffUL;\n#endif\n\n\t*size = GETSIZE(op.type);\n\tif (*type == CACHEOP) {\n\t\t*size = cache_op_size();\n\t\t*ea &= ~(*size - 1);\n\t} else if (*type == LOAD_VMX || *type == STORE_VMX) {\n\t\t*ea &= ~(*size - 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_8xx"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nint hw_breakpoint_handler(struct die_args *args)\n{\n\tbool err = false;\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp[HBP_NUM_MAX] = { NULL };\n\tstruct pt_regs *regs = args->regs;\n\tstruct arch_hw_breakpoint *info[HBP_NUM_MAX] = { NULL };\n\tint i;\n\tint hit[HBP_NUM_MAX] = {0};\n\tint nr_hit = 0;\n\tbool ptrace_bp = false;\n\tstruct ppc_inst instr = ppc_inst(0);\n\tint type = 0;\n\tint size = 0;\n\tunsigned long ea;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx))\n\t\twp_get_instr_detail(regs, &instr, &type, &size, &ea);\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tbp[i] = __this_cpu_read(bp_per_reg[i]);\n\t\tif (!bp[i])\n\t\t\tcontinue;\n\n\t\tinfo[i] = counter_arch_bp(bp[i]);\n\t\tinfo[i]->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t\tif (wp_check_constraints(regs, instr, ea, type, size, info[i])) {\n\t\t\tif (!IS_ENABLED(CONFIG_PPC_8xx) &&\n\t\t\t    ppc_inst_equal(instr, ppc_inst(0))) {\n\t\t\t\thandler_error(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t\terr = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ptrace_bp(bp[i]))\n\t\t\t\tptrace_bp = true;\n\t\t\thit[i] = 1;\n\t\t\tnr_hit++;\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto reset;\n\n\tif (!nr_hit) {\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (ptrace_bp) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tperf_bp_event(bp[i], regs);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\trc = NOTIFY_DONE;\n\t\tgoto reset;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (is_larx_stcx_instr(type)) {\n\t\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\t\tif (!hit[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tlarx_stcx_err(bp[i], info[i]);\n\t\t\t\tinfo[i] = NULL;\n\t\t\t}\n\t\t\tgoto reset;\n\t\t}\n\n\t\tif (!stepping_handler(regs, bp, info, hit, instr))\n\t\t\tgoto reset;\n\t}\n\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!hit[i])\n\t\t\tcontinue;\n\t\tif (!(info[i]->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\t\tperf_bp_event(bp[i], regs);\n\t}\n\nreset:\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!info[i])\n\t\t\tcontinue;\n\t\t__set_breakpoint(i, info[i]);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}"
  },
  {
    "function_name": "stepping_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "520-550",
    "snippet": "static bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,\n\t\t\t     struct arch_hw_breakpoint **info, int *hit,\n\t\t\t     struct ppc_inst instr)\n{\n\tint i;\n\tint stepped;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tcurrent->thread.last_hit_ubp[i] = bp[i];\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\tregs->msr |= MSR_SE;\n\t\treturn false;\n\t}\n\n\tstepped = emulate_step(regs, instr);\n\tif (!stepped) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\thandler_error(bp[i], info[i]);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler_error",
          "args": [
            "bp[i]",
            "info[i]"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "handler_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "506-511",
          "snippet": "static void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_step",
          "args": [
            "regs",
            "instr"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool stepping_handler(struct pt_regs *regs, struct perf_event **bp,\n\t\t\t     struct arch_hw_breakpoint **info, int *hit,\n\t\t\t     struct ppc_inst instr)\n{\n\tint i;\n\tint stepped;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\tcurrent->thread.last_hit_ubp[i] = bp[i];\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\tregs->msr |= MSR_SE;\n\t\treturn false;\n\t}\n\n\tstepped = emulate_step(regs, instr);\n\tif (!stepped) {\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (!hit[i])\n\t\t\t\tcontinue;\n\t\t\thandler_error(bp[i], info[i]);\n\t\t\tinfo[i] = NULL;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "larx_stcx_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "513-518",
    "snippet": "static void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tprintk_ratelimited(\"Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\\n\",\n\t\t\t   info->address);\n\tperf_event_disable_inatomic(bp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_disable_inatomic",
          "args": [
            "bp"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "\"Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\\n\"",
            "info->address"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic void larx_stcx_err(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tprintk_ratelimited(\"Breakpoint hit on instruction that can't be emulated. Breakpoint at 0x%lx will be disabled.\\n\",\n\t\t\t   info->address);\n\tperf_event_disable_inatomic(bp);\n}"
  },
  {
    "function_name": "handler_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "506-511",
    "snippet": "static void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_disable_inatomic",
          "args": [
            "bp"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\"",
            "info->address"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic void handler_error(struct perf_event *bp, struct arch_hw_breakpoint *info)\n{\n\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at 0x%lx will be disabled.\",\n\t     info->address);\n\tperf_event_disable_inatomic(bp);\n}"
  },
  {
    "function_name": "is_larx_stcx_instr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "497-500",
    "snippet": "static bool is_larx_stcx_instr(int type)\n{\n\treturn type == LARX || type == STCX;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_larx_stcx_instr(int type)\n{\n\treturn type == LARX || type == STCX;\n}"
  },
  {
    "function_name": "thread_change_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "477-495",
    "snippet": "void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (unlikely(tsk->thread.last_hit_ubp[i]))\n\t\t\tgoto reset;\n\t}\n\treturn;\n\nreset:\n\tregs->msr &= ~MSR_SE;\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tinfo = counter_arch_bp(__this_cpu_read(bp_per_reg[i]));\n\t\t__set_breakpoint(i, info);\n\t\ttsk->thread.last_hit_ubp[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "info"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "__this_cpu_read(bp_per_reg[i])"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bp_per_reg[i]"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->thread.last_hit_ubp[i]"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nvoid thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (unlikely(tsk->thread.last_hit_ubp[i]))\n\t\t\tgoto reset;\n\t}\n\treturn;\n\nreset:\n\tregs->msr &= ~MSR_SE;\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tinfo = counter_arch_bp(__this_cpu_read(bp_per_reg[i]));\n\t\t__set_breakpoint(i, info);\n\t\ttsk->thread.last_hit_ubp[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "hw_breakpoint_arch_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "440-470",
    "snippet": "int hw_breakpoint_arch_parse(struct perf_event *bp,\n\t\t\t     const struct perf_event_attr *attr,\n\t\t\t     struct arch_hw_breakpoint *hw)\n{\n\tint ret = -EINVAL;\n\n\tif (!bp || !attr->bp_len)\n\t\treturn ret;\n\n\thw->type = HW_BRK_TYPE_TRANSLATE;\n\tif (attr->bp_type & HW_BREAKPOINT_R)\n\t\thw->type |= HW_BRK_TYPE_READ;\n\tif (attr->bp_type & HW_BREAKPOINT_W)\n\t\thw->type |= HW_BRK_TYPE_WRITE;\n\tif (hw->type == HW_BRK_TYPE_TRANSLATE)\n\t\t/* must set alteast read or write */\n\t\treturn ret;\n\tif (!attr->exclude_user)\n\t\thw->type |= HW_BRK_TYPE_USER;\n\tif (!attr->exclude_kernel)\n\t\thw->type |= HW_BRK_TYPE_KERNEL;\n\tif (!attr->exclude_hv)\n\t\thw->type |= HW_BRK_TYPE_HYP;\n\thw->address = attr->bp_addr;\n\thw->len = attr->bp_len;\n\n\tif (!ppc_breakpoint_available())\n\t\treturn -ENODEV;\n\n\treturn hw_breakpoint_validate_len(hw);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_validate_len",
          "args": [
            "hw"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_validate_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "409-435",
          "snippet": "static int hw_breakpoint_validate_len(struct arch_hw_breakpoint *hw)\n{\n\tu16 max_len = DABR_MAX_LEN;\n\tu16 hw_len;\n\tunsigned long start_addr, end_addr;\n\n\tstart_addr = ALIGN_DOWN(hw->address, HW_BREAKPOINT_SIZE);\n\tend_addr = ALIGN(hw->address + hw->len, HW_BREAKPOINT_SIZE);\n\thw_len = end_addr - start_addr;\n\n\tif (dawr_enabled()) {\n\t\tmax_len = DAWR_MAX_LEN;\n\t\t/* DAWR region can't cross 512 bytes boundary on p10 predecessors */\n\t\tif (!cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    (ALIGN_DOWN(start_addr, SZ_512) != ALIGN_DOWN(end_addr - 1, SZ_512)))\n\t\t\treturn -EINVAL;\n\t} else if (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\t/* 8xx can setup a range without limitation */\n\t\tmax_len = U16_MAX;\n\t}\n\n\tif (hw_len > max_len)\n\t\treturn -EINVAL;\n\n\thw->hw_len = hw_len;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic int hw_breakpoint_validate_len(struct arch_hw_breakpoint *hw)\n{\n\tu16 max_len = DABR_MAX_LEN;\n\tu16 hw_len;\n\tunsigned long start_addr, end_addr;\n\n\tstart_addr = ALIGN_DOWN(hw->address, HW_BREAKPOINT_SIZE);\n\tend_addr = ALIGN(hw->address + hw->len, HW_BREAKPOINT_SIZE);\n\thw_len = end_addr - start_addr;\n\n\tif (dawr_enabled()) {\n\t\tmax_len = DAWR_MAX_LEN;\n\t\t/* DAWR region can't cross 512 bytes boundary on p10 predecessors */\n\t\tif (!cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    (ALIGN_DOWN(start_addr, SZ_512) != ALIGN_DOWN(end_addr - 1, SZ_512)))\n\t\t\treturn -EINVAL;\n\t} else if (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\t/* 8xx can setup a range without limitation */\n\t\tmax_len = U16_MAX;\n\t}\n\n\tif (hw_len > max_len)\n\t\treturn -EINVAL;\n\n\thw->hw_len = hw_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_breakpoint_available",
          "args": [],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_breakpoint_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "897-905",
          "snippet": "bool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nbool ppc_breakpoint_available(void)\n{\n\tif (dawr_enabled())\n\t\treturn true; /* POWER8 DAWR or POWER9 forced DAWR */\n\tif (cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn false; /* POWER9 with DAWR disabled */\n\t/* DABR: Everything but POWER8 and POWER9 */\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint hw_breakpoint_arch_parse(struct perf_event *bp,\n\t\t\t     const struct perf_event_attr *attr,\n\t\t\t     struct arch_hw_breakpoint *hw)\n{\n\tint ret = -EINVAL;\n\n\tif (!bp || !attr->bp_len)\n\t\treturn ret;\n\n\thw->type = HW_BRK_TYPE_TRANSLATE;\n\tif (attr->bp_type & HW_BREAKPOINT_R)\n\t\thw->type |= HW_BRK_TYPE_READ;\n\tif (attr->bp_type & HW_BREAKPOINT_W)\n\t\thw->type |= HW_BRK_TYPE_WRITE;\n\tif (hw->type == HW_BRK_TYPE_TRANSLATE)\n\t\t/* must set alteast read or write */\n\t\treturn ret;\n\tif (!attr->exclude_user)\n\t\thw->type |= HW_BRK_TYPE_USER;\n\tif (!attr->exclude_kernel)\n\t\thw->type |= HW_BRK_TYPE_KERNEL;\n\tif (!attr->exclude_hv)\n\t\thw->type |= HW_BRK_TYPE_HYP;\n\thw->address = attr->bp_addr;\n\thw->len = attr->bp_len;\n\n\tif (!ppc_breakpoint_available())\n\t\treturn -ENODEV;\n\n\treturn hw_breakpoint_validate_len(hw);\n}"
  },
  {
    "function_name": "hw_breakpoint_validate_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "409-435",
    "snippet": "static int hw_breakpoint_validate_len(struct arch_hw_breakpoint *hw)\n{\n\tu16 max_len = DABR_MAX_LEN;\n\tu16 hw_len;\n\tunsigned long start_addr, end_addr;\n\n\tstart_addr = ALIGN_DOWN(hw->address, HW_BREAKPOINT_SIZE);\n\tend_addr = ALIGN(hw->address + hw->len, HW_BREAKPOINT_SIZE);\n\thw_len = end_addr - start_addr;\n\n\tif (dawr_enabled()) {\n\t\tmax_len = DAWR_MAX_LEN;\n\t\t/* DAWR region can't cross 512 bytes boundary on p10 predecessors */\n\t\tif (!cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    (ALIGN_DOWN(start_addr, SZ_512) != ALIGN_DOWN(end_addr - 1, SZ_512)))\n\t\t\treturn -EINVAL;\n\t} else if (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\t/* 8xx can setup a range without limitation */\n\t\tmax_len = U16_MAX;\n\t}\n\n\tif (hw_len > max_len)\n\t\treturn -EINVAL;\n\n\thw->hw_len = hw_len;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_8xx"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "end_addr - 1",
            "SZ_512"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "start_addr",
            "SZ_512"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_31"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dawr_enabled",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "hw->address + hw->len",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "hw->address",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic int hw_breakpoint_validate_len(struct arch_hw_breakpoint *hw)\n{\n\tu16 max_len = DABR_MAX_LEN;\n\tu16 hw_len;\n\tunsigned long start_addr, end_addr;\n\n\tstart_addr = ALIGN_DOWN(hw->address, HW_BREAKPOINT_SIZE);\n\tend_addr = ALIGN(hw->address + hw->len, HW_BREAKPOINT_SIZE);\n\thw_len = end_addr - start_addr;\n\n\tif (dawr_enabled()) {\n\t\tmax_len = DAWR_MAX_LEN;\n\t\t/* DAWR region can't cross 512 bytes boundary on p10 predecessors */\n\t\tif (!cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    (ALIGN_DOWN(start_addr, SZ_512) != ALIGN_DOWN(end_addr - 1, SZ_512)))\n\t\t\treturn -EINVAL;\n\t} else if (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\t/* 8xx can setup a range without limitation */\n\t\tmax_len = U16_MAX;\n\t}\n\n\tif (hw_len > max_len)\n\t\treturn -EINVAL;\n\n\thw->hw_len = hw_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_bp_generic_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "378-388",
    "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_check_bp_in_kernelspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "373-376",
    "snippet": "int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw)\n{\n\treturn is_kernel_addr(hw->address);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "hw->address"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw)\n{\n\treturn is_kernel_addr(hw->address);\n}"
  },
  {
    "function_name": "arch_unregister_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "352-368",
    "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t * FIXME, this should not be using bp->ctx at all! Sayeth peterz.\n\t */\n\tif (bp->ctx && bp->ctx->task && bp->ctx->task != ((void *)-1L)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\t\tif (bp->ctx->task->thread.last_hit_ubp[i] == bp)\n\t\t\t\tbp->ctx->task->thread.last_hit_ubp[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "arch_release_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "338-346",
    "snippet": "void arch_release_bp_slot(struct perf_event *bp)\n{\n\tif (!is_kernel_addr(bp->attr.bp_addr)) {\n\t\tif (bp->hw.target)\n\t\t\ttask_bps_remove(bp);\n\t\tif (bp->cpu != -1)\n\t\t\tcpu_bps_remove(bp);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_bps_remove",
          "args": [
            "bp"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bps_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "248-264",
          "snippet": "static void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_bps_remove",
          "args": [
            "bp"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "task_bps_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "182-195",
          "snippet": "static void task_bps_remove(struct perf_event *bp)\n{\n\tstruct list_head *pos, *q;\n\n\tlist_for_each_safe(pos, q, &task_bps) {\n\t\tstruct breakpoint *tmp = list_entry(pos, struct breakpoint, list);\n\n\t\tif (tmp->bp == bp) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(task_bps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic void task_bps_remove(struct perf_event *bp)\n{\n\tstruct list_head *pos, *q;\n\n\tlist_for_each_safe(pos, q, &task_bps) {\n\t\tstruct breakpoint *tmp = list_entry(pos, struct breakpoint, list);\n\n\t\tif (tmp->bp == bp) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "bp->attr.bp_addr"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_release_bp_slot(struct perf_event *bp)\n{\n\tif (!is_kernel_addr(bp->attr.bp_addr)) {\n\t\tif (bp->hw.target)\n\t\t\ttask_bps_remove(bp);\n\t\tif (bp->cpu != -1)\n\t\t\tcpu_bps_remove(bp);\n\t}\n}"
  },
  {
    "function_name": "arch_reserve_bp_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "294-336",
    "snippet": "int arch_reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\t/* ptrace breakpoint */\n\tif (is_ptrace_bp(bp)) {\n\t\tif (all_cpu_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\tif (same_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn task_bps_add(bp);\n\t}\n\n\t/* perf breakpoint */\n\tif (is_kernel_addr(bp->attr.bp_addr))\n\t\treturn 0;\n\n\tif (bp->hw.target && bp->cpu == -1) {\n\t\tif (same_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn task_bps_add(bp);\n\t} else if (!bp->hw.target && bp->cpu != -1) {\n\t\tif (all_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn cpu_bps_add(bp);\n\t}\n\n\tif (same_task_bps_check(bp))\n\t\treturn -ENOSPC;\n\n\tret = cpu_bps_add(bp);\n\tif (ret)\n\t\treturn ret;\n\tret = task_bps_add(bp);\n\tif (ret)\n\t\tcpu_bps_remove(bp);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_bps_remove",
          "args": [
            "bp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bps_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "248-264",
          "snippet": "static void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_bps_add",
          "args": [
            "bp"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "task_bps_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "170-180",
          "snippet": "static int task_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tlist_add(&tmp->list, &task_bps);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(task_bps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic int task_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tlist_add(&tmp->list, &task_bps);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_bps_add",
          "args": [
            "bp"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bps_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "228-246",
          "snippet": "static int cpu_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tstruct breakpoint *tmp;\n\tint i = 0;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i]) {\n\t\t\tcpu_bp[i] = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic int cpu_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tstruct breakpoint *tmp;\n\tint i = 0;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i]) {\n\t\t\tcpu_bp[i] = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_task_bps_check",
          "args": [
            "bp"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "same_task_bps_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "216-226",
          "snippet": "static bool same_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (tmp->bp->hw.target == bp->hw.target &&\n\t\t    !can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(task_bps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic bool same_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (tmp->bp->hw.target == bp->hw.target &&\n\t\t    !can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_task_bps_check",
          "args": [
            "bp"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "all_task_bps_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "201-210",
          "snippet": "static bool all_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (!can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(task_bps);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic bool all_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (!can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "bp->attr.bp_addr"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_cpu_bps_check",
          "args": [
            "bp"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "all_cpu_bps_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "279-288",
          "snippet": "static bool all_cpu_bps_check(struct perf_event *bp)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu_bps_check(cpu, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool all_cpu_bps_check(struct perf_event *bp)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu_bps_check(cpu, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ptrace_bp",
          "args": [
            "bp"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "is_ptrace_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "122-125",
          "snippet": "static bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\t/* ptrace breakpoint */\n\tif (is_ptrace_bp(bp)) {\n\t\tif (all_cpu_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\tif (same_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn task_bps_add(bp);\n\t}\n\n\t/* perf breakpoint */\n\tif (is_kernel_addr(bp->attr.bp_addr))\n\t\treturn 0;\n\n\tif (bp->hw.target && bp->cpu == -1) {\n\t\tif (same_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn task_bps_add(bp);\n\t} else if (!bp->hw.target && bp->cpu != -1) {\n\t\tif (all_task_bps_check(bp))\n\t\t\treturn -ENOSPC;\n\n\t\treturn cpu_bps_add(bp);\n\t}\n\n\tif (same_task_bps_check(bp))\n\t\treturn -ENOSPC;\n\n\tret = cpu_bps_add(bp);\n\tif (ret)\n\t\treturn ret;\n\tret = task_bps_add(bp);\n\tif (ret)\n\t\tcpu_bps_remove(bp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "all_cpu_bps_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "279-288",
    "snippet": "static bool all_cpu_bps_check(struct perf_event *bp)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu_bps_check(cpu, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_bps_check",
          "args": [
            "cpu",
            "bp"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bps_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "266-277",
          "snippet": "static bool cpu_bps_check(int cpu, struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (cpu_bp[i] && !can_co_exist(cpu_bp[i], bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic bool cpu_bps_check(int cpu, struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (cpu_bp[i] && !can_co_exist(cpu_bp[i], bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool all_cpu_bps_check(struct perf_event *bp)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (cpu_bps_check(cpu, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "cpu_bps_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "266-277",
    "snippet": "static bool cpu_bps_check(int cpu, struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (cpu_bp[i] && !can_co_exist(cpu_bp[i], bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "can_co_exist",
          "args": [
            "cpu_bp[i]",
            "bp"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "can_co_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "165-168",
          "snippet": "static bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cpu_bps",
            "cpu"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic bool cpu_bps_check(int cpu, struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (cpu_bp[i] && !can_co_exist(cpu_bp[i], bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "cpu_bps_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "248-264",
    "snippet": "static void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cpu_bp[i]"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cpu_bps",
            "bp->cpu"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic void cpu_bps_remove(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tint i = 0;\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i])\n\t\t\tcontinue;\n\n\t\tif (cpu_bp[i]->bp == bp) {\n\t\t\tkfree(cpu_bp[i]);\n\t\t\tcpu_bp[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cpu_bps_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "228-246",
    "snippet": "static int cpu_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tstruct breakpoint *tmp;\n\tint i = 0;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i]) {\n\t\t\tcpu_bp[i] = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cpu_bps",
            "bp->cpu"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_breakpoint",
          "args": [
            "bp"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "136-146",
          "snippet": "static struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct breakpoint *, cpu_bps[HBP_NUM_MAX]);\n\nstatic int cpu_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint **cpu_bp;\n\tstruct breakpoint *tmp;\n\tint i = 0;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tcpu_bp = per_cpu_ptr(cpu_bps, bp->cpu);\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (!cpu_bp[i]) {\n\t\t\tcpu_bp[i] = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "same_task_bps_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "216-226",
    "snippet": "static bool same_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (tmp->bp->hw.target == bp->hw.target &&\n\t\t    !can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(task_bps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "can_co_exist",
          "args": [
            "tmp",
            "bp"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "can_co_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "165-168",
          "snippet": "static bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&task_bps",
            "list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic bool same_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (tmp->bp->hw.target == bp->hw.target &&\n\t\t    !can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "all_task_bps_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "201-210",
    "snippet": "static bool all_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (!can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(task_bps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "can_co_exist",
          "args": [
            "tmp",
            "bp"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "can_co_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "165-168",
          "snippet": "static bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&task_bps",
            "list"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic bool all_task_bps_check(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\tlist_for_each_entry(tmp, &task_bps, list) {\n\t\tif (!can_co_exist(tmp, bp))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "task_bps_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "182-195",
    "snippet": "static void task_bps_remove(struct perf_event *bp)\n{\n\tstruct list_head *pos, *q;\n\n\tlist_for_each_safe(pos, q, &task_bps) {\n\t\tstruct breakpoint *tmp = list_entry(pos, struct breakpoint, list);\n\n\t\tif (tmp->bp == bp) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(task_bps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tmp->list"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structbreakpoint",
            "list"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "&task_bps"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic void task_bps_remove(struct perf_event *bp)\n{\n\tstruct list_head *pos, *q;\n\n\tlist_for_each_safe(pos, q, &task_bps) {\n\t\tstruct breakpoint *tmp = list_entry(pos, struct breakpoint, list);\n\n\t\tif (tmp->bp == bp) {\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "task_bps_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "170-180",
    "snippet": "static int task_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tlist_add(&tmp->list, &task_bps);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(task_bps);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tmp->list",
            "&task_bps"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_breakpoint",
          "args": [
            "bp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "136-146",
          "snippet": "static struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic LIST_HEAD(task_bps);\n\nstatic int task_bps_add(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = alloc_breakpoint(bp);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tlist_add(&tmp->list, &task_bps);\n\treturn 0;\n}"
  },
  {
    "function_name": "can_co_exist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "165-168",
    "snippet": "static bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bp_addr_range_overlap",
          "args": [
            "b->bp",
            "bp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "bp_addr_range_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "148-158",
          "snippet": "static bool bp_addr_range_overlap(struct perf_event *bp1, struct perf_event *bp2)\n{\n\t__u64 bp1_saddr, bp1_eaddr, bp2_saddr, bp2_eaddr;\n\n\tbp1_saddr = ALIGN_DOWN(bp1->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp1_eaddr = ALIGN(bp1->attr.bp_addr + bp1->attr.bp_len, HW_BREAKPOINT_SIZE);\n\tbp2_saddr = ALIGN_DOWN(bp2->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp2_eaddr = ALIGN(bp2->attr.bp_addr + bp2->attr.bp_len, HW_BREAKPOINT_SIZE);\n\n\treturn (bp1_saddr < bp2_eaddr && bp1_eaddr > bp2_saddr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool bp_addr_range_overlap(struct perf_event *bp1, struct perf_event *bp2)\n{\n\t__u64 bp1_saddr, bp1_eaddr, bp2_saddr, bp2_eaddr;\n\n\tbp1_saddr = ALIGN_DOWN(bp1->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp1_eaddr = ALIGN(bp1->attr.bp_addr + bp1->attr.bp_len, HW_BREAKPOINT_SIZE);\n\tbp2_saddr = ALIGN_DOWN(bp2->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp2_eaddr = ALIGN(bp2->attr.bp_addr + bp2->attr.bp_len, HW_BREAKPOINT_SIZE);\n\n\treturn (bp1_saddr < bp2_eaddr && bp1_eaddr > bp2_saddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alternate_infra_bp",
          "args": [
            "b",
            "bp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "alternate_infra_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "160-163",
          "snippet": "static bool alternate_infra_bp(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn is_ptrace_bp(bp) ? !b->ptrace_bp : b->ptrace_bp;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool alternate_infra_bp(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn is_ptrace_bp(bp) ? !b->ptrace_bp : b->ptrace_bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool can_co_exist(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn !(alternate_infra_bp(b, bp) && bp_addr_range_overlap(b->bp, bp));\n}"
  },
  {
    "function_name": "alternate_infra_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "160-163",
    "snippet": "static bool alternate_infra_bp(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn is_ptrace_bp(bp) ? !b->ptrace_bp : b->ptrace_bp;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_ptrace_bp",
          "args": [
            "bp"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "is_ptrace_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "122-125",
          "snippet": "static bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool alternate_infra_bp(struct breakpoint *b, struct perf_event *bp)\n{\n\treturn is_ptrace_bp(bp) ? !b->ptrace_bp : b->ptrace_bp;\n}"
  },
  {
    "function_name": "bp_addr_range_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "148-158",
    "snippet": "static bool bp_addr_range_overlap(struct perf_event *bp1, struct perf_event *bp2)\n{\n\t__u64 bp1_saddr, bp1_eaddr, bp2_saddr, bp2_eaddr;\n\n\tbp1_saddr = ALIGN_DOWN(bp1->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp1_eaddr = ALIGN(bp1->attr.bp_addr + bp1->attr.bp_len, HW_BREAKPOINT_SIZE);\n\tbp2_saddr = ALIGN_DOWN(bp2->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp2_eaddr = ALIGN(bp2->attr.bp_addr + bp2->attr.bp_len, HW_BREAKPOINT_SIZE);\n\n\treturn (bp1_saddr < bp2_eaddr && bp1_eaddr > bp2_saddr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bp2->attr.bp_addr + bp2->attr.bp_len",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "bp2->attr.bp_addr",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bp1->attr.bp_addr + bp1->attr.bp_len",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "bp1->attr.bp_addr",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool bp_addr_range_overlap(struct perf_event *bp1, struct perf_event *bp2)\n{\n\t__u64 bp1_saddr, bp1_eaddr, bp2_saddr, bp2_eaddr;\n\n\tbp1_saddr = ALIGN_DOWN(bp1->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp1_eaddr = ALIGN(bp1->attr.bp_addr + bp1->attr.bp_len, HW_BREAKPOINT_SIZE);\n\tbp2_saddr = ALIGN_DOWN(bp2->attr.bp_addr, HW_BREAKPOINT_SIZE);\n\tbp2_eaddr = ALIGN(bp2->attr.bp_addr + bp2->attr.bp_len, HW_BREAKPOINT_SIZE);\n\n\treturn (bp1_saddr < bp2_eaddr && bp1_eaddr > bp2_saddr);\n}"
  },
  {
    "function_name": "alloc_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "136-146",
    "snippet": "static struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_ptrace_bp",
          "args": [
            "bp"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "is_ptrace_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "122-125",
          "snippet": "static bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tmp)",
            "GFP_KERNEL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic struct breakpoint *alloc_breakpoint(struct perf_event *bp)\n{\n\tstruct breakpoint *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttmp->bp = bp;\n\ttmp->ptrace_bp = is_ptrace_bp(bp);\n\treturn tmp;\n}"
  },
  {
    "function_name": "is_ptrace_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "122-125",
    "snippet": "static bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool is_ptrace_bp(struct perf_event *bp)\n{\n\treturn bp->overflow_handler == ptrace_triggered;\n}"
  },
  {
    "function_name": "arch_uninstall_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "102-120",
    "snippet": "void arch_uninstall_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tstruct perf_event **slot;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tslot = this_cpu_ptr(&bp_per_reg[i]);\n\t\tif (*slot == bp) {\n\t\t\t*slot = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == nr_wp_slots(), \"Can't find any breakpoint slot\"))\n\t\treturn;\n\n\t__set_breakpoint(i, &null_brk);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "&null_brk"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "i == nr_wp_slots()",
            "\"Can't find any breakpoint slot\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bp_per_reg[i]"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nvoid arch_uninstall_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint null_brk = {0};\n\tstruct perf_event **slot;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tslot = this_cpu_ptr(&bp_per_reg[i]);\n\t\tif (*slot == bp) {\n\t\t\t*slot = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == nr_wp_slots(), \"Can't find any breakpoint slot\"))\n\t\treturn;\n\n\t__set_breakpoint(i, &null_brk);\n}"
  },
  {
    "function_name": "arch_install_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "66-91",
    "snippet": "int arch_install_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tstruct perf_event **slot;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tslot = this_cpu_ptr(&bp_per_reg[i]);\n\t\tif (!*slot) {\n\t\t\t*slot = bp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == nr_wp_slots(), \"Can't find any breakpoint slot\"))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Do not install DABR values if the instruction must be single-stepped.\n\t * If so, DABR will be populated in single_step_dabr_instruction().\n\t */\n\tif (!single_step_pending())\n\t\t__set_breakpoint(i, info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "i",
            "info"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/process.c",
          "lines": "879-894",
          "snippet": "void __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/exec.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <linux/seq_buf.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/elf-randomize.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/hw_breakpoint.h>\n#include <asm/stacktrace.h>\n#include <asm/asm-prototypes.h>\n#include <asm/cpu_has_feature.h>\n#include <asm/livepatch.h>\n#include <asm/exec.h>\n#include <asm/code-patching.h>\n#include <asm/hw_irq.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <linux/seq_buf.h>\n#include <linux/pkeys.h>\n#include <linux/elf-randomize.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk[HBP_NUM_MAX]);\n\nvoid __set_breakpoint(int nr, struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk[nr]), brk, sizeof(*brk));\n\n\tif (dawr_enabled())\n\t\t// Power8 or later\n\t\tset_dawr(nr, brk);\n\telse if (IS_ENABLED(CONFIG_PPC_8xx))\n\t\tset_breakpoint_8xx(brk);\n\telse if (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\t// Power7 or earlier\n\t\tset_dabr(brk);\n\telse\n\t\t// Shouldn't happen due to higher level checks\n\t\tWARN_ON_ONCE(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "single_step_pending",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "single_step_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "46-55",
          "snippet": "static bool single_step_pending(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (current->thread.last_hit_ubp[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/inst.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/debugfs.h>",
            "#include <asm/debug.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool single_step_pending(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (current->thread.last_hit_ubp[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "i == nr_wp_slots()",
            "\"Can't find any breakpoint slot\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bp_per_reg[i]"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM_MAX]);\n\nint arch_install_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tstruct perf_event **slot;\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tslot = this_cpu_ptr(&bp_per_reg[i]);\n\t\tif (!*slot) {\n\t\t\t*slot = bp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ONCE(i == nr_wp_slots(), \"Can't find any breakpoint slot\"))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Do not install DABR values if the instruction must be single-stepped.\n\t * If so, DABR will be populated in single_step_dabr_instruction().\n\t */\n\tif (!single_step_pending())\n\t\t__set_breakpoint(i, info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "single_step_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "46-55",
    "snippet": "static bool single_step_pending(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (current->thread.last_hit_ubp[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic bool single_step_pending(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_wp_slots(); i++) {\n\t\tif (current->thread.last_hit_ubp[i])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "hw_breakpoint_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "39-44",
    "snippet": "int hw_breakpoint_slots(int type)\n{\n\tif (type == TYPE_DATA)\n\t\treturn nr_wp_slots();\n\treturn 0;\t\t/* no instruction breakpoints available */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/inst.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/debugfs.h>",
      "#include <asm/debug.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/init.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_wp_slots",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/inst.h>\n#include <asm/hvcall.h>\n#include <asm/debugfs.h>\n#include <asm/debug.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint hw_breakpoint_slots(int type)\n{\n\tif (type == TYPE_DATA)\n\t\treturn nr_wp_slots();\n\treturn 0;\t\t/* no instruction breakpoints available */\n}"
  }
]