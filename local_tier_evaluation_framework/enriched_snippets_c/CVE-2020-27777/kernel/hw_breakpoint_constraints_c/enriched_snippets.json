[
  {
    "function_name": "wp_get_instr_detail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "139-162",
    "snippet": "void wp_get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,\n\t\t\t int *type, int *size, unsigned long *ea)\n{\n\tstruct instruction_op op;\n\n\tif (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))\n\t\treturn;\n\n\tanalyse_instr(&op, regs, *instr);\n\t*type = GETTYPE(op.type);\n\t*ea = op.ea;\n#ifdef __powerpc64__\n\tif (!(regs->msr & MSR_64BIT))\n\t\t*ea &= 0xffffffffUL;\n#endif\n\n\t*size = GETSIZE(op.type);\n\tif (*type == CACHEOP) {\n\t\t*size = cache_op_size();\n\t\t*ea &= ~(*size - 1);\n\t} else if (*type == LOAD_VMX || *type == STORE_VMX) {\n\t\t*ea &= ~(*size - 1);\n\t}\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_op_size",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "cache_op_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "130-137",
          "snippet": "static int cache_op_size(void)\n{\n#ifdef __powerpc64__\n\treturn ppc64_caches.l1d.block_size;\n#else\n\treturn L1_CACHE_BYTES;\n#endif\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic int cache_op_size(void)\n{\n#ifdef __powerpc64__\n\treturn ppc64_caches.l1d.block_size;\n#else\n\treturn L1_CACHE_BYTES;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSIZE",
          "args": [
            "op.type"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETTYPE",
          "args": [
            "op.type"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "analyse_instr",
          "args": [
            "&op",
            "regs",
            "*instr"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_instr_inatomic",
          "args": [
            "*instr",
            "(void __user *)regs->nip"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nvoid wp_get_instr_detail(struct pt_regs *regs, struct ppc_inst *instr,\n\t\t\t int *type, int *size, unsigned long *ea)\n{\n\tstruct instruction_op op;\n\n\tif (__get_user_instr_inatomic(*instr, (void __user *)regs->nip))\n\t\treturn;\n\n\tanalyse_instr(&op, regs, *instr);\n\t*type = GETTYPE(op.type);\n\t*ea = op.ea;\n#ifdef __powerpc64__\n\tif (!(regs->msr & MSR_64BIT))\n\t\t*ea &= 0xffffffffUL;\n#endif\n\n\t*size = GETSIZE(op.type);\n\tif (*type == CACHEOP) {\n\t\t*size = cache_op_size();\n\t\t*ea &= ~(*size - 1);\n\t} else if (*type == LOAD_VMX || *type == STORE_VMX) {\n\t\t*ea &= ~(*size - 1);\n\t}\n}"
  },
  {
    "function_name": "cache_op_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "130-137",
    "snippet": "static int cache_op_size(void)\n{\n#ifdef __powerpc64__\n\treturn ppc64_caches.l1d.block_size;\n#else\n\treturn L1_CACHE_BYTES;\n#endif\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic int cache_op_size(void)\n{\n#ifdef __powerpc64__\n\treturn ppc64_caches.l1d.block_size;\n#else\n\treturn L1_CACHE_BYTES;\n#endif\n}"
  },
  {
    "function_name": "wp_check_constraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "83-128",
    "snippet": "bool wp_check_constraints(struct pt_regs *regs, struct ppc_inst instr,\n\t\t\t  unsigned long ea, int type, int size,\n\t\t\t  struct arch_hw_breakpoint *info)\n{\n\tbool in_user_range = dar_in_user_range(regs->dar, info);\n\tbool dawrx_constraints;\n\n\t/*\n\t * 8xx supports only one breakpoint and thus we can\n\t * unconditionally return true.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (!in_user_range)\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\treturn true;\n\t}\n\n\tif (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tdawrx_constraints = check_dawrx_constraints(regs, type, info);\n\n\tif (type == UNKNOWN) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn dawrx_constraints;\n\t}\n\n\tif (ea_user_range_overlaps(ea, size, info))\n\t\treturn dawrx_constraints;\n\n\tif (ea_hw_range_overlaps(ea, size, info)) {\n\t\tif (dawrx_constraints) {\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_hw_range_overlaps",
          "args": [
            "ea",
            "size",
            "info"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ea_hw_range_overlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "31-48",
          "snippet": "static bool ea_hw_range_overlaps(unsigned long ea, int size,\n\t\t\t\t struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\tunsigned long align_size = HW_BREAKPOINT_SIZE;\n\n\t/*\n\t * On p10 predecessors, quadword is handle differently then\n\t * other instructions.\n\t */\n\tif (!cpu_has_feature(CPU_FTR_ARCH_31) && size == 16)\n\t\talign_size = HW_BREAKPOINT_SIZE_QUADWORD;\n\n\thw_start_addr = ALIGN_DOWN(info->address, align_size);\n\thw_end_addr = ALIGN(info->address + info->len, align_size);\n\n\treturn ((ea < hw_end_addr) && (ea + size > hw_start_addr));\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool ea_hw_range_overlaps(unsigned long ea, int size,\n\t\t\t\t struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\tunsigned long align_size = HW_BREAKPOINT_SIZE;\n\n\t/*\n\t * On p10 predecessors, quadword is handle differently then\n\t * other instructions.\n\t */\n\tif (!cpu_has_feature(CPU_FTR_ARCH_31) && size == 16)\n\t\talign_size = HW_BREAKPOINT_SIZE_QUADWORD;\n\n\thw_start_addr = ALIGN_DOWN(info->address, align_size);\n\thw_end_addr = ALIGN(info->address + info->len, align_size);\n\n\treturn ((ea < hw_end_addr) && (ea + size > hw_start_addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_user_range_overlaps",
          "args": [
            "ea",
            "size",
            "info"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ea_user_range_overlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "14-19",
          "snippet": "static bool ea_user_range_overlaps(unsigned long ea, int size,\n\t\t\t\t   struct arch_hw_breakpoint *info)\n{\n\treturn ((ea < info->address + info->len) &&\n\t\t(ea + size > info->address));\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool ea_user_range_overlaps(unsigned long ea, int size,\n\t\t\t\t   struct arch_hw_breakpoint *info)\n{\n\treturn ((ea < info->address + info->len) &&\n\t\t(ea + size > info->address));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dar_in_hw_range",
          "args": [
            "regs->dar",
            "info"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "dar_in_hw_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "21-29",
          "snippet": "static bool dar_in_hw_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\n\thw_start_addr = ALIGN_DOWN(info->address, HW_BREAKPOINT_SIZE);\n\thw_end_addr = ALIGN(info->address + info->len, HW_BREAKPOINT_SIZE);\n\n\treturn ((hw_start_addr <= dar) && (hw_end_addr > dar));\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool dar_in_hw_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\n\thw_start_addr = ALIGN_DOWN(info->address, HW_BREAKPOINT_SIZE);\n\thw_end_addr = ALIGN(info->address + info->len, HW_BREAKPOINT_SIZE);\n\n\treturn ((hw_start_addr <= dar) && (hw_end_addr > dar));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_31"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_dawrx_constraints",
          "args": [
            "regs",
            "type",
            "info"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "check_dawrx_constraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "56-77",
          "snippet": "static bool check_dawrx_constraints(struct pt_regs *regs, int type,\n\t\t\t\t    struct arch_hw_breakpoint *info)\n{\n\tif (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))\n\t\treturn false;\n\n\t/*\n\t * The Cache Management instructions other than dcbz never\n\t * cause a match. i.e. if type is CACHEOP, the instruction\n\t * is dcbz, and dcbz is treated as Store.\n\t */\n\tif ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))\n\t\treturn false;\n\n\tif (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))\n\t\treturn false;\n\n\tif (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool check_dawrx_constraints(struct pt_regs *regs, int type,\n\t\t\t\t    struct arch_hw_breakpoint *info)\n{\n\tif (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))\n\t\treturn false;\n\n\t/*\n\t * The Cache Management instructions other than dcbz never\n\t * cause a match. i.e. if type is CACHEOP, the instruction\n\t * is dcbz, and dcbz is treated as Store.\n\t */\n\tif ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))\n\t\treturn false;\n\n\tif (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))\n\t\treturn false;\n\n\tif (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_31"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ppc_inst_equal(instr, ppc_inst(0))"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst_equal",
          "args": [
            "instr",
            "ppc_inst(0)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_inst",
          "args": [
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_8xx"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dar_in_user_range",
          "args": [
            "regs->dar",
            "info"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "dar_in_user_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
          "lines": "9-12",
          "snippet": "static bool dar_in_user_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\treturn ((info->address <= dar) && (dar - info->address < info->len));\n}",
          "includes": [
            "#include <asm/cache.h>",
            "#include <asm/sstep.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool dar_in_user_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\treturn ((info->address <= dar) && (dar - info->address < info->len));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nbool wp_check_constraints(struct pt_regs *regs, struct ppc_inst instr,\n\t\t\t  unsigned long ea, int type, int size,\n\t\t\t  struct arch_hw_breakpoint *info)\n{\n\tbool in_user_range = dar_in_user_range(regs->dar, info);\n\tbool dawrx_constraints;\n\n\t/*\n\t * 8xx supports only one breakpoint and thus we can\n\t * unconditionally return true.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_8xx)) {\n\t\tif (!in_user_range)\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\treturn true;\n\t}\n\n\tif (unlikely(ppc_inst_equal(instr, ppc_inst(0)))) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tdawrx_constraints = check_dawrx_constraints(regs, type, info);\n\n\tif (type == UNKNOWN) {\n\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) &&\n\t\t    !dar_in_hw_range(regs->dar, info))\n\t\t\treturn false;\n\n\t\treturn dawrx_constraints;\n\t}\n\n\tif (ea_user_range_overlaps(ea, size, info))\n\t\treturn dawrx_constraints;\n\n\tif (ea_hw_range_overlaps(ea, size, info)) {\n\t\tif (dawrx_constraints) {\n\t\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "check_dawrx_constraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "56-77",
    "snippet": "static bool check_dawrx_constraints(struct pt_regs *regs, int type,\n\t\t\t\t    struct arch_hw_breakpoint *info)\n{\n\tif (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))\n\t\treturn false;\n\n\t/*\n\t * The Cache Management instructions other than dcbz never\n\t * cause a match. i.e. if type is CACHEOP, the instruction\n\t * is dcbz, and dcbz is treated as Store.\n\t */\n\tif ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))\n\t\treturn false;\n\n\tif (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))\n\t\treturn false;\n\n\tif (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "regs->nip"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OP_IS_STORE",
          "args": [
            "type"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OP_IS_LOAD",
          "args": [
            "type"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool check_dawrx_constraints(struct pt_regs *regs, int type,\n\t\t\t\t    struct arch_hw_breakpoint *info)\n{\n\tif (OP_IS_LOAD(type) && !(info->type & HW_BRK_TYPE_READ))\n\t\treturn false;\n\n\t/*\n\t * The Cache Management instructions other than dcbz never\n\t * cause a match. i.e. if type is CACHEOP, the instruction\n\t * is dcbz, and dcbz is treated as Store.\n\t */\n\tif ((OP_IS_STORE(type) || type == CACHEOP) && !(info->type & HW_BRK_TYPE_WRITE))\n\t\treturn false;\n\n\tif (is_kernel_addr(regs->nip) && !(info->type & HW_BRK_TYPE_KERNEL))\n\t\treturn false;\n\n\tif (user_mode(regs) && !(info->type & HW_BRK_TYPE_USER))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "ea_hw_range_overlaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "31-48",
    "snippet": "static bool ea_hw_range_overlaps(unsigned long ea, int size,\n\t\t\t\t struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\tunsigned long align_size = HW_BREAKPOINT_SIZE;\n\n\t/*\n\t * On p10 predecessors, quadword is handle differently then\n\t * other instructions.\n\t */\n\tif (!cpu_has_feature(CPU_FTR_ARCH_31) && size == 16)\n\t\talign_size = HW_BREAKPOINT_SIZE_QUADWORD;\n\n\thw_start_addr = ALIGN_DOWN(info->address, align_size);\n\thw_end_addr = ALIGN(info->address + info->len, align_size);\n\n\treturn ((ea < hw_end_addr) && (ea + size > hw_start_addr));\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "info->address + info->len",
            "align_size"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "info->address",
            "align_size"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ARCH_31"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool ea_hw_range_overlaps(unsigned long ea, int size,\n\t\t\t\t struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\tunsigned long align_size = HW_BREAKPOINT_SIZE;\n\n\t/*\n\t * On p10 predecessors, quadword is handle differently then\n\t * other instructions.\n\t */\n\tif (!cpu_has_feature(CPU_FTR_ARCH_31) && size == 16)\n\t\talign_size = HW_BREAKPOINT_SIZE_QUADWORD;\n\n\thw_start_addr = ALIGN_DOWN(info->address, align_size);\n\thw_end_addr = ALIGN(info->address + info->len, align_size);\n\n\treturn ((ea < hw_end_addr) && (ea + size > hw_start_addr));\n}"
  },
  {
    "function_name": "dar_in_hw_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "21-29",
    "snippet": "static bool dar_in_hw_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\n\thw_start_addr = ALIGN_DOWN(info->address, HW_BREAKPOINT_SIZE);\n\thw_end_addr = ALIGN(info->address + info->len, HW_BREAKPOINT_SIZE);\n\n\treturn ((hw_start_addr <= dar) && (hw_end_addr > dar));\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "info->address + info->len",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "info->address",
            "HW_BREAKPOINT_SIZE"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool dar_in_hw_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\tunsigned long hw_start_addr, hw_end_addr;\n\n\thw_start_addr = ALIGN_DOWN(info->address, HW_BREAKPOINT_SIZE);\n\thw_end_addr = ALIGN(info->address + info->len, HW_BREAKPOINT_SIZE);\n\n\treturn ((hw_start_addr <= dar) && (hw_end_addr > dar));\n}"
  },
  {
    "function_name": "ea_user_range_overlaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "14-19",
    "snippet": "static bool ea_user_range_overlaps(unsigned long ea, int size,\n\t\t\t\t   struct arch_hw_breakpoint *info)\n{\n\treturn ((ea < info->address + info->len) &&\n\t\t(ea + size > info->address));\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool ea_user_range_overlaps(unsigned long ea, int size,\n\t\t\t\t   struct arch_hw_breakpoint *info)\n{\n\treturn ((ea < info->address + info->len) &&\n\t\t(ea + size > info->address));\n}"
  },
  {
    "function_name": "dar_in_user_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/hw_breakpoint_constraints.c",
    "lines": "9-12",
    "snippet": "static bool dar_in_user_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\treturn ((info->address <= dar) && (dar - info->address < info->len));\n}",
    "includes": [
      "#include <asm/cache.h>",
      "#include <asm/sstep.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/sched.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cache.h>\n#include <asm/sstep.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n\nstatic bool dar_in_user_range(unsigned long dar, struct arch_hw_breakpoint *info)\n{\n\treturn ((info->address <= dar) && (dar - info->address < info->len));\n}"
  }
]