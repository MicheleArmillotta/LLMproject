[
  {
    "function_name": "setup_noirqdistrib",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "821-825",
    "snippet": "static int __init setup_noirqdistrib(char *str)\n{\n\tdistribute_irqs = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic int __init setup_noirqdistrib(char *str)\n{\n\tdistribute_irqs = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "irq_choose_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "814-817",
    "snippet": "int irq_choose_cpu(const struct cpumask *mask)\n{\n\treturn hard_smp_processor_id();\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hard_smp_processor_id",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint irq_choose_cpu(const struct cpumask *mask)\n{\n\treturn hard_smp_processor_id();\n}"
  },
  {
    "function_name": "irq_choose_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "785-812",
    "snippet": "int irq_choose_cpu(const struct cpumask *mask)\n{\n\tint cpuid;\n\n\tif (cpumask_equal(mask, cpu_online_mask)) {\n\t\tstatic int irq_rover;\n\t\tstatic DEFINE_RAW_SPINLOCK(irq_rover_lock);\n\t\tunsigned long flags;\n\n\t\t/* Round-robin distribution... */\ndo_round_robin:\n\t\traw_spin_lock_irqsave(&irq_rover_lock, flags);\n\n\t\tirq_rover = cpumask_next(irq_rover, cpu_online_mask);\n\t\tif (irq_rover >= nr_cpu_ids)\n\t\t\tirq_rover = cpumask_first(cpu_online_mask);\n\n\t\tcpuid = irq_rover;\n\n\t\traw_spin_unlock_irqrestore(&irq_rover_lock, flags);\n\t} else {\n\t\tcpuid = cpumask_first_and(mask, cpu_online_mask);\n\t\tif (cpuid >= nr_cpu_ids)\n\t\t\tgoto do_round_robin;\n\t}\n\n\treturn get_hard_smp_processor_id(cpuid);\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "cpuid"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&irq_rover_lock",
            "flags"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "irq_rover",
            "cpu_online_mask"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&irq_rover_lock",
            "flags"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint irq_choose_cpu(const struct cpumask *mask)\n{\n\tint cpuid;\n\n\tif (cpumask_equal(mask, cpu_online_mask)) {\n\t\tstatic int irq_rover;\n\t\tstatic DEFINE_RAW_SPINLOCK(irq_rover_lock);\n\t\tunsigned long flags;\n\n\t\t/* Round-robin distribution... */\ndo_round_robin:\n\t\traw_spin_lock_irqsave(&irq_rover_lock, flags);\n\n\t\tirq_rover = cpumask_next(irq_rover, cpu_online_mask);\n\t\tif (irq_rover >= nr_cpu_ids)\n\t\t\tirq_rover = cpumask_first(cpu_online_mask);\n\n\t\tcpuid = irq_rover;\n\n\t\traw_spin_unlock_irqrestore(&irq_rover_lock, flags);\n\t} else {\n\t\tcpuid = cpumask_first_and(mask, cpu_online_mask);\n\t\tif (cpuid >= nr_cpu_ids)\n\t\t\tgoto do_round_robin;\n\t}\n\n\treturn get_hard_smp_processor_id(cpuid);\n}"
  },
  {
    "function_name": "virq_to_hw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "777-781",
    "snippet": "irq_hw_number_t virq_to_hw(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\treturn WARN_ON(!irq_data) ? 0 : irq_data->hwirq;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irq_data"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nirq_hw_number_t virq_to_hw(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\treturn WARN_ON(!irq_data) ? 0 : irq_data->hwirq;\n}"
  },
  {
    "function_name": "do_softirq_own_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "772-775",
    "snippet": "void do_softirq_own_stack(void)\n{\n\tcall_do_softirq(softirq_ctx[smp_processor_id()]);\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *softirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_do_softirq",
          "args": [
            "softirq_ctx[smp_processor_id()]"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid *softirq_ctx[NR_CPUS];\n\nvoid do_softirq_own_stack(void)\n{\n\tcall_do_softirq(softirq_ctx[smp_processor_id()]);\n}"
  },
  {
    "function_name": "init_IRQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "754-761",
    "snippet": "void __init init_IRQ(void)\n{\n\tif (IS_ENABLED(CONFIG_VMAP_STACK))\n\t\tvmap_irqstack_init();\n\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.init_IRQ",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "init_IRQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "754-761",
          "snippet": "void __init init_IRQ(void)\n{\n\tif (IS_ENABLED(CONFIG_VMAP_STACK))\n\t\tvmap_irqstack_init();\n\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vmap_irqstack_init",
          "args": [],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_irqstack_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "743-751",
          "snippet": "static void __init vmap_irqstack_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = alloc_vm_stack();\n\t\thardirq_ctx[i] = alloc_vm_stack();\n\t}\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *softirq_ctx[NR_CPUS]",
            "void *hardirq_ctx[NR_CPUS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid *softirq_ctx[NR_CPUS];\nvoid *hardirq_ctx[NR_CPUS];\n\nstatic void __init vmap_irqstack_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = alloc_vm_stack();\n\t\thardirq_ctx[i] = alloc_vm_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_VMAP_STACK"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __init init_IRQ(void)\n{\n\tif (IS_ENABLED(CONFIG_VMAP_STACK))\n\t\tvmap_irqstack_init();\n\n\tif (ppc_md.init_IRQ)\n\t\tppc_md.init_IRQ();\n}"
  },
  {
    "function_name": "vmap_irqstack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "743-751",
    "snippet": "static void __init vmap_irqstack_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = alloc_vm_stack();\n\t\thardirq_ctx[i] = alloc_vm_stack();\n\t}\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *softirq_ctx[NR_CPUS]",
      "void *hardirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_vm_stack",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vm_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "737-741",
          "snippet": "static void *__init alloc_vm_stack(void)\n{\n\treturn __vmalloc_node(THREAD_SIZE, THREAD_ALIGN, THREADINFO_GFP,\n\t\t\t      NUMA_NO_NODE, (void *)_RET_IP_);\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic void *__init alloc_vm_stack(void)\n{\n\treturn __vmalloc_node(THREAD_SIZE, THREAD_ALIGN, THREADINFO_GFP,\n\t\t\t      NUMA_NO_NODE, (void *)_RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid *softirq_ctx[NR_CPUS];\nvoid *hardirq_ctx[NR_CPUS];\n\nstatic void __init vmap_irqstack_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tsoftirq_ctx[i] = alloc_vm_stack();\n\t\thardirq_ctx[i] = alloc_vm_stack();\n\t}\n}"
  },
  {
    "function_name": "alloc_vm_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "737-741",
    "snippet": "static void *__init alloc_vm_stack(void)\n{\n\treturn __vmalloc_node(THREAD_SIZE, THREAD_ALIGN, THREADINFO_GFP,\n\t\t\t      NUMA_NO_NODE, (void *)_RET_IP_);\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "THREAD_SIZE",
            "THREAD_ALIGN",
            "THREADINFO_GFP",
            "NUMA_NO_NODE",
            "(void *)_RET_IP_"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic void *__init alloc_vm_stack(void)\n{\n\treturn __vmalloc_node(THREAD_SIZE, THREAD_ALIGN, THREADINFO_GFP,\n\t\t\t      NUMA_NO_NODE, (void *)_RET_IP_);\n}"
  },
  {
    "function_name": "do_IRQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "713-735",
    "snippet": "void do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tvoid *cursp, *irqsp, *sirqsp;\n\n\t/* Switch to the irq stack to handle this */\n\tcursp = (void *)(current_stack_pointer & ~(THREAD_SIZE - 1));\n\tirqsp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqsp = softirq_ctx[raw_smp_processor_id()];\n\n\tcheck_stack_overflow();\n\n\t/* Already there ? */\n\tif (unlikely(cursp == irqsp || cursp == sirqsp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqsp);\n\n\tset_irq_regs(old_regs);\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *softirq_ctx[NR_CPUS]",
      "void *hardirq_ctx[NR_CPUS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_do_irq",
          "args": [
            "regs",
            "irqsp"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "old_regs"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_irq",
          "args": [
            "regs"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__do_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "684-711",
          "snippet": "void __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(!irq))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(!irq))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cursp == irqsp || cursp == sirqsp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_overflow",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "668-682",
          "snippet": "static inline void check_stack_overflow(void)\n{\n\tlong sp;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACKOVERFLOW))\n\t\treturn;\n\n\tsp = current_stack_pointer & (THREAD_SIZE - 1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < 2048)) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\", sp);\n\t\tdump_stack();\n\t}\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline void check_stack_overflow(void)\n{\n\tlong sp;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACKOVERFLOW))\n\t\treturn;\n\n\tsp = current_stack_pointer & (THREAD_SIZE - 1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < 2048)) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\", sp);\n\t\tdump_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_irq_regs",
          "args": [
            "regs"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid *softirq_ctx[NR_CPUS];\nvoid *hardirq_ctx[NR_CPUS];\n\nvoid do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tvoid *cursp, *irqsp, *sirqsp;\n\n\t/* Switch to the irq stack to handle this */\n\tcursp = (void *)(current_stack_pointer & ~(THREAD_SIZE - 1));\n\tirqsp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqsp = softirq_ctx[raw_smp_processor_id()];\n\n\tcheck_stack_overflow();\n\n\t/* Already there ? */\n\tif (unlikely(cursp == irqsp || cursp == sirqsp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqsp);\n\n\tset_irq_regs(old_regs);\n}"
  },
  {
    "function_name": "__do_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "684-711",
    "snippet": "void __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(!irq))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_exit",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_exit",
          "args": [
            "regs"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_handle_irq",
          "args": [
            "irq"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "irq_stat.spurious_irqs"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!irq"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_hard_irq_enable",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.get_irq",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_entry",
          "args": [
            "regs"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_enter",
          "args": [],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid __do_irq(struct pt_regs *regs)\n{\n\tunsigned int irq;\n\n\tirq_enter();\n\n\ttrace_irq_entry(regs);\n\n\t/*\n\t * Query the platform PIC for the interrupt & ack it.\n\t *\n\t * This will typically lower the interrupt line to the CPU\n\t */\n\tirq = ppc_md.get_irq();\n\n\t/* We can hard enable interrupts now to allow perf interrupts */\n\tmay_hard_irq_enable();\n\n\t/* And finally process it */\n\tif (unlikely(!irq))\n\t\t__this_cpu_inc(irq_stat.spurious_irqs);\n\telse\n\t\tgeneric_handle_irq(irq);\n\n\ttrace_irq_exit(regs);\n\n\tirq_exit();\n}"
  },
  {
    "function_name": "check_stack_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "668-682",
    "snippet": "static inline void check_stack_overflow(void)\n{\n\tlong sp;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACKOVERFLOW))\n\t\treturn;\n\n\tsp = current_stack_pointer & (THREAD_SIZE - 1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < 2048)) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\", sp);\n\t\tdump_stack();\n\t}\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"do_IRQ: stack overflow: %ld\\n\"",
            "sp"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sp < 2048"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_STACKOVERFLOW"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline void check_stack_overflow(void)\n{\n\tlong sp;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACKOVERFLOW))\n\t\treturn;\n\n\tsp = current_stack_pointer & (THREAD_SIZE - 1);\n\n\t/* check for stack overflow: is there less than 2KB free? */\n\tif (unlikely(sp < 2048)) {\n\t\tpr_err(\"do_IRQ: stack overflow: %ld\\n\", sp);\n\t\tdump_stack();\n\t}\n}"
  },
  {
    "function_name": "arch_irq_stat_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "645-666",
    "snippet": "u64 arch_irq_stat_cpu(unsigned int cpu)\n{\n\tu64 sum = per_cpu(irq_stat, cpu).timer_irqs_event;\n\n\tsum += per_cpu(irq_stat, cpu).broadcast_irqs_event;\n\tsum += per_cpu(irq_stat, cpu).pmu_irqs;\n\tsum += per_cpu(irq_stat, cpu).mce_exceptions;\n\tsum += per_cpu(irq_stat, cpu).spurious_irqs;\n\tsum += per_cpu(irq_stat, cpu).timer_irqs_others;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tsum += paca_ptrs[cpu]->hmi_irqs;\n#endif\n\tsum += per_cpu(irq_stat, cpu).sreset_irqs;\n#ifdef CONFIG_PPC_WATCHDOG\n\tsum += per_cpu(irq_stat, cpu).soft_nmi_irqs;\n#endif\n#ifdef CONFIG_PPC_DOORBELL\n\tsum += per_cpu(irq_stat, cpu).doorbell_irqs;\n#endif\n\n\treturn sum;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "cpu"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nu64 arch_irq_stat_cpu(unsigned int cpu)\n{\n\tu64 sum = per_cpu(irq_stat, cpu).timer_irqs_event;\n\n\tsum += per_cpu(irq_stat, cpu).broadcast_irqs_event;\n\tsum += per_cpu(irq_stat, cpu).pmu_irqs;\n\tsum += per_cpu(irq_stat, cpu).mce_exceptions;\n\tsum += per_cpu(irq_stat, cpu).spurious_irqs;\n\tsum += per_cpu(irq_stat, cpu).timer_irqs_others;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tsum += paca_ptrs[cpu]->hmi_irqs;\n#endif\n\tsum += per_cpu(irq_stat, cpu).sreset_irqs;\n#ifdef CONFIG_PPC_WATCHDOG\n\tsum += per_cpu(irq_stat, cpu).soft_nmi_irqs;\n#endif\n#ifdef CONFIG_PPC_DOORBELL\n\tsum += per_cpu(irq_stat, cpu).doorbell_irqs;\n#endif\n\n\treturn sum;\n}"
  },
  {
    "function_name": "arch_show_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "566-640",
    "snippet": "int arch_show_interrupts(struct seq_file *p, int prec)\n{\n\tint j;\n\n#if defined(CONFIG_PPC32) && defined(CONFIG_TAU_INT)\n\tif (tau_initialized) {\n\t\tseq_printf(p, \"%*s: \", prec, \"TAU\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", tau_interrupts(j));\n\t\tseq_puts(p, \"  PowerPC             Thermal Assist (cpu temp)\\n\");\n\t}\n#endif /* CONFIG_PPC32 && CONFIG_TAU_INT */\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_event);\n        seq_printf(p, \"  Local timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"BCT\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).broadcast_irqs_event);\n\tseq_printf(p, \"  Broadcast timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_others);\n        seq_printf(p, \"  Local timer interrupts for others\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"SPU\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).spurious_irqs);\n\tseq_printf(p, \"  Spurious interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"PMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).pmu_irqs);\n\tseq_printf(p, \"  Performance monitoring interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"MCE\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).mce_exceptions);\n\tseq_printf(p, \"  Machine check exceptions\\n\");\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HMI\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", paca_ptrs[j]->hmi_irqs);\n\t\tseq_printf(p, \"  Hypervisor Maintenance Interrupts\\n\");\n\t}\n#endif\n\n\tseq_printf(p, \"%*s: \", prec, \"NMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).sreset_irqs);\n\tseq_printf(p, \"  System Reset interrupts\\n\");\n\n#ifdef CONFIG_PPC_WATCHDOG\n\tseq_printf(p, \"%*s: \", prec, \"WDG\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).soft_nmi_irqs);\n\tseq_printf(p, \"  Watchdog soft-NMI interrupts\\n\");\n#endif\n\n#ifdef CONFIG_PPC_DOORBELL\n\tif (cpu_has_feature(CPU_FTR_DBELL)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"DBL\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).doorbell_irqs);\n\t\tseq_printf(p, \"  Doorbell interrupts\\n\");\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Doorbell interrupts\\n\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"DBL\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DBELL"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Watchdog soft-NMI interrupts\\n\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"WDG\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  System Reset interrupts\\n\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"NMI\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Hypervisor Maintenance Interrupts\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"HMI\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HVMODE"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Machine check exceptions\\n\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"MCE\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Performance monitoring interrupts\\n\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"PMI\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Spurious interrupts\\n\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"SPU\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Local timer interrupts for others\\n\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"LOC\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Broadcast timer interrupts for timer event device\\n\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"BCT\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"  Local timer interrupts for timer event device\\n\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "irq_stat",
            "j"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"LOC\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "p",
            "\"  PowerPC             Thermal Assist (cpu temp)\\n\""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\"%*s: \"",
            "prec",
            "\"TAU\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nint arch_show_interrupts(struct seq_file *p, int prec)\n{\n\tint j;\n\n#if defined(CONFIG_PPC32) && defined(CONFIG_TAU_INT)\n\tif (tau_initialized) {\n\t\tseq_printf(p, \"%*s: \", prec, \"TAU\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", tau_interrupts(j));\n\t\tseq_puts(p, \"  PowerPC             Thermal Assist (cpu temp)\\n\");\n\t}\n#endif /* CONFIG_PPC32 && CONFIG_TAU_INT */\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_event);\n        seq_printf(p, \"  Local timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"BCT\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).broadcast_irqs_event);\n\tseq_printf(p, \"  Broadcast timer interrupts for timer event device\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"LOC\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).timer_irqs_others);\n        seq_printf(p, \"  Local timer interrupts for others\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"SPU\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).spurious_irqs);\n\tseq_printf(p, \"  Spurious interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"PMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).pmu_irqs);\n\tseq_printf(p, \"  Performance monitoring interrupts\\n\");\n\n\tseq_printf(p, \"%*s: \", prec, \"MCE\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).mce_exceptions);\n\tseq_printf(p, \"  Machine check exceptions\\n\");\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"HMI\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", paca_ptrs[j]->hmi_irqs);\n\t\tseq_printf(p, \"  Hypervisor Maintenance Interrupts\\n\");\n\t}\n#endif\n\n\tseq_printf(p, \"%*s: \", prec, \"NMI\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).sreset_irqs);\n\tseq_printf(p, \"  System Reset interrupts\\n\");\n\n#ifdef CONFIG_PPC_WATCHDOG\n\tseq_printf(p, \"%*s: \", prec, \"WDG\");\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).soft_nmi_irqs);\n\tseq_printf(p, \"  Watchdog soft-NMI interrupts\\n\");\n#endif\n\n#ifdef CONFIG_PPC_DOORBELL\n\tif (cpu_has_feature(CPU_FTR_DBELL)) {\n\t\tseq_printf(p, \"%*s: \", prec, \"DBL\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"%10u \", per_cpu(irq_stat, j).doorbell_irqs);\n\t\tseq_printf(p, \"  Doorbell interrupts\\n\");\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "force_external_irq_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "544-562",
    "snippet": "void force_external_irq_replay(void)\n{\n\t/*\n\t * This must only be called with interrupts soft-disabled,\n\t * the replay will happen when re-enabling.\n\t */\n\tWARN_ON(!arch_irqs_disabled());\n\n\t/*\n\t * Interrupts must always be hard disabled before irq_happened is\n\t * modified (to prevent lost update in case of interrupt between\n\t * load and store).\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/* Indicate in the PACA that we have an interrupt to replay */\n\tlocal_paca->irq_happened |= PACA_IRQ_EE;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!arch_irqs_disabled()"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_irqs_disabled",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid force_external_irq_replay(void)\n{\n\t/*\n\t * This must only be called with interrupts soft-disabled,\n\t * the replay will happen when re-enabling.\n\t */\n\tWARN_ON(!arch_irqs_disabled());\n\n\t/*\n\t * Interrupts must always be hard disabled before irq_happened is\n\t * modified (to prevent lost update in case of interrupt between\n\t * load and store).\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/* Indicate in the PACA that we have an interrupt to replay */\n\tlocal_paca->irq_happened |= PACA_IRQ_EE;\n}"
  },
  {
    "function_name": "irq_set_pending_from_srr1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "500-538",
    "snippet": "void irq_set_pending_from_srr1(unsigned long srr1)\n{\n\tunsigned int idx = (srr1 & SRR1_WAKEMASK_P8) >> 18;\n\tu8 reason = srr1_to_lazyirq[idx];\n\n\t/*\n\t * Take the system reset now, which is immediately after registers\n\t * are restored from idle. It's an NMI, so interrupts need not be\n\t * re-enabled before it is taken.\n\t */\n\tif (unlikely(reason == IRQ_SYSTEM_RESET)) {\n\t\treplay_system_reset();\n\t\treturn;\n\t}\n\n\tif (reason == PACA_IRQ_DBELL) {\n\t\t/*\n\t\t * When doorbell triggers a system reset wakeup, the message\n\t\t * is not cleared, so if the doorbell interrupt is replayed\n\t\t * and the IPI handled, the doorbell interrupt would still\n\t\t * fire when EE is enabled.\n\t\t *\n\t\t * To avoid taking the superfluous doorbell interrupt,\n\t\t * execute a msgclr here before the interrupt is replayed.\n\t\t */\n\t\tppc_msgclr(PPC_DBELL_MSGTYPE);\n\t}\n\n\t/*\n\t * The 0 index (SRR1[42:45]=b0000) must always evaluate to 0,\n\t * so this can be called unconditionally with the SRR1 wake\n\t * reason as returned by the idle code, which uses 0 to mean no\n\t * interrupt.\n\t *\n\t * If a future CPU was to designate this as an interrupt reason,\n\t * then a new index for no interrupt must be assigned.\n\t */\n\tlocal_paca->irq_happened |= reason;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define IRQ_SYSTEM_RESET\t0xff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_msgclr",
          "args": [
            "PPC_DBELL_MSGTYPE"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_system_reset",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "replay_system_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "488-497",
          "snippet": "void replay_system_reset(void)\n{\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.trap = 0x100;\n\tget_paca()->in_nmi = 1;\n\tsystem_reset_exception(&regs);\n\tget_paca()->in_nmi = 0;\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid replay_system_reset(void)\n{\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.trap = 0x100;\n\tget_paca()->in_nmi = 1;\n\tsystem_reset_exception(&regs);\n\tget_paca()->in_nmi = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "reason == IRQ_SYSTEM_RESET"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\n#define IRQ_SYSTEM_RESET\t0xff\n\nvoid irq_set_pending_from_srr1(unsigned long srr1)\n{\n\tunsigned int idx = (srr1 & SRR1_WAKEMASK_P8) >> 18;\n\tu8 reason = srr1_to_lazyirq[idx];\n\n\t/*\n\t * Take the system reset now, which is immediately after registers\n\t * are restored from idle. It's an NMI, so interrupts need not be\n\t * re-enabled before it is taken.\n\t */\n\tif (unlikely(reason == IRQ_SYSTEM_RESET)) {\n\t\treplay_system_reset();\n\t\treturn;\n\t}\n\n\tif (reason == PACA_IRQ_DBELL) {\n\t\t/*\n\t\t * When doorbell triggers a system reset wakeup, the message\n\t\t * is not cleared, so if the doorbell interrupt is replayed\n\t\t * and the IPI handled, the doorbell interrupt would still\n\t\t * fire when EE is enabled.\n\t\t *\n\t\t * To avoid taking the superfluous doorbell interrupt,\n\t\t * execute a msgclr here before the interrupt is replayed.\n\t\t */\n\t\tppc_msgclr(PPC_DBELL_MSGTYPE);\n\t}\n\n\t/*\n\t * The 0 index (SRR1[42:45]=b0000) must always evaluate to 0,\n\t * so this can be called unconditionally with the SRR1 wake\n\t * reason as returned by the idle code, which uses 0 to mean no\n\t * interrupt.\n\t *\n\t * If a future CPU was to designate this as an interrupt reason,\n\t * then a new index for no interrupt must be assigned.\n\t */\n\tlocal_paca->irq_happened |= reason;\n}"
  },
  {
    "function_name": "replay_system_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "488-497",
    "snippet": "void replay_system_reset(void)\n{\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.trap = 0x100;\n\tget_paca()->in_nmi = 1;\n\tsystem_reset_exception(&regs);\n\tget_paca()->in_nmi = 0;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_reset_exception",
          "args": [
            "&regs"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "system_reset_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "440-525",
          "snippet": "void system_reset_exception(struct pt_regs *regs)\n{\n\tunsigned long hsrr0, hsrr1;\n\tbool saved_hsrrs = false;\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tnmi_enter();\n\n\t/*\n\t * System reset can interrupt code where HSRRs are live and MSR[RI]=1.\n\t * The system reset interrupt itself may clobber HSRRs (e.g., to call\n\t * OPAL), so save them here and restore them before returning.\n\t *\n\t * Machine checks don't need to save HSRRs, as the real mode handler\n\t * is careful to avoid them, and the regular handler is not delivered\n\t * as an NMI.\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\thsrr0 = mfspr(SPRN_HSRR0);\n\t\thsrr1 = mfspr(SPRN_HSRR1);\n\t\tsaved_hsrrs = true;\n\t}\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t__this_cpu_inc(irq_stat.sreset_irqs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\tgoto out;\n\t}\n\n\tif (debugger(regs))\n\t\tgoto out;\n\n\tkmsg_dump(KMSG_DUMP_OOPS);\n\t/*\n\t * A system reset is a request to dump, so we always send\n\t * it through the crashdump code (if fadump or kdump are\n\t * registered).\n\t */\n\tcrash_fadump(regs, \"System Reset\");\n\n\tcrash_kexec(regs);\n\n\t/*\n\t * We aren't the primary crash CPU. We need to send it\n\t * to a holding pattern to avoid it ending up in the panic\n\t * code.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/*\n\t * No debugger or crash dump registered, print logs then\n\t * panic.\n\t */\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\tmdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tnmi_panic(regs, \"System Reset\");\n\nout:\n#ifdef CONFIG_PPC_BOOK3S_64\n\tBUG_ON(get_paca()->in_nmi == 0);\n\tif (get_paca()->in_nmi > 1)\n\t\tdie(\"Unrecoverable nested System Reset\", regs, SIGABRT);\n#endif\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable System Reset\", regs, SIGABRT);\n\n\tif (saved_hsrrs) {\n\t\tmtspr(SPRN_HSRR0, hsrr0);\n\t\tmtspr(SPRN_HSRR1, hsrr1);\n\t}\n\n\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid system_reset_exception(struct pt_regs *regs)\n{\n\tunsigned long hsrr0, hsrr1;\n\tbool saved_hsrrs = false;\n\tu8 ftrace_enabled = this_cpu_get_ftrace_enabled();\n\n\tthis_cpu_set_ftrace_enabled(0);\n\n\tnmi_enter();\n\n\t/*\n\t * System reset can interrupt code where HSRRs are live and MSR[RI]=1.\n\t * The system reset interrupt itself may clobber HSRRs (e.g., to call\n\t * OPAL), so save them here and restore them before returning.\n\t *\n\t * Machine checks don't need to save HSRRs, as the real mode handler\n\t * is careful to avoid them, and the regular handler is not delivered\n\t * as an NMI.\n\t */\n\tif (cpu_has_feature(CPU_FTR_HVMODE)) {\n\t\thsrr0 = mfspr(SPRN_HSRR0);\n\t\thsrr1 = mfspr(SPRN_HSRR1);\n\t\tsaved_hsrrs = true;\n\t}\n\n\thv_nmi_check_nonrecoverable(regs);\n\n\t__this_cpu_inc(irq_stat.sreset_irqs);\n\n\t/* See if any machine dependent calls */\n\tif (ppc_md.system_reset_exception) {\n\t\tif (ppc_md.system_reset_exception(regs))\n\t\t\tgoto out;\n\t}\n\n\tif (debugger(regs))\n\t\tgoto out;\n\n\tkmsg_dump(KMSG_DUMP_OOPS);\n\t/*\n\t * A system reset is a request to dump, so we always send\n\t * it through the crashdump code (if fadump or kdump are\n\t * registered).\n\t */\n\tcrash_fadump(regs, \"System Reset\");\n\n\tcrash_kexec(regs);\n\n\t/*\n\t * We aren't the primary crash CPU. We need to send it\n\t * to a holding pattern to avoid it ending up in the panic\n\t * code.\n\t */\n\tcrash_kexec_secondary(regs);\n\n\t/*\n\t * No debugger or crash dump registered, print logs then\n\t * panic.\n\t */\n\tdie(\"System Reset\", regs, SIGABRT);\n\n\tmdelay(2*MSEC_PER_SEC); /* Wait a little while for others to print */\n\tadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\n\tnmi_panic(regs, \"System Reset\");\n\nout:\n#ifdef CONFIG_PPC_BOOK3S_64\n\tBUG_ON(get_paca()->in_nmi == 0);\n\tif (get_paca()->in_nmi > 1)\n\t\tdie(\"Unrecoverable nested System Reset\", regs, SIGABRT);\n#endif\n\t/* Must die if the interrupt is not recoverable */\n\tif (!(regs->msr & MSR_RI))\n\t\tdie(\"Unrecoverable System Reset\", regs, SIGABRT);\n\n\tif (saved_hsrrs) {\n\t\tmtspr(SPRN_HSRR0, hsrr0);\n\t\tmtspr(SPRN_HSRR1, hsrr1);\n\t}\n\n\tnmi_exit();\n\n\tthis_cpu_set_ftrace_enabled(ftrace_enabled);\n\n\t/* What should we do here? We could issue a shutdown or hard reset. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_save_regs",
          "args": [
            "&regs"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid replay_system_reset(void)\n{\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.trap = 0x100;\n\tget_paca()->in_nmi = 1;\n\tsystem_reset_exception(&regs);\n\tget_paca()->in_nmi = 0;\n}"
  },
  {
    "function_name": "prep_irq_for_idle_irqsoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "440-462",
    "snippet": "bool prep_irq_for_idle_irqsoff(void)\n{\n\tWARN_ON(!irqs_disabled());\n\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_irq_pending",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nbool prep_irq_for_idle_irqsoff(void)\n{\n\tWARN_ON(!irqs_disabled());\n\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\treturn true;\n}"
  },
  {
    "function_name": "prep_irq_for_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "401-431",
    "snippet": "bool prep_irq_for_idle(void)\n{\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\t/*\n\t * Mark interrupts as soft-enabled and clear the\n\t * PACA_IRQ_HARD_DIS from the pending mask since we\n\t * are about to hard enable as well as a side effect\n\t * of entering the low power state.\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\t/* Tell the caller to enter the low power state */\n\treturn true;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_soft_mask_set",
          "args": [
            "IRQS_ENABLED"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_irq_pending",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nbool prep_irq_for_idle(void)\n{\n\t/*\n\t * First we need to hard disable to ensure no interrupt\n\t * occurs before we effectively enter the low power state\n\t */\n\t__hard_irq_disable();\n\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\n\t/*\n\t * If anything happened while we were soft-disabled,\n\t * we return now and do not enter the low power state.\n\t */\n\tif (lazy_irq_pending())\n\t\treturn false;\n\n\t/* Tell lockdep we are about to re-enable */\n\ttrace_hardirqs_on();\n\n\t/*\n\t * Mark interrupts as soft-enabled and clear the\n\t * PACA_IRQ_HARD_DIS from the pending mask since we\n\t * are about to hard enable as well as a side effect\n\t * of entering the low power state.\n\t */\n\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\tirq_soft_mask_set(IRQS_ENABLED);\n\n\t/* Tell the caller to enter the low power state */\n\treturn true;\n}"
  },
  {
    "function_name": "arch_local_irq_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "314-383",
    "snippet": "notrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_enable",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_soft_mask_set",
          "args": [
            "IRQS_ENABLED"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_soft_interrupts",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "replay_soft_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "215-312",
          "snippet": "void replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_soft_mask_set",
          "args": [
            "IRQS_ALL_DISABLED"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_enable",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mfmsr() & MSR_EE"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_IRQ_SOFT_MASK_DEBUG"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hard_irq_disable",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mfmsr() & MSR_EE)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_IRQ_SOFT_MASK_DEBUG"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mfmsr() & MSR_EE)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_IRQ_SOFT_MASK_DEBUG"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_irq_happened",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_irq_happened",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "95-103",
          "snippet": "static inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_soft_mask_set",
          "args": [
            "mask"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long mask)\n{\n\tunsigned char irq_happened;\n\n\t/* Write the new soft-enabled value */\n\tirq_soft_mask_set(mask);\n\tif (mask)\n\t\treturn;\n\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\treturn;\n\t}\n\n\t/* We need to hard disable to replay. */\n\tif (!(irq_happened & PACA_IRQ_HARD_DIS)) {\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\t\tWARN_ON_ONCE(!(mfmsr() & MSR_EE));\n\t\t__hard_irq_disable();\n\t} else {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG)) {\n\t\t\tif (WARN_ON_ONCE(mfmsr() & MSR_EE))\n\t\t\t\t__hard_irq_disable();\n\t\t}\n\n\t\tif (irq_happened == PACA_IRQ_HARD_DIS) {\n\t\t\tlocal_paca->irq_happened = 0;\n\t\t\t__hard_irq_enable();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Disable preempt here, so that the below preempt_enable will\n\t * perform resched if required (a replayed interrupt may set\n\t * need_resched).\n\t */\n\tpreempt_disable();\n\tirq_soft_mask_set(IRQS_ALL_DISABLED);\n\ttrace_hardirqs_off();\n\n\treplay_soft_interrupts();\n\tlocal_paca->irq_happened = 0;\n\n\ttrace_hardirqs_on();\n\tirq_soft_mask_set(IRQS_ENABLED);\n\t__hard_irq_enable();\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "replay_soft_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "215-312",
    "snippet": "void replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_hardirqs_off",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "performance_monitor_exception",
          "args": [
            "&regs"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "performance_monitor_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1926-1931",
          "snippet": "void performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid performance_monitor_exception(struct pt_regs *regs)\n{\n\t__this_cpu_inc(irq_stat.pmu_irqs);\n\n\tperf_irq(regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "doorbell_exception",
          "args": [
            "&regs"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "doorbell_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/dbell.c",
          "lines": "42-45",
          "snippet": "void doorbell_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_WARNING \"Received doorbell on non-smp system\\n\");\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/dbell.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/threads.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/kvm_ppc.h>\n#include <asm/irq_regs.h>\n#include <asm/dbell.h>\n#include <linux/hardirq.h>\n#include <linux/threads.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nvoid doorbell_exception(struct pt_regs *regs)\n{\n\tprintk(KERN_WARNING \"Received doorbell on non-smp system\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3E"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_DOORBELL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_IRQ",
          "args": [
            "&regs"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "do_IRQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "713-735",
          "snippet": "void do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tvoid *cursp, *irqsp, *sirqsp;\n\n\t/* Switch to the irq stack to handle this */\n\tcursp = (void *)(current_stack_pointer & ~(THREAD_SIZE - 1));\n\tirqsp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqsp = softirq_ctx[raw_smp_processor_id()];\n\n\tcheck_stack_overflow();\n\n\t/* Already there ? */\n\tif (unlikely(cursp == irqsp || cursp == sirqsp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqsp);\n\n\tset_irq_regs(old_regs);\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *softirq_ctx[NR_CPUS]",
            "void *hardirq_ctx[NR_CPUS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid *softirq_ctx[NR_CPUS];\nvoid *hardirq_ctx[NR_CPUS];\n\nvoid do_IRQ(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs = set_irq_regs(regs);\n\tvoid *cursp, *irqsp, *sirqsp;\n\n\t/* Switch to the irq stack to handle this */\n\tcursp = (void *)(current_stack_pointer & ~(THREAD_SIZE - 1));\n\tirqsp = hardirq_ctx[raw_smp_processor_id()];\n\tsirqsp = softirq_ctx[raw_smp_processor_id()];\n\n\tcheck_stack_overflow();\n\n\t/* Already there ? */\n\tif (unlikely(cursp == irqsp || cursp == sirqsp)) {\n\t\t__do_irq(regs);\n\t\tset_irq_regs(old_regs);\n\t\treturn;\n\t}\n\t/* Switch stack and call */\n\tcall_do_irq(regs, irqsp);\n\n\tset_irq_regs(old_regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_interrupt",
          "args": [
            "&regs"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_timer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/watchdog.c",
          "lines": "238-248",
          "snippet": "static void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}",
          "includes": [
            "#include <asm/paca.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/reboot.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/init.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 wd_smp_panic_timeout_tb",
            "static DEFINE_PER_CPU(u64, wd_timer_tb);",
            "static u64 wd_smp_last_reset_tb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/paca.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/sched/debug.h>\n#include <linux/kdebug.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/hardirq.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/init.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic u64 wd_smp_panic_timeout_tb;\nstatic DEFINE_PER_CPU(u64, wd_timer_tb);\nstatic u64 wd_smp_last_reset_tb;\n\nstatic void watchdog_timer_interrupt(int cpu)\n{\n\tu64 tb = get_tb();\n\n\tper_cpu(wd_timer_tb, cpu) = tb;\n\n\twd_smp_clear_cpu_pending(cpu, tb);\n\n\tif ((s64)(tb - wd_smp_last_reset_tb) >= (s64)wd_smp_panic_timeout_tb)\n\t\twatchdog_smp_panic(cpu, tb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_hmi_exception",
          "args": [
            "&regs"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "handle_hmi_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/traps.c",
          "lines": "1068-1095",
          "snippet": "void handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n#ifdef CONFIG_VSX\n\t/* Real mode flagged P9 special emu is needed */\n\tif (local_paca->hmi_p9_special_emu) {\n\t\tlocal_paca->hmi_p9_special_emu = 0;\n\n\t\t/*\n\t\t * We don't want to take page faults while doing the\n\t\t * emulation, we just replay the instruction if necessary.\n\t\t */\n\t\tpagefault_disable();\n\t\tp9_hmi_special_emu(regs);\n\t\tpagefault_enable();\n\t}\n#endif /* CONFIG_VSX */\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}",
          "includes": [
            "#include <asm/nmi.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/kprobes.h>",
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/hmi.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/debugfs.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/console.h>",
            "#include <linux/smp.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>\t/* print_modules */",
            "#include <linux/extable.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/kprobes.h>\n#include <sysdev/fsl_pci.h>\n#include <asm/hmi.h>\n#include <asm/asm-prototypes.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/debugfs.h>\n#include <linux/uaccess.h>\n#include <asm/emulated_ops.h>\n#include <linux/kmsg_dump.h>\n#include <linux/console.h>\n#include <linux/smp.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\t/* print_modules */\n#include <linux/extable.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/pkeys.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid handle_hmi_exception(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\told_regs = set_irq_regs(regs);\n\tirq_enter();\n\n#ifdef CONFIG_VSX\n\t/* Real mode flagged P9 special emu is needed */\n\tif (local_paca->hmi_p9_special_emu) {\n\t\tlocal_paca->hmi_p9_special_emu = 0;\n\n\t\t/*\n\t\t * We don't want to take page faults while doing the\n\t\t * emulation, we just replay the instruction if necessary.\n\t\t */\n\t\tpagefault_disable();\n\t\tp9_hmi_special_emu(regs);\n\t\tpagefault_enable();\n\t}\n#endif /* CONFIG_VSX */\n\n\tif (ppc_md.handle_hmi_exception)\n\t\tppc_md.handle_hmi_exception(regs);\n\n\tirq_exit();\n\tset_irq_regs(old_regs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_BOOK3S"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lv1_get_version_info",
          "args": [
            "&tmp",
            "&tmp2"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_PS3_LV1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decrementer_check_overflow",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "decrementer_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "105-111",
          "snippet": "static inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "mfmsr() & MSR_EE"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PPC_IRQ_SOFT_MASK_DEBUG"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_save_regs",
          "args": [
            "&regs"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid replay_soft_interrupts(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\tstruct pt_regs regs;\n\n\tppc_save_regs(&regs);\n\tregs.softe = IRQS_ENABLED;\n\nagain:\n\tif (IS_ENABLED(CONFIG_PPC_IRQ_SOFT_MASK_DEBUG))\n\t\tWARN_ON_ONCE(mfmsr() & MSR_EE);\n\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow())\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t}\n\t}\n\n\t/*\n\t * Force the delivery of pending soft-disabled interrupts on PS3.\n\t * Any HV call will have this side effect.\n\t */\n\tif (firmware_has_feature(FW_FEATURE_PS3_LV1)) {\n\t\tu64 tmp, tmp2;\n\t\tlv1_get_version_info(&tmp, &tmp2);\n\t}\n\n\t/*\n\t * Check if an hypervisor Maintenance interrupt happened.\n\t * This is a higher priority interrupt than the others, so\n\t * replay it first.\n\t */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_HMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HMI;\n\t\tregs.trap = 0xe60;\n\t\thandle_hmi_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\tregs.trap = 0x900;\n\t\ttimer_interrupt(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\tregs.trap = 0x500;\n\t\tdo_IRQ(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\tif (IS_ENABLED(CONFIG_PPC_DOORBELL) && (happened & PACA_IRQ_DBELL)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\tif (IS_ENABLED(CONFIG_PPC_BOOK3E))\n\t\t\tregs.trap = 0x280;\n\t\telse\n\t\t\tregs.trap = 0xa00;\n\t\tdoorbell_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\t/* Book3E does not support soft-masking PMI interrupts */\n\tif (IS_ENABLED(CONFIG_PPC_BOOK3S) && (happened & PACA_IRQ_PMI)) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_PMI;\n\t\tregs.trap = 0xf00;\n\t\tperformance_monitor_exception(&regs);\n\t\tif (!(local_paca->irq_happened & PACA_IRQ_HARD_DIS))\n\t\t\thard_irq_disable();\n\t}\n\n\thappened = local_paca->irq_happened;\n\tif (happened & ~PACA_IRQ_HARD_DIS) {\n\t\t/*\n\t\t * We are responding to the next interrupt, so interrupt-off\n\t\t * latencies should be reset here.\n\t\t */\n\t\ttrace_hardirqs_on();\n\t\ttrace_hardirqs_off();\n\t\tgoto again;\n\t}\n}"
  },
  {
    "function_name": "restore_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "204-211",
    "snippet": "void notrace restore_interrupts(void)\n{\n\tif (irqs_disabled()) {\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\t\tlocal_irq_enable();\n\t} else\n\t\t__hard_irq_enable();\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hard_irq_enable",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nvoid notrace restore_interrupts(void)\n{\n\tif (irqs_disabled()) {\n\t\tlocal_paca->irq_happened |= PACA_IRQ_HARD_DIS;\n\t\tlocal_irq_enable();\n\t} else\n\t\t__hard_irq_enable();\n}"
  },
  {
    "function_name": "__check_irq_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "129-193",
    "snippet": "notrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/*\n\t * We are responding to the next interrupt, so interrupt-off\n\t * latencies should be reset here.\n\t */\n\ttrace_hardirqs_on();\n\ttrace_hardirqs_off();\n\n\t/*\n\t * We are always hard disabled here, but PACA_IRQ_HARD_DIS may\n\t * not be set, which means interrupts have only just been hard\n\t * disabled as part of the local_irq_restore or interrupt return\n\t * code. In that case, skip the decrementr check becaus it's\n\t * expensive to read the TB.\n\t *\n\t * HARD_DIS then gets cleared here, but it's reconciled later.\n\t * Either local_irq_disable will replay the interrupt and that\n\t * will reconcile state like other hard interrupts. Or interrupt\n\t * retur will replay the interrupt and in that case it sets\n\t * PACA_IRQ_HARD_DIS by hand (see comments in entry_64.S).\n\t */\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow()) {\n\t\t\t\tlocal_paca->irq_happened |= PACA_IRQ_DEC;\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\treturn 0x900;\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\treturn 0x500;\n\t}\n\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\treturn 0x280;\n\t}\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "local_paca->irq_happened != 0"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decrementer_check_overflow",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "decrementer_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
          "lines": "105-111",
          "snippet": "static inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}",
          "includes": [
            "#include <asm/cpu_has_feature.h>",
            "#include <asm/trace.h>",
            "#include <asm/dbell.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/asm-prototypes.h>",
            "#include <asm/livepatch.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_off",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_hardirqs_on",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace unsigned int __check_irq_replay(void)\n{\n\t/*\n\t * We use local_paca rather than get_paca() to avoid all\n\t * the debug_smp_processor_id() business in this low level\n\t * function\n\t */\n\tunsigned char happened = local_paca->irq_happened;\n\n\t/*\n\t * We are responding to the next interrupt, so interrupt-off\n\t * latencies should be reset here.\n\t */\n\ttrace_hardirqs_on();\n\ttrace_hardirqs_off();\n\n\t/*\n\t * We are always hard disabled here, but PACA_IRQ_HARD_DIS may\n\t * not be set, which means interrupts have only just been hard\n\t * disabled as part of the local_irq_restore or interrupt return\n\t * code. In that case, skip the decrementr check becaus it's\n\t * expensive to read the TB.\n\t *\n\t * HARD_DIS then gets cleared here, but it's reconciled later.\n\t * Either local_irq_disable will replay the interrupt and that\n\t * will reconcile state like other hard interrupts. Or interrupt\n\t * retur will replay the interrupt and in that case it sets\n\t * PACA_IRQ_HARD_DIS by hand (see comments in entry_64.S).\n\t */\n\tif (happened & PACA_IRQ_HARD_DIS) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_HARD_DIS;\n\n\t\t/*\n\t\t * We may have missed a decrementer interrupt if hard disabled.\n\t\t * Check the decrementer register in case we had a rollover\n\t\t * while hard disabled.\n\t\t */\n\t\tif (!(happened & PACA_IRQ_DEC)) {\n\t\t\tif (decrementer_check_overflow()) {\n\t\t\t\tlocal_paca->irq_happened |= PACA_IRQ_DEC;\n\t\t\t\thappened |= PACA_IRQ_DEC;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (happened & PACA_IRQ_DEC) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DEC;\n\t\treturn 0x900;\n\t}\n\n\tif (happened & PACA_IRQ_EE) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_EE;\n\t\treturn 0x500;\n\t}\n\n\tif (happened & PACA_IRQ_DBELL) {\n\t\tlocal_paca->irq_happened &= ~PACA_IRQ_DBELL;\n\t\treturn 0x280;\n\t}\n\n\t/* There should be nothing left ! */\n\tBUG_ON(local_paca->irq_happened != 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decrementer_check_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "105-111",
    "snippet": "static inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&decrementers_next_tb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb_or_rtc",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace int decrementer_check_overflow(void)\n{\n \tu64 now = get_tb_or_rtc();\n\tu64 *next_tb = this_cpu_ptr(&decrementers_next_tb);\n \n\treturn now >= *next_tb;\n}"
  },
  {
    "function_name": "get_irq_happened",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/irq.c",
    "lines": "95-103",
    "snippet": "static inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}",
    "includes": [
      "#include <asm/cpu_has_feature.h>",
      "#include <asm/trace.h>",
      "#include <asm/dbell.h>",
      "#include <asm/lv1call.h>",
      "#include <asm/firmware.h>",
      "#include <asm/paca.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/asm-prototypes.h>",
      "#include <asm/livepatch.h>",
      "#include <asm/smp.h>",
      "#include <asm/udbg.h>",
      "#include <asm/machdep.h>",
      "#include <asm/ptrace.h>",
      "#include <asm/prom.h>",
      "#include <asm/cache.h>",
      "#include <asm/irq.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/pgtable.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/pci.h>",
      "#include <linux/mutex.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/list.h>",
      "#include <linux/bitops.h>",
      "#include <linux/profile.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/timex.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ioport.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/threads.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/cpu_has_feature.h>\n#include <asm/trace.h>\n#include <asm/dbell.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/hw_irq.h>\n#include <asm/asm-prototypes.h>\n#include <asm/livepatch.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/pgtable.h>\n#include <linux/vmalloc.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nstatic inline notrace unsigned long get_irq_happened(void)\n{\n\tunsigned long happened;\n\n\t__asm__ __volatile__(\"lbz %0,%1(13)\"\n\t: \"=r\" (happened) : \"i\" (offsetof(struct paca_struct, irq_happened)));\n\n\treturn happened;\n}"
  }
]