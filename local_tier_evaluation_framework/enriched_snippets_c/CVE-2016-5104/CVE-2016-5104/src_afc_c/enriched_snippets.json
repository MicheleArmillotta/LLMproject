[
  {
    "function_name": "afc_dictionary_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "1025-1038",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dictionary"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
  },
  {
    "function_name": "afc_remove_path_and_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "1001-1023",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_remove_path_and_contents(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH_AND_CONTENTS, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_REMOVE_PATH_AND_CONTENTS",
            "path",
            "strlen(path)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_remove_path_and_contents(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH_AND_CONTENTS, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_set_file_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "972-999",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_set_file_time(afc_client_t client, const char *path, uint64_t mtime)\n{\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(path) + 1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t mtime_loc = htole64(mtime);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, &mtime_loc, 8);\n\tmemcpy(buffer + 8, path, strlen(path) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_SET_FILE_MOD_TIME, buffer, 8 + strlen(path) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_SET_FILE_MOD_TIME",
            "buffer",
            "8 + strlen(path) + 1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + 8",
            "path",
            "strlen(path) + 1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&mtime_loc",
            "8"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "mtime"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (strlen(path) + 1 + 8)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_set_file_time(afc_client_t client, const char *path, uint64_t mtime)\n{\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(path) + 1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t mtime_loc = htole64(mtime);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, &mtime_loc, 8);\n\tmemcpy(buffer + 8, path, strlen(path) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_SET_FILE_MOD_TIME, buffer, 8 + strlen(path) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_make_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "938-970",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_make_link(afc_client_t client, afc_link_type_t linktype, const char *target, const char *linkname)\n{\n\tif (!client || !target || !linkname || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(target)+1 + strlen(linkname)+1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t type = htole64(linktype);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\tdebug_info(\"link type: %lld\", type);\n\tdebug_info(\"target: %s, length:%d\", target, strlen(target));\n\tdebug_info(\"linkname: %s, length:%d\", linkname, strlen(linkname));\n\n\t/* Send command */\n\tmemcpy(buffer, &type, 8);\n\tmemcpy(buffer + 8, target, strlen(target) + 1);\n\tmemcpy(buffer + 8 + strlen(target) + 1, linkname, strlen(linkname) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_LINK, buffer, 8 + strlen(linkname) + 1 + strlen(target) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_MAKE_LINK",
            "buffer",
            "8 + strlen(linkname) + 1 + strlen(target) + 1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "linkname"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + 8 + strlen(target) + 1",
            "linkname",
            "strlen(linkname) + 1"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "linkname"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + 8",
            "target",
            "strlen(target) + 1"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&type",
            "8"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"linkname: %s, length:%d\"",
            "linkname",
            "strlen(linkname)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "linkname"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"target: %s, length:%d\"",
            "target",
            "strlen(target)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"link type: %lld\"",
            "type"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "linktype"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (strlen(target)+1 + strlen(linkname)+1 + 8)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "linkname"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_make_link(afc_client_t client, afc_link_type_t linktype, const char *target, const char *linkname)\n{\n\tif (!client || !target || !linkname || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(target)+1 + strlen(linkname)+1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t type = htole64(linktype);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\tdebug_info(\"link type: %lld\", type);\n\tdebug_info(\"target: %s, length:%d\", target, strlen(target));\n\tdebug_info(\"linkname: %s, length:%d\", linkname, strlen(linkname));\n\n\t/* Send command */\n\tmemcpy(buffer, &type, 8);\n\tmemcpy(buffer + 8, target, strlen(target) + 1);\n\tmemcpy(buffer + 8 + strlen(target) + 1, linkname, strlen(linkname) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_LINK, buffer, 8 + strlen(linkname) + 1 + strlen(target) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "908-936",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_truncate(afc_client_t client, const char *path, uint64_t newsize)\n{\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(path) + 1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t size_requested = htole64(newsize);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, &size_requested, 8);\n\tmemcpy(buffer + 8, path, strlen(path) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_TRUNCATE, buffer, 8 + strlen(path) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_TRUNCATE",
            "buffer",
            "8 + strlen(path) + 1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + 8",
            "path",
            "strlen(path) + 1"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&size_requested",
            "8"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "newsize"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (strlen(path) + 1 + 8)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_truncate(afc_client_t client, const char *path, uint64_t newsize)\n{\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(path) + 1 + 8));\n\tuint32_t bytes = 0;\n\tuint64_t size_requested = htole64(newsize);\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, &size_requested, 8);\n\tmemcpy(buffer + 8, path, strlen(path) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_TRUNCATE, buffer, 8 + strlen(path) + 1, NULL, 0, &bytes);\n\tfree(buffer);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "877-906",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_truncate(afc_client_t client, uint64_t handle, uint64_t newsize)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t newsize;\n\t} truncinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\ttruncinfo.handle = handle;\n\ttruncinfo.newsize = htole64(newsize);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_SET_SIZE, (const char*)&truncinfo, sizeof(truncinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_SET_SIZE",
            "(const char*)&truncinfo",
            "sizeof(truncinfo)",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "newsize"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_truncate(afc_client_t client, uint64_t handle, uint64_t newsize)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t newsize;\n\t} truncinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\ttruncinfo.handle = handle;\n\ttruncinfo.newsize = htole64(newsize);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_SET_SIZE, (const char*)&truncinfo, sizeof(truncinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_tell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "844-875",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_tell(afc_client_t client, uint64_t handle, uint64_t *position)\n{\n\tchar *buffer = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_TELL, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive the data */\n\tret = afc_receive_data(client, &buffer, &bytes);\n\tif (bytes > 0 && buffer) {\n\t\t/* Get the position */\n\t\tmemcpy(position, buffer, sizeof(uint64_t));\n\t\t*position = le64toh(*position);\n\t}\n\tfree(buffer);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64toh",
          "args": [
            "*position"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "position",
            "buffer",
            "sizeof(uint64_t)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&buffer",
            "&bytes"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_TELL",
            "(const char*)&handle",
            "8",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_tell(afc_client_t client, uint64_t handle, uint64_t *position)\n{\n\tchar *buffer = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_TELL, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive the data */\n\tret = afc_receive_data(client, &buffer, &bytes);\n\tif (bytes > 0 && buffer) {\n\t\t/* Get the position */\n\t\tmemcpy(position, buffer, sizeof(uint64_t));\n\t\t*position = le64toh(*position);\n\t}\n\tfree(buffer);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "811-842",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_seek(afc_client_t client, uint64_t handle, int64_t offset, int whence)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t whence;\n\t\tint64_t offset;\n\t} seekinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tseekinfo.handle = handle;\n\tseekinfo.whence = htole64(whence);\n\tseekinfo.offset = (int64_t)htole64(offset);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_SEEK, (const char*)&seekinfo, sizeof(seekinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_SEEK",
            "(const char*)&seekinfo",
            "sizeof(seekinfo)",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "offset"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "whence"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_seek(afc_client_t client, uint64_t handle, int64_t offset, int whence)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t whence;\n\t\tint64_t offset;\n\t} seekinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tseekinfo.handle = handle;\n\tseekinfo.whence = htole64(whence);\n\tseekinfo.offset = (int64_t)htole64(offset);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_SEEK, (const char*)&seekinfo, sizeof(seekinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "777-809",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"could not send lock command\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_LOCK",
            "(const char*)&lockinfo",
            "sizeof(lockinfo)",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "operation"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"file handle %i\"",
            "handle"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "749-775",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_CLOSE",
            "(const char*)&handle",
            "8",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"File handle %i\"",
            "handle"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "717-747",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_write(afc_client_t client, uint64_t handle, const char *data, uint32_t length, uint32_t *bytes_written)\n{\n\tuint32_t current_count = 0;\n\tuint32_t bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || !bytes_written || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"Write length: %i\", length);\n\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_WRITE, (const char*)&handle, 8, data, length, &bytes_loc);\n\n\tcurrent_count += bytes_loc - (sizeof(AFCPacket) + 8);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\t*bytes_written = current_count;\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tret = afc_receive_data(client, NULL, &bytes_loc);\n\tafc_unlock(client);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"uh oh?\");\n\t}\n\t*bytes_written = current_count;\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"uh oh?\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes_loc"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_WRITE",
            "(const char*)&handle",
            "8",
            "data",
            "length",
            "&bytes_loc"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Write length: %i\"",
            "length"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_write(afc_client_t client, uint64_t handle, const char *data, uint32_t length, uint32_t *bytes_written)\n{\n\tuint32_t current_count = 0;\n\tuint32_t bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || !bytes_written || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"Write length: %i\", length);\n\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_WRITE, (const char*)&handle, 8, data, length, &bytes_loc);\n\n\tcurrent_count += bytes_loc - (sizeof(AFCPacket) + 8);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\t*bytes_written = current_count;\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tret = afc_receive_data(client, NULL, &bytes_loc);\n\tafc_unlock(client);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"uh oh?\");\n\t}\n\t*bytes_written = current_count;\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "664-715",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "input"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + current_count",
            "input",
            "(bytes_loc > length) ? length : bytes_loc"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"%d\"",
            "bytes_loc"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"bytes returned: %i\"",
            "bytes_loc"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"afc_receive_data returned error: %d\"",
            "ret"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&input",
            "&bytes_loc"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_READ",
            "(const char*)&readinfo",
            "sizeof(readinfo)",
            "NULL",
            "0",
            "&bytes_loc"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "length"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"called for length %i\"",
            "length"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "616-662",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Didn't get any further data\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "handle",
            "data",
            "sizeof(uint64_t)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&data",
            "&bytes"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Didn't receive a response to the command\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_FILE_OPEN",
            "data",
            "8 + strlen(filename) + 1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 8",
            "filename",
            "strlen(filename)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "&file_mode_loc",
            "8"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (8 + strlen(filename) + 1)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "filename"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htole64",
          "args": [
            "file_mode"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_get_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "586-614",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "received"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_strings_list",
          "args": [
            "received",
            "bytes"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "make_strings_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "386-403",
          "snippet": "static char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&received",
            "&bytes"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_GET_FILE_INFO",
            "path",
            "strlen(path)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_make_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "562-584",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_make_directory(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_MAKE_DIR",
            "path",
            "strlen(path)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_make_directory(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_rename_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "533-560",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_rename_path(afc_client_t client, const char *from, const char *to)\n{\n\tif (!client || !from || !to || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(from) + strlen(to) + 1 + sizeof(uint32_t)));\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, from, strlen(from) + 1);\n\tmemcpy(buffer + strlen(from) + 1, to, strlen(to) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_RENAME_PATH, buffer, strlen(to)+1 + strlen(from)+1, NULL, 0, &bytes);\n\tfree(buffer);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_RENAME_PATH",
            "buffer",
            "strlen(to)+1 + strlen(from)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "from"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "to"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + strlen(from) + 1",
            "to",
            "strlen(to) + 1"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "to"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "from"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "from",
            "strlen(from) + 1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "from"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * (strlen(from) + strlen(to) + 1 + sizeof(uint32_t))"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "to"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "from"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_rename_path(afc_client_t client, const char *from, const char *to)\n{\n\tif (!client || !from || !to || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tchar *buffer = (char *) malloc(sizeof(char) * (strlen(from) + strlen(to) + 1 + sizeof(uint32_t)));\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(buffer, from, strlen(from) + 1);\n\tmemcpy(buffer + strlen(from) + 1, to, strlen(to) + 1);\n\tret = afc_dispatch_packet(client, AFC_OP_RENAME_PATH, buffer, strlen(to)+1 + strlen(from)+1, NULL, 0, &bytes);\n\tfree(buffer);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_remove_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "505-531",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_remove_path(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\t/* special case; unknown error actually means directory not empty */\n\tif (ret == AFC_E_UNKNOWN_ERROR)\n\t\tret = AFC_E_DIR_NOT_EMPTY;\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "NULL",
            "&bytes"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_REMOVE_PATH",
            "path",
            "strlen(path)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_remove_path(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\t/* special case; unknown error actually means directory not empty */\n\tif (ret == AFC_E_UNKNOWN_ERROR)\n\t\tret = AFC_E_DIR_NOT_EMPTY;\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_get_device_info_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "478-503",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_device_info_key(afc_client_t client, const char *key, char **value)\n{\n\tafc_error_t ret = AFC_E_INTERNAL_ERROR;\n\tchar **kvps, **ptr;\n\n\t*value = NULL;\n\tif (key == NULL)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tret = afc_get_device_info(client, &kvps);\n\tif (ret != AFC_E_SUCCESS)\n\t\treturn ret;\n\n\tfor (ptr = kvps; *ptr; ptr++) {\n\t\tif (!strcmp(*ptr, key)) {\n\t\t\t*value = strdup(*(ptr+1));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (ptr = kvps; *ptr; ptr++) {\n\t\tfree(*ptr);\n\t}\n\tfree(kvps);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "kvps"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "*(ptr+1)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*ptr",
            "key"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_get_device_info",
          "args": [
            "client",
            "&kvps"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "afc_get_device_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "441-476",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_device_info(afc_client_t client, char ***device_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !device_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_DEVINFO, NULL, 0, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\n\t*device_information = list;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_device_info(afc_client_t client, char ***device_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !device_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_DEVINFO, NULL, 0, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\n\t*device_information = list;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_device_info_key(afc_client_t client, const char *key, char **value)\n{\n\tafc_error_t ret = AFC_E_INTERNAL_ERROR;\n\tchar **kvps, **ptr;\n\n\t*value = NULL;\n\tif (key == NULL)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tret = afc_get_device_info(client, &kvps);\n\tif (ret != AFC_E_SUCCESS)\n\t\treturn ret;\n\n\tfor (ptr = kvps; *ptr; ptr++) {\n\t\tif (!strcmp(*ptr, key)) {\n\t\t\t*value = strdup(*(ptr+1));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (ptr = kvps; *ptr; ptr++) {\n\t\tfree(*ptr);\n\t}\n\tfree(kvps);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_get_device_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "441-476",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_device_info(afc_client_t client, char ***device_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !device_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_DEVINFO, NULL, 0, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\n\t*device_information = list;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_strings_list",
          "args": [
            "data",
            "bytes"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "make_strings_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "386-403",
          "snippet": "static char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&data",
            "&bytes"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_GET_DEVINFO",
            "NULL",
            "0",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_device_info(afc_client_t client, char ***device_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !device_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_DEVINFO, NULL, 0, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\n\t*device_information = list;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "afc_read_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "405-439",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_read_directory(afc_client_t client, const char *path, char ***directory_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list_loc = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !directory_information || (directory_information && *directory_information))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_READ_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist_loc = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\t*directory_information = list_loc;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_unlock",
          "args": [
            "client"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "afc_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "53-57",
          "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_strings_list",
          "args": [
            "data",
            "bytes"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "make_strings_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "386-403",
          "snippet": "static char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_receive_data",
          "args": [
            "client",
            "&data",
            "&bytes"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "afc_receive_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "221-359",
          "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dispatch_packet",
          "args": [
            "client",
            "AFC_OP_READ_DIR",
            "path",
            "strlen(path)+1",
            "NULL",
            "0",
            "&bytes"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dispatch_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "153-210",
          "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_lock",
          "args": [
            "client"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "afc_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "42-46",
          "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_read_directory(afc_client_t client, const char *path, char ***directory_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list_loc = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !directory_information || (directory_information && *directory_information))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_READ_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist_loc = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\t*directory_information = list_loc;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "make_strings_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "386-403",
    "snippet": "static char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list[i]"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tokens + j"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char *) * (nulls + 1)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_nullspaces",
          "args": [
            "tokens",
            "length"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "count_nullspaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "364-374",
          "snippet": "static uint32_t count_nullspaces(char *string, uint32_t number)\n{\n\tuint32_t i = 0, nulls = 0;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (string[i] == '\\0')\n\t\t\tnulls++;\n\t}\n\n\treturn nulls;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic uint32_t count_nullspaces(char *string, uint32_t number)\n{\n\tuint32_t i = 0, nulls = 0;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (string[i] == '\\0')\n\t\t\tnulls++;\n\t}\n\n\treturn nulls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char **make_strings_list(char *tokens, uint32_t length)\n{\n\tuint32_t nulls = 0, i = 0, j = 0;\n\tchar **list = NULL;\n\n\tif (!tokens || !length)\n\t\treturn NULL;\n\n\tnulls = count_nullspaces(tokens, length);\n\tlist = (char **) malloc(sizeof(char *) * (nulls + 1));\n\tfor (i = 0; i < nulls; i++) {\n\t\tlist[i] = strdup(tokens + j);\n\t\tj += strlen(list[i]) + 1;\n\t}\n\tlist[i] = NULL;\n\n\treturn list;\n}"
  },
  {
    "function_name": "count_nullspaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "364-374",
    "snippet": "static uint32_t count_nullspaces(char *string, uint32_t number)\n{\n\tuint32_t i = 0, nulls = 0;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (string[i] == '\\0')\n\t\t\tnulls++;\n\t}\n\n\treturn nulls;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic uint32_t count_nullspaces(char *string, uint32_t number)\n{\n\tuint32_t i = 0, nulls = 0;\n\n\tfor (i = 0; i < number; i++) {\n\t\tif (string[i] == '\\0')\n\t\t\tnulls++;\n\t}\n\n\treturn nulls;\n}"
  },
  {
    "function_name": "afc_receive_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "221-359",
    "snippet": "static afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dump_here"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\"",
            "__func__",
            "(long long)header.operation",
            "(long long)param1"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: Unknown operation code received 0x%llx param1=%lld\"",
            "header.operation",
            "param1"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"got a tell response, position=%lld\"",
            "param1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"got a file handle response, handle=%lld\"",
            "param1"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"got a data response\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"got a status response, code=%lld\"",
            "param1"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_buffer",
          "args": [
            "dump_here",
            "current_count"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"packet data follows\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"packet data size = %i\"",
            "current_count"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64toh",
          "args": [
            "*(uint64_t*)(dump_here)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: could not receive full packet (read %s, size %d)\"",
            "current_count",
            "entire_len"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Error receiving data (recv returned %d)\"",
            "*bytes_recv"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_receive",
          "args": [
            "client->parent",
            "dump_here+current_count",
            "entire_len - current_count",
            "bytes_recv"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "service_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "172-175",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_receive(service_client_t client, char* data, uint32_t size, uint32_t *received)\n{\n\treturn service_receive_with_timeout(client, data, size, received, 10000);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_receive(service_client_t client, char* data, uint32_t size, uint32_t *received)\n{\n\treturn service_receive_with_timeout(client, data, size, received, 10000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Could not receive this_len=%d bytes\"",
            "this_len"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Did not get packet contents!\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "entire_len"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\"",
            "header.entire_length",
            "header.this_length",
            "header.operation"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "debug_info_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "81-99",
          "snippet": "void debug_info_real(const char *func, const char *file, int line, const char *format, ...)\n{\n#ifndef STRIP_DEBUG_CODE\n\tva_list args;\n\tchar *buffer = NULL;\n\n\tif (!debug_level)\n\t\treturn;\n\n\t/* run the real fprintf */\n\tva_start(args, format);\n\t(void)vasprintf(&buffer, format, args);\n\tva_end(args);\n\n\tdebug_print_line(func, file, line, buffer);\n\n\tfree(buffer);\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_info_real(const char *func, const char *file, int line, const char *format, ...)\n{\n#ifndef STRIP_DEBUG_CODE\n\tva_list args;\n\tchar *buffer = NULL;\n\n\tif (!debug_level)\n\t\treturn;\n\n\t/* run the real fprintf */\n\tva_start(args, format);\n\t(void)vasprintf(&buffer, format, args);\n\tva_end(args);\n\n\tdebug_print_line(func, file, line, buffer);\n\n\tfree(buffer);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Empty AFCPacket received!\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Invalid AFCPacket header received!\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Unexpected packet number (%lld != %lld) aborting.\"",
            "header.packet_num",
            "client->afc_packet->packet_num"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "header.magic",
            "AFC_MAGIC",
            "AFC_MAGIC_LEN"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Did not even get the AFCPacket header\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Just didn't get enough.\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFCPacket_from_LE",
          "args": [
            "&header"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_receive_data(afc_client_t client, char **bytes, uint32_t *bytes_recv)\n{\n\tAFCPacket header;\n\tuint32_t entire_len = 0;\n\tuint32_t this_len = 0;\n\tuint32_t current_count = 0;\n\tuint64_t param1 = -1;\n\tchar* dump_here = NULL;\n\n\tif (bytes_recv) {\n\t\t*bytes_recv = 0;\n\t}\n\tif (bytes) {\n\t\t*bytes = NULL;\n\t}\n\n\t/* first, read the AFC header */\n\tservice_receive(client->parent, (char*)&header, sizeof(AFCPacket), bytes_recv);\n\tAFCPacket_from_LE(&header);\n\tif (*bytes_recv == 0) {\n\t\tdebug_info(\"Just didn't get enough.\");\n\t\treturn AFC_E_MUX_ERROR;\n\t} else if (*bytes_recv < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Did not even get the AFCPacket header\");\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\t/* check if it's a valid AFC header */\n\tif (strncmp(header.magic, AFC_MAGIC, AFC_MAGIC_LEN)) {\n\t\tdebug_info(\"Invalid AFC packet received (magic != \" AFC_MAGIC \")!\");\n\t}\n\n\t/* check if it has the correct packet number */\n\tif (header.packet_num != client->afc_packet->packet_num) {\n\t\t/* otherwise print a warning but do not abort */\n\t\tdebug_info(\"ERROR: Unexpected packet number (%lld != %lld) aborting.\", header.packet_num, client->afc_packet->packet_num);\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t}\n\n\t/* then, read the attached packet */\n\tif (header.this_length < sizeof(AFCPacket)) {\n\t\tdebug_info(\"Invalid AFCPacket header received!\");\n\t\treturn AFC_E_OP_HEADER_INVALID;\n\t} else if ((header.this_length == header.entire_length)\n\t\t\t&& header.entire_length == sizeof(AFCPacket)) {\n\t\tdebug_info(\"Empty AFCPacket received!\");\n\t\t*bytes_recv = 0;\n\t\tif (header.operation == AFC_OP_DATA) {\n\t\t\treturn AFC_E_SUCCESS;\n\t\t} else {\n\t\t\treturn AFC_E_IO_ERROR;\n\t\t}\n\t}\n\n\tdebug_info(\"received AFC packet, full len=%lld, this len=%lld, operation=0x%llx\", header.entire_length, header.this_length, header.operation);\n\n\tentire_len = (uint32_t)header.entire_length - sizeof(AFCPacket);\n\tthis_len = (uint32_t)header.this_length - sizeof(AFCPacket);\n\n\tdump_here = (char*)malloc(entire_len);\n\tif (this_len > 0) {\n\t\tservice_receive(client->parent, dump_here, this_len, bytes_recv);\n\t\tif (*bytes_recv <= 0) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Did not get packet contents!\");\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t} else if (*bytes_recv < this_len) {\n\t\t\tfree(dump_here);\n\t\t\tdebug_info(\"Could not receive this_len=%d bytes\", this_len);\n\t\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t\t}\n\t}\n\n\tcurrent_count = this_len;\n\n\tif (entire_len > this_len) {\n\t\twhile (current_count < entire_len) {\n\t\t\tservice_receive(client->parent, dump_here+current_count, entire_len - current_count, bytes_recv);\n\t\t\tif (*bytes_recv <= 0) {\n\t\t\t\tdebug_info(\"Error receiving data (recv returned %d)\", *bytes_recv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_count += *bytes_recv;\n\t\t}\n\t\tif (current_count < entire_len) {\n\t\t\tdebug_info(\"WARNING: could not receive full packet (read %s, size %d)\", current_count, entire_len);\n\t\t}\n\t}\n\n\tif (current_count >= sizeof(uint64_t)) {\n\t\tparam1 = le64toh(*(uint64_t*)(dump_here));\n\t}\n\n\tdebug_info(\"packet data size = %i\", current_count);\n\tdebug_info(\"packet data follows\");\n\tdebug_buffer(dump_here, current_count);\n\n\t/* check operation types */\n\tif (header.operation == AFC_OP_STATUS) {\n\t\t/* status response */\n\t\tdebug_info(\"got a status response, code=%lld\", param1);\n\n\t\tif (param1 != AFC_E_SUCCESS) {\n\t\t\t/* error status */\n\t\t\t/* free buffer */\n\t\t\tfree(dump_here);\n\t\t\treturn (afc_error_t)param1;\n\t\t}\n\t} else if (header.operation == AFC_OP_DATA) {\n\t\t/* data response */\n\t\tdebug_info(\"got a data response\");\n\t} else if (header.operation == AFC_OP_FILE_OPEN_RES) {\n\t\t/* file handle response */\n\t\tdebug_info(\"got a file handle response, handle=%lld\", param1);\n\t} else if (header.operation == AFC_OP_FILE_TELL_RES) {\n\t\t/* tell response */\n\t\tdebug_info(\"got a tell response, position=%lld\", param1);\n\t} else {\n\t\t/* unknown operation code received */\n\t\tfree(dump_here);\n\t\t*bytes_recv = 0;\n\n\t\tdebug_info(\"WARNING: Unknown operation code received 0x%llx param1=%lld\", header.operation, param1);\n#ifndef WIN32\n\t\tfprintf(stderr, \"%s: WARNING: Unknown operation code received 0x%llx param1=%lld\", __func__, (long long)header.operation, (long long)param1);\n#endif\n\n\t\treturn AFC_E_OP_NOT_SUPPORTED;\n\t}\n\n\tif (bytes) {\n\t\t*bytes = dump_here;\n\t} else {\n\t\tfree(dump_here);\n\t}\n\n\t*bytes_recv = current_count;\n\treturn AFC_E_SUCCESS;\n}"
  },
  {
    "function_name": "afc_dispatch_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "153-210",
    "snippet": "static afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_send",
          "args": [
            "client->parent",
            "payload",
            "payload_length",
            "&sent"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "service_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "131-150",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_send(service_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = idevice_to_service_error(idevice_connection_send(client->connection, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_send(service_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = idevice_to_service_error(idevice_connection_send(client->connection, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_buffer",
          "args": [
            "payload",
            "payload_length"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"packet payload follows\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"packet data follows\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFCPacket_from_LE",
          "args": [
            "client->afc_packet"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFCPacket_to_LE",
          "args": [
            "client->afc_packet"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"packet length = %i\"",
            "client->afc_packet->this_length"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic afc_error_t afc_dispatch_packet(afc_client_t client, uint64_t operation, const char *data, uint32_t data_length, const char* payload, uint32_t payload_length, uint32_t *bytes_sent)\n{\n\tuint32_t sent = 0;\n\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\t*bytes_sent = 0;\n\n\tif (!data || !data_length)\n\t\tdata_length = 0;\n\tif (!payload || !payload_length)\n\t\tpayload_length = 0;\n\n\tclient->afc_packet->packet_num++;\n\tclient->afc_packet->operation = operation;\n\tclient->afc_packet->entire_length = sizeof(AFCPacket) + data_length + payload_length;\n\tclient->afc_packet->this_length = sizeof(AFCPacket) + data_length;\n\n\tdebug_info(\"packet length = %i\", client->afc_packet->this_length);\n\n\tdebug_buffer((char*)client->afc_packet, sizeof(AFCPacket));\n\n\t/* send AFC packet header */\n\tAFCPacket_to_LE(client->afc_packet);\n\tsent = 0;\n\tservice_send(client->parent, (void*)client->afc_packet, sizeof(AFCPacket), &sent);\n\tAFCPacket_from_LE(client->afc_packet);\n\t*bytes_sent += sent;\n\tif (sent < sizeof(AFCPacket)) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\t/* send AFC packet data (if there's data to send) */\n\tsent = 0;\n\tif (data_length > 0) {\n\t\tdebug_info(\"packet data follows\");\n\t\tdebug_buffer(data, data_length);\n\t\tservice_send(client->parent, data, data_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < data_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tsent = 0;\n\tif (payload_length > 0) {\n\t\tdebug_info(\"packet payload follows\");\n\t\tdebug_buffer(payload, payload_length);\n\t\tservice_send(client->parent, payload, payload_length, &sent);\n\t}\n\t*bytes_sent += sent;\n\tif (sent < payload_length) {\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\treturn AFC_E_SUCCESS;\n}"
  },
  {
    "function_name": "afc_client_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "125-138",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&client->mutex"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "65-72",
          "snippet": "void mutex_destroy(mutex_t* mutex)\n{\n#ifdef WIN32\n\tDeleteCriticalSection(mutex);\n#else\n\tpthread_mutex_destroy(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_destroy(mutex_t* mutex)\n{\n#ifdef WIN32\n\tDeleteCriticalSection(mutex);\n#else\n\tpthread_mutex_destroy(mutex);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "service_client_free",
          "args": [
            "client->parent"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "device_link_service_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/device_link_service.c",
          "lines": "119-129",
          "snippet": "device_link_service_error_t device_link_service_client_free(device_link_service_client_t client)\n{\n\tif (!client)\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_UNKNOWN_ERROR;\n\t}\n\tfree(client);\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"device_link_service.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"device_link_service.h\"\n#include <stdlib.h>\n#include <string.h>\n\ndevice_link_service_error_t device_link_service_client_free(device_link_service_client_t client)\n{\n\tif (!client)\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_UNKNOWN_ERROR;\n\t}\n\tfree(client);\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}"
  },
  {
    "function_name": "afc_client_start_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "118-123",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_start_service(idevice_t device, afc_client_t * client, const char* label)\n{\n\tafc_error_t err = AFC_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, AFC_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(afc_client_new), &err);\n\treturn err;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_client_factory_start_service",
          "args": [
            "device",
            "AFC_SERVICE_NAME",
            "(void**)client",
            "label",
            "SERVICE_CONSTRUCTOR(afc_client_new)",
            "&err"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "service_client_factory_start_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "79-116",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_factory_start_service(idevice_t device, const char* service_name, void **client, const char* label, int32_t (*constructor_func)(idevice_t, lockdownd_service_descriptor_t, void**), int32_t *error_code)\n{\n\t*client = NULL;\n\n\tlockdownd_client_t lckd = NULL;\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_client_new_with_handshake(device, &lckd, label)) {\n\t\tdebug_info(\"Could not create a lockdown client.\");\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_start_service(lckd, service_name, &service);\n\tlockdownd_client_free(lckd);\n\n\tif (!service || service->port == 0) {\n\t\tdebug_info(\"Could not start service %s!\", service_name);\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tint32_t ec;\n\tif (constructor_func) {\n\t\tec = (int32_t)constructor_func(device, service, client);\n\t} else {\n\t\tec = service_client_new(device, service, (service_client_t*)client);\n\t}\n\tif (error_code) {\n\t\t*error_code = ec;\n\t}\n\n\tif (ec != SERVICE_E_SUCCESS) {\n\t\tdebug_info(\"Could not connect to service %s! Port: %i, error: %i\", service_name, service->port, ec);\n\t}\n\n\tlockdownd_service_descriptor_free(service);\n\tservice = NULL;\n\n\treturn (ec == SERVICE_E_SUCCESS) ? SERVICE_E_SUCCESS : SERVICE_E_START_SERVICE_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_client_factory_start_service(idevice_t device, const char* service_name, void **client, const char* label, int32_t (*constructor_func)(idevice_t, lockdownd_service_descriptor_t, void**), int32_t *error_code)\n{\n\t*client = NULL;\n\n\tlockdownd_client_t lckd = NULL;\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_client_new_with_handshake(device, &lckd, label)) {\n\t\tdebug_info(\"Could not create a lockdown client.\");\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_start_service(lckd, service_name, &service);\n\tlockdownd_client_free(lckd);\n\n\tif (!service || service->port == 0) {\n\t\tdebug_info(\"Could not start service %s!\", service_name);\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tint32_t ec;\n\tif (constructor_func) {\n\t\tec = (int32_t)constructor_func(device, service, client);\n\t} else {\n\t\tec = service_client_new(device, service, (service_client_t*)client);\n\t}\n\tif (error_code) {\n\t\t*error_code = ec;\n\t}\n\n\tif (ec != SERVICE_E_SUCCESS) {\n\t\tdebug_info(\"Could not connect to service %s! Port: %i, error: %i\", service_name, service->port, ec);\n\t}\n\n\tlockdownd_service_descriptor_free(service);\n\tservice = NULL;\n\n\treturn (ec == SERVICE_E_SUCCESS) ? SERVICE_E_SUCCESS : SERVICE_E_START_SERVICE_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SERVICE_CONSTRUCTOR",
          "args": [
            "afc_client_new"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_start_service(idevice_t device, afc_client_t * client, const char* label)\n{\n\tafc_error_t err = AFC_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, AFC_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(afc_client_new), &err);\n\treturn err;\n}"
  },
  {
    "function_name": "afc_client_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "99-116",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_client_free",
          "args": [
            "parent"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "device_link_service_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/device_link_service.c",
          "lines": "119-129",
          "snippet": "device_link_service_error_t device_link_service_client_free(device_link_service_client_t client)\n{\n\tif (!client)\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_UNKNOWN_ERROR;\n\t}\n\tfree(client);\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"device_link_service.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"device_link_service.h\"\n#include <stdlib.h>\n#include <string.h>\n\ndevice_link_service_error_t device_link_service_client_free(device_link_service_client_t client)\n{\n\tif (!client)\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_UNKNOWN_ERROR;\n\t}\n\tfree(client);\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_new_with_service_client",
          "args": [
            "parent",
            "client"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_new_with_service_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "71-97",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new_with_service_client(service_client_t service_client, afc_client_t *client)\n{\n\tif (!service_client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_client_t client_loc = (afc_client_t) malloc(sizeof(struct afc_client_private));\n\tclient_loc->parent = service_client;\n\tclient_loc->free_parent = 0;\n\n\t/* allocate a packet */\n\tclient_loc->afc_packet = (AFCPacket *) malloc(sizeof(AFCPacket));\n\tif (!client_loc->afc_packet) {\n\t\tfree(client_loc);\n\t\treturn AFC_E_NO_MEM;\n\t}\n\n\tclient_loc->afc_packet->packet_num = 0;\n\tclient_loc->afc_packet->entire_length = 0;\n\tclient_loc->afc_packet->this_length = 0;\n\tmemcpy(client_loc->afc_packet->magic, AFC_MAGIC, AFC_MAGIC_LEN);\n\tclient_loc->file_handle = 0;\n\tclient_loc->lock = 0;\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new_with_service_client(service_client_t service_client, afc_client_t *client)\n{\n\tif (!service_client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_client_t client_loc = (afc_client_t) malloc(sizeof(struct afc_client_private));\n\tclient_loc->parent = service_client;\n\tclient_loc->free_parent = 0;\n\n\t/* allocate a packet */\n\tclient_loc->afc_packet = (AFCPacket *) malloc(sizeof(AFCPacket));\n\tif (!client_loc->afc_packet) {\n\t\tfree(client_loc);\n\t\treturn AFC_E_NO_MEM;\n\t}\n\n\tclient_loc->afc_packet->packet_num = 0;\n\tclient_loc->afc_packet->entire_length = 0;\n\tclient_loc->afc_packet->this_length = 0;\n\tmemcpy(client_loc->afc_packet->magic, AFC_MAGIC, AFC_MAGIC_LEN);\n\tclient_loc->file_handle = 0;\n\tclient_loc->lock = 0;\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "service_client_new",
          "args": [
            "device",
            "service",
            "&parent"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "device_link_service_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/device_link_service.c",
          "lines": "85-107",
          "snippet": "device_link_service_error_t device_link_service_client_new(idevice_t device, lockdownd_service_descriptor_t service, device_link_service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client) {\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\t}\n\n\tproperty_list_service_client_t plistclient = NULL;\n\tif (property_list_service_client_new(device, service, &plistclient) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tdevice_link_service_client_t client_loc = (device_link_service_client_t) malloc(sizeof(struct device_link_service_client_private));\n\tclient_loc->parent = plistclient;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled)\n\t\tproperty_list_service_enable_ssl(client_loc->parent);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"device_link_service.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"device_link_service.h\"\n#include <stdlib.h>\n#include <string.h>\n\ndevice_link_service_error_t device_link_service_client_new(idevice_t device, lockdownd_service_descriptor_t service, device_link_service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client) {\n\t\treturn DEVICE_LINK_SERVICE_E_INVALID_ARG;\n\t}\n\n\tproperty_list_service_client_t plistclient = NULL;\n\tif (property_list_service_client_new(device, service, &plistclient) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DEVICE_LINK_SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tdevice_link_service_client_t client_loc = (device_link_service_client_t) malloc(sizeof(struct device_link_service_client_private));\n\tclient_loc->parent = plistclient;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled)\n\t\tproperty_list_service_enable_ssl(client_loc->parent);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn DEVICE_LINK_SERVICE_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "afc_client_new_with_service_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "71-97",
    "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new_with_service_client(service_client_t service_client, afc_client_t *client)\n{\n\tif (!service_client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_client_t client_loc = (afc_client_t) malloc(sizeof(struct afc_client_private));\n\tclient_loc->parent = service_client;\n\tclient_loc->free_parent = 0;\n\n\t/* allocate a packet */\n\tclient_loc->afc_packet = (AFCPacket *) malloc(sizeof(AFCPacket));\n\tif (!client_loc->afc_packet) {\n\t\tfree(client_loc);\n\t\treturn AFC_E_NO_MEM;\n\t}\n\n\tclient_loc->afc_packet->packet_num = 0;\n\tclient_loc->afc_packet->entire_length = 0;\n\tclient_loc->afc_packet->this_length = 0;\n\tmemcpy(client_loc->afc_packet->magic, AFC_MAGIC, AFC_MAGIC_LEN);\n\tclient_loc->file_handle = 0;\n\tclient_loc->lock = 0;\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn AFC_E_SUCCESS;\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&client_loc->mutex"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "56-63",
          "snippet": "void mutex_init(mutex_t* mutex)\n{\n#ifdef WIN32\n\tInitializeCriticalSection(mutex);\n#else\n\tpthread_mutex_init(mutex, NULL);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_init(mutex_t* mutex)\n{\n#ifdef WIN32\n\tInitializeCriticalSection(mutex);\n#else\n\tpthread_mutex_init(mutex, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "client_loc->afc_packet->magic",
            "AFC_MAGIC",
            "AFC_MAGIC_LEN"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client_loc"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(AFCPacket)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct afc_client_private)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new_with_service_client(service_client_t service_client, afc_client_t *client)\n{\n\tif (!service_client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_client_t client_loc = (afc_client_t) malloc(sizeof(struct afc_client_private));\n\tclient_loc->parent = service_client;\n\tclient_loc->free_parent = 0;\n\n\t/* allocate a packet */\n\tclient_loc->afc_packet = (AFCPacket *) malloc(sizeof(AFCPacket));\n\tif (!client_loc->afc_packet) {\n\t\tfree(client_loc);\n\t\treturn AFC_E_NO_MEM;\n\t}\n\n\tclient_loc->afc_packet->packet_num = 0;\n\tclient_loc->afc_packet->entire_length = 0;\n\tclient_loc->afc_packet->this_length = 0;\n\tmemcpy(client_loc->afc_packet->magic, AFC_MAGIC, AFC_MAGIC_LEN);\n\tclient_loc->file_handle = 0;\n\tclient_loc->lock = 0;\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn AFC_E_SUCCESS;\n}"
  },
  {
    "function_name": "afc_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "53-57",
    "snippet": "static void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&client->mutex"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "83-90",
          "snippet": "void mutex_unlock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tLeaveCriticalSection(mutex);\n#else\n\tpthread_mutex_unlock(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_unlock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tLeaveCriticalSection(mutex);\n#else\n\tpthread_mutex_unlock(mutex);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unlocked\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_unlock(afc_client_t client)\n{\n\tdebug_info(\"Unlocked\");\n\tmutex_unlock(&client->mutex);\n}"
  },
  {
    "function_name": "afc_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
    "lines": "42-46",
    "snippet": "static void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}",
    "includes": [
      "#include \"endianness.h\"",
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"afc.h\"",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&client->mutex"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "74-81",
          "snippet": "void mutex_lock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tEnterCriticalSection(mutex);\n#else\n\tpthread_mutex_lock(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_lock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tEnterCriticalSection(mutex);\n#else\n\tpthread_mutex_lock(mutex);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Locked\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void afc_lock(afc_client_t client)\n{\n\tdebug_info(\"Locked\");\n\tmutex_lock(&client->mutex);\n}"
  }
]